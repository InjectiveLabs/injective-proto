// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_spot_exchange_rpc.proto

#include "exchange/injective_spot_exchange_rpc.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace injective_spot_exchange_rpc {
template <typename>
PROTOBUF_CONSTEXPR MarketsRequest::MarketsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_status_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.base_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quote_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MarketsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketsRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketsRequestDefaultTypeInternal() {}
  union {
    MarketsRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketsRequestDefaultTypeInternal _MarketsRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketsResponse::MarketsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.markets_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MarketsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketsResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketsResponseDefaultTypeInternal() {}
  union {
    MarketsResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketsResponseDefaultTypeInternal _MarketsResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotMarketInfo::SpotMarketInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_status_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ticker_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.base_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quote_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.maker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.taker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.service_provider_fee_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_price_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_quantity_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.base_token_meta_)*/nullptr
  , /*decltype(_impl_.quote_token_meta_)*/nullptr} {}
struct SpotMarketInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotMarketInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotMarketInfoDefaultTypeInternal() {}
  union {
    SpotMarketInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotMarketInfoDefaultTypeInternal _SpotMarketInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TokenMeta::TokenMeta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.symbol_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.logo_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.updated_at_)*/ ::int64_t{0}

  , /*decltype(_impl_.decimals_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenMetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenMetaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenMetaDefaultTypeInternal() {}
  union {
    TokenMeta _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenMetaDefaultTypeInternal _TokenMeta_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketRequest::MarketRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MarketRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketRequestDefaultTypeInternal() {}
  union {
    MarketRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketRequestDefaultTypeInternal _MarketRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketResponse::MarketResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_)*/nullptr} {}
struct MarketResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketResponseDefaultTypeInternal() {}
  union {
    MarketResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketResponseDefaultTypeInternal _MarketResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamMarketsRequest::StreamMarketsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamMarketsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamMarketsRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamMarketsRequestDefaultTypeInternal() {}
  union {
    StreamMarketsRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamMarketsRequestDefaultTypeInternal _StreamMarketsRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamMarketsResponse::StreamMarketsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamMarketsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamMarketsResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamMarketsResponseDefaultTypeInternal() {}
  union {
    StreamMarketsResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamMarketsResponseDefaultTypeInternal _StreamMarketsResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbookRequest::OrderbookRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbookRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookRequestDefaultTypeInternal() {}
  union {
    OrderbookRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookRequestDefaultTypeInternal _OrderbookRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbookResponse::OrderbookResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.orderbook_)*/nullptr} {}
struct OrderbookResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookResponseDefaultTypeInternal() {}
  union {
    OrderbookResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookResponseDefaultTypeInternal _OrderbookResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotLimitOrderbook::SpotLimitOrderbook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buys_)*/{}
  , /*decltype(_impl_.sells_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpotLimitOrderbookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotLimitOrderbookDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotLimitOrderbookDefaultTypeInternal() {}
  union {
    SpotLimitOrderbook _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotLimitOrderbookDefaultTypeInternal _SpotLimitOrderbook_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceLevel::PriceLevel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceLevelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceLevelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceLevelDefaultTypeInternal() {}
  union {
    PriceLevel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceLevelDefaultTypeInternal _PriceLevel_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbookV2Request::OrderbookV2Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbookV2RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookV2RequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookV2RequestDefaultTypeInternal() {}
  union {
    OrderbookV2Request _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookV2RequestDefaultTypeInternal _OrderbookV2Request_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbookV2Response::OrderbookV2Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.orderbook_)*/nullptr} {}
struct OrderbookV2ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookV2ResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookV2ResponseDefaultTypeInternal() {}
  union {
    OrderbookV2Response _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookV2ResponseDefaultTypeInternal _OrderbookV2Response_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotLimitOrderbookV2::SpotLimitOrderbookV2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buys_)*/{}
  , /*decltype(_impl_.sells_)*/{}
  , /*decltype(_impl_.sequence_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpotLimitOrderbookV2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotLimitOrderbookV2DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotLimitOrderbookV2DefaultTypeInternal() {}
  union {
    SpotLimitOrderbookV2 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotLimitOrderbookV2DefaultTypeInternal _SpotLimitOrderbookV2_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbooksRequest::OrderbooksRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbooksRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbooksRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbooksRequestDefaultTypeInternal() {}
  union {
    OrderbooksRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbooksRequestDefaultTypeInternal _OrderbooksRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbooksResponse::OrderbooksResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.orderbooks_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbooksResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbooksResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbooksResponseDefaultTypeInternal() {}
  union {
    OrderbooksResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbooksResponseDefaultTypeInternal _OrderbooksResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SingleSpotLimitOrderbook::SingleSpotLimitOrderbook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.orderbook_)*/nullptr} {}
struct SingleSpotLimitOrderbookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SingleSpotLimitOrderbookDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SingleSpotLimitOrderbookDefaultTypeInternal() {}
  union {
    SingleSpotLimitOrderbook _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SingleSpotLimitOrderbookDefaultTypeInternal _SingleSpotLimitOrderbook_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbooksV2Request::OrderbooksV2Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbooksV2RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbooksV2RequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbooksV2RequestDefaultTypeInternal() {}
  union {
    OrderbooksV2Request _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbooksV2RequestDefaultTypeInternal _OrderbooksV2Request_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbooksV2Response::OrderbooksV2Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.orderbooks_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbooksV2ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbooksV2ResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbooksV2ResponseDefaultTypeInternal() {}
  union {
    OrderbooksV2Response _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbooksV2ResponseDefaultTypeInternal _OrderbooksV2Response_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SingleSpotLimitOrderbookV2::SingleSpotLimitOrderbookV2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.orderbook_)*/nullptr} {}
struct SingleSpotLimitOrderbookV2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR SingleSpotLimitOrderbookV2DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SingleSpotLimitOrderbookV2DefaultTypeInternal() {}
  union {
    SingleSpotLimitOrderbookV2 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SingleSpotLimitOrderbookV2DefaultTypeInternal _SingleSpotLimitOrderbookV2_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrderbookRequest::StreamOrderbookRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamOrderbookRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrderbookRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrderbookRequestDefaultTypeInternal() {}
  union {
    StreamOrderbookRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrderbookRequestDefaultTypeInternal _StreamOrderbookRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrderbookResponse::StreamOrderbookResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.orderbook_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamOrderbookResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrderbookResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrderbookResponseDefaultTypeInternal() {}
  union {
    StreamOrderbookResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrderbookResponseDefaultTypeInternal _StreamOrderbookResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrderbookV2Request::StreamOrderbookV2Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamOrderbookV2RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrderbookV2RequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrderbookV2RequestDefaultTypeInternal() {}
  union {
    StreamOrderbookV2Request _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrderbookV2RequestDefaultTypeInternal _StreamOrderbookV2Request_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrderbookV2Response::StreamOrderbookV2Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.orderbook_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamOrderbookV2ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrderbookV2ResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrderbookV2ResponseDefaultTypeInternal() {}
  union {
    StreamOrderbookV2Response _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrderbookV2ResponseDefaultTypeInternal _StreamOrderbookV2Response_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrderbookUpdateRequest::StreamOrderbookUpdateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamOrderbookUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrderbookUpdateRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrderbookUpdateRequestDefaultTypeInternal() {}
  union {
    StreamOrderbookUpdateRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrderbookUpdateRequestDefaultTypeInternal _StreamOrderbookUpdateRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrderbookUpdateResponse::StreamOrderbookUpdateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.orderbook_level_updates_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamOrderbookUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrderbookUpdateResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrderbookUpdateResponseDefaultTypeInternal() {}
  union {
    StreamOrderbookUpdateResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrderbookUpdateResponseDefaultTypeInternal _StreamOrderbookUpdateResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbookLevelUpdates::OrderbookLevelUpdates(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buys_)*/{}
  , /*decltype(_impl_.sells_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.sequence_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.updated_at_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbookLevelUpdatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookLevelUpdatesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookLevelUpdatesDefaultTypeInternal() {}
  union {
    OrderbookLevelUpdates _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookLevelUpdatesDefaultTypeInternal _OrderbookLevelUpdates_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceLevelUpdate::PriceLevelUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.is_active_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceLevelUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceLevelUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceLevelUpdateDefaultTypeInternal() {}
  union {
    PriceLevelUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceLevelUpdateDefaultTypeInternal _PriceLevelUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrdersRequest::OrdersRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_side_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_.include_inactive_)*/ false

  , /*decltype(_impl_.subaccount_total_orders_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrdersRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrdersRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrdersRequestDefaultTypeInternal() {}
  union {
    OrdersRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrdersRequestDefaultTypeInternal _OrdersRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrdersResponse::OrdersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_.paging_)*/nullptr} {}
struct OrdersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrdersResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrdersResponseDefaultTypeInternal() {}
  union {
    OrdersResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrdersResponseDefaultTypeInternal _OrdersResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotLimitOrder::SpotLimitOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_side_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.unfilled_quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_recipient_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.state_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.created_at_)*/ ::int64_t{0}

  , /*decltype(_impl_.updated_at_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpotLimitOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotLimitOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotLimitOrderDefaultTypeInternal() {}
  union {
    SpotLimitOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotLimitOrderDefaultTypeInternal _SpotLimitOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Paging::Paging(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.total_)*/ ::int64_t{0}

  , /*decltype(_impl_.from_)*/ 0

  , /*decltype(_impl_.to_)*/ 0

  , /*decltype(_impl_.count_by_subaccount_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PagingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PagingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PagingDefaultTypeInternal() {}
  union {
    Paging _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PagingDefaultTypeInternal _Paging_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrdersRequest::StreamOrdersRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_side_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_.include_inactive_)*/ false

  , /*decltype(_impl_.subaccount_total_orders_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamOrdersRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrdersRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrdersRequestDefaultTypeInternal() {}
  union {
    StreamOrdersRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrdersRequestDefaultTypeInternal _StreamOrdersRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrdersResponse::StreamOrdersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamOrdersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrdersResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrdersResponseDefaultTypeInternal() {}
  union {
    StreamOrdersResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrdersResponseDefaultTypeInternal _StreamOrdersResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradesRequest::TradesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_.subaccount_ids_)*/{}
  , /*decltype(_impl_.execution_types_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.execution_side_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TradesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradesRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradesRequestDefaultTypeInternal() {}
  union {
    TradesRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradesRequestDefaultTypeInternal _TradesRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradesResponse::TradesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trades_)*/{}
  , /*decltype(_impl_.paging_)*/nullptr} {}
struct TradesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradesResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradesResponseDefaultTypeInternal() {}
  union {
    TradesResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradesResponseDefaultTypeInternal _TradesResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotTrade::SpotTrade(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trade_execution_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trade_direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_recipient_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trade_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.execution_side_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_)*/nullptr
  , /*decltype(_impl_.executed_at_)*/ ::int64_t{0}
} {}
struct SpotTradeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotTradeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotTradeDefaultTypeInternal() {}
  union {
    SpotTrade _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotTradeDefaultTypeInternal _SpotTrade_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamTradesRequest::StreamTradesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_ids_)*/{}
  , /*decltype(_impl_.subaccount_ids_)*/{}
  , /*decltype(_impl_.execution_types_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.execution_side_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamTradesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamTradesRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamTradesRequestDefaultTypeInternal() {}
  union {
    StreamTradesRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamTradesRequestDefaultTypeInternal _StreamTradesRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamTradesResponse::StreamTradesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trade_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamTradesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamTradesResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamTradesResponseDefaultTypeInternal() {}
  union {
    StreamTradesResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamTradesResponseDefaultTypeInternal _StreamTradesResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountOrdersListRequest::SubaccountOrdersListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountOrdersListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountOrdersListRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountOrdersListRequestDefaultTypeInternal() {}
  union {
    SubaccountOrdersListRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountOrdersListRequestDefaultTypeInternal _SubaccountOrdersListRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountOrdersListResponse::SubaccountOrdersListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_.paging_)*/nullptr} {}
struct SubaccountOrdersListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountOrdersListResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountOrdersListResponseDefaultTypeInternal() {}
  union {
    SubaccountOrdersListResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountOrdersListResponseDefaultTypeInternal _SubaccountOrdersListResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountTradesListRequest::SubaccountTradesListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.execution_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountTradesListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountTradesListRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountTradesListRequestDefaultTypeInternal() {}
  union {
    SubaccountTradesListRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountTradesListRequestDefaultTypeInternal _SubaccountTradesListRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountTradesListResponse::SubaccountTradesListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.trades_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountTradesListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountTradesListResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountTradesListResponseDefaultTypeInternal() {}
  union {
    SubaccountTradesListResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountTradesListResponseDefaultTypeInternal _SubaccountTradesListResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrdersHistoryRequest::OrdersHistoryRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.order_types_)*/{}
  , /*decltype(_impl_.execution_types_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.state_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrdersHistoryRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrdersHistoryRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrdersHistoryRequestDefaultTypeInternal() {}
  union {
    OrdersHistoryRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrdersHistoryRequestDefaultTypeInternal _OrdersHistoryRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrdersHistoryResponse::OrdersHistoryResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_.paging_)*/nullptr} {}
struct OrdersHistoryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrdersHistoryResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrdersHistoryResponseDefaultTypeInternal() {}
  union {
    OrdersHistoryResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrdersHistoryResponseDefaultTypeInternal _OrdersHistoryResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotOrderHistory::SpotOrderHistory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.execution_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.filled_quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.state_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.created_at_)*/ ::int64_t{0}

  , /*decltype(_impl_.updated_at_)*/ ::int64_t{0}

  , /*decltype(_impl_.is_active_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpotOrderHistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotOrderHistoryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotOrderHistoryDefaultTypeInternal() {}
  union {
    SpotOrderHistory _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotOrderHistoryDefaultTypeInternal _SpotOrderHistory_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrdersHistoryRequest::StreamOrdersHistoryRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.order_types_)*/{}
  , /*decltype(_impl_.execution_types_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.state_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamOrdersHistoryRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrdersHistoryRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrdersHistoryRequestDefaultTypeInternal() {}
  union {
    StreamOrdersHistoryRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrdersHistoryRequestDefaultTypeInternal _StreamOrdersHistoryRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamOrdersHistoryResponse::StreamOrdersHistoryResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamOrdersHistoryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamOrdersHistoryResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamOrdersHistoryResponseDefaultTypeInternal() {}
  union {
    StreamOrdersHistoryResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamOrdersHistoryResponseDefaultTypeInternal _StreamOrdersHistoryResponse_default_instance_;
}  // namespace injective_spot_exchange_rpc
static ::_pb::Metadata file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[49];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto = nullptr;
const ::uint32_t TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketsRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketsRequest, _impl_.market_status_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketsRequest, _impl_.base_denom_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketsRequest, _impl_.quote_denom_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketsResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketsResponse, _impl_.markets_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.market_status_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.ticker_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.base_denom_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.base_token_meta_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.quote_denom_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.quote_token_meta_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.maker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.taker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.service_provider_fee_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.min_price_tick_size_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotMarketInfo, _impl_.min_quantity_tick_size_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TokenMeta, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TokenMeta, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TokenMeta, _impl_.address_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TokenMeta, _impl_.symbol_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TokenMeta, _impl_.logo_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TokenMeta, _impl_.decimals_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TokenMeta, _impl_.updated_at_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::MarketResponse, _impl_.market_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamMarketsRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamMarketsRequest, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamMarketsResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamMarketsResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamMarketsResponse, _impl_.market_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamMarketsResponse, _impl_.operation_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamMarketsResponse, _impl_.timestamp_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookResponse, _impl_.orderbook_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrderbook, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrderbook, _impl_.buys_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrderbook, _impl_.sells_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevel, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevel, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevel, _impl_.timestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookV2Request, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookV2Request, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookV2Response, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookV2Response, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookV2Response, _impl_.orderbook_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrderbookV2, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrderbookV2, _impl_.buys_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrderbookV2, _impl_.sells_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrderbookV2, _impl_.sequence_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksRequest, _impl_.market_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksResponse, _impl_.orderbooks_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbook, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbook, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbook, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbook, _impl_.orderbook_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksV2Request, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksV2Request, _impl_.market_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksV2Response, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbooksV2Response, _impl_.orderbooks_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2, _impl_.orderbook_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookRequest, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookResponse, _impl_.orderbook_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookResponse, _impl_.operation_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookResponse, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookResponse, _impl_.market_id_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Request, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Request, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Response, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Response, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Response, _impl_.orderbook_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Response, _impl_.operation_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Response, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookV2Response, _impl_.market_id_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse, _impl_.orderbook_level_updates_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse, _impl_.operation_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse, _impl_.market_id_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookLevelUpdates, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookLevelUpdates, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookLevelUpdates, _impl_.sequence_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookLevelUpdates, _impl_.buys_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookLevelUpdates, _impl_.sells_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrderbookLevelUpdates, _impl_.updated_at_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevelUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevelUpdate, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevelUpdate, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevelUpdate, _impl_.is_active_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::PriceLevelUpdate, _impl_.timestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.order_side_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.end_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.include_inactive_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersRequest, _impl_.subaccount_total_orders_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersResponse, _impl_.orders_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersResponse, _impl_.paging_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.order_side_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.unfilled_quantity_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.trigger_price_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.fee_recipient_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.created_at_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotLimitOrder, _impl_.updated_at_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::Paging, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::Paging, _impl_.total_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::Paging, _impl_.from_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::Paging, _impl_.to_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::Paging, _impl_.count_by_subaccount_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.order_side_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.end_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.include_inactive_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersRequest, _impl_.subaccount_total_orders_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersResponse, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersResponse, _impl_.operation_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersResponse, _impl_.timestamp_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.execution_side_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.direction_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.end_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.subaccount_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesRequest, _impl_.execution_types_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesResponse, _impl_.trades_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::TradesResponse, _impl_.paging_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.trade_execution_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.trade_direction_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.fee_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.executed_at_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.fee_recipient_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.trade_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotTrade, _impl_.execution_side_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.execution_side_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.direction_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.end_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.subaccount_ids_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesRequest, _impl_.execution_types_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesResponse, _impl_.trade_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesResponse, _impl_.operation_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamTradesResponse, _impl_.timestamp_),
    0,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListResponse, _impl_.orders_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountOrdersListResponse, _impl_.paging_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListRequest, _impl_.execution_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListRequest, _impl_.direction_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListRequest, _impl_.limit_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SubaccountTradesListResponse, _impl_.trades_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.order_types_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.direction_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.end_time_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryRequest, _impl_.execution_types_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryResponse, _impl_.orders_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::OrdersHistoryResponse, _impl_.paging_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.is_active_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.execution_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.trigger_price_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.filled_quantity_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.created_at_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.updated_at_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::SpotOrderHistory, _impl_.direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest, _impl_.order_types_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest, _impl_.direction_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest, _impl_.execution_types_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryResponse, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryResponse, _impl_.operation_type_),
    PROTOBUF_FIELD_OFFSET(::injective_spot_exchange_rpc::StreamOrdersHistoryResponse, _impl_.timestamp_),
    0,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::injective_spot_exchange_rpc::MarketsRequest)},
        { 11, -1, -1, sizeof(::injective_spot_exchange_rpc::MarketsResponse)},
        { 20, 40, -1, sizeof(::injective_spot_exchange_rpc::SpotMarketInfo)},
        { 52, -1, -1, sizeof(::injective_spot_exchange_rpc::TokenMeta)},
        { 66, -1, -1, sizeof(::injective_spot_exchange_rpc::MarketRequest)},
        { 75, 84, -1, sizeof(::injective_spot_exchange_rpc::MarketResponse)},
        { 85, -1, -1, sizeof(::injective_spot_exchange_rpc::StreamMarketsRequest)},
        { 94, 105, -1, sizeof(::injective_spot_exchange_rpc::StreamMarketsResponse)},
        { 108, -1, -1, sizeof(::injective_spot_exchange_rpc::OrderbookRequest)},
        { 117, 126, -1, sizeof(::injective_spot_exchange_rpc::OrderbookResponse)},
        { 127, -1, -1, sizeof(::injective_spot_exchange_rpc::SpotLimitOrderbook)},
        { 137, -1, -1, sizeof(::injective_spot_exchange_rpc::PriceLevel)},
        { 148, -1, -1, sizeof(::injective_spot_exchange_rpc::OrderbookV2Request)},
        { 157, 166, -1, sizeof(::injective_spot_exchange_rpc::OrderbookV2Response)},
        { 167, -1, -1, sizeof(::injective_spot_exchange_rpc::SpotLimitOrderbookV2)},
        { 178, -1, -1, sizeof(::injective_spot_exchange_rpc::OrderbooksRequest)},
        { 187, -1, -1, sizeof(::injective_spot_exchange_rpc::OrderbooksResponse)},
        { 196, 206, -1, sizeof(::injective_spot_exchange_rpc::SingleSpotLimitOrderbook)},
        { 208, -1, -1, sizeof(::injective_spot_exchange_rpc::OrderbooksV2Request)},
        { 217, -1, -1, sizeof(::injective_spot_exchange_rpc::OrderbooksV2Response)},
        { 226, 236, -1, sizeof(::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2)},
        { 238, -1, -1, sizeof(::injective_spot_exchange_rpc::StreamOrderbookRequest)},
        { 247, 259, -1, sizeof(::injective_spot_exchange_rpc::StreamOrderbookResponse)},
        { 263, -1, -1, sizeof(::injective_spot_exchange_rpc::StreamOrderbookV2Request)},
        { 272, 284, -1, sizeof(::injective_spot_exchange_rpc::StreamOrderbookV2Response)},
        { 288, -1, -1, sizeof(::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest)},
        { 297, 309, -1, sizeof(::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse)},
        { 313, -1, -1, sizeof(::injective_spot_exchange_rpc::OrderbookLevelUpdates)},
        { 326, -1, -1, sizeof(::injective_spot_exchange_rpc::PriceLevelUpdate)},
        { 338, -1, -1, sizeof(::injective_spot_exchange_rpc::OrdersRequest)},
        { 356, 366, -1, sizeof(::injective_spot_exchange_rpc::OrdersResponse)},
        { 368, -1, -1, sizeof(::injective_spot_exchange_rpc::SpotLimitOrder)},
        { 388, -1, -1, sizeof(::injective_spot_exchange_rpc::Paging)},
        { 400, -1, -1, sizeof(::injective_spot_exchange_rpc::StreamOrdersRequest)},
        { 418, 429, -1, sizeof(::injective_spot_exchange_rpc::StreamOrdersResponse)},
        { 432, -1, -1, sizeof(::injective_spot_exchange_rpc::TradesRequest)},
        { 451, 461, -1, sizeof(::injective_spot_exchange_rpc::TradesResponse)},
        { 463, 482, -1, sizeof(::injective_spot_exchange_rpc::SpotTrade)},
        { 493, -1, -1, sizeof(::injective_spot_exchange_rpc::StreamTradesRequest)},
        { 512, 523, -1, sizeof(::injective_spot_exchange_rpc::StreamTradesResponse)},
        { 526, -1, -1, sizeof(::injective_spot_exchange_rpc::SubaccountOrdersListRequest)},
        { 538, 548, -1, sizeof(::injective_spot_exchange_rpc::SubaccountOrdersListResponse)},
        { 550, -1, -1, sizeof(::injective_spot_exchange_rpc::SubaccountTradesListRequest)},
        { 564, -1, -1, sizeof(::injective_spot_exchange_rpc::SubaccountTradesListResponse)},
        { 573, -1, -1, sizeof(::injective_spot_exchange_rpc::OrdersHistoryRequest)},
        { 591, 601, -1, sizeof(::injective_spot_exchange_rpc::OrdersHistoryResponse)},
        { 603, -1, -1, sizeof(::injective_spot_exchange_rpc::SpotOrderHistory)},
        { 625, -1, -1, sizeof(::injective_spot_exchange_rpc::StreamOrdersHistoryRequest)},
        { 639, 650, -1, sizeof(::injective_spot_exchange_rpc::StreamOrdersHistoryResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::injective_spot_exchange_rpc::_MarketsRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_MarketsResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SpotMarketInfo_default_instance_._instance,
    &::injective_spot_exchange_rpc::_TokenMeta_default_instance_._instance,
    &::injective_spot_exchange_rpc::_MarketRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_MarketResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamMarketsRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamMarketsResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbookRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbookResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SpotLimitOrderbook_default_instance_._instance,
    &::injective_spot_exchange_rpc::_PriceLevel_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbookV2Request_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbookV2Response_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SpotLimitOrderbookV2_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbooksRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbooksResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SingleSpotLimitOrderbook_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbooksV2Request_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbooksV2Response_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SingleSpotLimitOrderbookV2_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrderbookRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrderbookResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrderbookV2Request_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrderbookV2Response_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrderbookUpdateRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrderbookUpdateResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrderbookLevelUpdates_default_instance_._instance,
    &::injective_spot_exchange_rpc::_PriceLevelUpdate_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrdersRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrdersResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SpotLimitOrder_default_instance_._instance,
    &::injective_spot_exchange_rpc::_Paging_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrdersRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrdersResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_TradesRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_TradesResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SpotTrade_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamTradesRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamTradesResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SubaccountOrdersListRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SubaccountOrdersListResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SubaccountTradesListRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SubaccountTradesListResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrdersHistoryRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_OrdersHistoryResponse_default_instance_._instance,
    &::injective_spot_exchange_rpc::_SpotOrderHistory_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrdersHistoryRequest_default_instance_._instance,
    &::injective_spot_exchange_rpc::_StreamOrdersHistoryResponse_default_instance_._instance,
};
const char descriptor_table_protodef_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n*exchange/injective_spot_exchange_rpc.p"
    "roto\022\033injective_spot_exchange_rpc\"u\n\016Mar"
    "ketsRequest\022#\n\rmarket_status\030\001 \001(\tR\014mark"
    "etStatus\022\035\n\nbase_denom\030\002 \001(\tR\tbaseDenom\022"
    "\037\n\013quote_denom\030\003 \001(\tR\nquoteDenom\"X\n\017Mark"
    "etsResponse\022E\n\007markets\030\001 \003(\0132+.injective"
    "_spot_exchange_rpc.SpotMarketInfoR\007marke"
    "ts\"\256\004\n\016SpotMarketInfo\022\033\n\tmarket_id\030\001 \001(\t"
    "R\010marketId\022#\n\rmarket_status\030\002 \001(\tR\014marke"
    "tStatus\022\026\n\006ticker\030\003 \001(\tR\006ticker\022\035\n\nbase_"
    "denom\030\004 \001(\tR\tbaseDenom\022N\n\017base_token_met"
    "a\030\005 \001(\0132&.injective_spot_exchange_rpc.To"
    "kenMetaR\rbaseTokenMeta\022\037\n\013quote_denom\030\006 "
    "\001(\tR\nquoteDenom\022P\n\020quote_token_meta\030\007 \001("
    "\0132&.injective_spot_exchange_rpc.TokenMet"
    "aR\016quoteTokenMeta\022$\n\016maker_fee_rate\030\010 \001("
    "\tR\014makerFeeRate\022$\n\016taker_fee_rate\030\t \001(\tR"
    "\014takerFeeRate\0220\n\024service_provider_fee\030\n "
    "\001(\tR\022serviceProviderFee\022-\n\023min_price_tic"
    "k_size\030\013 \001(\tR\020minPriceTickSize\0223\n\026min_qu"
    "antity_tick_size\030\014 \001(\tR\023minQuantityTickS"
    "ize\"\240\001\n\tTokenMeta\022\022\n\004name\030\001 \001(\tR\004name\022\030\n"
    "\007address\030\002 \001(\tR\007address\022\026\n\006symbol\030\003 \001(\tR"
    "\006symbol\022\022\n\004logo\030\004 \001(\tR\004logo\022\032\n\010decimals\030"
    "\005 \001(\021R\010decimals\022\035\n\nupdated_at\030\006 \001(\022R\tupd"
    "atedAt\",\n\rMarketRequest\022\033\n\tmarket_id\030\001 \001"
    "(\tR\010marketId\"U\n\016MarketResponse\022C\n\006market"
    "\030\001 \001(\0132+.injective_spot_exchange_rpc.Spo"
    "tMarketInfoR\006market\"5\n\024StreamMarketsRequ"
    "est\022\035\n\nmarket_ids\030\001 \003(\tR\tmarketIds\"\241\001\n\025S"
    "treamMarketsResponse\022C\n\006market\030\001 \001(\0132+.i"
    "njective_spot_exchange_rpc.SpotMarketInf"
    "oR\006market\022%\n\016operation_type\030\002 \001(\tR\ropera"
    "tionType\022\034\n\ttimestamp\030\003 \001(\022R\ttimestamp\"/"
    "\n\020OrderbookRequest\022\033\n\tmarket_id\030\001 \001(\tR\010m"
    "arketId\"b\n\021OrderbookResponse\022M\n\torderboo"
    "k\030\001 \001(\0132/.injective_spot_exchange_rpc.Sp"
    "otLimitOrderbookR\torderbook\"\220\001\n\022SpotLimi"
    "tOrderbook\022;\n\004buys\030\001 \003(\0132\'.injective_spo"
    "t_exchange_rpc.PriceLevelR\004buys\022=\n\005sells"
    "\030\002 \003(\0132\'.injective_spot_exchange_rpc.Pri"
    "ceLevelR\005sells\"\\\n\nPriceLevel\022\024\n\005price\030\001 "
    "\001(\tR\005price\022\032\n\010quantity\030\002 \001(\tR\010quantity\022\034"
    "\n\ttimestamp\030\003 \001(\022R\ttimestamp\"1\n\022Orderboo"
    "kV2Request\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\""
    "f\n\023OrderbookV2Response\022O\n\torderbook\030\001 \001("
    "\01321.injective_spot_exchange_rpc.SpotLimi"
    "tOrderbookV2R\torderbook\"\256\001\n\024SpotLimitOrd"
    "erbookV2\022;\n\004buys\030\001 \003(\0132\'.injective_spot_"
    "exchange_rpc.PriceLevelR\004buys\022=\n\005sells\030\002"
    " \003(\0132\'.injective_spot_exchange_rpc.Price"
    "LevelR\005sells\022\032\n\010sequence\030\003 \001(\004R\010sequence"
    "\"2\n\021OrderbooksRequest\022\035\n\nmarket_ids\030\001 \003("
    "\tR\tmarketIds\"k\n\022OrderbooksResponse\022U\n\nor"
    "derbooks\030\001 \003(\01325.injective_spot_exchange"
    "_rpc.SingleSpotLimitOrderbookR\norderbook"
    "s\"\206\001\n\030SingleSpotLimitOrderbook\022\033\n\tmarket"
    "_id\030\001 \001(\tR\010marketId\022M\n\torderbook\030\002 \001(\0132/"
    ".injective_spot_exchange_rpc.SpotLimitOr"
    "derbookR\torderbook\"4\n\023OrderbooksV2Reques"
    "t\022\035\n\nmarket_ids\030\001 \003(\tR\tmarketIds\"o\n\024Orde"
    "rbooksV2Response\022W\n\norderbooks\030\001 \003(\01327.i"
    "njective_spot_exchange_rpc.SingleSpotLim"
    "itOrderbookV2R\norderbooks\"\212\001\n\032SingleSpot"
    "LimitOrderbookV2\022\033\n\tmarket_id\030\001 \001(\tR\010mar"
    "ketId\022O\n\torderbook\030\002 \001(\01321.injective_spo"
    "t_exchange_rpc.SpotLimitOrderbookV2R\tord"
    "erbook\"7\n\026StreamOrderbookRequest\022\035\n\nmark"
    "et_ids\030\001 \003(\tR\tmarketIds\"\312\001\n\027StreamOrderb"
    "ookResponse\022M\n\torderbook\030\001 \001(\0132/.injecti"
    "ve_spot_exchange_rpc.SpotLimitOrderbookR"
    "\torderbook\022%\n\016operation_type\030\002 \001(\tR\roper"
    "ationType\022\034\n\ttimestamp\030\003 \001(\022R\ttimestamp\022"
    "\033\n\tmarket_id\030\004 \001(\tR\010marketId\"9\n\030StreamOr"
    "derbookV2Request\022\035\n\nmarket_ids\030\001 \003(\tR\tma"
    "rketIds\"\316\001\n\031StreamOrderbookV2Response\022O\n"
    "\torderbook\030\001 \001(\01321.injective_spot_exchan"
    "ge_rpc.SpotLimitOrderbookV2R\torderbook\022%"
    "\n\016operation_type\030\002 \001(\tR\roperationType\022\034\n"
    "\ttimestamp\030\003 \001(\022R\ttimestamp\022\033\n\tmarket_id"
    "\030\004 \001(\tR\010marketId\"=\n\034StreamOrderbookUpdat"
    "eRequest\022\035\n\nmarket_ids\030\001 \003(\tR\tmarketIds\""
    "\355\001\n\035StreamOrderbookUpdateResponse\022j\n\027ord"
    "erbook_level_updates\030\001 \001(\01322.injective_s"
    "pot_exchange_rpc.OrderbookLevelUpdatesR\025"
    "orderbookLevelUpdates\022%\n\016operation_type\030"
    "\002 \001(\tR\roperationType\022\034\n\ttimestamp\030\003 \001(\022R"
    "\ttimestamp\022\033\n\tmarket_id\030\004 \001(\tR\010marketId\""
    "\367\001\n\025OrderbookLevelUpdates\022\033\n\tmarket_id\030\001"
    " \001(\tR\010marketId\022\032\n\010sequence\030\002 \001(\004R\010sequen"
    "ce\022A\n\004buys\030\003 \003(\0132-.injective_spot_exchan"
    "ge_rpc.PriceLevelUpdateR\004buys\022C\n\005sells\030\004"
    " \003(\0132-.injective_spot_exchange_rpc.Price"
    "LevelUpdateR\005sells\022\035\n\nupdated_at\030\005 \001(\022R\t"
    "updatedAt\"\177\n\020PriceLevelUpdate\022\024\n\005price\030\001"
    " \001(\tR\005price\022\032\n\010quantity\030\002 \001(\tR\010quantity\022"
    "\033\n\tis_active\030\003 \001(\010R\010isActive\022\034\n\ttimestam"
    "p\030\004 \001(\022R\ttimestamp\"\326\002\n\rOrdersRequest\022\033\n\t"
    "market_id\030\001 \001(\tR\010marketId\022\035\n\norder_side\030"
    "\002 \001(\tR\torderSide\022#\n\rsubaccount_id\030\003 \001(\tR"
    "\014subaccountId\022\022\n\004skip\030\004 \001(\004R\004skip\022\024\n\005lim"
    "it\030\005 \001(\021R\005limit\022\035\n\nstart_time\030\006 \001(\022R\tsta"
    "rtTime\022\031\n\010end_time\030\007 \001(\022R\007endTime\022\035\n\nmar"
    "ket_ids\030\010 \003(\tR\tmarketIds\022)\n\020include_inac"
    "tive\030\t \001(\010R\017includeInactive\0226\n\027subaccoun"
    "t_total_orders\030\n \001(\010R\025subaccountTotalOrd"
    "ers\"\222\001\n\016OrdersResponse\022C\n\006orders\030\001 \003(\0132+"
    ".injective_spot_exchange_rpc.SpotLimitOr"
    "derR\006orders\022;\n\006paging\030\002 \001(\0132#.injective_"
    "spot_exchange_rpc.PagingR\006paging\"\215\003\n\016Spo"
    "tLimitOrder\022\035\n\norder_hash\030\001 \001(\tR\torderHa"
    "sh\022\035\n\norder_side\030\002 \001(\tR\torderSide\022\033\n\tmar"
    "ket_id\030\003 \001(\tR\010marketId\022#\n\rsubaccount_id\030"
    "\004 \001(\tR\014subaccountId\022\024\n\005price\030\005 \001(\tR\005pric"
    "e\022\032\n\010quantity\030\006 \001(\tR\010quantity\022+\n\021unfille"
    "d_quantity\030\007 \001(\tR\020unfilledQuantity\022#\n\rtr"
    "igger_price\030\010 \001(\tR\014triggerPrice\022#\n\rfee_r"
    "ecipient\030\t \001(\tR\014feeRecipient\022\024\n\005state\030\n "
    "\001(\tR\005state\022\035\n\ncreated_at\030\013 \001(\022R\tcreatedA"
    "t\022\035\n\nupdated_at\030\014 \001(\022R\tupdatedAt\"r\n\006Pagi"
    "ng\022\024\n\005total\030\001 \001(\022R\005total\022\022\n\004from\030\002 \001(\021R\004"
    "from\022\016\n\002to\030\003 \001(\021R\002to\022.\n\023count_by_subacco"
    "unt\030\004 \001(\022R\021countBySubaccount\"\334\002\n\023StreamO"
    "rdersRequest\022\033\n\tmarket_id\030\001 \001(\tR\010marketI"
    "d\022\035\n\norder_side\030\002 \001(\tR\torderSide\022#\n\rsuba"
    "ccount_id\030\003 \001(\tR\014subaccountId\022\022\n\004skip\030\004 "
    "\001(\004R\004skip\022\024\n\005limit\030\005 \001(\021R\005limit\022\035\n\nstart"
    "_time\030\006 \001(\022R\tstartTime\022\031\n\010end_time\030\007 \001(\022"
    "R\007endTime\022\035\n\nmarket_ids\030\010 \003(\tR\tmarketIds"
    "\022)\n\020include_inactive\030\t \001(\010R\017includeInact"
    "ive\0226\n\027subaccount_total_orders\030\n \001(\010R\025su"
    "baccountTotalOrders\"\236\001\n\024StreamOrdersResp"
    "onse\022A\n\005order\030\001 \001(\0132+.injective_spot_exc"
    "hange_rpc.SpotLimitOrderR\005order\022%\n\016opera"
    "tion_type\030\002 \001(\tR\roperationType\022\034\n\ttimest"
    "amp\030\003 \001(\022R\ttimestamp\"\351\002\n\rTradesRequest\022\033"
    "\n\tmarket_id\030\001 \001(\tR\010marketId\022%\n\016execution"
    "_side\030\002 \001(\tR\rexecutionSide\022\034\n\tdirection\030"
    "\003 \001(\tR\tdirection\022#\n\rsubaccount_id\030\004 \001(\tR"
    "\014subaccountId\022\022\n\004skip\030\005 \001(\004R\004skip\022\024\n\005lim"
    "it\030\006 \001(\021R\005limit\022\035\n\nstart_time\030\007 \001(\022R\tsta"
    "rtTime\022\031\n\010end_time\030\010 \001(\022R\007endTime\022\035\n\nmar"
    "ket_ids\030\t \003(\tR\tmarketIds\022%\n\016subaccount_i"
    "ds\030\n \003(\tR\rsubaccountIds\022\'\n\017execution_typ"
    "es\030\013 \003(\tR\016executionTypes\"\215\001\n\016TradesRespo"
    "nse\022>\n\006trades\030\001 \003(\0132&.injective_spot_exc"
    "hange_rpc.SpotTradeR\006trades\022;\n\006paging\030\002 "
    "\001(\0132#.injective_spot_exchange_rpc.Paging"
    "R\006paging\"\240\003\n\tSpotTrade\022\035\n\norder_hash\030\001 \001"
    "(\tR\torderHash\022#\n\rsubaccount_id\030\002 \001(\tR\014su"
    "baccountId\022\033\n\tmarket_id\030\003 \001(\tR\010marketId\022"
    "0\n\024trade_execution_type\030\004 \001(\tR\022tradeExec"
    "utionType\022\'\n\017trade_direction\030\005 \001(\tR\016trad"
    "eDirection\022=\n\005price\030\006 \001(\0132\'.injective_sp"
    "ot_exchange_rpc.PriceLevelR\005price\022\020\n\003fee"
    "\030\007 \001(\tR\003fee\022\037\n\013executed_at\030\010 \001(\022R\nexecut"
    "edAt\022#\n\rfee_recipient\030\t \001(\tR\014feeRecipien"
    "t\022\031\n\010trade_id\030\n \001(\tR\007tradeId\022%\n\016executio"
    "n_side\030\013 \001(\tR\rexecutionSide\"\357\002\n\023StreamTr"
    "adesRequest\022\033\n\tmarket_id\030\001 \001(\tR\010marketId"
    "\022%\n\016execution_side\030\002 \001(\tR\rexecutionSide\022"
    "\034\n\tdirection\030\003 \001(\tR\tdirection\022#\n\rsubacco"
    "unt_id\030\004 \001(\tR\014subaccountId\022\022\n\004skip\030\005 \001(\004"
    "R\004skip\022\024\n\005limit\030\006 \001(\021R\005limit\022\035\n\nstart_ti"
    "me\030\007 \001(\022R\tstartTime\022\031\n\010end_time\030\010 \001(\022R\007e"
    "ndTime\022\035\n\nmarket_ids\030\t \003(\tR\tmarketIds\022%\n"
    "\016subaccount_ids\030\n \003(\tR\rsubaccountIds\022\'\n\017"
    "execution_types\030\013 \003(\tR\016executionTypes\"\231\001"
    "\n\024StreamTradesResponse\022<\n\005trade\030\001 \001(\0132&."
    "injective_spot_exchange_rpc.SpotTradeR\005t"
    "rade\022%\n\016operation_type\030\002 \001(\tR\roperationT"
    "ype\022\034\n\ttimestamp\030\003 \001(\022R\ttimestamp\"\211\001\n\033Su"
    "baccountOrdersListRequest\022#\n\rsubaccount_"
    "id\030\001 \001(\tR\014subaccountId\022\033\n\tmarket_id\030\002 \001("
    "\tR\010marketId\022\022\n\004skip\030\003 \001(\004R\004skip\022\024\n\005limit"
    "\030\004 \001(\021R\005limit\"\240\001\n\034SubaccountOrdersListRe"
    "sponse\022C\n\006orders\030\001 \003(\0132+.injective_spot_"
    "exchange_rpc.SpotLimitOrderR\006orders\022;\n\006p"
    "aging\030\002 \001(\0132#.injective_spot_exchange_rp"
    "c.PagingR\006paging\"\316\001\n\033SubaccountTradesLis"
    "tRequest\022#\n\rsubaccount_id\030\001 \001(\tR\014subacco"
    "untId\022\033\n\tmarket_id\030\002 \001(\tR\010marketId\022%\n\016ex"
    "ecution_type\030\003 \001(\tR\rexecutionType\022\034\n\tdir"
    "ection\030\004 \001(\tR\tdirection\022\022\n\004skip\030\005 \001(\004R\004s"
    "kip\022\024\n\005limit\030\006 \001(\021R\005limit\"^\n\034SubaccountT"
    "radesListResponse\022>\n\006trades\030\001 \003(\0132&.inje"
    "ctive_spot_exchange_rpc.SpotTradeR\006trade"
    "s\"\272\002\n\024OrdersHistoryRequest\022#\n\rsubaccount"
    "_id\030\001 \001(\tR\014subaccountId\022\033\n\tmarket_id\030\002 \001"
    "(\tR\010marketId\022\022\n\004skip\030\003 \001(\004R\004skip\022\024\n\005limi"
    "t\030\004 \001(\021R\005limit\022\037\n\013order_types\030\005 \003(\tR\nord"
    "erTypes\022\034\n\tdirection\030\006 \001(\tR\tdirection\022\035\n"
    "\nstart_time\030\007 \001(\022R\tstartTime\022\031\n\010end_time"
    "\030\010 \001(\022R\007endTime\022\024\n\005state\030\t \001(\tR\005state\022\'\n"
    "\017execution_types\030\n \003(\tR\016executionTypes\"\233"
    "\001\n\025OrdersHistoryResponse\022E\n\006orders\030\001 \003(\013"
    "2-.injective_spot_exchange_rpc.SpotOrder"
    "HistoryR\006orders\022;\n\006paging\030\002 \001(\0132#.inject"
    "ive_spot_exchange_rpc.PagingR\006paging\"\310\003\n"
    "\020SpotOrderHistory\022\035\n\norder_hash\030\001 \001(\tR\to"
    "rderHash\022\033\n\tmarket_id\030\002 \001(\tR\010marketId\022\033\n"
    "\tis_active\030\003 \001(\010R\010isActive\022#\n\rsubaccount"
    "_id\030\004 \001(\tR\014subaccountId\022%\n\016execution_typ"
    "e\030\005 \001(\tR\rexecutionType\022\035\n\norder_type\030\006 \001"
    "(\tR\torderType\022\024\n\005price\030\007 \001(\tR\005price\022#\n\rt"
    "rigger_price\030\010 \001(\tR\014triggerPrice\022\032\n\010quan"
    "tity\030\t \001(\tR\010quantity\022\'\n\017filled_quantity\030"
    "\n \001(\tR\016filledQuantity\022\024\n\005state\030\013 \001(\tR\005st"
    "ate\022\035\n\ncreated_at\030\014 \001(\022R\tcreatedAt\022\035\n\nup"
    "dated_at\030\r \001(\022R\tupdatedAt\022\034\n\tdirection\030\016"
    " \001(\tR\tdirection\"\334\001\n\032StreamOrdersHistoryR"
    "equest\022#\n\rsubaccount_id\030\001 \001(\tR\014subaccoun"
    "tId\022\033\n\tmarket_id\030\002 \001(\tR\010marketId\022\037\n\013orde"
    "r_types\030\003 \003(\tR\norderTypes\022\034\n\tdirection\030\004"
    " \001(\tR\tdirection\022\024\n\005state\030\005 \001(\tR\005state\022\'\n"
    "\017execution_types\030\006 \003(\tR\016executionTypes\"\247"
    "\001\n\033StreamOrdersHistoryResponse\022C\n\005order\030"
    "\001 \001(\0132-.injective_spot_exchange_rpc.Spot"
    "OrderHistoryR\005order\022%\n\016operation_type\030\002 "
    "\001(\tR\roperationType\022\034\n\ttimestamp\030\003 \001(\022R\tt"
    "imestamp2\216\021\n\030InjectiveSpotExchangeRPC\022d\n"
    "\007Markets\022+.injective_spot_exchange_rpc.M"
    "arketsRequest\032,.injective_spot_exchange_"
    "rpc.MarketsResponse\022a\n\006Market\022*.injectiv"
    "e_spot_exchange_rpc.MarketRequest\032+.inje"
    "ctive_spot_exchange_rpc.MarketResponse\022x"
    "\n\rStreamMarkets\0221.injective_spot_exchang"
    "e_rpc.StreamMarketsRequest\0322.injective_s"
    "pot_exchange_rpc.StreamMarketsResponse0\001"
    "\022j\n\tOrderbook\022-.injective_spot_exchange_"
    "rpc.OrderbookRequest\032..injective_spot_ex"
    "change_rpc.OrderbookResponse\022p\n\013Orderboo"
    "kV2\022/.injective_spot_exchange_rpc.Orderb"
    "ookV2Request\0320.injective_spot_exchange_r"
    "pc.OrderbookV2Response\022m\n\nOrderbooks\022..i"
    "njective_spot_exchange_rpc.OrderbooksReq"
    "uest\032/.injective_spot_exchange_rpc.Order"
    "booksResponse\022s\n\014OrderbooksV2\0220.injectiv"
    "e_spot_exchange_rpc.OrderbooksV2Request\032"
    "1.injective_spot_exchange_rpc.Orderbooks"
    "V2Response\022~\n\017StreamOrderbook\0223.injectiv"
    "e_spot_exchange_rpc.StreamOrderbookReque"
    "st\0324.injective_spot_exchange_rpc.StreamO"
    "rderbookResponse0\001\022\204\001\n\021StreamOrderbookV2"
    "\0225.injective_spot_exchange_rpc.StreamOrd"
    "erbookV2Request\0326.injective_spot_exchang"
    "e_rpc.StreamOrderbookV2Response0\001\022\220\001\n\025St"
    "reamOrderbookUpdate\0229.injective_spot_exc"
    "hange_rpc.StreamOrderbookUpdateRequest\032:"
    ".injective_spot_exchange_rpc.StreamOrder"
    "bookUpdateResponse0\001\022a\n\006Orders\022*.injecti"
    "ve_spot_exchange_rpc.OrdersRequest\032+.inj"
    "ective_spot_exchange_rpc.OrdersResponse\022"
    "u\n\014StreamOrders\0220.injective_spot_exchang"
    "e_rpc.StreamOrdersRequest\0321.injective_sp"
    "ot_exchange_rpc.StreamOrdersResponse0\001\022a"
    "\n\006Trades\022*.injective_spot_exchange_rpc.T"
    "radesRequest\032+.injective_spot_exchange_r"
    "pc.TradesResponse\022u\n\014StreamTrades\0220.inje"
    "ctive_spot_exchange_rpc.StreamTradesRequ"
    "est\0321.injective_spot_exchange_rpc.Stream"
    "TradesResponse0\001\022\213\001\n\024SubaccountOrdersLis"
    "t\0228.injective_spot_exchange_rpc.Subaccou"
    "ntOrdersListRequest\0329.injective_spot_exc"
    "hange_rpc.SubaccountOrdersListResponse\022\213"
    "\001\n\024SubaccountTradesList\0228.injective_spot"
    "_exchange_rpc.SubaccountTradesListReques"
    "t\0329.injective_spot_exchange_rpc.Subaccou"
    "ntTradesListResponse\022v\n\rOrdersHistory\0221."
    "injective_spot_exchange_rpc.OrdersHistor"
    "yRequest\0322.injective_spot_exchange_rpc.O"
    "rdersHistoryResponse\022\212\001\n\023StreamOrdersHis"
    "tory\0227.injective_spot_exchange_rpc.Strea"
    "mOrdersHistoryRequest\0328.injective_spot_e"
    "xchange_rpc.StreamOrdersHistoryResponse0"
    "\001B\340\001\n\037com.injective_spot_exchange_rpcB\035I"
    "njectiveSpotExchangeRpcProtoP\001Z\036/injecti"
    "ve_spot_exchange_rpcpb\242\002\003IXX\252\002\030Injective"
    "SpotExchangeRpc\312\002\030InjectiveSpotExchangeR"
    "pc\342\002$InjectiveSpotExchangeRpc\\GPBMetadat"
    "a\352\002\030InjectiveSpotExchangeRpcb\006proto3"
};
static ::absl::once_flag descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto = {
    false,
    false,
    11236,
    descriptor_table_protodef_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto,
    "exchange/injective_spot_exchange_rpc.proto",
    &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
    nullptr,
    0,
    49,
    schemas,
    file_default_instances,
    TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto::offsets,
    file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto,
    file_level_enum_descriptors_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto,
    file_level_service_descriptors_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter() {
  return &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto(&descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto);
namespace injective_spot_exchange_rpc {
// ===================================================================

class MarketsRequest::_Internal {
 public:
};

MarketsRequest::MarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.MarketsRequest)
}
MarketsRequest::MarketsRequest(const MarketsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_status_) {}

    , decltype(_impl_.base_denom_) {}

    , decltype(_impl_.quote_denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_status_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_status().empty()) {
    _this->_impl_.market_status_.Set(from._internal_market_status(), _this->GetArenaForAllocation());
  }
  _impl_.base_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_denom().empty()) {
    _this->_impl_.base_denom_.Set(from._internal_base_denom(), _this->GetArenaForAllocation());
  }
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quote_denom().empty()) {
    _this->_impl_.quote_denom_.Set(from._internal_quote_denom(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.MarketsRequest)
}

inline void MarketsRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_status_) {}

    , decltype(_impl_.base_denom_) {}

    , decltype(_impl_.quote_denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_status_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarketsRequest::~MarketsRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.MarketsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketsRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_status_.Destroy();
  _impl_.base_denom_.Destroy();
  _impl_.quote_denom_.Destroy();
}

void MarketsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.MarketsRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_status_.ClearToEmpty();
  _impl_.base_denom_.ClearToEmpty();
  _impl_.quote_denom_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_status = 1 [json_name = "marketStatus"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.MarketsRequest.market_status"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string base_denom = 2 [json_name = "baseDenom"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_base_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.MarketsRequest.base_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quote_denom = 3 [json_name = "quoteDenom"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_quote_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.MarketsRequest.quote_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketsRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.MarketsRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_status = 1 [json_name = "marketStatus"];
  if (!this->_internal_market_status().empty()) {
    const std::string& _s = this->_internal_market_status();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.MarketsRequest.market_status");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string base_denom = 2 [json_name = "baseDenom"];
  if (!this->_internal_base_denom().empty()) {
    const std::string& _s = this->_internal_base_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.MarketsRequest.base_denom");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string quote_denom = 3 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    const std::string& _s = this->_internal_quote_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.MarketsRequest.quote_denom");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.MarketsRequest)
  return target;
}

::size_t MarketsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.MarketsRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_status = 1 [json_name = "marketStatus"];
  if (!this->_internal_market_status().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_status());
  }

  // string base_denom = 2 [json_name = "baseDenom"];
  if (!this->_internal_base_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_base_denom());
  }

  // string quote_denom = 3 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quote_denom());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketsRequest::GetClassData() const { return &_class_data_; }


void MarketsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketsRequest*>(&to_msg);
  auto& from = static_cast<const MarketsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.MarketsRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_status().empty()) {
    _this->_internal_set_market_status(from._internal_market_status());
  }
  if (!from._internal_base_denom().empty()) {
    _this->_internal_set_base_denom(from._internal_base_denom());
  }
  if (!from._internal_quote_denom().empty()) {
    _this->_internal_set_quote_denom(from._internal_quote_denom());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketsRequest::CopyFrom(const MarketsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.MarketsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketsRequest::IsInitialized() const {
  return true;
}

void MarketsRequest::InternalSwap(MarketsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_status_, lhs_arena,
                                       &other->_impl_.market_status_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.base_denom_, lhs_arena,
                                       &other->_impl_.base_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quote_denom_, lhs_arena,
                                       &other->_impl_.quote_denom_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[0]);
}
// ===================================================================

class MarketsResponse::_Internal {
 public:
};

MarketsResponse::MarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.MarketsResponse)
}
MarketsResponse::MarketsResponse(const MarketsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.markets_){from._impl_.markets_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.MarketsResponse)
}

inline void MarketsResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.markets_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MarketsResponse::~MarketsResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.MarketsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketsResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_markets()->~RepeatedPtrField();
}

void MarketsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.MarketsResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_markets()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SpotMarketInfo markets = 1 [json_name = "markets"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_markets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketsResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.MarketsResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotMarketInfo markets = 1 [json_name = "markets"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_markets_size()); i < n; i++) {
    const auto& repfield = this->_internal_markets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.MarketsResponse)
  return target;
}

::size_t MarketsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.MarketsResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotMarketInfo markets = 1 [json_name = "markets"];
  total_size += 1UL * this->_internal_markets_size();
  for (const auto& msg : this->_internal_markets()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketsResponse::GetClassData() const { return &_class_data_; }


void MarketsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketsResponse*>(&to_msg);
  auto& from = static_cast<const MarketsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.MarketsResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_markets()->MergeFrom(from._internal_markets());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketsResponse::CopyFrom(const MarketsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.MarketsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketsResponse::IsInitialized() const {
  return true;
}

void MarketsResponse::InternalSwap(MarketsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_markets()->InternalSwap(other->_internal_mutable_markets());
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[1]);
}
// ===================================================================

class SpotMarketInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SpotMarketInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpotMarketInfo, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::TokenMeta& base_token_meta(const SpotMarketInfo* msg);
  static void set_has_base_token_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::injective_spot_exchange_rpc::TokenMeta& quote_token_meta(const SpotMarketInfo* msg);
  static void set_has_quote_token_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::injective_spot_exchange_rpc::TokenMeta&
SpotMarketInfo::_Internal::base_token_meta(const SpotMarketInfo* msg) {
  return *msg->_impl_.base_token_meta_;
}
const ::injective_spot_exchange_rpc::TokenMeta&
SpotMarketInfo::_Internal::quote_token_meta(const SpotMarketInfo* msg) {
  return *msg->_impl_.quote_token_meta_;
}
SpotMarketInfo::SpotMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SpotMarketInfo)
}
SpotMarketInfo::SpotMarketInfo(const SpotMarketInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotMarketInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.market_status_) {}

    , decltype(_impl_.ticker_) {}

    , decltype(_impl_.base_denom_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.service_provider_fee_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.base_token_meta_){nullptr}
    , decltype(_impl_.quote_token_meta_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_status_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_status().empty()) {
    _this->_impl_.market_status_.Set(from._internal_market_status(), _this->GetArenaForAllocation());
  }
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ticker().empty()) {
    _this->_impl_.ticker_.Set(from._internal_ticker(), _this->GetArenaForAllocation());
  }
  _impl_.base_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_denom().empty()) {
    _this->_impl_.base_denom_.Set(from._internal_base_denom(), _this->GetArenaForAllocation());
  }
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quote_denom().empty()) {
    _this->_impl_.quote_denom_.Set(from._internal_quote_denom(), _this->GetArenaForAllocation());
  }
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_impl_.maker_fee_rate_.Set(from._internal_maker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_impl_.taker_fee_rate_.Set(from._internal_taker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.service_provider_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_provider_fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_service_provider_fee().empty()) {
    _this->_impl_.service_provider_fee_.Set(from._internal_service_provider_fee(), _this->GetArenaForAllocation());
  }
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_impl_.min_price_tick_size_.Set(from._internal_min_price_tick_size(), _this->GetArenaForAllocation());
  }
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_impl_.min_quantity_tick_size_.Set(from._internal_min_quantity_tick_size(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.base_token_meta_ = new ::injective_spot_exchange_rpc::TokenMeta(*from._impl_.base_token_meta_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.quote_token_meta_ = new ::injective_spot_exchange_rpc::TokenMeta(*from._impl_.quote_token_meta_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SpotMarketInfo)
}

inline void SpotMarketInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.market_status_) {}

    , decltype(_impl_.ticker_) {}

    , decltype(_impl_.base_denom_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.service_provider_fee_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.base_token_meta_){nullptr}
    , decltype(_impl_.quote_token_meta_){nullptr}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_status_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.service_provider_fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_provider_fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotMarketInfo::~SpotMarketInfo() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SpotMarketInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotMarketInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.market_status_.Destroy();
  _impl_.ticker_.Destroy();
  _impl_.base_denom_.Destroy();
  _impl_.quote_denom_.Destroy();
  _impl_.maker_fee_rate_.Destroy();
  _impl_.taker_fee_rate_.Destroy();
  _impl_.service_provider_fee_.Destroy();
  _impl_.min_price_tick_size_.Destroy();
  _impl_.min_quantity_tick_size_.Destroy();
  if (this != internal_default_instance()) delete _impl_.base_token_meta_;
  if (this != internal_default_instance()) delete _impl_.quote_token_meta_;
}

void SpotMarketInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotMarketInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SpotMarketInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.market_status_.ClearToEmpty();
  _impl_.ticker_.ClearToEmpty();
  _impl_.base_denom_.ClearToEmpty();
  _impl_.quote_denom_.ClearToEmpty();
  _impl_.maker_fee_rate_.ClearToEmpty();
  _impl_.taker_fee_rate_.ClearToEmpty();
  _impl_.service_provider_fee_.ClearToEmpty();
  _impl_.min_price_tick_size_.ClearToEmpty();
  _impl_.min_quantity_tick_size_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.base_token_meta_ != nullptr);
      _impl_.base_token_meta_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.quote_token_meta_ != nullptr);
      _impl_.quote_token_meta_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotMarketInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_status = 2 [json_name = "marketStatus"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.market_status"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string ticker = 3 [json_name = "ticker"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ticker();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.ticker"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string base_denom = 4 [json_name = "baseDenom"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_base_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.base_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.TokenMeta base_token_meta = 5 [json_name = "baseTokenMeta"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_base_token_meta(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string quote_denom = 6 [json_name = "quoteDenom"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_quote_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.quote_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7 [json_name = "quoteTokenMeta"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_quote_token_meta(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string maker_fee_rate = 8 [json_name = "makerFeeRate"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_maker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.maker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string taker_fee_rate = 9 [json_name = "takerFeeRate"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_taker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.taker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string service_provider_fee = 10 [json_name = "serviceProviderFee"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_service_provider_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.service_provider_fee"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_price_tick_size = 11 [json_name = "minPriceTickSize"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_min_price_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.min_price_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_quantity_tick_size = 12 [json_name = "minQuantityTickSize"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_min_quantity_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotMarketInfo.min_quantity_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotMarketInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SpotMarketInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_status = 2 [json_name = "marketStatus"];
  if (!this->_internal_market_status().empty()) {
    const std::string& _s = this->_internal_market_status();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.market_status");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string ticker = 3 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    const std::string& _s = this->_internal_ticker();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.ticker");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string base_denom = 4 [json_name = "baseDenom"];
  if (!this->_internal_base_denom().empty()) {
    const std::string& _s = this->_internal_base_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.base_denom");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.TokenMeta base_token_meta = 5 [json_name = "baseTokenMeta"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::base_token_meta(this),
        _Internal::base_token_meta(this).GetCachedSize(), target, stream);
  }

  // string quote_denom = 6 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    const std::string& _s = this->_internal_quote_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.quote_denom");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // .injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7 [json_name = "quoteTokenMeta"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::quote_token_meta(this),
        _Internal::quote_token_meta(this).GetCachedSize(), target, stream);
  }

  // string maker_fee_rate = 8 [json_name = "makerFeeRate"];
  if (!this->_internal_maker_fee_rate().empty()) {
    const std::string& _s = this->_internal_maker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.maker_fee_rate");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string taker_fee_rate = 9 [json_name = "takerFeeRate"];
  if (!this->_internal_taker_fee_rate().empty()) {
    const std::string& _s = this->_internal_taker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.taker_fee_rate");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string service_provider_fee = 10 [json_name = "serviceProviderFee"];
  if (!this->_internal_service_provider_fee().empty()) {
    const std::string& _s = this->_internal_service_provider_fee();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.service_provider_fee");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // string min_price_tick_size = 11 [json_name = "minPriceTickSize"];
  if (!this->_internal_min_price_tick_size().empty()) {
    const std::string& _s = this->_internal_min_price_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.min_price_tick_size");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // string min_quantity_tick_size = 12 [json_name = "minQuantityTickSize"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    const std::string& _s = this->_internal_min_quantity_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotMarketInfo.min_quantity_tick_size");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SpotMarketInfo)
  return target;
}

::size_t SpotMarketInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SpotMarketInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string market_status = 2 [json_name = "marketStatus"];
  if (!this->_internal_market_status().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_status());
  }

  // string ticker = 3 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ticker());
  }

  // string base_denom = 4 [json_name = "baseDenom"];
  if (!this->_internal_base_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_base_denom());
  }

  // string quote_denom = 6 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quote_denom());
  }

  // string maker_fee_rate = 8 [json_name = "makerFeeRate"];
  if (!this->_internal_maker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maker_fee_rate());
  }

  // string taker_fee_rate = 9 [json_name = "takerFeeRate"];
  if (!this->_internal_taker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_taker_fee_rate());
  }

  // string service_provider_fee = 10 [json_name = "serviceProviderFee"];
  if (!this->_internal_service_provider_fee().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_service_provider_fee());
  }

  // string min_price_tick_size = 11 [json_name = "minPriceTickSize"];
  if (!this->_internal_min_price_tick_size().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_price_tick_size());
  }

  // string min_quantity_tick_size = 12 [json_name = "minQuantityTickSize"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_quantity_tick_size());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .injective_spot_exchange_rpc.TokenMeta base_token_meta = 5 [json_name = "baseTokenMeta"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_token_meta_);
    }

    // .injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7 [json_name = "quoteTokenMeta"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quote_token_meta_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotMarketInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotMarketInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotMarketInfo::GetClassData() const { return &_class_data_; }


void SpotMarketInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotMarketInfo*>(&to_msg);
  auto& from = static_cast<const SpotMarketInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SpotMarketInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_market_status().empty()) {
    _this->_internal_set_market_status(from._internal_market_status());
  }
  if (!from._internal_ticker().empty()) {
    _this->_internal_set_ticker(from._internal_ticker());
  }
  if (!from._internal_base_denom().empty()) {
    _this->_internal_set_base_denom(from._internal_base_denom());
  }
  if (!from._internal_quote_denom().empty()) {
    _this->_internal_set_quote_denom(from._internal_quote_denom());
  }
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_internal_set_maker_fee_rate(from._internal_maker_fee_rate());
  }
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_internal_set_taker_fee_rate(from._internal_taker_fee_rate());
  }
  if (!from._internal_service_provider_fee().empty()) {
    _this->_internal_set_service_provider_fee(from._internal_service_provider_fee());
  }
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_internal_set_min_price_tick_size(from._internal_min_price_tick_size());
  }
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_internal_set_min_quantity_tick_size(from._internal_min_quantity_tick_size());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base_token_meta()->::injective_spot_exchange_rpc::TokenMeta::MergeFrom(
          from._internal_base_token_meta());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_quote_token_meta()->::injective_spot_exchange_rpc::TokenMeta::MergeFrom(
          from._internal_quote_token_meta());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotMarketInfo::CopyFrom(const SpotMarketInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SpotMarketInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotMarketInfo::IsInitialized() const {
  return true;
}

void SpotMarketInfo::InternalSwap(SpotMarketInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_status_, lhs_arena,
                                       &other->_impl_.market_status_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ticker_, lhs_arena,
                                       &other->_impl_.ticker_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.base_denom_, lhs_arena,
                                       &other->_impl_.base_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quote_denom_, lhs_arena,
                                       &other->_impl_.quote_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maker_fee_rate_, lhs_arena,
                                       &other->_impl_.maker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.taker_fee_rate_, lhs_arena,
                                       &other->_impl_.taker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_provider_fee_, lhs_arena,
                                       &other->_impl_.service_provider_fee_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_price_tick_size_, lhs_arena,
                                       &other->_impl_.min_price_tick_size_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_quantity_tick_size_, lhs_arena,
                                       &other->_impl_.min_quantity_tick_size_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpotMarketInfo, _impl_.quote_token_meta_)
      + sizeof(SpotMarketInfo::_impl_.quote_token_meta_)
      - PROTOBUF_FIELD_OFFSET(SpotMarketInfo, _impl_.base_token_meta_)>(
          reinterpret_cast<char*>(&_impl_.base_token_meta_),
          reinterpret_cast<char*>(&other->_impl_.base_token_meta_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotMarketInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[2]);
}
// ===================================================================

class TokenMeta::_Internal {
 public:
};

TokenMeta::TokenMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.TokenMeta)
}
TokenMeta::TokenMeta(const TokenMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenMeta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.address_) {}

    , decltype(_impl_.symbol_) {}

    , decltype(_impl_.logo_) {}

    , decltype(_impl_.updated_at_) {}

    , decltype(_impl_.decimals_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), _this->GetArenaForAllocation());
  }
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol().empty()) {
    _this->_impl_.symbol_.Set(from._internal_symbol(), _this->GetArenaForAllocation());
  }
  _impl_.logo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.logo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_logo().empty()) {
    _this->_impl_.logo_.Set(from._internal_logo(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.updated_at_, &from._impl_.updated_at_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.decimals_) -
    reinterpret_cast<char*>(&_impl_.updated_at_)) + sizeof(_impl_.decimals_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.TokenMeta)
}

inline void TokenMeta::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.name_) {}

    , decltype(_impl_.address_) {}

    , decltype(_impl_.symbol_) {}

    , decltype(_impl_.logo_) {}

    , decltype(_impl_.updated_at_) { ::int64_t{0} }

    , decltype(_impl_.decimals_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.logo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.logo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TokenMeta::~TokenMeta() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.TokenMeta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenMeta::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.address_.Destroy();
  _impl_.symbol_.Destroy();
  _impl_.logo_.Destroy();
}

void TokenMeta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.TokenMeta)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.address_.ClearToEmpty();
  _impl_.symbol_.ClearToEmpty();
  _impl_.logo_.ClearToEmpty();
  ::memset(&_impl_.updated_at_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.decimals_) -
      reinterpret_cast<char*>(&_impl_.updated_at_)) + sizeof(_impl_.decimals_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenMeta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [json_name = "name"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TokenMeta.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string address = 2 [json_name = "address"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TokenMeta.address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string symbol = 3 [json_name = "symbol"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TokenMeta.symbol"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string logo = 4 [json_name = "logo"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_logo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TokenMeta.logo"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 decimals = 5 [json_name = "decimals"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.decimals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 updated_at = 6 [json_name = "updatedAt"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TokenMeta::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.TokenMeta)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [json_name = "name"];
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TokenMeta.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string address = 2 [json_name = "address"];
  if (!this->_internal_address().empty()) {
    const std::string& _s = this->_internal_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TokenMeta.address");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string symbol = 3 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    const std::string& _s = this->_internal_symbol();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TokenMeta.symbol");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string logo = 4 [json_name = "logo"];
  if (!this->_internal_logo().empty()) {
    const std::string& _s = this->_internal_logo();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TokenMeta.logo");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // sint32 decimals = 5 [json_name = "decimals"];
  if (this->_internal_decimals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        5, this->_internal_decimals(), target);
  }

  // sint64 updated_at = 6 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        6, this->_internal_updated_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.TokenMeta)
  return target;
}

::size_t TokenMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.TokenMeta)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [json_name = "name"];
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // string address = 2 [json_name = "address"];
  if (!this->_internal_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_address());
  }

  // string symbol = 3 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_symbol());
  }

  // string logo = 4 [json_name = "logo"];
  if (!this->_internal_logo().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_logo());
  }

  // sint64 updated_at = 6 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_updated_at());
  }

  // sint32 decimals = 5 [json_name = "decimals"];
  if (this->_internal_decimals() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_decimals());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenMeta::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenMeta::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenMeta::GetClassData() const { return &_class_data_; }


void TokenMeta::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenMeta*>(&to_msg);
  auto& from = static_cast<const TokenMeta&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.TokenMeta)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (!from._internal_symbol().empty()) {
    _this->_internal_set_symbol(from._internal_symbol());
  }
  if (!from._internal_logo().empty()) {
    _this->_internal_set_logo(from._internal_logo());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  if (from._internal_decimals() != 0) {
    _this->_internal_set_decimals(from._internal_decimals());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenMeta::CopyFrom(const TokenMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.TokenMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenMeta::IsInitialized() const {
  return true;
}

void TokenMeta::InternalSwap(TokenMeta* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, lhs_arena,
                                       &other->_impl_.address_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.symbol_, lhs_arena,
                                       &other->_impl_.symbol_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.logo_, lhs_arena,
                                       &other->_impl_.logo_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenMeta, _impl_.decimals_)
      + sizeof(TokenMeta::_impl_.decimals_)
      - PROTOBUF_FIELD_OFFSET(TokenMeta, _impl_.updated_at_)>(
          reinterpret_cast<char*>(&_impl_.updated_at_),
          reinterpret_cast<char*>(&other->_impl_.updated_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenMeta::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[3]);
}
// ===================================================================

class MarketRequest::_Internal {
 public:
};

MarketRequest::MarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.MarketRequest)
}
MarketRequest::MarketRequest(const MarketRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.MarketRequest)
}

inline void MarketRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarketRequest::~MarketRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.MarketRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
}

void MarketRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.MarketRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.MarketRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.MarketRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.MarketRequest.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.MarketRequest)
  return target;
}

::size_t MarketRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.MarketRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketRequest::GetClassData() const { return &_class_data_; }


void MarketRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketRequest*>(&to_msg);
  auto& from = static_cast<const MarketRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.MarketRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketRequest::CopyFrom(const MarketRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.MarketRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketRequest::IsInitialized() const {
  return true;
}

void MarketRequest::InternalSwap(MarketRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[4]);
}
// ===================================================================

class MarketResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MarketResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MarketResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotMarketInfo& market(const MarketResponse* msg);
  static void set_has_market(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotMarketInfo&
MarketResponse::_Internal::market(const MarketResponse* msg) {
  return *msg->_impl_.market_;
}
MarketResponse::MarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.MarketResponse)
}
MarketResponse::MarketResponse(const MarketResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_ = new ::injective_spot_exchange_rpc::SpotMarketInfo(*from._impl_.market_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.MarketResponse)
}

inline void MarketResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}
  };
}

MarketResponse::~MarketResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.MarketResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.market_;
}

void MarketResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.MarketResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.market_ != nullptr);
    _impl_.market_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.MarketResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::market(this),
        _Internal::market(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.MarketResponse)
  return target;
}

::size_t MarketResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.MarketResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.market_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketResponse::GetClassData() const { return &_class_data_; }


void MarketResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketResponse*>(&to_msg);
  auto& from = static_cast<const MarketResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.MarketResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_market()->::injective_spot_exchange_rpc::SpotMarketInfo::MergeFrom(
        from._internal_market());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketResponse::CopyFrom(const MarketResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.MarketResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketResponse::IsInitialized() const {
  return true;
}

void MarketResponse::InternalSwap(MarketResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.market_, other->_impl_.market_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[5]);
}
// ===================================================================

class StreamMarketsRequest::_Internal {
 public:
};

StreamMarketsRequest::StreamMarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamMarketsRequest)
}
StreamMarketsRequest::StreamMarketsRequest(const StreamMarketsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamMarketsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamMarketsRequest)
}

inline void StreamMarketsRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamMarketsRequest::~StreamMarketsRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamMarketsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamMarketsRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
}

void StreamMarketsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamMarketsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamMarketsRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamMarketsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string market_ids = 1 [json_name = "marketIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamMarketsRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamMarketsRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamMarketsRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamMarketsRequest.market_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamMarketsRequest)
  return target;
}

::size_t StreamMarketsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamMarketsRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamMarketsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamMarketsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamMarketsRequest::GetClassData() const { return &_class_data_; }


void StreamMarketsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamMarketsRequest*>(&to_msg);
  auto& from = static_cast<const StreamMarketsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamMarketsRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamMarketsRequest::CopyFrom(const StreamMarketsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamMarketsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamMarketsRequest::IsInitialized() const {
  return true;
}

void StreamMarketsRequest::InternalSwap(StreamMarketsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamMarketsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[6]);
}
// ===================================================================

class StreamMarketsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamMarketsResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamMarketsResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotMarketInfo& market(const StreamMarketsResponse* msg);
  static void set_has_market(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotMarketInfo&
StreamMarketsResponse::_Internal::market(const StreamMarketsResponse* msg) {
  return *msg->_impl_.market_;
}
StreamMarketsResponse::StreamMarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamMarketsResponse)
}
StreamMarketsResponse::StreamMarketsResponse(const StreamMarketsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamMarketsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_type().empty()) {
    _this->_impl_.operation_type_.Set(from._internal_operation_type(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_ = new ::injective_spot_exchange_rpc::SpotMarketInfo(*from._impl_.market_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamMarketsResponse)
}

inline void StreamMarketsResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamMarketsResponse::~StreamMarketsResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamMarketsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamMarketsResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.operation_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.market_;
}

void StreamMarketsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamMarketsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamMarketsResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_type_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.market_ != nullptr);
    _impl_.market_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamMarketsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string operation_type = 2 [json_name = "operationType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamMarketsResponse.operation_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamMarketsResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamMarketsResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::market(this),
        _Internal::market(this).GetCachedSize(), target, stream);
  }

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    const std::string& _s = this->_internal_operation_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamMarketsResponse.operation_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamMarketsResponse)
  return target;
}

::size_t StreamMarketsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamMarketsResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_operation_type());
  }

  // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.market_);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamMarketsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamMarketsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamMarketsResponse::GetClassData() const { return &_class_data_; }


void StreamMarketsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamMarketsResponse*>(&to_msg);
  auto& from = static_cast<const StreamMarketsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamMarketsResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_operation_type().empty()) {
    _this->_internal_set_operation_type(from._internal_operation_type());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_market()->::injective_spot_exchange_rpc::SpotMarketInfo::MergeFrom(
        from._internal_market());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamMarketsResponse::CopyFrom(const StreamMarketsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamMarketsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamMarketsResponse::IsInitialized() const {
  return true;
}

void StreamMarketsResponse::InternalSwap(StreamMarketsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_type_, lhs_arena,
                                       &other->_impl_.operation_type_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamMarketsResponse, _impl_.timestamp_)
      + sizeof(StreamMarketsResponse::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamMarketsResponse, _impl_.market_)>(
          reinterpret_cast<char*>(&_impl_.market_),
          reinterpret_cast<char*>(&other->_impl_.market_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamMarketsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[7]);
}
// ===================================================================

class OrderbookRequest::_Internal {
 public:
};

OrderbookRequest::OrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbookRequest)
}
OrderbookRequest::OrderbookRequest(const OrderbookRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbookRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbookRequest)
}

inline void OrderbookRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrderbookRequest::~OrderbookRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbookRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbookRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
}

void OrderbookRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbookRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbookRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbookRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrderbookRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbookRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbookRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrderbookRequest.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbookRequest)
  return target;
}

::size_t OrderbookRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbookRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbookRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbookRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbookRequest::GetClassData() const { return &_class_data_; }


void OrderbookRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbookRequest*>(&to_msg);
  auto& from = static_cast<const OrderbookRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbookRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbookRequest::CopyFrom(const OrderbookRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbookRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbookRequest::IsInitialized() const {
  return true;
}

void OrderbookRequest::InternalSwap(OrderbookRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbookRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[8]);
}
// ===================================================================

class OrderbookResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<OrderbookResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OrderbookResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotLimitOrderbook& orderbook(const OrderbookResponse* msg);
  static void set_has_orderbook(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotLimitOrderbook&
OrderbookResponse::_Internal::orderbook(const OrderbookResponse* msg) {
  return *msg->_impl_.orderbook_;
}
OrderbookResponse::OrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbookResponse)
}
OrderbookResponse::OrderbookResponse(const OrderbookResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbookResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orderbook_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_ = new ::injective_spot_exchange_rpc::SpotLimitOrderbook(*from._impl_.orderbook_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbookResponse)
}

inline void OrderbookResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orderbook_){nullptr}
  };
}

OrderbookResponse::~OrderbookResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbookResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbookResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.orderbook_;
}

void OrderbookResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbookResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbookResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_ != nullptr);
    _impl_.orderbook_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbookResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbookResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbookResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::orderbook(this),
        _Internal::orderbook(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbookResponse)
  return target;
}

::size_t OrderbookResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbookResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbookResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbookResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbookResponse::GetClassData() const { return &_class_data_; }


void OrderbookResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbookResponse*>(&to_msg);
  auto& from = static_cast<const OrderbookResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbookResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook()->::injective_spot_exchange_rpc::SpotLimitOrderbook::MergeFrom(
        from._internal_orderbook());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbookResponse::CopyFrom(const OrderbookResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbookResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbookResponse::IsInitialized() const {
  return true;
}

void OrderbookResponse::InternalSwap(OrderbookResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.orderbook_, other->_impl_.orderbook_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbookResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[9]);
}
// ===================================================================

class SpotLimitOrderbook::_Internal {
 public:
};

SpotLimitOrderbook::SpotLimitOrderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SpotLimitOrderbook)
}
SpotLimitOrderbook::SpotLimitOrderbook(const SpotLimitOrderbook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotLimitOrderbook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buys_){from._impl_.buys_}
    , decltype(_impl_.sells_){from._impl_.sells_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SpotLimitOrderbook)
}

inline void SpotLimitOrderbook::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.buys_){arena}
    , decltype(_impl_.sells_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SpotLimitOrderbook::~SpotLimitOrderbook() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SpotLimitOrderbook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotLimitOrderbook::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_buys()->~RepeatedPtrField();
  _internal_mutable_sells()->~RepeatedPtrField();
}

void SpotLimitOrderbook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotLimitOrderbook::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SpotLimitOrderbook)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_buys()->Clear();
  _internal_mutable_sells()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotLimitOrderbook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotLimitOrderbook::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SpotLimitOrderbook)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buys_size()); i < n; i++) {
    const auto& repfield = this->_internal_buys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sells_size()); i < n; i++) {
    const auto& repfield = this->_internal_sells(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SpotLimitOrderbook)
  return target;
}

::size_t SpotLimitOrderbook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SpotLimitOrderbook)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  total_size += 1UL * this->_internal_buys_size();
  for (const auto& msg : this->_internal_buys()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  total_size += 1UL * this->_internal_sells_size();
  for (const auto& msg : this->_internal_sells()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotLimitOrderbook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotLimitOrderbook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotLimitOrderbook::GetClassData() const { return &_class_data_; }


void SpotLimitOrderbook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotLimitOrderbook*>(&to_msg);
  auto& from = static_cast<const SpotLimitOrderbook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SpotLimitOrderbook)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_buys()->MergeFrom(from._internal_buys());
  _this->_internal_mutable_sells()->MergeFrom(from._internal_sells());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotLimitOrderbook::CopyFrom(const SpotLimitOrderbook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SpotLimitOrderbook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotLimitOrderbook::IsInitialized() const {
  return true;
}

void SpotLimitOrderbook::InternalSwap(SpotLimitOrderbook* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_buys()->InternalSwap(other->_internal_mutable_buys());
  _internal_mutable_sells()->InternalSwap(other->_internal_mutable_sells());
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotLimitOrderbook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[10]);
}
// ===================================================================

class PriceLevel::_Internal {
 public:
};

PriceLevel::PriceLevel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.PriceLevel)
}
PriceLevel::PriceLevel(const PriceLevel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceLevel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.PriceLevel)
}

inline void PriceLevel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceLevel::~PriceLevel() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.PriceLevel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceLevel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_.Destroy();
  _impl_.quantity_.Destroy();
}

void PriceLevel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceLevel::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.PriceLevel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_.ClearToEmpty();
  _impl_.quantity_.ClearToEmpty();
  _impl_.timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceLevel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string price = 1 [json_name = "price"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.PriceLevel.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 2 [json_name = "quantity"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.PriceLevel.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceLevel::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.PriceLevel)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string price = 1 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.PriceLevel.price");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string quantity = 2 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.PriceLevel.quantity");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.PriceLevel)
  return target;
}

::size_t PriceLevel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.PriceLevel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price = 1 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string quantity = 2 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceLevel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceLevel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceLevel::GetClassData() const { return &_class_data_; }


void PriceLevel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceLevel*>(&to_msg);
  auto& from = static_cast<const PriceLevel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.PriceLevel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceLevel::CopyFrom(const PriceLevel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.PriceLevel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceLevel::IsInitialized() const {
  return true;
}

void PriceLevel::InternalSwap(PriceLevel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);

  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceLevel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[11]);
}
// ===================================================================

class OrderbookV2Request::_Internal {
 public:
};

OrderbookV2Request::OrderbookV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbookV2Request)
}
OrderbookV2Request::OrderbookV2Request(const OrderbookV2Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbookV2Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbookV2Request)
}

inline void OrderbookV2Request::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrderbookV2Request::~OrderbookV2Request() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbookV2Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbookV2Request::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
}

void OrderbookV2Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbookV2Request::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbookV2Request)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbookV2Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrderbookV2Request.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbookV2Request::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbookV2Request)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrderbookV2Request.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbookV2Request)
  return target;
}

::size_t OrderbookV2Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbookV2Request)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbookV2Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbookV2Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbookV2Request::GetClassData() const { return &_class_data_; }


void OrderbookV2Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbookV2Request*>(&to_msg);
  auto& from = static_cast<const OrderbookV2Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbookV2Request)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbookV2Request::CopyFrom(const OrderbookV2Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbookV2Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbookV2Request::IsInitialized() const {
  return true;
}

void OrderbookV2Request::InternalSwap(OrderbookV2Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbookV2Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[12]);
}
// ===================================================================

class OrderbookV2Response::_Internal {
 public:
  using HasBits = decltype(std::declval<OrderbookV2Response>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OrderbookV2Response, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& orderbook(const OrderbookV2Response* msg);
  static void set_has_orderbook(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2&
OrderbookV2Response::_Internal::orderbook(const OrderbookV2Response* msg) {
  return *msg->_impl_.orderbook_;
}
OrderbookV2Response::OrderbookV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbookV2Response)
}
OrderbookV2Response::OrderbookV2Response(const OrderbookV2Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbookV2Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orderbook_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_ = new ::injective_spot_exchange_rpc::SpotLimitOrderbookV2(*from._impl_.orderbook_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbookV2Response)
}

inline void OrderbookV2Response::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orderbook_){nullptr}
  };
}

OrderbookV2Response::~OrderbookV2Response() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbookV2Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbookV2Response::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.orderbook_;
}

void OrderbookV2Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbookV2Response::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbookV2Response)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_ != nullptr);
    _impl_.orderbook_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbookV2Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbookV2Response::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbookV2Response)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::orderbook(this),
        _Internal::orderbook(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbookV2Response)
  return target;
}

::size_t OrderbookV2Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbookV2Response)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbookV2Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbookV2Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbookV2Response::GetClassData() const { return &_class_data_; }


void OrderbookV2Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbookV2Response*>(&to_msg);
  auto& from = static_cast<const OrderbookV2Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbookV2Response)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook()->::injective_spot_exchange_rpc::SpotLimitOrderbookV2::MergeFrom(
        from._internal_orderbook());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbookV2Response::CopyFrom(const OrderbookV2Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbookV2Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbookV2Response::IsInitialized() const {
  return true;
}

void OrderbookV2Response::InternalSwap(OrderbookV2Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.orderbook_, other->_impl_.orderbook_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbookV2Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[13]);
}
// ===================================================================

class SpotLimitOrderbookV2::_Internal {
 public:
};

SpotLimitOrderbookV2::SpotLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
}
SpotLimitOrderbookV2::SpotLimitOrderbookV2(const SpotLimitOrderbookV2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotLimitOrderbookV2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buys_){from._impl_.buys_}
    , decltype(_impl_.sells_){from._impl_.sells_}
    , decltype(_impl_.sequence_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sequence_ = from._impl_.sequence_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
}

inline void SpotLimitOrderbookV2::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.buys_){arena}
    , decltype(_impl_.sells_){arena}
    , decltype(_impl_.sequence_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SpotLimitOrderbookV2::~SpotLimitOrderbookV2() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotLimitOrderbookV2::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_buys()->~RepeatedPtrField();
  _internal_mutable_sells()->~RepeatedPtrField();
}

void SpotLimitOrderbookV2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotLimitOrderbookV2::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_buys()->Clear();
  _internal_mutable_sells()->Clear();
  _impl_.sequence_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotLimitOrderbookV2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 sequence = 3 [json_name = "sequence"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotLimitOrderbookV2::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buys_size()); i < n; i++) {
    const auto& repfield = this->_internal_buys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sells_size()); i < n; i++) {
    const auto& repfield = this->_internal_sells(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint64 sequence = 3 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_sequence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
  return target;
}

::size_t SpotLimitOrderbookV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  total_size += 1UL * this->_internal_buys_size();
  for (const auto& msg : this->_internal_buys()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  total_size += 1UL * this->_internal_sells_size();
  for (const auto& msg : this->_internal_sells()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 sequence = 3 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_sequence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotLimitOrderbookV2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotLimitOrderbookV2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotLimitOrderbookV2::GetClassData() const { return &_class_data_; }


void SpotLimitOrderbookV2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotLimitOrderbookV2*>(&to_msg);
  auto& from = static_cast<const SpotLimitOrderbookV2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_buys()->MergeFrom(from._internal_buys());
  _this->_internal_mutable_sells()->MergeFrom(from._internal_sells());
  if (from._internal_sequence() != 0) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotLimitOrderbookV2::CopyFrom(const SpotLimitOrderbookV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotLimitOrderbookV2::IsInitialized() const {
  return true;
}

void SpotLimitOrderbookV2::InternalSwap(SpotLimitOrderbookV2* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_buys()->InternalSwap(other->_internal_mutable_buys());
  _internal_mutable_sells()->InternalSwap(other->_internal_mutable_sells());

  swap(_impl_.sequence_, other->_impl_.sequence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotLimitOrderbookV2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[14]);
}
// ===================================================================

class OrderbooksRequest::_Internal {
 public:
};

OrderbooksRequest::OrderbooksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbooksRequest)
}
OrderbooksRequest::OrderbooksRequest(const OrderbooksRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbooksRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbooksRequest)
}

inline void OrderbooksRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OrderbooksRequest::~OrderbooksRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbooksRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbooksRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
}

void OrderbooksRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbooksRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbooksRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbooksRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string market_ids = 1 [json_name = "marketIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrderbooksRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbooksRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbooksRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrderbooksRequest.market_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbooksRequest)
  return target;
}

::size_t OrderbooksRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbooksRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbooksRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbooksRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbooksRequest::GetClassData() const { return &_class_data_; }


void OrderbooksRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbooksRequest*>(&to_msg);
  auto& from = static_cast<const OrderbooksRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbooksRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbooksRequest::CopyFrom(const OrderbooksRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbooksRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbooksRequest::IsInitialized() const {
  return true;
}

void OrderbooksRequest::InternalSwap(OrderbooksRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbooksRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[15]);
}
// ===================================================================

class OrderbooksResponse::_Internal {
 public:
};

OrderbooksResponse::OrderbooksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbooksResponse)
}
OrderbooksResponse::OrderbooksResponse(const OrderbooksResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbooksResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.orderbooks_){from._impl_.orderbooks_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbooksResponse)
}

inline void OrderbooksResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.orderbooks_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OrderbooksResponse::~OrderbooksResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbooksResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbooksResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_orderbooks()->~RepeatedPtrField();
}

void OrderbooksResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbooksResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbooksResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_orderbooks()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbooksResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbook orderbooks = 1 [json_name = "orderbooks"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orderbooks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbooksResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbooksResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbook orderbooks = 1 [json_name = "orderbooks"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orderbooks_size()); i < n; i++) {
    const auto& repfield = this->_internal_orderbooks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbooksResponse)
  return target;
}

::size_t OrderbooksResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbooksResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbook orderbooks = 1 [json_name = "orderbooks"];
  total_size += 1UL * this->_internal_orderbooks_size();
  for (const auto& msg : this->_internal_orderbooks()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbooksResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbooksResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbooksResponse::GetClassData() const { return &_class_data_; }


void OrderbooksResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbooksResponse*>(&to_msg);
  auto& from = static_cast<const OrderbooksResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbooksResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_orderbooks()->MergeFrom(from._internal_orderbooks());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbooksResponse::CopyFrom(const OrderbooksResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbooksResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbooksResponse::IsInitialized() const {
  return true;
}

void OrderbooksResponse::InternalSwap(OrderbooksResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_orderbooks()->InternalSwap(other->_internal_mutable_orderbooks());
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbooksResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[16]);
}
// ===================================================================

class SingleSpotLimitOrderbook::_Internal {
 public:
  using HasBits = decltype(std::declval<SingleSpotLimitOrderbook>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SingleSpotLimitOrderbook, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotLimitOrderbook& orderbook(const SingleSpotLimitOrderbook* msg);
  static void set_has_orderbook(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotLimitOrderbook&
SingleSpotLimitOrderbook::_Internal::orderbook(const SingleSpotLimitOrderbook* msg) {
  return *msg->_impl_.orderbook_;
}
SingleSpotLimitOrderbook::SingleSpotLimitOrderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
}
SingleSpotLimitOrderbook::SingleSpotLimitOrderbook(const SingleSpotLimitOrderbook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SingleSpotLimitOrderbook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_ = new ::injective_spot_exchange_rpc::SpotLimitOrderbook(*from._impl_.orderbook_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
}

inline void SingleSpotLimitOrderbook::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SingleSpotLimitOrderbook::~SingleSpotLimitOrderbook() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SingleSpotLimitOrderbook::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.orderbook_;
}

void SingleSpotLimitOrderbook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SingleSpotLimitOrderbook::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_ != nullptr);
    _impl_.orderbook_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SingleSpotLimitOrderbook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SingleSpotLimitOrderbook.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 2 [json_name = "orderbook"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SingleSpotLimitOrderbook::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SingleSpotLimitOrderbook.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 2 [json_name = "orderbook"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::orderbook(this),
        _Internal::orderbook(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
  return target;
}

::size_t SingleSpotLimitOrderbook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 2 [json_name = "orderbook"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SingleSpotLimitOrderbook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SingleSpotLimitOrderbook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SingleSpotLimitOrderbook::GetClassData() const { return &_class_data_; }


void SingleSpotLimitOrderbook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SingleSpotLimitOrderbook*>(&to_msg);
  auto& from = static_cast<const SingleSpotLimitOrderbook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook()->::injective_spot_exchange_rpc::SpotLimitOrderbook::MergeFrom(
        from._internal_orderbook());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SingleSpotLimitOrderbook::CopyFrom(const SingleSpotLimitOrderbook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleSpotLimitOrderbook::IsInitialized() const {
  return true;
}

void SingleSpotLimitOrderbook::InternalSwap(SingleSpotLimitOrderbook* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  swap(_impl_.orderbook_, other->_impl_.orderbook_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SingleSpotLimitOrderbook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[17]);
}
// ===================================================================

class OrderbooksV2Request::_Internal {
 public:
};

OrderbooksV2Request::OrderbooksV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbooksV2Request)
}
OrderbooksV2Request::OrderbooksV2Request(const OrderbooksV2Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbooksV2Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbooksV2Request)
}

inline void OrderbooksV2Request::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OrderbooksV2Request::~OrderbooksV2Request() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbooksV2Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbooksV2Request::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
}

void OrderbooksV2Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbooksV2Request::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbooksV2Request)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbooksV2Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string market_ids = 1 [json_name = "marketIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrderbooksV2Request.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbooksV2Request::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbooksV2Request)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrderbooksV2Request.market_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbooksV2Request)
  return target;
}

::size_t OrderbooksV2Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbooksV2Request)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbooksV2Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbooksV2Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbooksV2Request::GetClassData() const { return &_class_data_; }


void OrderbooksV2Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbooksV2Request*>(&to_msg);
  auto& from = static_cast<const OrderbooksV2Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbooksV2Request)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbooksV2Request::CopyFrom(const OrderbooksV2Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbooksV2Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbooksV2Request::IsInitialized() const {
  return true;
}

void OrderbooksV2Request::InternalSwap(OrderbooksV2Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbooksV2Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[18]);
}
// ===================================================================

class OrderbooksV2Response::_Internal {
 public:
};

OrderbooksV2Response::OrderbooksV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbooksV2Response)
}
OrderbooksV2Response::OrderbooksV2Response(const OrderbooksV2Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbooksV2Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.orderbooks_){from._impl_.orderbooks_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbooksV2Response)
}

inline void OrderbooksV2Response::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.orderbooks_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OrderbooksV2Response::~OrderbooksV2Response() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbooksV2Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbooksV2Response::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_orderbooks()->~RepeatedPtrField();
}

void OrderbooksV2Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbooksV2Response::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbooksV2Response)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_orderbooks()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbooksV2Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1 [json_name = "orderbooks"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orderbooks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbooksV2Response::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbooksV2Response)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1 [json_name = "orderbooks"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orderbooks_size()); i < n; i++) {
    const auto& repfield = this->_internal_orderbooks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbooksV2Response)
  return target;
}

::size_t OrderbooksV2Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbooksV2Response)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1 [json_name = "orderbooks"];
  total_size += 1UL * this->_internal_orderbooks_size();
  for (const auto& msg : this->_internal_orderbooks()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbooksV2Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbooksV2Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbooksV2Response::GetClassData() const { return &_class_data_; }


void OrderbooksV2Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbooksV2Response*>(&to_msg);
  auto& from = static_cast<const OrderbooksV2Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbooksV2Response)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_orderbooks()->MergeFrom(from._internal_orderbooks());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbooksV2Response::CopyFrom(const OrderbooksV2Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbooksV2Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbooksV2Response::IsInitialized() const {
  return true;
}

void OrderbooksV2Response::InternalSwap(OrderbooksV2Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_orderbooks()->InternalSwap(other->_internal_mutable_orderbooks());
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbooksV2Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[19]);
}
// ===================================================================

class SingleSpotLimitOrderbookV2::_Internal {
 public:
  using HasBits = decltype(std::declval<SingleSpotLimitOrderbookV2>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SingleSpotLimitOrderbookV2, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& orderbook(const SingleSpotLimitOrderbookV2* msg);
  static void set_has_orderbook(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2&
SingleSpotLimitOrderbookV2::_Internal::orderbook(const SingleSpotLimitOrderbookV2* msg) {
  return *msg->_impl_.orderbook_;
}
SingleSpotLimitOrderbookV2::SingleSpotLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
}
SingleSpotLimitOrderbookV2::SingleSpotLimitOrderbookV2(const SingleSpotLimitOrderbookV2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SingleSpotLimitOrderbookV2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_ = new ::injective_spot_exchange_rpc::SpotLimitOrderbookV2(*from._impl_.orderbook_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
}

inline void SingleSpotLimitOrderbookV2::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SingleSpotLimitOrderbookV2::~SingleSpotLimitOrderbookV2() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SingleSpotLimitOrderbookV2::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.orderbook_;
}

void SingleSpotLimitOrderbookV2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SingleSpotLimitOrderbookV2::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_ != nullptr);
    _impl_.orderbook_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SingleSpotLimitOrderbookV2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2 [json_name = "orderbook"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SingleSpotLimitOrderbookV2::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2 [json_name = "orderbook"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::orderbook(this),
        _Internal::orderbook(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
  return target;
}

::size_t SingleSpotLimitOrderbookV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2 [json_name = "orderbook"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SingleSpotLimitOrderbookV2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SingleSpotLimitOrderbookV2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SingleSpotLimitOrderbookV2::GetClassData() const { return &_class_data_; }


void SingleSpotLimitOrderbookV2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SingleSpotLimitOrderbookV2*>(&to_msg);
  auto& from = static_cast<const SingleSpotLimitOrderbookV2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook()->::injective_spot_exchange_rpc::SpotLimitOrderbookV2::MergeFrom(
        from._internal_orderbook());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SingleSpotLimitOrderbookV2::CopyFrom(const SingleSpotLimitOrderbookV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleSpotLimitOrderbookV2::IsInitialized() const {
  return true;
}

void SingleSpotLimitOrderbookV2::InternalSwap(SingleSpotLimitOrderbookV2* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  swap(_impl_.orderbook_, other->_impl_.orderbook_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SingleSpotLimitOrderbookV2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[20]);
}
// ===================================================================

class StreamOrderbookRequest::_Internal {
 public:
};

StreamOrderbookRequest::StreamOrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrderbookRequest)
}
StreamOrderbookRequest::StreamOrderbookRequest(const StreamOrderbookRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrderbookRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrderbookRequest)
}

inline void StreamOrderbookRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamOrderbookRequest::~StreamOrderbookRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrderbookRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrderbookRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
}

void StreamOrderbookRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrderbookRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrderbookRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrderbookRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string market_ids = 1 [json_name = "marketIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrderbookRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrderbookRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrderbookRequest)
  return target;
}

::size_t StreamOrderbookRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrderbookRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrderbookRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrderbookRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrderbookRequest::GetClassData() const { return &_class_data_; }


void StreamOrderbookRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrderbookRequest*>(&to_msg);
  auto& from = static_cast<const StreamOrderbookRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrderbookRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrderbookRequest::CopyFrom(const StreamOrderbookRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrderbookRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrderbookRequest::IsInitialized() const {
  return true;
}

void StreamOrderbookRequest::InternalSwap(StreamOrderbookRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrderbookRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[21]);
}
// ===================================================================

class StreamOrderbookResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamOrderbookResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamOrderbookResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotLimitOrderbook& orderbook(const StreamOrderbookResponse* msg);
  static void set_has_orderbook(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotLimitOrderbook&
StreamOrderbookResponse::_Internal::orderbook(const StreamOrderbookResponse* msg) {
  return *msg->_impl_.orderbook_;
}
StreamOrderbookResponse::StreamOrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrderbookResponse)
}
StreamOrderbookResponse::StreamOrderbookResponse(const StreamOrderbookResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrderbookResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_type().empty()) {
    _this->_impl_.operation_type_.Set(from._internal_operation_type(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_ = new ::injective_spot_exchange_rpc::SpotLimitOrderbook(*from._impl_.orderbook_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrderbookResponse)
}

inline void StreamOrderbookResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamOrderbookResponse::~StreamOrderbookResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrderbookResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrderbookResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.operation_type_.Destroy();
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.orderbook_;
}

void StreamOrderbookResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrderbookResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrderbookResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_type_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_ != nullptr);
    _impl_.orderbook_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrderbookResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string operation_type = 2 [json_name = "operationType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookResponse.operation_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 4 [json_name = "marketId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookResponse.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrderbookResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrderbookResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::orderbook(this),
        _Internal::orderbook(this).GetCachedSize(), target, stream);
  }

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    const std::string& _s = this->_internal_operation_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookResponse.operation_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  // string market_id = 4 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookResponse.market_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrderbookResponse)
  return target;
}

::size_t StreamOrderbookResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrderbookResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_operation_type());
  }

  // string market_id = 4 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrderbookResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrderbookResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrderbookResponse::GetClassData() const { return &_class_data_; }


void StreamOrderbookResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrderbookResponse*>(&to_msg);
  auto& from = static_cast<const StreamOrderbookResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrderbookResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_operation_type().empty()) {
    _this->_internal_set_operation_type(from._internal_operation_type());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook()->::injective_spot_exchange_rpc::SpotLimitOrderbook::MergeFrom(
        from._internal_orderbook());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrderbookResponse::CopyFrom(const StreamOrderbookResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrderbookResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrderbookResponse::IsInitialized() const {
  return true;
}

void StreamOrderbookResponse::InternalSwap(StreamOrderbookResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_type_, lhs_arena,
                                       &other->_impl_.operation_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamOrderbookResponse, _impl_.timestamp_)
      + sizeof(StreamOrderbookResponse::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamOrderbookResponse, _impl_.orderbook_)>(
          reinterpret_cast<char*>(&_impl_.orderbook_),
          reinterpret_cast<char*>(&other->_impl_.orderbook_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrderbookResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[22]);
}
// ===================================================================

class StreamOrderbookV2Request::_Internal {
 public:
};

StreamOrderbookV2Request::StreamOrderbookV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrderbookV2Request)
}
StreamOrderbookV2Request::StreamOrderbookV2Request(const StreamOrderbookV2Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrderbookV2Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrderbookV2Request)
}

inline void StreamOrderbookV2Request::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamOrderbookV2Request::~StreamOrderbookV2Request() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrderbookV2Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrderbookV2Request::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
}

void StreamOrderbookV2Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrderbookV2Request::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrderbookV2Request)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrderbookV2Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string market_ids = 1 [json_name = "marketIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrderbookV2Request::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrderbookV2Request)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrderbookV2Request)
  return target;
}

::size_t StreamOrderbookV2Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrderbookV2Request)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrderbookV2Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrderbookV2Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrderbookV2Request::GetClassData() const { return &_class_data_; }


void StreamOrderbookV2Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrderbookV2Request*>(&to_msg);
  auto& from = static_cast<const StreamOrderbookV2Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrderbookV2Request)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrderbookV2Request::CopyFrom(const StreamOrderbookV2Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrderbookV2Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrderbookV2Request::IsInitialized() const {
  return true;
}

void StreamOrderbookV2Request::InternalSwap(StreamOrderbookV2Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrderbookV2Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[23]);
}
// ===================================================================

class StreamOrderbookV2Response::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamOrderbookV2Response>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamOrderbookV2Response, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& orderbook(const StreamOrderbookV2Response* msg);
  static void set_has_orderbook(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2&
StreamOrderbookV2Response::_Internal::orderbook(const StreamOrderbookV2Response* msg) {
  return *msg->_impl_.orderbook_;
}
StreamOrderbookV2Response::StreamOrderbookV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrderbookV2Response)
}
StreamOrderbookV2Response::StreamOrderbookV2Response(const StreamOrderbookV2Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrderbookV2Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_type().empty()) {
    _this->_impl_.operation_type_.Set(from._internal_operation_type(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_ = new ::injective_spot_exchange_rpc::SpotLimitOrderbookV2(*from._impl_.orderbook_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrderbookV2Response)
}

inline void StreamOrderbookV2Response::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamOrderbookV2Response::~StreamOrderbookV2Response() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrderbookV2Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrderbookV2Response::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.operation_type_.Destroy();
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.orderbook_;
}

void StreamOrderbookV2Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrderbookV2Response::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrderbookV2Response)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_type_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_ != nullptr);
    _impl_.orderbook_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrderbookV2Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string operation_type = 2 [json_name = "operationType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookV2Response.operation_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 4 [json_name = "marketId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookV2Response.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrderbookV2Response::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrderbookV2Response)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::orderbook(this),
        _Internal::orderbook(this).GetCachedSize(), target, stream);
  }

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    const std::string& _s = this->_internal_operation_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookV2Response.operation_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  // string market_id = 4 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookV2Response.market_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrderbookV2Response)
  return target;
}

::size_t StreamOrderbookV2Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrderbookV2Response)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_operation_type());
  }

  // string market_id = 4 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrderbookV2Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrderbookV2Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrderbookV2Response::GetClassData() const { return &_class_data_; }


void StreamOrderbookV2Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrderbookV2Response*>(&to_msg);
  auto& from = static_cast<const StreamOrderbookV2Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrderbookV2Response)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_operation_type().empty()) {
    _this->_internal_set_operation_type(from._internal_operation_type());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook()->::injective_spot_exchange_rpc::SpotLimitOrderbookV2::MergeFrom(
        from._internal_orderbook());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrderbookV2Response::CopyFrom(const StreamOrderbookV2Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrderbookV2Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrderbookV2Response::IsInitialized() const {
  return true;
}

void StreamOrderbookV2Response::InternalSwap(StreamOrderbookV2Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_type_, lhs_arena,
                                       &other->_impl_.operation_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamOrderbookV2Response, _impl_.timestamp_)
      + sizeof(StreamOrderbookV2Response::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamOrderbookV2Response, _impl_.orderbook_)>(
          reinterpret_cast<char*>(&_impl_.orderbook_),
          reinterpret_cast<char*>(&other->_impl_.orderbook_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrderbookV2Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[24]);
}
// ===================================================================

class StreamOrderbookUpdateRequest::_Internal {
 public:
};

StreamOrderbookUpdateRequest::StreamOrderbookUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
}
StreamOrderbookUpdateRequest::StreamOrderbookUpdateRequest(const StreamOrderbookUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrderbookUpdateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
}

inline void StreamOrderbookUpdateRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamOrderbookUpdateRequest::~StreamOrderbookUpdateRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrderbookUpdateRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
}

void StreamOrderbookUpdateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrderbookUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrderbookUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string market_ids = 1 [json_name = "marketIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrderbookUpdateRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
  return target;
}

::size_t StreamOrderbookUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 1 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrderbookUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrderbookUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrderbookUpdateRequest::GetClassData() const { return &_class_data_; }


void StreamOrderbookUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrderbookUpdateRequest*>(&to_msg);
  auto& from = static_cast<const StreamOrderbookUpdateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrderbookUpdateRequest::CopyFrom(const StreamOrderbookUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrderbookUpdateRequest::IsInitialized() const {
  return true;
}

void StreamOrderbookUpdateRequest::InternalSwap(StreamOrderbookUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrderbookUpdateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[25]);
}
// ===================================================================

class StreamOrderbookUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamOrderbookUpdateResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamOrderbookUpdateResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::OrderbookLevelUpdates& orderbook_level_updates(const StreamOrderbookUpdateResponse* msg);
  static void set_has_orderbook_level_updates(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::OrderbookLevelUpdates&
StreamOrderbookUpdateResponse::_Internal::orderbook_level_updates(const StreamOrderbookUpdateResponse* msg) {
  return *msg->_impl_.orderbook_level_updates_;
}
StreamOrderbookUpdateResponse::StreamOrderbookUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
}
StreamOrderbookUpdateResponse::StreamOrderbookUpdateResponse(const StreamOrderbookUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrderbookUpdateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_level_updates_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_type().empty()) {
    _this->_impl_.operation_type_.Set(from._internal_operation_type(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_level_updates_ = new ::injective_spot_exchange_rpc::OrderbookLevelUpdates(*from._impl_.orderbook_level_updates_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
}

inline void StreamOrderbookUpdateResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.orderbook_level_updates_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamOrderbookUpdateResponse::~StreamOrderbookUpdateResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrderbookUpdateResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.operation_type_.Destroy();
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.orderbook_level_updates_;
}

void StreamOrderbookUpdateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrderbookUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_type_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_level_updates_ != nullptr);
    _impl_.orderbook_level_updates_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrderbookUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1 [json_name = "orderbookLevelUpdates"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook_level_updates(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string operation_type = 2 [json_name = "operationType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.operation_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 4 [json_name = "marketId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrderbookUpdateResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1 [json_name = "orderbookLevelUpdates"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::orderbook_level_updates(this),
        _Internal::orderbook_level_updates(this).GetCachedSize(), target, stream);
  }

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    const std::string& _s = this->_internal_operation_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.operation_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  // string market_id = 4 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.market_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
  return target;
}

::size_t StreamOrderbookUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_operation_type());
  }

  // string market_id = 4 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1 [json_name = "orderbookLevelUpdates"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_level_updates_);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrderbookUpdateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrderbookUpdateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrderbookUpdateResponse::GetClassData() const { return &_class_data_; }


void StreamOrderbookUpdateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrderbookUpdateResponse*>(&to_msg);
  auto& from = static_cast<const StreamOrderbookUpdateResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_operation_type().empty()) {
    _this->_internal_set_operation_type(from._internal_operation_type());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook_level_updates()->::injective_spot_exchange_rpc::OrderbookLevelUpdates::MergeFrom(
        from._internal_orderbook_level_updates());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrderbookUpdateResponse::CopyFrom(const StreamOrderbookUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrderbookUpdateResponse::IsInitialized() const {
  return true;
}

void StreamOrderbookUpdateResponse::InternalSwap(StreamOrderbookUpdateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_type_, lhs_arena,
                                       &other->_impl_.operation_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamOrderbookUpdateResponse, _impl_.timestamp_)
      + sizeof(StreamOrderbookUpdateResponse::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamOrderbookUpdateResponse, _impl_.orderbook_level_updates_)>(
          reinterpret_cast<char*>(&_impl_.orderbook_level_updates_),
          reinterpret_cast<char*>(&other->_impl_.orderbook_level_updates_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrderbookUpdateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[26]);
}
// ===================================================================

class OrderbookLevelUpdates::_Internal {
 public:
};

OrderbookLevelUpdates::OrderbookLevelUpdates(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrderbookLevelUpdates)
}
OrderbookLevelUpdates::OrderbookLevelUpdates(const OrderbookLevelUpdates& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbookLevelUpdates* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buys_){from._impl_.buys_}
    , decltype(_impl_.sells_){from._impl_.sells_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.sequence_) {}

    , decltype(_impl_.updated_at_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.sequence_, &from._impl_.sequence_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.updated_at_) -
    reinterpret_cast<char*>(&_impl_.sequence_)) + sizeof(_impl_.updated_at_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrderbookLevelUpdates)
}

inline void OrderbookLevelUpdates::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.buys_){arena}
    , decltype(_impl_.sells_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.sequence_) { ::uint64_t{0u} }

    , decltype(_impl_.updated_at_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrderbookLevelUpdates::~OrderbookLevelUpdates() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrderbookLevelUpdates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbookLevelUpdates::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_buys()->~RepeatedPtrField();
  _internal_mutable_sells()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void OrderbookLevelUpdates::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbookLevelUpdates::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrderbookLevelUpdates)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_buys()->Clear();
  _internal_mutable_sells()->Clear();
  _impl_.market_id_.ClearToEmpty();
  ::memset(&_impl_.sequence_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.updated_at_) -
      reinterpret_cast<char*>(&_impl_.sequence_)) + sizeof(_impl_.updated_at_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbookLevelUpdates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrderbookLevelUpdates.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 sequence = 2 [json_name = "sequence"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective_spot_exchange_rpc.PriceLevelUpdate buys = 3 [json_name = "buys"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective_spot_exchange_rpc.PriceLevelUpdate sells = 4 [json_name = "sells"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 updated_at = 5 [json_name = "updatedAt"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbookLevelUpdates::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrderbookLevelUpdates)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrderbookLevelUpdates.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint64 sequence = 2 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_sequence(), target);
  }

  // repeated .injective_spot_exchange_rpc.PriceLevelUpdate buys = 3 [json_name = "buys"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buys_size()); i < n; i++) {
    const auto& repfield = this->_internal_buys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective_spot_exchange_rpc.PriceLevelUpdate sells = 4 [json_name = "sells"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sells_size()); i < n; i++) {
    const auto& repfield = this->_internal_sells(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // sint64 updated_at = 5 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        5, this->_internal_updated_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrderbookLevelUpdates)
  return target;
}

::size_t OrderbookLevelUpdates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrderbookLevelUpdates)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.PriceLevelUpdate buys = 3 [json_name = "buys"];
  total_size += 1UL * this->_internal_buys_size();
  for (const auto& msg : this->_internal_buys()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective_spot_exchange_rpc.PriceLevelUpdate sells = 4 [json_name = "sells"];
  total_size += 1UL * this->_internal_sells_size();
  for (const auto& msg : this->_internal_sells()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // uint64 sequence = 2 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_sequence());
  }

  // sint64 updated_at = 5 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_updated_at());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbookLevelUpdates::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbookLevelUpdates::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbookLevelUpdates::GetClassData() const { return &_class_data_; }


void OrderbookLevelUpdates::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbookLevelUpdates*>(&to_msg);
  auto& from = static_cast<const OrderbookLevelUpdates&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrderbookLevelUpdates)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_buys()->MergeFrom(from._internal_buys());
  _this->_internal_mutable_sells()->MergeFrom(from._internal_sells());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_sequence() != 0) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbookLevelUpdates::CopyFrom(const OrderbookLevelUpdates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrderbookLevelUpdates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbookLevelUpdates::IsInitialized() const {
  return true;
}

void OrderbookLevelUpdates::InternalSwap(OrderbookLevelUpdates* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_buys()->InternalSwap(other->_internal_mutable_buys());
  _internal_mutable_sells()->InternalSwap(other->_internal_mutable_sells());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OrderbookLevelUpdates, _impl_.updated_at_)
      + sizeof(OrderbookLevelUpdates::_impl_.updated_at_)
      - PROTOBUF_FIELD_OFFSET(OrderbookLevelUpdates, _impl_.sequence_)>(
          reinterpret_cast<char*>(&_impl_.sequence_),
          reinterpret_cast<char*>(&other->_impl_.sequence_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbookLevelUpdates::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[27]);
}
// ===================================================================

class PriceLevelUpdate::_Internal {
 public:
};

PriceLevelUpdate::PriceLevelUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.PriceLevelUpdate)
}
PriceLevelUpdate::PriceLevelUpdate(const PriceLevelUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceLevelUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.timestamp_) {}

    , decltype(_impl_.is_active_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_active_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.is_active_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.PriceLevelUpdate)
}

inline void PriceLevelUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.timestamp_) { ::int64_t{0} }

    , decltype(_impl_.is_active_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceLevelUpdate::~PriceLevelUpdate() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.PriceLevelUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceLevelUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_.Destroy();
  _impl_.quantity_.Destroy();
}

void PriceLevelUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceLevelUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.PriceLevelUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_.ClearToEmpty();
  _impl_.quantity_.ClearToEmpty();
  ::memset(&_impl_.timestamp_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_active_) -
      reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.is_active_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceLevelUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string price = 1 [json_name = "price"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.PriceLevelUpdate.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 2 [json_name = "quantity"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.PriceLevelUpdate.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_active = 3 [json_name = "isActive"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 4 [json_name = "timestamp"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceLevelUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.PriceLevelUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string price = 1 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.PriceLevelUpdate.price");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string quantity = 2 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.PriceLevelUpdate.quantity");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // bool is_active = 3 [json_name = "isActive"];
  if (this->_internal_is_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_is_active(), target);
  }

  // sint64 timestamp = 4 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        4, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.PriceLevelUpdate)
  return target;
}

::size_t PriceLevelUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.PriceLevelUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price = 1 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string quantity = 2 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // sint64 timestamp = 4 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  // bool is_active = 3 [json_name = "isActive"];
  if (this->_internal_is_active() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceLevelUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceLevelUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceLevelUpdate::GetClassData() const { return &_class_data_; }


void PriceLevelUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceLevelUpdate*>(&to_msg);
  auto& from = static_cast<const PriceLevelUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.PriceLevelUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_is_active() != 0) {
    _this->_internal_set_is_active(from._internal_is_active());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceLevelUpdate::CopyFrom(const PriceLevelUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.PriceLevelUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceLevelUpdate::IsInitialized() const {
  return true;
}

void PriceLevelUpdate::InternalSwap(PriceLevelUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PriceLevelUpdate, _impl_.is_active_)
      + sizeof(PriceLevelUpdate::_impl_.is_active_)
      - PROTOBUF_FIELD_OFFSET(PriceLevelUpdate, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceLevelUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[28]);
}
// ===================================================================

class OrdersRequest::_Internal {
 public:
};

OrdersRequest::OrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrdersRequest)
}
OrdersRequest::OrdersRequest(const OrdersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrdersRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.end_time_) {}

    , decltype(_impl_.limit_) {}

    , decltype(_impl_.include_inactive_) {}

    , decltype(_impl_.subaccount_total_orders_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_side().empty()) {
    _this->_impl_.order_side_.Set(from._internal_order_side(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.subaccount_total_orders_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.subaccount_total_orders_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrdersRequest)
}

inline void OrdersRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.start_time_) { ::int64_t{0} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

    , decltype(_impl_.limit_) { 0 }

    , decltype(_impl_.include_inactive_) { false }

    , decltype(_impl_.subaccount_total_orders_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrdersRequest::~OrdersRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrdersRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrdersRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
  _impl_.order_side_.Destroy();
  _impl_.subaccount_id_.Destroy();
}

void OrdersRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrdersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrdersRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _impl_.order_side_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.subaccount_total_orders_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.subaccount_total_orders_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrdersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string order_side = 2 [json_name = "orderSide"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_order_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersRequest.order_side"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 3 [json_name = "subaccountId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 4 [json_name = "skip"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 5 [json_name = "limit"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 start_time = 6 [json_name = "startTime"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 end_time = 7 [json_name = "endTime"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string market_ids = 8 [json_name = "marketIds"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool include_inactive = 9 [json_name = "includeInactive"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.include_inactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.subaccount_total_orders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrdersRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrdersRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersRequest.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string order_side = 2 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    const std::string& _s = this->_internal_order_side();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersRequest.order_side");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string subaccount_id = 3 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // uint64 skip = 4 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_skip(), target);
  }

  // sint32 limit = 5 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        5, this->_internal_limit(), target);
  }

  // sint64 start_time = 6 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        6, this->_internal_start_time(), target);
  }

  // sint64 end_time = 7 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this->_internal_end_time(), target);
  }

  // repeated string market_ids = 8 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersRequest.market_ids");
    target = stream->WriteString(8, s, target);
  }

  // bool include_inactive = 9 [json_name = "includeInactive"];
  if (this->_internal_include_inactive() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_include_inactive(), target);
  }

  // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
  if (this->_internal_subaccount_total_orders() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_subaccount_total_orders(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrdersRequest)
  return target;
}

::size_t OrdersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrdersRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 8 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string order_side = 2 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_side());
  }

  // string subaccount_id = 3 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // uint64 skip = 4 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint64 start_time = 6 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_start_time());
  }

  // sint64 end_time = 7 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_end_time());
  }

  // sint32 limit = 5 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  // bool include_inactive = 9 [json_name = "includeInactive"];
  if (this->_internal_include_inactive() != 0) {
    total_size += 2;
  }

  // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
  if (this->_internal_subaccount_total_orders() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrdersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrdersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrdersRequest::GetClassData() const { return &_class_data_; }


void OrdersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrdersRequest*>(&to_msg);
  auto& from = static_cast<const OrdersRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrdersRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_order_side().empty()) {
    _this->_internal_set_order_side(from._internal_order_side());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_start_time() != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  if (from._internal_end_time() != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  if (from._internal_include_inactive() != 0) {
    _this->_internal_set_include_inactive(from._internal_include_inactive());
  }
  if (from._internal_subaccount_total_orders() != 0) {
    _this->_internal_set_subaccount_total_orders(from._internal_subaccount_total_orders());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrdersRequest::CopyFrom(const OrdersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrdersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrdersRequest::IsInitialized() const {
  return true;
}

void OrdersRequest::InternalSwap(OrdersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_side_, lhs_arena,
                                       &other->_impl_.order_side_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OrdersRequest, _impl_.subaccount_total_orders_)
      + sizeof(OrdersRequest::_impl_.subaccount_total_orders_)
      - PROTOBUF_FIELD_OFFSET(OrdersRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OrdersRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[29]);
}
// ===================================================================

class OrdersResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<OrdersResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OrdersResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::Paging& paging(const OrdersResponse* msg);
  static void set_has_paging(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::Paging&
OrdersResponse::_Internal::paging(const OrdersResponse* msg) {
  return *msg->_impl_.paging_;
}
OrdersResponse::OrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrdersResponse)
}
OrdersResponse::OrdersResponse(const OrdersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrdersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){from._impl_.orders_}
    , decltype(_impl_.paging_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.paging_ = new ::injective_spot_exchange_rpc::Paging(*from._impl_.paging_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrdersResponse)
}

inline void OrdersResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){arena}
    , decltype(_impl_.paging_){nullptr}
  };
}

OrdersResponse::~OrdersResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrdersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrdersResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_orders()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.paging_;
}

void OrdersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrdersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrdersResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_orders()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.paging_ != nullptr);
    _impl_.paging_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrdersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_paging(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrdersResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrdersResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::paging(this),
        _Internal::paging(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrdersResponse)
  return target;
}

::size_t OrdersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrdersResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
  total_size += 1UL * this->_internal_orders_size();
  for (const auto& msg : this->_internal_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.paging_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrdersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrdersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrdersResponse::GetClassData() const { return &_class_data_; }


void OrdersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrdersResponse*>(&to_msg);
  auto& from = static_cast<const OrdersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrdersResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_orders()->MergeFrom(from._internal_orders());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_paging()->::injective_spot_exchange_rpc::Paging::MergeFrom(
        from._internal_paging());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrdersResponse::CopyFrom(const OrdersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrdersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrdersResponse::IsInitialized() const {
  return true;
}

void OrdersResponse::InternalSwap(OrdersResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_orders()->InternalSwap(other->_internal_mutable_orders());
  swap(_impl_.paging_, other->_impl_.paging_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrdersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[30]);
}
// ===================================================================

class SpotLimitOrder::_Internal {
 public:
};

SpotLimitOrder::SpotLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SpotLimitOrder)
}
SpotLimitOrder::SpotLimitOrder(const SpotLimitOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotLimitOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.unfilled_quantity_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.fee_recipient_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.created_at_) {}

    , decltype(_impl_.updated_at_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_side().empty()) {
    _this->_impl_.order_side_.Set(from._internal_order_side(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.unfilled_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.unfilled_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_unfilled_quantity().empty()) {
    _this->_impl_.unfilled_quantity_.Set(from._internal_unfilled_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  _impl_.fee_recipient_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_recipient().empty()) {
    _this->_impl_.fee_recipient_.Set(from._internal_fee_recipient(), _this->GetArenaForAllocation());
  }
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state().empty()) {
    _this->_impl_.state_.Set(from._internal_state(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.created_at_, &from._impl_.created_at_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.updated_at_) -
    reinterpret_cast<char*>(&_impl_.created_at_)) + sizeof(_impl_.updated_at_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SpotLimitOrder)
}

inline void SpotLimitOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.unfilled_quantity_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.fee_recipient_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.created_at_) { ::int64_t{0} }

    , decltype(_impl_.updated_at_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unfilled_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.unfilled_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_recipient_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotLimitOrder::~SpotLimitOrder() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SpotLimitOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotLimitOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.order_hash_.Destroy();
  _impl_.order_side_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.subaccount_id_.Destroy();
  _impl_.price_.Destroy();
  _impl_.quantity_.Destroy();
  _impl_.unfilled_quantity_.Destroy();
  _impl_.trigger_price_.Destroy();
  _impl_.fee_recipient_.Destroy();
  _impl_.state_.Destroy();
}

void SpotLimitOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotLimitOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SpotLimitOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.order_hash_.ClearToEmpty();
  _impl_.order_side_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.price_.ClearToEmpty();
  _impl_.quantity_.ClearToEmpty();
  _impl_.unfilled_quantity_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  _impl_.fee_recipient_.ClearToEmpty();
  _impl_.state_.ClearToEmpty();
  ::memset(&_impl_.created_at_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.updated_at_) -
      reinterpret_cast<char*>(&_impl_.created_at_)) + sizeof(_impl_.updated_at_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotLimitOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string order_hash = 1 [json_name = "orderHash"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.order_hash"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string order_side = 2 [json_name = "orderSide"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_order_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.order_side"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 3 [json_name = "marketId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 4 [json_name = "subaccountId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string price = 5 [json_name = "price"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 6 [json_name = "quantity"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string unfilled_quantity = 7 [json_name = "unfilledQuantity"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_unfilled_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.unfilled_quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 8 [json_name = "triggerPrice"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string fee_recipient = 9 [json_name = "feeRecipient"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_fee_recipient();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.fee_recipient"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string state = 10 [json_name = "state"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotLimitOrder.state"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 created_at = 11 [json_name = "createdAt"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _impl_.created_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 updated_at = 12 [json_name = "updatedAt"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotLimitOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SpotLimitOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.order_hash");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string order_side = 2 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    const std::string& _s = this->_internal_order_side();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.order_side");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string market_id = 3 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.market_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.subaccount_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string price = 5 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.price");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // string quantity = 6 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.quantity");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // string unfilled_quantity = 7 [json_name = "unfilledQuantity"];
  if (!this->_internal_unfilled_quantity().empty()) {
    const std::string& _s = this->_internal_unfilled_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.unfilled_quantity");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // string trigger_price = 8 [json_name = "triggerPrice"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.trigger_price");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string fee_recipient = 9 [json_name = "feeRecipient"];
  if (!this->_internal_fee_recipient().empty()) {
    const std::string& _s = this->_internal_fee_recipient();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.fee_recipient");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string state = 10 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    const std::string& _s = this->_internal_state();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotLimitOrder.state");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // sint64 created_at = 11 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        11, this->_internal_created_at(), target);
  }

  // sint64 updated_at = 12 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        12, this->_internal_updated_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SpotLimitOrder)
  return target;
}

::size_t SpotLimitOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SpotLimitOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_hash());
  }

  // string order_side = 2 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_side());
  }

  // string market_id = 3 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string price = 5 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string quantity = 6 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // string unfilled_quantity = 7 [json_name = "unfilledQuantity"];
  if (!this->_internal_unfilled_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_unfilled_quantity());
  }

  // string trigger_price = 8 [json_name = "triggerPrice"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // string fee_recipient = 9 [json_name = "feeRecipient"];
  if (!this->_internal_fee_recipient().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fee_recipient());
  }

  // string state = 10 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_state());
  }

  // sint64 created_at = 11 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_created_at());
  }

  // sint64 updated_at = 12 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_updated_at());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotLimitOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotLimitOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotLimitOrder::GetClassData() const { return &_class_data_; }


void SpotLimitOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotLimitOrder*>(&to_msg);
  auto& from = static_cast<const SpotLimitOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SpotLimitOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if (!from._internal_order_side().empty()) {
    _this->_internal_set_order_side(from._internal_order_side());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (!from._internal_unfilled_quantity().empty()) {
    _this->_internal_set_unfilled_quantity(from._internal_unfilled_quantity());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if (!from._internal_fee_recipient().empty()) {
    _this->_internal_set_fee_recipient(from._internal_fee_recipient());
  }
  if (!from._internal_state().empty()) {
    _this->_internal_set_state(from._internal_state());
  }
  if (from._internal_created_at() != 0) {
    _this->_internal_set_created_at(from._internal_created_at());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotLimitOrder::CopyFrom(const SpotLimitOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SpotLimitOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotLimitOrder::IsInitialized() const {
  return true;
}

void SpotLimitOrder::InternalSwap(SpotLimitOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_side_, lhs_arena,
                                       &other->_impl_.order_side_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.unfilled_quantity_, lhs_arena,
                                       &other->_impl_.unfilled_quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_recipient_, lhs_arena,
                                       &other->_impl_.fee_recipient_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_, lhs_arena,
                                       &other->_impl_.state_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpotLimitOrder, _impl_.updated_at_)
      + sizeof(SpotLimitOrder::_impl_.updated_at_)
      - PROTOBUF_FIELD_OFFSET(SpotLimitOrder, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotLimitOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[31]);
}
// ===================================================================

class Paging::_Internal {
 public:
};

Paging::Paging(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.Paging)
}
Paging::Paging(const Paging& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.Paging)
}

inline void Paging::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.total_) { ::int64_t{0} }

    , decltype(_impl_.from_) { 0 }

    , decltype(_impl_.to_) { 0 }

    , decltype(_impl_.count_by_subaccount_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Paging::~Paging() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.Paging)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Paging::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Paging::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Paging::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.Paging)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.total_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_by_subaccount_) -
      reinterpret_cast<char*>(&_impl_.total_)) + sizeof(_impl_.count_by_subaccount_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Paging::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // sint64 total = 1 [json_name = "total"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 from = 2 [json_name = "from"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 to = 3 [json_name = "to"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.count_by_subaccount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Paging::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.Paging)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // sint64 total = 1 [json_name = "total"];
  if (this->_internal_total() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        1, this->_internal_total(), target);
  }

  // sint32 from = 2 [json_name = "from"];
  if (this->_internal_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        2, this->_internal_from(), target);
  }

  // sint32 to = 3 [json_name = "to"];
  if (this->_internal_to() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        3, this->_internal_to(), target);
  }

  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  if (this->_internal_count_by_subaccount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        4, this->_internal_count_by_subaccount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.Paging)
  return target;
}

::size_t Paging::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.Paging)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // sint64 total = 1 [json_name = "total"];
  if (this->_internal_total() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_total());
  }

  // sint32 from = 2 [json_name = "from"];
  if (this->_internal_from() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_from());
  }

  // sint32 to = 3 [json_name = "to"];
  if (this->_internal_to() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_to());
  }

  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  if (this->_internal_count_by_subaccount() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_count_by_subaccount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Paging::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Paging::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Paging::GetClassData() const { return &_class_data_; }


void Paging::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Paging*>(&to_msg);
  auto& from = static_cast<const Paging&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.Paging)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_total() != 0) {
    _this->_internal_set_total(from._internal_total());
  }
  if (from._internal_from() != 0) {
    _this->_internal_set_from(from._internal_from());
  }
  if (from._internal_to() != 0) {
    _this->_internal_set_to(from._internal_to());
  }
  if (from._internal_count_by_subaccount() != 0) {
    _this->_internal_set_count_by_subaccount(from._internal_count_by_subaccount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Paging::CopyFrom(const Paging& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.Paging)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Paging::IsInitialized() const {
  return true;
}

void Paging::InternalSwap(Paging* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Paging, _impl_.count_by_subaccount_)
      + sizeof(Paging::_impl_.count_by_subaccount_)
      - PROTOBUF_FIELD_OFFSET(Paging, _impl_.total_)>(
          reinterpret_cast<char*>(&_impl_.total_),
          reinterpret_cast<char*>(&other->_impl_.total_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Paging::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[32]);
}
// ===================================================================

class StreamOrdersRequest::_Internal {
 public:
};

StreamOrdersRequest::StreamOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrdersRequest)
}
StreamOrdersRequest::StreamOrdersRequest(const StreamOrdersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrdersRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.end_time_) {}

    , decltype(_impl_.limit_) {}

    , decltype(_impl_.include_inactive_) {}

    , decltype(_impl_.subaccount_total_orders_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_side().empty()) {
    _this->_impl_.order_side_.Set(from._internal_order_side(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.subaccount_total_orders_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.subaccount_total_orders_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrdersRequest)
}

inline void StreamOrdersRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.start_time_) { ::int64_t{0} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

    , decltype(_impl_.limit_) { 0 }

    , decltype(_impl_.include_inactive_) { false }

    , decltype(_impl_.subaccount_total_orders_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamOrdersRequest::~StreamOrdersRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrdersRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrdersRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
  _impl_.order_side_.Destroy();
  _impl_.subaccount_id_.Destroy();
}

void StreamOrdersRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrdersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrdersRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _impl_.order_side_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.subaccount_total_orders_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.subaccount_total_orders_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrdersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string order_side = 2 [json_name = "orderSide"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_order_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersRequest.order_side"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 3 [json_name = "subaccountId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 4 [json_name = "skip"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 5 [json_name = "limit"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 start_time = 6 [json_name = "startTime"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 end_time = 7 [json_name = "endTime"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string market_ids = 8 [json_name = "marketIds"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool include_inactive = 9 [json_name = "includeInactive"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.include_inactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.subaccount_total_orders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrdersRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrdersRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersRequest.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string order_side = 2 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    const std::string& _s = this->_internal_order_side();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersRequest.order_side");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string subaccount_id = 3 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // uint64 skip = 4 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_skip(), target);
  }

  // sint32 limit = 5 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        5, this->_internal_limit(), target);
  }

  // sint64 start_time = 6 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        6, this->_internal_start_time(), target);
  }

  // sint64 end_time = 7 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this->_internal_end_time(), target);
  }

  // repeated string market_ids = 8 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersRequest.market_ids");
    target = stream->WriteString(8, s, target);
  }

  // bool include_inactive = 9 [json_name = "includeInactive"];
  if (this->_internal_include_inactive() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_include_inactive(), target);
  }

  // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
  if (this->_internal_subaccount_total_orders() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_subaccount_total_orders(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrdersRequest)
  return target;
}

::size_t StreamOrdersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrdersRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 8 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string order_side = 2 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_side());
  }

  // string subaccount_id = 3 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // uint64 skip = 4 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint64 start_time = 6 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_start_time());
  }

  // sint64 end_time = 7 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_end_time());
  }

  // sint32 limit = 5 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  // bool include_inactive = 9 [json_name = "includeInactive"];
  if (this->_internal_include_inactive() != 0) {
    total_size += 2;
  }

  // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
  if (this->_internal_subaccount_total_orders() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrdersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrdersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrdersRequest::GetClassData() const { return &_class_data_; }


void StreamOrdersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrdersRequest*>(&to_msg);
  auto& from = static_cast<const StreamOrdersRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrdersRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_order_side().empty()) {
    _this->_internal_set_order_side(from._internal_order_side());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_start_time() != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  if (from._internal_end_time() != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  if (from._internal_include_inactive() != 0) {
    _this->_internal_set_include_inactive(from._internal_include_inactive());
  }
  if (from._internal_subaccount_total_orders() != 0) {
    _this->_internal_set_subaccount_total_orders(from._internal_subaccount_total_orders());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrdersRequest::CopyFrom(const StreamOrdersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrdersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrdersRequest::IsInitialized() const {
  return true;
}

void StreamOrdersRequest::InternalSwap(StreamOrdersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_side_, lhs_arena,
                                       &other->_impl_.order_side_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamOrdersRequest, _impl_.subaccount_total_orders_)
      + sizeof(StreamOrdersRequest::_impl_.subaccount_total_orders_)
      - PROTOBUF_FIELD_OFFSET(StreamOrdersRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrdersRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[33]);
}
// ===================================================================

class StreamOrdersResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamOrdersResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamOrdersResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotLimitOrder& order(const StreamOrdersResponse* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotLimitOrder&
StreamOrdersResponse::_Internal::order(const StreamOrdersResponse* msg) {
  return *msg->_impl_.order_;
}
StreamOrdersResponse::StreamOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrdersResponse)
}
StreamOrdersResponse::StreamOrdersResponse(const StreamOrdersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrdersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.order_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_type().empty()) {
    _this->_impl_.operation_type_.Set(from._internal_operation_type(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::injective_spot_exchange_rpc::SpotLimitOrder(*from._impl_.order_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrdersResponse)
}

inline void StreamOrdersResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.order_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamOrdersResponse::~StreamOrdersResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrdersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrdersResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.operation_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_;
}

void StreamOrdersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrdersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrdersResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_type_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrdersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotLimitOrder order = 1 [json_name = "order"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string operation_type = 2 [json_name = "operationType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersResponse.operation_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrdersResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrdersResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotLimitOrder order = 1 [json_name = "order"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    const std::string& _s = this->_internal_operation_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersResponse.operation_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrdersResponse)
  return target;
}

::size_t StreamOrdersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrdersResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_operation_type());
  }

  // .injective_spot_exchange_rpc.SpotLimitOrder order = 1 [json_name = "order"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrdersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrdersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrdersResponse::GetClassData() const { return &_class_data_; }


void StreamOrdersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrdersResponse*>(&to_msg);
  auto& from = static_cast<const StreamOrdersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrdersResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_operation_type().empty()) {
    _this->_internal_set_operation_type(from._internal_operation_type());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::injective_spot_exchange_rpc::SpotLimitOrder::MergeFrom(
        from._internal_order());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrdersResponse::CopyFrom(const StreamOrdersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrdersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrdersResponse::IsInitialized() const {
  return true;
}

void StreamOrdersResponse::InternalSwap(StreamOrdersResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_type_, lhs_arena,
                                       &other->_impl_.operation_type_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamOrdersResponse, _impl_.timestamp_)
      + sizeof(StreamOrdersResponse::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamOrdersResponse, _impl_.order_)>(
          reinterpret_cast<char*>(&_impl_.order_),
          reinterpret_cast<char*>(&other->_impl_.order_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrdersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[34]);
}
// ===================================================================

class TradesRequest::_Internal {
 public:
};

TradesRequest::TradesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.TradesRequest)
}
TradesRequest::TradesRequest(const TradesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , decltype(_impl_.subaccount_ids_){from._impl_.subaccount_ids_}
    , decltype(_impl_.execution_types_){from._impl_.execution_types_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.execution_side_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.end_time_) {}

    , decltype(_impl_.limit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.execution_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_side().empty()) {
    _this->_impl_.execution_side_.Set(from._internal_execution_side(), _this->GetArenaForAllocation());
  }
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_direction().empty()) {
    _this->_impl_.direction_.Set(from._internal_direction(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.limit_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.TradesRequest)
}

inline void TradesRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , decltype(_impl_.subaccount_ids_){arena}
    , decltype(_impl_.execution_types_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.execution_side_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.start_time_) { ::int64_t{0} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

    , decltype(_impl_.limit_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradesRequest::~TradesRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.TradesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradesRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
  _internal_mutable_subaccount_ids()->~RepeatedPtrField();
  _internal_mutable_execution_types()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
  _impl_.execution_side_.Destroy();
  _impl_.direction_.Destroy();
  _impl_.subaccount_id_.Destroy();
}

void TradesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.TradesRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_mutable_subaccount_ids()->Clear();
  _internal_mutable_execution_types()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _impl_.execution_side_.ClearToEmpty();
  _impl_.direction_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.limit_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TradesRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_side = 2 [json_name = "executionSide"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_execution_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TradesRequest.execution_side"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string direction = 3 [json_name = "direction"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TradesRequest.direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 4 [json_name = "subaccountId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TradesRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 5 [json_name = "skip"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 6 [json_name = "limit"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 start_time = 7 [json_name = "startTime"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 end_time = 8 [json_name = "endTime"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string market_ids = 9 [json_name = "marketIds"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TradesRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_subaccount_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TradesRequest.subaccount_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string execution_types = 11 [json_name = "executionTypes"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_execution_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.TradesRequest.execution_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradesRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.TradesRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TradesRequest.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string execution_side = 2 [json_name = "executionSide"];
  if (!this->_internal_execution_side().empty()) {
    const std::string& _s = this->_internal_execution_side();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TradesRequest.execution_side");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string direction = 3 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    const std::string& _s = this->_internal_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TradesRequest.direction");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TradesRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // uint64 skip = 5 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_skip(), target);
  }

  // sint32 limit = 6 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        6, this->_internal_limit(), target);
  }

  // sint64 start_time = 7 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this->_internal_start_time(), target);
  }

  // sint64 end_time = 8 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        8, this->_internal_end_time(), target);
  }

  // repeated string market_ids = 9 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TradesRequest.market_ids");
    target = stream->WriteString(9, s, target);
  }

  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  for (int i = 0, n = this->_internal_subaccount_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_subaccount_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TradesRequest.subaccount_ids");
    target = stream->WriteString(10, s, target);
  }

  // repeated string execution_types = 11 [json_name = "executionTypes"];
  for (int i = 0, n = this->_internal_execution_types_size(); i < n; ++i) {
    const auto& s = this->_internal_execution_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.TradesRequest.execution_types");
    target = stream->WriteString(11, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.TradesRequest)
  return target;
}

::size_t TradesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.TradesRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 9 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_subaccount_ids().size());
  for (int i = 0, n = _internal_subaccount_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_subaccount_ids().Get(i));
  }

  // repeated string execution_types = 11 [json_name = "executionTypes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_execution_types().size());
  for (int i = 0, n = _internal_execution_types().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_execution_types().Get(i));
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string execution_side = 2 [json_name = "executionSide"];
  if (!this->_internal_execution_side().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_side());
  }

  // string direction = 3 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_direction());
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // uint64 skip = 5 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint64 start_time = 7 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_start_time());
  }

  // sint64 end_time = 8 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_end_time());
  }

  // sint32 limit = 6 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradesRequest::GetClassData() const { return &_class_data_; }


void TradesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradesRequest*>(&to_msg);
  auto& from = static_cast<const TradesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.TradesRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_mutable_subaccount_ids()->MergeFrom(from._internal_subaccount_ids());
  _this->_internal_mutable_execution_types()->MergeFrom(from._internal_execution_types());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_execution_side().empty()) {
    _this->_internal_set_execution_side(from._internal_execution_side());
  }
  if (!from._internal_direction().empty()) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_start_time() != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  if (from._internal_end_time() != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradesRequest::CopyFrom(const TradesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.TradesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradesRequest::IsInitialized() const {
  return true;
}

void TradesRequest::InternalSwap(TradesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
  _internal_mutable_subaccount_ids()->InternalSwap(
      other->_internal_mutable_subaccount_ids());
  _internal_mutable_execution_types()->InternalSwap(
      other->_internal_mutable_execution_types());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_side_, lhs_arena,
                                       &other->_impl_.execution_side_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.direction_, lhs_arena,
                                       &other->_impl_.direction_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradesRequest, _impl_.limit_)
      + sizeof(TradesRequest::_impl_.limit_)
      - PROTOBUF_FIELD_OFFSET(TradesRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[35]);
}
// ===================================================================

class TradesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<TradesResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TradesResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::Paging& paging(const TradesResponse* msg);
  static void set_has_paging(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::Paging&
TradesResponse::_Internal::paging(const TradesResponse* msg) {
  return *msg->_impl_.paging_;
}
TradesResponse::TradesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.TradesResponse)
}
TradesResponse::TradesResponse(const TradesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trades_){from._impl_.trades_}
    , decltype(_impl_.paging_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.paging_ = new ::injective_spot_exchange_rpc::Paging(*from._impl_.paging_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.TradesResponse)
}

inline void TradesResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trades_){arena}
    , decltype(_impl_.paging_){nullptr}
  };
}

TradesResponse::~TradesResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.TradesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradesResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_trades()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.paging_;
}

void TradesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.TradesResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_trades()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.paging_ != nullptr);
    _impl_.paging_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trades(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_paging(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradesResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.TradesResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trades_size()); i < n; i++) {
    const auto& repfield = this->_internal_trades(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::paging(this),
        _Internal::paging(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.TradesResponse)
  return target;
}

::size_t TradesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.TradesResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
  total_size += 1UL * this->_internal_trades_size();
  for (const auto& msg : this->_internal_trades()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.paging_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradesResponse::GetClassData() const { return &_class_data_; }


void TradesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradesResponse*>(&to_msg);
  auto& from = static_cast<const TradesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.TradesResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_trades()->MergeFrom(from._internal_trades());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_paging()->::injective_spot_exchange_rpc::Paging::MergeFrom(
        from._internal_paging());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradesResponse::CopyFrom(const TradesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.TradesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradesResponse::IsInitialized() const {
  return true;
}

void TradesResponse::InternalSwap(TradesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_trades()->InternalSwap(other->_internal_mutable_trades());
  swap(_impl_.paging_, other->_impl_.paging_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TradesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[36]);
}
// ===================================================================

class SpotTrade::_Internal {
 public:
  using HasBits = decltype(std::declval<SpotTrade>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpotTrade, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::PriceLevel& price(const SpotTrade* msg);
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::PriceLevel&
SpotTrade::_Internal::price(const SpotTrade* msg) {
  return *msg->_impl_.price_;
}
SpotTrade::SpotTrade(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SpotTrade)
}
SpotTrade::SpotTrade(const SpotTrade& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotTrade* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.trade_execution_type_) {}

    , decltype(_impl_.trade_direction_) {}

    , decltype(_impl_.fee_) {}

    , decltype(_impl_.fee_recipient_) {}

    , decltype(_impl_.trade_id_) {}

    , decltype(_impl_.execution_side_) {}

    , decltype(_impl_.price_){nullptr}
    , decltype(_impl_.executed_at_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.trade_execution_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trade_execution_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trade_execution_type().empty()) {
    _this->_impl_.trade_execution_type_.Set(from._internal_trade_execution_type(), _this->GetArenaForAllocation());
  }
  _impl_.trade_direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trade_direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trade_direction().empty()) {
    _this->_impl_.trade_direction_.Set(from._internal_trade_direction(), _this->GetArenaForAllocation());
  }
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee().empty()) {
    _this->_impl_.fee_.Set(from._internal_fee(), _this->GetArenaForAllocation());
  }
  _impl_.fee_recipient_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_recipient().empty()) {
    _this->_impl_.fee_recipient_.Set(from._internal_fee_recipient(), _this->GetArenaForAllocation());
  }
  _impl_.trade_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trade_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trade_id().empty()) {
    _this->_impl_.trade_id_.Set(from._internal_trade_id(), _this->GetArenaForAllocation());
  }
  _impl_.execution_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_side().empty()) {
    _this->_impl_.execution_side_.Set(from._internal_execution_side(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.price_ = new ::injective_spot_exchange_rpc::PriceLevel(*from._impl_.price_);
  }
  _this->_impl_.executed_at_ = from._impl_.executed_at_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SpotTrade)
}

inline void SpotTrade::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.trade_execution_type_) {}

    , decltype(_impl_.trade_direction_) {}

    , decltype(_impl_.fee_) {}

    , decltype(_impl_.fee_recipient_) {}

    , decltype(_impl_.trade_id_) {}

    , decltype(_impl_.execution_side_) {}

    , decltype(_impl_.price_){nullptr}
    , decltype(_impl_.executed_at_) { ::int64_t{0} }

  };
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trade_execution_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trade_execution_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trade_direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trade_direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_recipient_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trade_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trade_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotTrade::~SpotTrade() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SpotTrade)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotTrade::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.order_hash_.Destroy();
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.trade_execution_type_.Destroy();
  _impl_.trade_direction_.Destroy();
  _impl_.fee_.Destroy();
  _impl_.fee_recipient_.Destroy();
  _impl_.trade_id_.Destroy();
  _impl_.execution_side_.Destroy();
  if (this != internal_default_instance()) delete _impl_.price_;
}

void SpotTrade::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotTrade::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SpotTrade)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.order_hash_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.trade_execution_type_.ClearToEmpty();
  _impl_.trade_direction_.ClearToEmpty();
  _impl_.fee_.ClearToEmpty();
  _impl_.fee_recipient_.ClearToEmpty();
  _impl_.trade_id_.ClearToEmpty();
  _impl_.execution_side_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.price_ != nullptr);
    _impl_.price_->Clear();
  }
  _impl_.executed_at_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotTrade::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string order_hash = 1 [json_name = "orderHash"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.order_hash"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 2 [json_name = "subaccountId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 3 [json_name = "marketId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trade_execution_type = 4 [json_name = "tradeExecutionType"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_trade_execution_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.trade_execution_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trade_direction = 5 [json_name = "tradeDirection"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_trade_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.trade_direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.PriceLevel price = 6 [json_name = "price"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_price(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string fee = 7 [json_name = "fee"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.fee"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 executed_at = 8 [json_name = "executedAt"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.executed_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string fee_recipient = 9 [json_name = "feeRecipient"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_fee_recipient();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.fee_recipient"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trade_id = 10 [json_name = "tradeId"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_trade_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.trade_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_side = 11 [json_name = "executionSide"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_execution_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotTrade.execution_side"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotTrade::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SpotTrade)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.order_hash");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.subaccount_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string market_id = 3 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.market_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string trade_execution_type = 4 [json_name = "tradeExecutionType"];
  if (!this->_internal_trade_execution_type().empty()) {
    const std::string& _s = this->_internal_trade_execution_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.trade_execution_type");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string trade_direction = 5 [json_name = "tradeDirection"];
  if (!this->_internal_trade_direction().empty()) {
    const std::string& _s = this->_internal_trade_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.trade_direction");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.PriceLevel price = 6 [json_name = "price"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::price(this),
        _Internal::price(this).GetCachedSize(), target, stream);
  }

  // string fee = 7 [json_name = "fee"];
  if (!this->_internal_fee().empty()) {
    const std::string& _s = this->_internal_fee();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.fee");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // sint64 executed_at = 8 [json_name = "executedAt"];
  if (this->_internal_executed_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        8, this->_internal_executed_at(), target);
  }

  // string fee_recipient = 9 [json_name = "feeRecipient"];
  if (!this->_internal_fee_recipient().empty()) {
    const std::string& _s = this->_internal_fee_recipient();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.fee_recipient");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string trade_id = 10 [json_name = "tradeId"];
  if (!this->_internal_trade_id().empty()) {
    const std::string& _s = this->_internal_trade_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.trade_id");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // string execution_side = 11 [json_name = "executionSide"];
  if (!this->_internal_execution_side().empty()) {
    const std::string& _s = this->_internal_execution_side();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotTrade.execution_side");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SpotTrade)
  return target;
}

::size_t SpotTrade::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SpotTrade)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_hash());
  }

  // string subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 3 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string trade_execution_type = 4 [json_name = "tradeExecutionType"];
  if (!this->_internal_trade_execution_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trade_execution_type());
  }

  // string trade_direction = 5 [json_name = "tradeDirection"];
  if (!this->_internal_trade_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trade_direction());
  }

  // string fee = 7 [json_name = "fee"];
  if (!this->_internal_fee().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fee());
  }

  // string fee_recipient = 9 [json_name = "feeRecipient"];
  if (!this->_internal_fee_recipient().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fee_recipient());
  }

  // string trade_id = 10 [json_name = "tradeId"];
  if (!this->_internal_trade_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trade_id());
  }

  // string execution_side = 11 [json_name = "executionSide"];
  if (!this->_internal_execution_side().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_side());
  }

  // .injective_spot_exchange_rpc.PriceLevel price = 6 [json_name = "price"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.price_);
  }

  // sint64 executed_at = 8 [json_name = "executedAt"];
  if (this->_internal_executed_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_executed_at());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotTrade::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotTrade::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotTrade::GetClassData() const { return &_class_data_; }


void SpotTrade::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotTrade*>(&to_msg);
  auto& from = static_cast<const SpotTrade&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SpotTrade)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_trade_execution_type().empty()) {
    _this->_internal_set_trade_execution_type(from._internal_trade_execution_type());
  }
  if (!from._internal_trade_direction().empty()) {
    _this->_internal_set_trade_direction(from._internal_trade_direction());
  }
  if (!from._internal_fee().empty()) {
    _this->_internal_set_fee(from._internal_fee());
  }
  if (!from._internal_fee_recipient().empty()) {
    _this->_internal_set_fee_recipient(from._internal_fee_recipient());
  }
  if (!from._internal_trade_id().empty()) {
    _this->_internal_set_trade_id(from._internal_trade_id());
  }
  if (!from._internal_execution_side().empty()) {
    _this->_internal_set_execution_side(from._internal_execution_side());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_price()->::injective_spot_exchange_rpc::PriceLevel::MergeFrom(
        from._internal_price());
  }
  if (from._internal_executed_at() != 0) {
    _this->_internal_set_executed_at(from._internal_executed_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotTrade::CopyFrom(const SpotTrade& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SpotTrade)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotTrade::IsInitialized() const {
  return true;
}

void SpotTrade::InternalSwap(SpotTrade* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trade_execution_type_, lhs_arena,
                                       &other->_impl_.trade_execution_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trade_direction_, lhs_arena,
                                       &other->_impl_.trade_direction_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_, lhs_arena,
                                       &other->_impl_.fee_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_recipient_, lhs_arena,
                                       &other->_impl_.fee_recipient_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trade_id_, lhs_arena,
                                       &other->_impl_.trade_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_side_, lhs_arena,
                                       &other->_impl_.execution_side_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpotTrade, _impl_.executed_at_)
      + sizeof(SpotTrade::_impl_.executed_at_)
      - PROTOBUF_FIELD_OFFSET(SpotTrade, _impl_.price_)>(
          reinterpret_cast<char*>(&_impl_.price_),
          reinterpret_cast<char*>(&other->_impl_.price_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotTrade::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[37]);
}
// ===================================================================

class StreamTradesRequest::_Internal {
 public:
};

StreamTradesRequest::StreamTradesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamTradesRequest)
}
StreamTradesRequest::StreamTradesRequest(const StreamTradesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamTradesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){from._impl_.market_ids_}
    , decltype(_impl_.subaccount_ids_){from._impl_.subaccount_ids_}
    , decltype(_impl_.execution_types_){from._impl_.execution_types_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.execution_side_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.end_time_) {}

    , decltype(_impl_.limit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.execution_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_side().empty()) {
    _this->_impl_.execution_side_.Set(from._internal_execution_side(), _this->GetArenaForAllocation());
  }
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_direction().empty()) {
    _this->_impl_.direction_.Set(from._internal_direction(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.limit_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamTradesRequest)
}

inline void StreamTradesRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_ids_){arena}
    , decltype(_impl_.subaccount_ids_){arena}
    , decltype(_impl_.execution_types_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.execution_side_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.start_time_) { ::int64_t{0} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

    , decltype(_impl_.limit_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamTradesRequest::~StreamTradesRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamTradesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamTradesRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_ids()->~RepeatedPtrField();
  _internal_mutable_subaccount_ids()->~RepeatedPtrField();
  _internal_mutable_execution_types()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
  _impl_.execution_side_.Destroy();
  _impl_.direction_.Destroy();
  _impl_.subaccount_id_.Destroy();
}

void StreamTradesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamTradesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamTradesRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_ids()->Clear();
  _internal_mutable_subaccount_ids()->Clear();
  _internal_mutable_execution_types()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _impl_.execution_side_.ClearToEmpty();
  _impl_.direction_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.limit_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamTradesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_side = 2 [json_name = "executionSide"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_execution_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesRequest.execution_side"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string direction = 3 [json_name = "direction"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesRequest.direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 4 [json_name = "subaccountId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 5 [json_name = "skip"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 6 [json_name = "limit"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 start_time = 7 [json_name = "startTime"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 end_time = 8 [json_name = "endTime"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string market_ids = 9 [json_name = "marketIds"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesRequest.market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_subaccount_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string execution_types = 11 [json_name = "executionTypes"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_execution_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesRequest.execution_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamTradesRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamTradesRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesRequest.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string execution_side = 2 [json_name = "executionSide"];
  if (!this->_internal_execution_side().empty()) {
    const std::string& _s = this->_internal_execution_side();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesRequest.execution_side");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string direction = 3 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    const std::string& _s = this->_internal_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesRequest.direction");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // uint64 skip = 5 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_skip(), target);
  }

  // sint32 limit = 6 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        6, this->_internal_limit(), target);
  }

  // sint64 start_time = 7 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this->_internal_start_time(), target);
  }

  // sint64 end_time = 8 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        8, this->_internal_end_time(), target);
  }

  // repeated string market_ids = 9 [json_name = "marketIds"];
  for (int i = 0, n = this->_internal_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesRequest.market_ids");
    target = stream->WriteString(9, s, target);
  }

  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  for (int i = 0, n = this->_internal_subaccount_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_subaccount_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids");
    target = stream->WriteString(10, s, target);
  }

  // repeated string execution_types = 11 [json_name = "executionTypes"];
  for (int i = 0, n = this->_internal_execution_types_size(); i < n; ++i) {
    const auto& s = this->_internal_execution_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesRequest.execution_types");
    target = stream->WriteString(11, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamTradesRequest)
  return target;
}

::size_t StreamTradesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamTradesRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string market_ids = 9 [json_name = "marketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_market_ids().size());
  for (int i = 0, n = _internal_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_market_ids().Get(i));
  }

  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_subaccount_ids().size());
  for (int i = 0, n = _internal_subaccount_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_subaccount_ids().Get(i));
  }

  // repeated string execution_types = 11 [json_name = "executionTypes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_execution_types().size());
  for (int i = 0, n = _internal_execution_types().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_execution_types().Get(i));
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string execution_side = 2 [json_name = "executionSide"];
  if (!this->_internal_execution_side().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_side());
  }

  // string direction = 3 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_direction());
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // uint64 skip = 5 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint64 start_time = 7 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_start_time());
  }

  // sint64 end_time = 8 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_end_time());
  }

  // sint32 limit = 6 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamTradesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamTradesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamTradesRequest::GetClassData() const { return &_class_data_; }


void StreamTradesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamTradesRequest*>(&to_msg);
  auto& from = static_cast<const StreamTradesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamTradesRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_ids()->MergeFrom(from._internal_market_ids());
  _this->_internal_mutable_subaccount_ids()->MergeFrom(from._internal_subaccount_ids());
  _this->_internal_mutable_execution_types()->MergeFrom(from._internal_execution_types());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_execution_side().empty()) {
    _this->_internal_set_execution_side(from._internal_execution_side());
  }
  if (!from._internal_direction().empty()) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_start_time() != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  if (from._internal_end_time() != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamTradesRequest::CopyFrom(const StreamTradesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamTradesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamTradesRequest::IsInitialized() const {
  return true;
}

void StreamTradesRequest::InternalSwap(StreamTradesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_ids()->InternalSwap(
      other->_internal_mutable_market_ids());
  _internal_mutable_subaccount_ids()->InternalSwap(
      other->_internal_mutable_subaccount_ids());
  _internal_mutable_execution_types()->InternalSwap(
      other->_internal_mutable_execution_types());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_side_, lhs_arena,
                                       &other->_impl_.execution_side_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.direction_, lhs_arena,
                                       &other->_impl_.direction_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamTradesRequest, _impl_.limit_)
      + sizeof(StreamTradesRequest::_impl_.limit_)
      - PROTOBUF_FIELD_OFFSET(StreamTradesRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamTradesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[38]);
}
// ===================================================================

class StreamTradesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamTradesResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamTradesResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotTrade& trade(const StreamTradesResponse* msg);
  static void set_has_trade(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotTrade&
StreamTradesResponse::_Internal::trade(const StreamTradesResponse* msg) {
  return *msg->_impl_.trade_;
}
StreamTradesResponse::StreamTradesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamTradesResponse)
}
StreamTradesResponse::StreamTradesResponse(const StreamTradesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamTradesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.trade_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_type().empty()) {
    _this->_impl_.operation_type_.Set(from._internal_operation_type(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.trade_ = new ::injective_spot_exchange_rpc::SpotTrade(*from._impl_.trade_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamTradesResponse)
}

inline void StreamTradesResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.trade_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamTradesResponse::~StreamTradesResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamTradesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamTradesResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.operation_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.trade_;
}

void StreamTradesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamTradesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamTradesResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_type_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.trade_ != nullptr);
    _impl_.trade_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamTradesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotTrade trade = 1 [json_name = "trade"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_trade(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string operation_type = 2 [json_name = "operationType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamTradesResponse.operation_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamTradesResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamTradesResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotTrade trade = 1 [json_name = "trade"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::trade(this),
        _Internal::trade(this).GetCachedSize(), target, stream);
  }

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    const std::string& _s = this->_internal_operation_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamTradesResponse.operation_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamTradesResponse)
  return target;
}

::size_t StreamTradesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamTradesResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_operation_type());
  }

  // .injective_spot_exchange_rpc.SpotTrade trade = 1 [json_name = "trade"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.trade_);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamTradesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamTradesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamTradesResponse::GetClassData() const { return &_class_data_; }


void StreamTradesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamTradesResponse*>(&to_msg);
  auto& from = static_cast<const StreamTradesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamTradesResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_operation_type().empty()) {
    _this->_internal_set_operation_type(from._internal_operation_type());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_trade()->::injective_spot_exchange_rpc::SpotTrade::MergeFrom(
        from._internal_trade());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamTradesResponse::CopyFrom(const StreamTradesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamTradesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamTradesResponse::IsInitialized() const {
  return true;
}

void StreamTradesResponse::InternalSwap(StreamTradesResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_type_, lhs_arena,
                                       &other->_impl_.operation_type_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamTradesResponse, _impl_.timestamp_)
      + sizeof(StreamTradesResponse::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamTradesResponse, _impl_.trade_)>(
          reinterpret_cast<char*>(&_impl_.trade_),
          reinterpret_cast<char*>(&other->_impl_.trade_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamTradesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[39]);
}
// ===================================================================

class SubaccountOrdersListRequest::_Internal {
 public:
};

SubaccountOrdersListRequest::SubaccountOrdersListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
}
SubaccountOrdersListRequest::SubaccountOrdersListRequest(const SubaccountOrdersListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountOrdersListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.limit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.limit_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
}

inline void SubaccountOrdersListRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.limit_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountOrdersListRequest::~SubaccountOrdersListRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountOrdersListRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
}

void SubaccountOrdersListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountOrdersListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.limit_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountOrdersListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SubaccountOrdersListRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SubaccountOrdersListRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 3 [json_name = "skip"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 4 [json_name = "limit"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountOrdersListRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SubaccountOrdersListRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SubaccountOrdersListRequest.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint64 skip = 3 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_skip(), target);
  }

  // sint32 limit = 4 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        4, this->_internal_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
  return target;
}

::size_t SubaccountOrdersListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // uint64 skip = 3 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint32 limit = 4 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountOrdersListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountOrdersListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountOrdersListRequest::GetClassData() const { return &_class_data_; }


void SubaccountOrdersListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountOrdersListRequest*>(&to_msg);
  auto& from = static_cast<const SubaccountOrdersListRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountOrdersListRequest::CopyFrom(const SubaccountOrdersListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountOrdersListRequest::IsInitialized() const {
  return true;
}

void SubaccountOrdersListRequest::InternalSwap(SubaccountOrdersListRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubaccountOrdersListRequest, _impl_.limit_)
      + sizeof(SubaccountOrdersListRequest::_impl_.limit_)
      - PROTOBUF_FIELD_OFFSET(SubaccountOrdersListRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountOrdersListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[40]);
}
// ===================================================================

class SubaccountOrdersListResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountOrdersListResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountOrdersListResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::Paging& paging(const SubaccountOrdersListResponse* msg);
  static void set_has_paging(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::Paging&
SubaccountOrdersListResponse::_Internal::paging(const SubaccountOrdersListResponse* msg) {
  return *msg->_impl_.paging_;
}
SubaccountOrdersListResponse::SubaccountOrdersListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
}
SubaccountOrdersListResponse::SubaccountOrdersListResponse(const SubaccountOrdersListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountOrdersListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){from._impl_.orders_}
    , decltype(_impl_.paging_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.paging_ = new ::injective_spot_exchange_rpc::Paging(*from._impl_.paging_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
}

inline void SubaccountOrdersListResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){arena}
    , decltype(_impl_.paging_){nullptr}
  };
}

SubaccountOrdersListResponse::~SubaccountOrdersListResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountOrdersListResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_orders()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.paging_;
}

void SubaccountOrdersListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountOrdersListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_orders()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.paging_ != nullptr);
    _impl_.paging_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountOrdersListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_paging(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountOrdersListResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::paging(this),
        _Internal::paging(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
  return target;
}

::size_t SubaccountOrdersListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
  total_size += 1UL * this->_internal_orders_size();
  for (const auto& msg : this->_internal_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.paging_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountOrdersListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountOrdersListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountOrdersListResponse::GetClassData() const { return &_class_data_; }


void SubaccountOrdersListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountOrdersListResponse*>(&to_msg);
  auto& from = static_cast<const SubaccountOrdersListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_orders()->MergeFrom(from._internal_orders());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_paging()->::injective_spot_exchange_rpc::Paging::MergeFrom(
        from._internal_paging());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountOrdersListResponse::CopyFrom(const SubaccountOrdersListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountOrdersListResponse::IsInitialized() const {
  return true;
}

void SubaccountOrdersListResponse::InternalSwap(SubaccountOrdersListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_orders()->InternalSwap(other->_internal_mutable_orders());
  swap(_impl_.paging_, other->_impl_.paging_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountOrdersListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[41]);
}
// ===================================================================

class SubaccountTradesListRequest::_Internal {
 public:
};

SubaccountTradesListRequest::SubaccountTradesListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SubaccountTradesListRequest)
}
SubaccountTradesListRequest::SubaccountTradesListRequest(const SubaccountTradesListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountTradesListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.execution_type_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.limit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.execution_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_type().empty()) {
    _this->_impl_.execution_type_.Set(from._internal_execution_type(), _this->GetArenaForAllocation());
  }
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_direction().empty()) {
    _this->_impl_.direction_.Set(from._internal_direction(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.limit_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SubaccountTradesListRequest)
}

inline void SubaccountTradesListRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.execution_type_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.limit_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountTradesListRequest::~SubaccountTradesListRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SubaccountTradesListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountTradesListRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.execution_type_.Destroy();
  _impl_.direction_.Destroy();
}

void SubaccountTradesListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountTradesListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SubaccountTradesListRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.execution_type_.ClearToEmpty();
  _impl_.direction_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.limit_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountTradesListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SubaccountTradesListRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SubaccountTradesListRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_type = 3 [json_name = "executionType"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_execution_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SubaccountTradesListRequest.execution_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string direction = 4 [json_name = "direction"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SubaccountTradesListRequest.direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 5 [json_name = "skip"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 6 [json_name = "limit"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountTradesListRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SubaccountTradesListRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SubaccountTradesListRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SubaccountTradesListRequest.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string execution_type = 3 [json_name = "executionType"];
  if (!this->_internal_execution_type().empty()) {
    const std::string& _s = this->_internal_execution_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SubaccountTradesListRequest.execution_type");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string direction = 4 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    const std::string& _s = this->_internal_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SubaccountTradesListRequest.direction");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // uint64 skip = 5 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_skip(), target);
  }

  // sint32 limit = 6 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        6, this->_internal_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SubaccountTradesListRequest)
  return target;
}

::size_t SubaccountTradesListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SubaccountTradesListRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string execution_type = 3 [json_name = "executionType"];
  if (!this->_internal_execution_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_type());
  }

  // string direction = 4 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_direction());
  }

  // uint64 skip = 5 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint32 limit = 6 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountTradesListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountTradesListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountTradesListRequest::GetClassData() const { return &_class_data_; }


void SubaccountTradesListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountTradesListRequest*>(&to_msg);
  auto& from = static_cast<const SubaccountTradesListRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SubaccountTradesListRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_execution_type().empty()) {
    _this->_internal_set_execution_type(from._internal_execution_type());
  }
  if (!from._internal_direction().empty()) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountTradesListRequest::CopyFrom(const SubaccountTradesListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SubaccountTradesListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountTradesListRequest::IsInitialized() const {
  return true;
}

void SubaccountTradesListRequest::InternalSwap(SubaccountTradesListRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_type_, lhs_arena,
                                       &other->_impl_.execution_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.direction_, lhs_arena,
                                       &other->_impl_.direction_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubaccountTradesListRequest, _impl_.limit_)
      + sizeof(SubaccountTradesListRequest::_impl_.limit_)
      - PROTOBUF_FIELD_OFFSET(SubaccountTradesListRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountTradesListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[42]);
}
// ===================================================================

class SubaccountTradesListResponse::_Internal {
 public:
};

SubaccountTradesListResponse::SubaccountTradesListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SubaccountTradesListResponse)
}
SubaccountTradesListResponse::SubaccountTradesListResponse(const SubaccountTradesListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountTradesListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.trades_){from._impl_.trades_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SubaccountTradesListResponse)
}

inline void SubaccountTradesListResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.trades_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SubaccountTradesListResponse::~SubaccountTradesListResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SubaccountTradesListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountTradesListResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_trades()->~RepeatedPtrField();
}

void SubaccountTradesListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountTradesListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SubaccountTradesListResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_trades()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountTradesListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trades(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountTradesListResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SubaccountTradesListResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trades_size()); i < n; i++) {
    const auto& repfield = this->_internal_trades(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SubaccountTradesListResponse)
  return target;
}

::size_t SubaccountTradesListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SubaccountTradesListResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
  total_size += 1UL * this->_internal_trades_size();
  for (const auto& msg : this->_internal_trades()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountTradesListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountTradesListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountTradesListResponse::GetClassData() const { return &_class_data_; }


void SubaccountTradesListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountTradesListResponse*>(&to_msg);
  auto& from = static_cast<const SubaccountTradesListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SubaccountTradesListResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_trades()->MergeFrom(from._internal_trades());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountTradesListResponse::CopyFrom(const SubaccountTradesListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SubaccountTradesListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountTradesListResponse::IsInitialized() const {
  return true;
}

void SubaccountTradesListResponse::InternalSwap(SubaccountTradesListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_trades()->InternalSwap(other->_internal_mutable_trades());
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountTradesListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[43]);
}
// ===================================================================

class OrdersHistoryRequest::_Internal {
 public:
};

OrdersHistoryRequest::OrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrdersHistoryRequest)
}
OrdersHistoryRequest::OrdersHistoryRequest(const OrdersHistoryRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrdersHistoryRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.order_types_){from._impl_.order_types_}
    , decltype(_impl_.execution_types_){from._impl_.execution_types_}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.end_time_) {}

    , decltype(_impl_.limit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_direction().empty()) {
    _this->_impl_.direction_.Set(from._internal_direction(), _this->GetArenaForAllocation());
  }
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state().empty()) {
    _this->_impl_.state_.Set(from._internal_state(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.limit_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrdersHistoryRequest)
}

inline void OrdersHistoryRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.order_types_){arena}
    , decltype(_impl_.execution_types_){arena}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.start_time_) { ::int64_t{0} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

    , decltype(_impl_.limit_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrdersHistoryRequest::~OrdersHistoryRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrdersHistoryRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrdersHistoryRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_order_types()->~RepeatedPtrField();
  _internal_mutable_execution_types()->~RepeatedPtrField();
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.direction_.Destroy();
  _impl_.state_.Destroy();
}

void OrdersHistoryRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrdersHistoryRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrdersHistoryRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_order_types()->Clear();
  _internal_mutable_execution_types()->Clear();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.direction_.ClearToEmpty();
  _impl_.state_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.limit_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrdersHistoryRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersHistoryRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersHistoryRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 3 [json_name = "skip"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 4 [json_name = "limit"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string order_types = 5 [json_name = "orderTypes"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_order_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersHistoryRequest.order_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string direction = 6 [json_name = "direction"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersHistoryRequest.direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 start_time = 7 [json_name = "startTime"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 end_time = 8 [json_name = "endTime"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string state = 9 [json_name = "state"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersHistoryRequest.state"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string execution_types = 10 [json_name = "executionTypes"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_execution_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrdersHistoryRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrdersHistoryRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersHistoryRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersHistoryRequest.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint64 skip = 3 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_skip(), target);
  }

  // sint32 limit = 4 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        4, this->_internal_limit(), target);
  }

  // repeated string order_types = 5 [json_name = "orderTypes"];
  for (int i = 0, n = this->_internal_order_types_size(); i < n; ++i) {
    const auto& s = this->_internal_order_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersHistoryRequest.order_types");
    target = stream->WriteString(5, s, target);
  }

  // string direction = 6 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    const std::string& _s = this->_internal_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersHistoryRequest.direction");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // sint64 start_time = 7 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this->_internal_start_time(), target);
  }

  // sint64 end_time = 8 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        8, this->_internal_end_time(), target);
  }

  // string state = 9 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    const std::string& _s = this->_internal_state();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersHistoryRequest.state");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // repeated string execution_types = 10 [json_name = "executionTypes"];
  for (int i = 0, n = this->_internal_execution_types_size(); i < n; ++i) {
    const auto& s = this->_internal_execution_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types");
    target = stream->WriteString(10, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrdersHistoryRequest)
  return target;
}

::size_t OrdersHistoryRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrdersHistoryRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string order_types = 5 [json_name = "orderTypes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_order_types().size());
  for (int i = 0, n = _internal_order_types().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_order_types().Get(i));
  }

  // repeated string execution_types = 10 [json_name = "executionTypes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_execution_types().size());
  for (int i = 0, n = _internal_execution_types().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_execution_types().Get(i));
  }

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string direction = 6 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_direction());
  }

  // string state = 9 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_state());
  }

  // uint64 skip = 3 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint64 start_time = 7 [json_name = "startTime"];
  if (this->_internal_start_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_start_time());
  }

  // sint64 end_time = 8 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_end_time());
  }

  // sint32 limit = 4 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrdersHistoryRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrdersHistoryRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrdersHistoryRequest::GetClassData() const { return &_class_data_; }


void OrdersHistoryRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrdersHistoryRequest*>(&to_msg);
  auto& from = static_cast<const OrdersHistoryRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrdersHistoryRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_order_types()->MergeFrom(from._internal_order_types());
  _this->_internal_mutable_execution_types()->MergeFrom(from._internal_execution_types());
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_direction().empty()) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (!from._internal_state().empty()) {
    _this->_internal_set_state(from._internal_state());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_start_time() != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  if (from._internal_end_time() != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrdersHistoryRequest::CopyFrom(const OrdersHistoryRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrdersHistoryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrdersHistoryRequest::IsInitialized() const {
  return true;
}

void OrdersHistoryRequest::InternalSwap(OrdersHistoryRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_order_types()->InternalSwap(
      other->_internal_mutable_order_types());
  _internal_mutable_execution_types()->InternalSwap(
      other->_internal_mutable_execution_types());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.direction_, lhs_arena,
                                       &other->_impl_.direction_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_, lhs_arena,
                                       &other->_impl_.state_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OrdersHistoryRequest, _impl_.limit_)
      + sizeof(OrdersHistoryRequest::_impl_.limit_)
      - PROTOBUF_FIELD_OFFSET(OrdersHistoryRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OrdersHistoryRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[44]);
}
// ===================================================================

class OrdersHistoryResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<OrdersHistoryResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OrdersHistoryResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::Paging& paging(const OrdersHistoryResponse* msg);
  static void set_has_paging(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::Paging&
OrdersHistoryResponse::_Internal::paging(const OrdersHistoryResponse* msg) {
  return *msg->_impl_.paging_;
}
OrdersHistoryResponse::OrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.OrdersHistoryResponse)
}
OrdersHistoryResponse::OrdersHistoryResponse(const OrdersHistoryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrdersHistoryResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){from._impl_.orders_}
    , decltype(_impl_.paging_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.paging_ = new ::injective_spot_exchange_rpc::Paging(*from._impl_.paging_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.OrdersHistoryResponse)
}

inline void OrdersHistoryResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orders_){arena}
    , decltype(_impl_.paging_){nullptr}
  };
}

OrdersHistoryResponse::~OrdersHistoryResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.OrdersHistoryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrdersHistoryResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_orders()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.paging_;
}

void OrdersHistoryResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrdersHistoryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.OrdersHistoryResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_orders()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.paging_ != nullptr);
    _impl_.paging_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrdersHistoryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_spot_exchange_rpc.SpotOrderHistory orders = 1 [json_name = "orders"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_paging(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrdersHistoryResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.OrdersHistoryResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotOrderHistory orders = 1 [json_name = "orders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::paging(this),
        _Internal::paging(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.OrdersHistoryResponse)
  return target;
}

::size_t OrdersHistoryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.OrdersHistoryResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_spot_exchange_rpc.SpotOrderHistory orders = 1 [json_name = "orders"];
  total_size += 1UL * this->_internal_orders_size();
  for (const auto& msg : this->_internal_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.paging_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrdersHistoryResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrdersHistoryResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrdersHistoryResponse::GetClassData() const { return &_class_data_; }


void OrdersHistoryResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrdersHistoryResponse*>(&to_msg);
  auto& from = static_cast<const OrdersHistoryResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.OrdersHistoryResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_orders()->MergeFrom(from._internal_orders());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_paging()->::injective_spot_exchange_rpc::Paging::MergeFrom(
        from._internal_paging());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrdersHistoryResponse::CopyFrom(const OrdersHistoryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.OrdersHistoryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrdersHistoryResponse::IsInitialized() const {
  return true;
}

void OrdersHistoryResponse::InternalSwap(OrdersHistoryResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_orders()->InternalSwap(other->_internal_mutable_orders());
  swap(_impl_.paging_, other->_impl_.paging_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrdersHistoryResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[45]);
}
// ===================================================================

class SpotOrderHistory::_Internal {
 public:
};

SpotOrderHistory::SpotOrderHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.SpotOrderHistory)
}
SpotOrderHistory::SpotOrderHistory(const SpotOrderHistory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotOrderHistory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.order_hash_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.execution_type_) {}

    , decltype(_impl_.order_type_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.filled_quantity_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.created_at_) {}

    , decltype(_impl_.updated_at_) {}

    , decltype(_impl_.is_active_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.execution_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_type().empty()) {
    _this->_impl_.execution_type_.Set(from._internal_execution_type(), _this->GetArenaForAllocation());
  }
  _impl_.order_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_type().empty()) {
    _this->_impl_.order_type_.Set(from._internal_order_type(), _this->GetArenaForAllocation());
  }
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.filled_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.filled_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_filled_quantity().empty()) {
    _this->_impl_.filled_quantity_.Set(from._internal_filled_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state().empty()) {
    _this->_impl_.state_.Set(from._internal_state(), _this->GetArenaForAllocation());
  }
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_direction().empty()) {
    _this->_impl_.direction_.Set(from._internal_direction(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.created_at_, &from._impl_.created_at_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_active_) -
    reinterpret_cast<char*>(&_impl_.created_at_)) + sizeof(_impl_.is_active_));
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.SpotOrderHistory)
}

inline void SpotOrderHistory::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.order_hash_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.execution_type_) {}

    , decltype(_impl_.order_type_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.filled_quantity_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.created_at_) { ::int64_t{0} }

    , decltype(_impl_.updated_at_) { ::int64_t{0} }

    , decltype(_impl_.is_active_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filled_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.filled_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotOrderHistory::~SpotOrderHistory() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.SpotOrderHistory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotOrderHistory::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.order_hash_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.subaccount_id_.Destroy();
  _impl_.execution_type_.Destroy();
  _impl_.order_type_.Destroy();
  _impl_.price_.Destroy();
  _impl_.trigger_price_.Destroy();
  _impl_.quantity_.Destroy();
  _impl_.filled_quantity_.Destroy();
  _impl_.state_.Destroy();
  _impl_.direction_.Destroy();
}

void SpotOrderHistory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotOrderHistory::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.SpotOrderHistory)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.order_hash_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.execution_type_.ClearToEmpty();
  _impl_.order_type_.ClearToEmpty();
  _impl_.price_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  _impl_.quantity_.ClearToEmpty();
  _impl_.filled_quantity_.ClearToEmpty();
  _impl_.state_.ClearToEmpty();
  _impl_.direction_.ClearToEmpty();
  ::memset(&_impl_.created_at_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_active_) -
      reinterpret_cast<char*>(&_impl_.created_at_)) + sizeof(_impl_.is_active_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotOrderHistory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string order_hash = 1 [json_name = "orderHash"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.order_hash"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_active = 3 [json_name = "isActive"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 4 [json_name = "subaccountId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_type = 5 [json_name = "executionType"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_execution_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.execution_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string order_type = 6 [json_name = "orderType"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_order_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.order_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string price = 7 [json_name = "price"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 8 [json_name = "triggerPrice"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 9 [json_name = "quantity"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string filled_quantity = 10 [json_name = "filledQuantity"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_filled_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.filled_quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string state = 11 [json_name = "state"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.state"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 created_at = 12 [json_name = "createdAt"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _impl_.created_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 updated_at = 13 [json_name = "updatedAt"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string direction = 14 [json_name = "direction"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.SpotOrderHistory.direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotOrderHistory::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.SpotOrderHistory)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.order_hash");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // bool is_active = 3 [json_name = "isActive"];
  if (this->_internal_is_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_is_active(), target);
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.subaccount_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string execution_type = 5 [json_name = "executionType"];
  if (!this->_internal_execution_type().empty()) {
    const std::string& _s = this->_internal_execution_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.execution_type");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // string order_type = 6 [json_name = "orderType"];
  if (!this->_internal_order_type().empty()) {
    const std::string& _s = this->_internal_order_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.order_type");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // string price = 7 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.price");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // string trigger_price = 8 [json_name = "triggerPrice"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.trigger_price");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string quantity = 9 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.quantity");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string filled_quantity = 10 [json_name = "filledQuantity"];
  if (!this->_internal_filled_quantity().empty()) {
    const std::string& _s = this->_internal_filled_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.filled_quantity");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // string state = 11 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    const std::string& _s = this->_internal_state();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.state");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // sint64 created_at = 12 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        12, this->_internal_created_at(), target);
  }

  // sint64 updated_at = 13 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        13, this->_internal_updated_at(), target);
  }

  // string direction = 14 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    const std::string& _s = this->_internal_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.SpotOrderHistory.direction");
    target = stream->WriteStringMaybeAliased(14, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.SpotOrderHistory)
  return target;
}

::size_t SpotOrderHistory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.SpotOrderHistory)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_hash());
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string subaccount_id = 4 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string execution_type = 5 [json_name = "executionType"];
  if (!this->_internal_execution_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_type());
  }

  // string order_type = 6 [json_name = "orderType"];
  if (!this->_internal_order_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_type());
  }

  // string price = 7 [json_name = "price"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string trigger_price = 8 [json_name = "triggerPrice"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // string quantity = 9 [json_name = "quantity"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // string filled_quantity = 10 [json_name = "filledQuantity"];
  if (!this->_internal_filled_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_filled_quantity());
  }

  // string state = 11 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_state());
  }

  // string direction = 14 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_direction());
  }

  // sint64 created_at = 12 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_created_at());
  }

  // sint64 updated_at = 13 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_updated_at());
  }

  // bool is_active = 3 [json_name = "isActive"];
  if (this->_internal_is_active() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotOrderHistory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotOrderHistory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotOrderHistory::GetClassData() const { return &_class_data_; }


void SpotOrderHistory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotOrderHistory*>(&to_msg);
  auto& from = static_cast<const SpotOrderHistory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.SpotOrderHistory)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_execution_type().empty()) {
    _this->_internal_set_execution_type(from._internal_execution_type());
  }
  if (!from._internal_order_type().empty()) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (!from._internal_filled_quantity().empty()) {
    _this->_internal_set_filled_quantity(from._internal_filled_quantity());
  }
  if (!from._internal_state().empty()) {
    _this->_internal_set_state(from._internal_state());
  }
  if (!from._internal_direction().empty()) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (from._internal_created_at() != 0) {
    _this->_internal_set_created_at(from._internal_created_at());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  if (from._internal_is_active() != 0) {
    _this->_internal_set_is_active(from._internal_is_active());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotOrderHistory::CopyFrom(const SpotOrderHistory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.SpotOrderHistory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotOrderHistory::IsInitialized() const {
  return true;
}

void SpotOrderHistory::InternalSwap(SpotOrderHistory* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_type_, lhs_arena,
                                       &other->_impl_.execution_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_type_, lhs_arena,
                                       &other->_impl_.order_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.filled_quantity_, lhs_arena,
                                       &other->_impl_.filled_quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_, lhs_arena,
                                       &other->_impl_.state_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.direction_, lhs_arena,
                                       &other->_impl_.direction_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpotOrderHistory, _impl_.is_active_)
      + sizeof(SpotOrderHistory::_impl_.is_active_)
      - PROTOBUF_FIELD_OFFSET(SpotOrderHistory, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotOrderHistory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[46]);
}
// ===================================================================

class StreamOrdersHistoryRequest::_Internal {
 public:
};

StreamOrdersHistoryRequest::StreamOrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
}
StreamOrdersHistoryRequest::StreamOrdersHistoryRequest(const StreamOrdersHistoryRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrdersHistoryRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.order_types_){from._impl_.order_types_}
    , decltype(_impl_.execution_types_){from._impl_.execution_types_}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.state_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_direction().empty()) {
    _this->_impl_.direction_.Set(from._internal_direction(), _this->GetArenaForAllocation());
  }
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state().empty()) {
    _this->_impl_.state_.Set(from._internal_state(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
}

inline void StreamOrdersHistoryRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.order_types_){arena}
    , decltype(_impl_.execution_types_){arena}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.state_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamOrdersHistoryRequest::~StreamOrdersHistoryRequest() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrdersHistoryRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_order_types()->~RepeatedPtrField();
  _internal_mutable_execution_types()->~RepeatedPtrField();
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.direction_.Destroy();
  _impl_.state_.Destroy();
}

void StreamOrdersHistoryRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrdersHistoryRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_order_types()->Clear();
  _internal_mutable_execution_types()->Clear();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.direction_.ClearToEmpty();
  _impl_.state_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrdersHistoryRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string order_types = 3 [json_name = "orderTypes"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_order_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string direction = 4 [json_name = "direction"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string state = 5 [json_name = "state"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.state"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string execution_types = 6 [json_name = "executionTypes"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_execution_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrdersHistoryRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated string order_types = 3 [json_name = "orderTypes"];
  for (int i = 0, n = this->_internal_order_types_size(); i < n; ++i) {
    const auto& s = this->_internal_order_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types");
    target = stream->WriteString(3, s, target);
  }

  // string direction = 4 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    const std::string& _s = this->_internal_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.direction");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string state = 5 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    const std::string& _s = this->_internal_state();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.state");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // repeated string execution_types = 6 [json_name = "executionTypes"];
  for (int i = 0, n = this->_internal_execution_types_size(); i < n; ++i) {
    const auto& s = this->_internal_execution_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
  return target;
}

::size_t StreamOrdersHistoryRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string order_types = 3 [json_name = "orderTypes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_order_types().size());
  for (int i = 0, n = _internal_order_types().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_order_types().Get(i));
  }

  // repeated string execution_types = 6 [json_name = "executionTypes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_execution_types().size());
  for (int i = 0, n = _internal_execution_types().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_execution_types().Get(i));
  }

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string direction = 4 [json_name = "direction"];
  if (!this->_internal_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_direction());
  }

  // string state = 5 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrdersHistoryRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrdersHistoryRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrdersHistoryRequest::GetClassData() const { return &_class_data_; }


void StreamOrdersHistoryRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrdersHistoryRequest*>(&to_msg);
  auto& from = static_cast<const StreamOrdersHistoryRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_order_types()->MergeFrom(from._internal_order_types());
  _this->_internal_mutable_execution_types()->MergeFrom(from._internal_execution_types());
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_direction().empty()) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (!from._internal_state().empty()) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrdersHistoryRequest::CopyFrom(const StreamOrdersHistoryRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrdersHistoryRequest::IsInitialized() const {
  return true;
}

void StreamOrdersHistoryRequest::InternalSwap(StreamOrdersHistoryRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_order_types()->InternalSwap(
      other->_internal_mutable_order_types());
  _internal_mutable_execution_types()->InternalSwap(
      other->_internal_mutable_execution_types());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.direction_, lhs_arena,
                                       &other->_impl_.direction_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_, lhs_arena,
                                       &other->_impl_.state_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrdersHistoryRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[47]);
}
// ===================================================================

class StreamOrdersHistoryResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamOrdersHistoryResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamOrdersHistoryResponse, _impl_._has_bits_);
  static const ::injective_spot_exchange_rpc::SpotOrderHistory& order(const StreamOrdersHistoryResponse* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_spot_exchange_rpc::SpotOrderHistory&
StreamOrdersHistoryResponse::_Internal::order(const StreamOrdersHistoryResponse* msg) {
  return *msg->_impl_.order_;
}
StreamOrdersHistoryResponse::StreamOrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
}
StreamOrdersHistoryResponse::StreamOrdersHistoryResponse(const StreamOrdersHistoryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamOrdersHistoryResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.order_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_operation_type().empty()) {
    _this->_impl_.operation_type_.Set(from._internal_operation_type(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::injective_spot_exchange_rpc::SpotOrderHistory(*from._impl_.order_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
}

inline void StreamOrdersHistoryResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_type_) {}

    , decltype(_impl_.order_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
  _impl_.operation_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.operation_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamOrdersHistoryResponse::~StreamOrdersHistoryResponse() {
  // @@protoc_insertion_point(destructor:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamOrdersHistoryResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.operation_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_;
}

void StreamOrdersHistoryResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamOrdersHistoryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_type_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamOrdersHistoryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_spot_exchange_rpc.SpotOrderHistory order = 1 [json_name = "order"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string operation_type = 2 [json_name = "operationType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operation_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_spot_exchange_rpc.StreamOrdersHistoryResponse.operation_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamOrdersHistoryResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_spot_exchange_rpc.SpotOrderHistory order = 1 [json_name = "order"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    const std::string& _s = this->_internal_operation_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_spot_exchange_rpc.StreamOrdersHistoryResponse.operation_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
  return target;
}

::size_t StreamOrdersHistoryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string operation_type = 2 [json_name = "operationType"];
  if (!this->_internal_operation_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_operation_type());
  }

  // .injective_spot_exchange_rpc.SpotOrderHistory order = 1 [json_name = "order"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  // sint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamOrdersHistoryResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamOrdersHistoryResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamOrdersHistoryResponse::GetClassData() const { return &_class_data_; }


void StreamOrdersHistoryResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamOrdersHistoryResponse*>(&to_msg);
  auto& from = static_cast<const StreamOrdersHistoryResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_operation_type().empty()) {
    _this->_internal_set_operation_type(from._internal_operation_type());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::injective_spot_exchange_rpc::SpotOrderHistory::MergeFrom(
        from._internal_order());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamOrdersHistoryResponse::CopyFrom(const StreamOrdersHistoryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamOrdersHistoryResponse::IsInitialized() const {
  return true;
}

void StreamOrdersHistoryResponse::InternalSwap(StreamOrdersHistoryResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_type_, lhs_arena,
                                       &other->_impl_.operation_type_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamOrdersHistoryResponse, _impl_.timestamp_)
      + sizeof(StreamOrdersHistoryResponse::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamOrdersHistoryResponse, _impl_.order_)>(
          reinterpret_cast<char*>(&_impl_.order_),
          reinterpret_cast<char*>(&other->_impl_.order_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamOrdersHistoryResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto[48]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_spot_exchange_rpc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::MarketsRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::MarketsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::MarketsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::MarketsResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::MarketsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::MarketsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SpotMarketInfo*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SpotMarketInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SpotMarketInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::TokenMeta*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::TokenMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::TokenMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::MarketRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::MarketRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::MarketRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::MarketResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::MarketResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::MarketResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamMarketsRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamMarketsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamMarketsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamMarketsResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamMarketsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamMarketsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbookRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbookRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbookRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbookResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbookResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbookResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SpotLimitOrderbook*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SpotLimitOrderbook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SpotLimitOrderbook >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::PriceLevel*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::PriceLevel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::PriceLevel >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbookV2Request*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbookV2Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbookV2Request >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbookV2Response*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbookV2Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbookV2Response >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SpotLimitOrderbookV2*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SpotLimitOrderbookV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SpotLimitOrderbookV2 >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbooksRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbooksRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbooksRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbooksResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbooksResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbooksResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbooksV2Request*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbooksV2Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbooksV2Request >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbooksV2Response*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbooksV2Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbooksV2Response >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2 >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrderbookRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrderbookRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrderbookRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrderbookResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrderbookResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrderbookResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrderbookV2Request*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrderbookV2Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrderbookV2Request >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrderbookV2Response*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrderbookV2Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrderbookV2Response >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrderbookLevelUpdates*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrderbookLevelUpdates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrderbookLevelUpdates >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::PriceLevelUpdate*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::PriceLevelUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::PriceLevelUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrdersRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrdersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrdersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrdersResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrdersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrdersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SpotLimitOrder*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SpotLimitOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SpotLimitOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::Paging*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::Paging >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::Paging >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrdersRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrdersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrdersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrdersResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrdersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrdersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::TradesRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::TradesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::TradesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::TradesResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::TradesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::TradesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SpotTrade*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SpotTrade >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SpotTrade >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamTradesRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamTradesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamTradesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamTradesResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamTradesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamTradesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SubaccountOrdersListRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SubaccountOrdersListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SubaccountOrdersListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SubaccountOrdersListResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SubaccountOrdersListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SubaccountOrdersListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SubaccountTradesListRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SubaccountTradesListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SubaccountTradesListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SubaccountTradesListResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SubaccountTradesListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SubaccountTradesListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrdersHistoryRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrdersHistoryRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrdersHistoryRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::OrdersHistoryResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::OrdersHistoryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::OrdersHistoryResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::SpotOrderHistory*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::SpotOrderHistory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::SpotOrderHistory >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrdersHistoryRequest*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrdersHistoryRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrdersHistoryRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_spot_exchange_rpc::StreamOrdersHistoryResponse*
Arena::CreateMaybeMessage< ::injective_spot_exchange_rpc::StreamOrdersHistoryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_spot_exchange_rpc::StreamOrdersHistoryResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
