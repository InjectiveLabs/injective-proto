// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_insurance_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5finsurance_5frpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5finsurance_5frpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_exchange_2finjective_5finsurance_5frpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_exchange_2finjective_5finsurance_5frpc_2eproto;
namespace injective_insurance_rpc {
class FundsRequest;
struct FundsRequestDefaultTypeInternal;
extern FundsRequestDefaultTypeInternal _FundsRequest_default_instance_;
class FundsResponse;
struct FundsResponseDefaultTypeInternal;
extern FundsResponseDefaultTypeInternal _FundsResponse_default_instance_;
class InsuranceFund;
struct InsuranceFundDefaultTypeInternal;
extern InsuranceFundDefaultTypeInternal _InsuranceFund_default_instance_;
class RedemptionSchedule;
struct RedemptionScheduleDefaultTypeInternal;
extern RedemptionScheduleDefaultTypeInternal _RedemptionSchedule_default_instance_;
class RedemptionsRequest;
struct RedemptionsRequestDefaultTypeInternal;
extern RedemptionsRequestDefaultTypeInternal _RedemptionsRequest_default_instance_;
class RedemptionsResponse;
struct RedemptionsResponseDefaultTypeInternal;
extern RedemptionsResponseDefaultTypeInternal _RedemptionsResponse_default_instance_;
class TokenMeta;
struct TokenMetaDefaultTypeInternal;
extern TokenMetaDefaultTypeInternal _TokenMeta_default_instance_;
}  // namespace injective_insurance_rpc
PROTOBUF_NAMESPACE_OPEN
template <>
::injective_insurance_rpc::FundsRequest* Arena::CreateMaybeMessage<::injective_insurance_rpc::FundsRequest>(Arena*);
template <>
::injective_insurance_rpc::FundsResponse* Arena::CreateMaybeMessage<::injective_insurance_rpc::FundsResponse>(Arena*);
template <>
::injective_insurance_rpc::InsuranceFund* Arena::CreateMaybeMessage<::injective_insurance_rpc::InsuranceFund>(Arena*);
template <>
::injective_insurance_rpc::RedemptionSchedule* Arena::CreateMaybeMessage<::injective_insurance_rpc::RedemptionSchedule>(Arena*);
template <>
::injective_insurance_rpc::RedemptionsRequest* Arena::CreateMaybeMessage<::injective_insurance_rpc::RedemptionsRequest>(Arena*);
template <>
::injective_insurance_rpc::RedemptionsResponse* Arena::CreateMaybeMessage<::injective_insurance_rpc::RedemptionsResponse>(Arena*);
template <>
::injective_insurance_rpc::TokenMeta* Arena::CreateMaybeMessage<::injective_insurance_rpc::TokenMeta>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective_insurance_rpc {

// ===================================================================


// -------------------------------------------------------------------

class FundsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective_insurance_rpc.FundsRequest) */ {
 public:
  inline FundsRequest() : FundsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundsRequest(const FundsRequest& from);
  FundsRequest(FundsRequest&& from) noexcept
    : FundsRequest() {
    *this = ::std::move(from);
  }

  inline FundsRequest& operator=(const FundsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundsRequest& operator=(FundsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundsRequest* internal_default_instance() {
    return reinterpret_cast<const FundsRequest*>(
               &_FundsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FundsRequest& a, FundsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FundsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FundsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FundsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_insurance_rpc.FundsRequest";
  }
  protected:
  explicit FundsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective_insurance_rpc.FundsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto;
};// -------------------------------------------------------------------

class FundsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_insurance_rpc.FundsResponse) */ {
 public:
  inline FundsResponse() : FundsResponse(nullptr) {}
  ~FundsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundsResponse(const FundsResponse& from);
  FundsResponse(FundsResponse&& from) noexcept
    : FundsResponse() {
    *this = ::std::move(from);
  }

  inline FundsResponse& operator=(const FundsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundsResponse& operator=(FundsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundsResponse* internal_default_instance() {
    return reinterpret_cast<const FundsResponse*>(
               &_FundsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FundsResponse& a, FundsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FundsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FundsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FundsResponse& from) {
    FundsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FundsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_insurance_rpc.FundsResponse";
  }
  protected:
  explicit FundsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsFieldNumber = 1,
  };
  // repeated .injective_insurance_rpc.InsuranceFund funds = 1 [json_name = "funds"];
  int funds_size() const;
  private:
  int _internal_funds_size() const;

  public:
  void clear_funds() ;
  ::injective_insurance_rpc::InsuranceFund* mutable_funds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::InsuranceFund >*
      mutable_funds();
  private:
  const ::injective_insurance_rpc::InsuranceFund& _internal_funds(int index) const;
  ::injective_insurance_rpc::InsuranceFund* _internal_add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::InsuranceFund>& _internal_funds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::InsuranceFund>* _internal_mutable_funds();
  public:
  const ::injective_insurance_rpc::InsuranceFund& funds(int index) const;
  ::injective_insurance_rpc::InsuranceFund* add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::InsuranceFund >&
      funds() const;
  // @@protoc_insertion_point(class_scope:injective_insurance_rpc.FundsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::InsuranceFund > funds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto;
};// -------------------------------------------------------------------

class InsuranceFund final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_insurance_rpc.InsuranceFund) */ {
 public:
  inline InsuranceFund() : InsuranceFund(nullptr) {}
  ~InsuranceFund() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InsuranceFund(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsuranceFund(const InsuranceFund& from);
  InsuranceFund(InsuranceFund&& from) noexcept
    : InsuranceFund() {
    *this = ::std::move(from);
  }

  inline InsuranceFund& operator=(const InsuranceFund& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsuranceFund& operator=(InsuranceFund&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsuranceFund& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsuranceFund* internal_default_instance() {
    return reinterpret_cast<const InsuranceFund*>(
               &_InsuranceFund_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InsuranceFund& a, InsuranceFund& b) {
    a.Swap(&b);
  }
  inline void Swap(InsuranceFund* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsuranceFund* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsuranceFund* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsuranceFund>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsuranceFund& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsuranceFund& from) {
    InsuranceFund::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsuranceFund* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_insurance_rpc.InsuranceFund";
  }
  protected:
  explicit InsuranceFund(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketTickerFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kDepositDenomFieldNumber = 3,
    kPoolTokenDenomFieldNumber = 4,
    kBalanceFieldNumber = 6,
    kTotalShareFieldNumber = 7,
    kOracleBaseFieldNumber = 8,
    kOracleQuoteFieldNumber = 9,
    kOracleTypeFieldNumber = 10,
    kDepositTokenMetaFieldNumber = 12,
    kRedemptionNoticePeriodDurationFieldNumber = 5,
    kExpiryFieldNumber = 11,
  };
  // string market_ticker = 1 [json_name = "marketTicker"];
  void clear_market_ticker() ;
  const std::string& market_ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_market_ticker();
  PROTOBUF_NODISCARD std::string* release_market_ticker();
  void set_allocated_market_ticker(std::string* ptr);

  private:
  const std::string& _internal_market_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_ticker(
      const std::string& value);
  std::string* _internal_mutable_market_ticker();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string deposit_denom = 3 [json_name = "depositDenom"];
  void clear_deposit_denom() ;
  const std::string& deposit_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deposit_denom(Arg_&& arg, Args_... args);
  std::string* mutable_deposit_denom();
  PROTOBUF_NODISCARD std::string* release_deposit_denom();
  void set_allocated_deposit_denom(std::string* ptr);

  private:
  const std::string& _internal_deposit_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deposit_denom(
      const std::string& value);
  std::string* _internal_mutable_deposit_denom();

  public:
  // string pool_token_denom = 4 [json_name = "poolTokenDenom"];
  void clear_pool_token_denom() ;
  const std::string& pool_token_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pool_token_denom(Arg_&& arg, Args_... args);
  std::string* mutable_pool_token_denom();
  PROTOBUF_NODISCARD std::string* release_pool_token_denom();
  void set_allocated_pool_token_denom(std::string* ptr);

  private:
  const std::string& _internal_pool_token_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pool_token_denom(
      const std::string& value);
  std::string* _internal_mutable_pool_token_denom();

  public:
  // string balance = 6 [json_name = "balance"];
  void clear_balance() ;
  const std::string& balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* ptr);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // string total_share = 7 [json_name = "totalShare"];
  void clear_total_share() ;
  const std::string& total_share() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_share(Arg_&& arg, Args_... args);
  std::string* mutable_total_share();
  PROTOBUF_NODISCARD std::string* release_total_share();
  void set_allocated_total_share(std::string* ptr);

  private:
  const std::string& _internal_total_share() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_share(
      const std::string& value);
  std::string* _internal_mutable_total_share();

  public:
  // string oracle_base = 8 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 9 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // string oracle_type = 10 [json_name = "oracleType"];
  void clear_oracle_type() ;
  const std::string& oracle_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_type(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_type();
  PROTOBUF_NODISCARD std::string* release_oracle_type();
  void set_allocated_oracle_type(std::string* ptr);

  private:
  const std::string& _internal_oracle_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_type(
      const std::string& value);
  std::string* _internal_mutable_oracle_type();

  public:
  // .injective_insurance_rpc.TokenMeta deposit_token_meta = 12 [json_name = "depositTokenMeta"];
  bool has_deposit_token_meta() const;
  void clear_deposit_token_meta() ;
  const ::injective_insurance_rpc::TokenMeta& deposit_token_meta() const;
  PROTOBUF_NODISCARD ::injective_insurance_rpc::TokenMeta* release_deposit_token_meta();
  ::injective_insurance_rpc::TokenMeta* mutable_deposit_token_meta();
  void set_allocated_deposit_token_meta(::injective_insurance_rpc::TokenMeta* deposit_token_meta);
  private:
  const ::injective_insurance_rpc::TokenMeta& _internal_deposit_token_meta() const;
  ::injective_insurance_rpc::TokenMeta* _internal_mutable_deposit_token_meta();
  public:
  void unsafe_arena_set_allocated_deposit_token_meta(
      ::injective_insurance_rpc::TokenMeta* deposit_token_meta);
  ::injective_insurance_rpc::TokenMeta* unsafe_arena_release_deposit_token_meta();
  // sint64 redemption_notice_period_duration = 5 [json_name = "redemptionNoticePeriodDuration"];
  void clear_redemption_notice_period_duration() ;
  ::int64_t redemption_notice_period_duration() const;
  void set_redemption_notice_period_duration(::int64_t value);

  private:
  ::int64_t _internal_redemption_notice_period_duration() const;
  void _internal_set_redemption_notice_period_duration(::int64_t value);

  public:
  // sint64 expiry = 11 [json_name = "expiry"];
  void clear_expiry() ;
  ::int64_t expiry() const;
  void set_expiry(::int64_t value);

  private:
  ::int64_t _internal_expiry() const;
  void _internal_set_expiry(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_insurance_rpc.InsuranceFund)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deposit_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pool_token_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_share_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_type_;
    ::injective_insurance_rpc::TokenMeta* deposit_token_meta_;
    ::int64_t redemption_notice_period_duration_;
    ::int64_t expiry_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto;
};// -------------------------------------------------------------------

class TokenMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_insurance_rpc.TokenMeta) */ {
 public:
  inline TokenMeta() : TokenMeta(nullptr) {}
  ~TokenMeta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenMeta(const TokenMeta& from);
  TokenMeta(TokenMeta&& from) noexcept
    : TokenMeta() {
    *this = ::std::move(from);
  }

  inline TokenMeta& operator=(const TokenMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenMeta& operator=(TokenMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenMeta* internal_default_instance() {
    return reinterpret_cast<const TokenMeta*>(
               &_TokenMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TokenMeta& a, TokenMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenMeta& from) {
    TokenMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_insurance_rpc.TokenMeta";
  }
  protected:
  explicit TokenMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kSymbolFieldNumber = 3,
    kLogoFieldNumber = 4,
    kUpdatedAtFieldNumber = 6,
    kDecimalsFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string symbol = 3 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string logo = 4 [json_name = "logo"];
  void clear_logo() ;
  const std::string& logo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_logo(Arg_&& arg, Args_... args);
  std::string* mutable_logo();
  PROTOBUF_NODISCARD std::string* release_logo();
  void set_allocated_logo(std::string* ptr);

  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(
      const std::string& value);
  std::string* _internal_mutable_logo();

  public:
  // sint64 updated_at = 6 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // sint32 decimals = 5 [json_name = "decimals"];
  void clear_decimals() ;
  ::int32_t decimals() const;
  void set_decimals(::int32_t value);

  private:
  ::int32_t _internal_decimals() const;
  void _internal_set_decimals(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_insurance_rpc.TokenMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
    ::int64_t updated_at_;
    ::int32_t decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto;
};// -------------------------------------------------------------------

class RedemptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_insurance_rpc.RedemptionsRequest) */ {
 public:
  inline RedemptionsRequest() : RedemptionsRequest(nullptr) {}
  ~RedemptionsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RedemptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedemptionsRequest(const RedemptionsRequest& from);
  RedemptionsRequest(RedemptionsRequest&& from) noexcept
    : RedemptionsRequest() {
    *this = ::std::move(from);
  }

  inline RedemptionsRequest& operator=(const RedemptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedemptionsRequest& operator=(RedemptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedemptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedemptionsRequest* internal_default_instance() {
    return reinterpret_cast<const RedemptionsRequest*>(
               &_RedemptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RedemptionsRequest& a, RedemptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RedemptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedemptionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedemptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedemptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedemptionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedemptionsRequest& from) {
    RedemptionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedemptionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_insurance_rpc.RedemptionsRequest";
  }
  protected:
  explicit RedemptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedeemerFieldNumber = 1,
    kRedemptionDenomFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string redeemer = 1 [json_name = "redeemer"];
  void clear_redeemer() ;
  const std::string& redeemer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redeemer(Arg_&& arg, Args_... args);
  std::string* mutable_redeemer();
  PROTOBUF_NODISCARD std::string* release_redeemer();
  void set_allocated_redeemer(std::string* ptr);

  private:
  const std::string& _internal_redeemer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redeemer(
      const std::string& value);
  std::string* _internal_mutable_redeemer();

  public:
  // string redemption_denom = 2 [json_name = "redemptionDenom"];
  void clear_redemption_denom() ;
  const std::string& redemption_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redemption_denom(Arg_&& arg, Args_... args);
  std::string* mutable_redemption_denom();
  PROTOBUF_NODISCARD std::string* release_redemption_denom();
  void set_allocated_redemption_denom(std::string* ptr);

  private:
  const std::string& _internal_redemption_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redemption_denom(
      const std::string& value);
  std::string* _internal_mutable_redemption_denom();

  public:
  // string status = 3 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:injective_insurance_rpc.RedemptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redeemer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redemption_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto;
};// -------------------------------------------------------------------

class RedemptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_insurance_rpc.RedemptionsResponse) */ {
 public:
  inline RedemptionsResponse() : RedemptionsResponse(nullptr) {}
  ~RedemptionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RedemptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedemptionsResponse(const RedemptionsResponse& from);
  RedemptionsResponse(RedemptionsResponse&& from) noexcept
    : RedemptionsResponse() {
    *this = ::std::move(from);
  }

  inline RedemptionsResponse& operator=(const RedemptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedemptionsResponse& operator=(RedemptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedemptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedemptionsResponse* internal_default_instance() {
    return reinterpret_cast<const RedemptionsResponse*>(
               &_RedemptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RedemptionsResponse& a, RedemptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RedemptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedemptionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedemptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedemptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedemptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedemptionsResponse& from) {
    RedemptionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedemptionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_insurance_rpc.RedemptionsResponse";
  }
  protected:
  explicit RedemptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedemptionSchedulesFieldNumber = 1,
  };
  // repeated .injective_insurance_rpc.RedemptionSchedule redemption_schedules = 1 [json_name = "redemptionSchedules"];
  int redemption_schedules_size() const;
  private:
  int _internal_redemption_schedules_size() const;

  public:
  void clear_redemption_schedules() ;
  ::injective_insurance_rpc::RedemptionSchedule* mutable_redemption_schedules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::RedemptionSchedule >*
      mutable_redemption_schedules();
  private:
  const ::injective_insurance_rpc::RedemptionSchedule& _internal_redemption_schedules(int index) const;
  ::injective_insurance_rpc::RedemptionSchedule* _internal_add_redemption_schedules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::RedemptionSchedule>& _internal_redemption_schedules() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::RedemptionSchedule>* _internal_mutable_redemption_schedules();
  public:
  const ::injective_insurance_rpc::RedemptionSchedule& redemption_schedules(int index) const;
  ::injective_insurance_rpc::RedemptionSchedule* add_redemption_schedules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::RedemptionSchedule >&
      redemption_schedules() const;
  // @@protoc_insertion_point(class_scope:injective_insurance_rpc.RedemptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::RedemptionSchedule > redemption_schedules_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto;
};// -------------------------------------------------------------------

class RedemptionSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_insurance_rpc.RedemptionSchedule) */ {
 public:
  inline RedemptionSchedule() : RedemptionSchedule(nullptr) {}
  ~RedemptionSchedule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RedemptionSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedemptionSchedule(const RedemptionSchedule& from);
  RedemptionSchedule(RedemptionSchedule&& from) noexcept
    : RedemptionSchedule() {
    *this = ::std::move(from);
  }

  inline RedemptionSchedule& operator=(const RedemptionSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedemptionSchedule& operator=(RedemptionSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedemptionSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedemptionSchedule* internal_default_instance() {
    return reinterpret_cast<const RedemptionSchedule*>(
               &_RedemptionSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RedemptionSchedule& a, RedemptionSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(RedemptionSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedemptionSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedemptionSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedemptionSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedemptionSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedemptionSchedule& from) {
    RedemptionSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedemptionSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_insurance_rpc.RedemptionSchedule";
  }
  protected:
  explicit RedemptionSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kRedeemerFieldNumber = 3,
    kRedemptionAmountFieldNumber = 5,
    kRedemptionDenomFieldNumber = 6,
    kDisbursedAmountFieldNumber = 8,
    kDisbursedDenomFieldNumber = 9,
    kRedemptionIdFieldNumber = 1,
    kClaimableRedemptionTimeFieldNumber = 4,
    kRequestedAtFieldNumber = 7,
    kDisbursedAtFieldNumber = 10,
  };
  // string status = 2 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string redeemer = 3 [json_name = "redeemer"];
  void clear_redeemer() ;
  const std::string& redeemer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redeemer(Arg_&& arg, Args_... args);
  std::string* mutable_redeemer();
  PROTOBUF_NODISCARD std::string* release_redeemer();
  void set_allocated_redeemer(std::string* ptr);

  private:
  const std::string& _internal_redeemer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redeemer(
      const std::string& value);
  std::string* _internal_mutable_redeemer();

  public:
  // string redemption_amount = 5 [json_name = "redemptionAmount"];
  void clear_redemption_amount() ;
  const std::string& redemption_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redemption_amount(Arg_&& arg, Args_... args);
  std::string* mutable_redemption_amount();
  PROTOBUF_NODISCARD std::string* release_redemption_amount();
  void set_allocated_redemption_amount(std::string* ptr);

  private:
  const std::string& _internal_redemption_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redemption_amount(
      const std::string& value);
  std::string* _internal_mutable_redemption_amount();

  public:
  // string redemption_denom = 6 [json_name = "redemptionDenom"];
  void clear_redemption_denom() ;
  const std::string& redemption_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redemption_denom(Arg_&& arg, Args_... args);
  std::string* mutable_redemption_denom();
  PROTOBUF_NODISCARD std::string* release_redemption_denom();
  void set_allocated_redemption_denom(std::string* ptr);

  private:
  const std::string& _internal_redemption_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redemption_denom(
      const std::string& value);
  std::string* _internal_mutable_redemption_denom();

  public:
  // string disbursed_amount = 8 [json_name = "disbursedAmount"];
  void clear_disbursed_amount() ;
  const std::string& disbursed_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_disbursed_amount(Arg_&& arg, Args_... args);
  std::string* mutable_disbursed_amount();
  PROTOBUF_NODISCARD std::string* release_disbursed_amount();
  void set_allocated_disbursed_amount(std::string* ptr);

  private:
  const std::string& _internal_disbursed_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_disbursed_amount(
      const std::string& value);
  std::string* _internal_mutable_disbursed_amount();

  public:
  // string disbursed_denom = 9 [json_name = "disbursedDenom"];
  void clear_disbursed_denom() ;
  const std::string& disbursed_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_disbursed_denom(Arg_&& arg, Args_... args);
  std::string* mutable_disbursed_denom();
  PROTOBUF_NODISCARD std::string* release_disbursed_denom();
  void set_allocated_disbursed_denom(std::string* ptr);

  private:
  const std::string& _internal_disbursed_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_disbursed_denom(
      const std::string& value);
  std::string* _internal_mutable_disbursed_denom();

  public:
  // uint64 redemption_id = 1 [json_name = "redemptionId"];
  void clear_redemption_id() ;
  ::uint64_t redemption_id() const;
  void set_redemption_id(::uint64_t value);

  private:
  ::uint64_t _internal_redemption_id() const;
  void _internal_set_redemption_id(::uint64_t value);

  public:
  // sint64 claimable_redemption_time = 4 [json_name = "claimableRedemptionTime"];
  void clear_claimable_redemption_time() ;
  ::int64_t claimable_redemption_time() const;
  void set_claimable_redemption_time(::int64_t value);

  private:
  ::int64_t _internal_claimable_redemption_time() const;
  void _internal_set_claimable_redemption_time(::int64_t value);

  public:
  // sint64 requested_at = 7 [json_name = "requestedAt"];
  void clear_requested_at() ;
  ::int64_t requested_at() const;
  void set_requested_at(::int64_t value);

  private:
  ::int64_t _internal_requested_at() const;
  void _internal_set_requested_at(::int64_t value);

  public:
  // sint64 disbursed_at = 10 [json_name = "disbursedAt"];
  void clear_disbursed_at() ;
  ::int64_t disbursed_at() const;
  void set_disbursed_at(::int64_t value);

  private:
  ::int64_t _internal_disbursed_at() const;
  void _internal_set_disbursed_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_insurance_rpc.RedemptionSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redeemer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redemption_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redemption_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr disbursed_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr disbursed_denom_;
    ::uint64_t redemption_id_;
    ::int64_t claimable_redemption_time_;
    ::int64_t requested_at_;
    ::int64_t disbursed_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5finsurance_5frpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FundsRequest

// -------------------------------------------------------------------

// FundsResponse

// repeated .injective_insurance_rpc.InsuranceFund funds = 1 [json_name = "funds"];
inline int FundsResponse::_internal_funds_size() const {
  return _impl_.funds_.size();
}
inline int FundsResponse::funds_size() const {
  return _internal_funds_size();
}
inline void FundsResponse::clear_funds() {
  _internal_mutable_funds()->Clear();
}
inline ::injective_insurance_rpc::InsuranceFund* FundsResponse::mutable_funds(int index) {
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.FundsResponse.funds)
  return _internal_mutable_funds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::InsuranceFund >*
FundsResponse::mutable_funds() {
  // @@protoc_insertion_point(field_mutable_list:injective_insurance_rpc.FundsResponse.funds)
  return _internal_mutable_funds();
}
inline const ::injective_insurance_rpc::InsuranceFund& FundsResponse::_internal_funds(int index) const {
  return _internal_funds().Get(index);
}
inline const ::injective_insurance_rpc::InsuranceFund& FundsResponse::funds(int index) const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.FundsResponse.funds)
  return _internal_funds(index);
}
inline ::injective_insurance_rpc::InsuranceFund* FundsResponse::_internal_add_funds() {
  return _internal_mutable_funds()->Add();
}
inline ::injective_insurance_rpc::InsuranceFund* FundsResponse::add_funds() {
  ::injective_insurance_rpc::InsuranceFund* _add = _internal_add_funds();
  // @@protoc_insertion_point(field_add:injective_insurance_rpc.FundsResponse.funds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::InsuranceFund >&
FundsResponse::funds() const {
  // @@protoc_insertion_point(field_list:injective_insurance_rpc.FundsResponse.funds)
  return _internal_funds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::InsuranceFund>&
FundsResponse::_internal_funds() const {
  return _impl_.funds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::InsuranceFund>*
FundsResponse::_internal_mutable_funds() {
  return &_impl_.funds_;
}

// -------------------------------------------------------------------

// InsuranceFund

// string market_ticker = 1 [json_name = "marketTicker"];
inline void InsuranceFund::clear_market_ticker() {
  _impl_.market_ticker_.ClearToEmpty();
}
inline const std::string& InsuranceFund::market_ticker() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.market_ticker)
  return _internal_market_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_market_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.market_ticker)
}
inline std::string* InsuranceFund::mutable_market_ticker() {
  std::string* _s = _internal_mutable_market_ticker();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.market_ticker)
  return _s;
}
inline const std::string& InsuranceFund::_internal_market_ticker() const {
  return _impl_.market_ticker_.Get();
}
inline void InsuranceFund::_internal_set_market_ticker(const std::string& value) {
  ;


  _impl_.market_ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_market_ticker() {
  ;
  return _impl_.market_ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_market_ticker() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.market_ticker)
  return _impl_.market_ticker_.Release();
}
inline void InsuranceFund::set_allocated_market_ticker(std::string* value) {
  _impl_.market_ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_ticker_.IsDefault()) {
          _impl_.market_ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.market_ticker)
}

// string market_id = 2 [json_name = "marketId"];
inline void InsuranceFund::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& InsuranceFund::market_id() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.market_id)
}
inline std::string* InsuranceFund::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.market_id)
  return _s;
}
inline const std::string& InsuranceFund::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void InsuranceFund::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.market_id)
  return _impl_.market_id_.Release();
}
inline void InsuranceFund::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.market_id)
}

// string deposit_denom = 3 [json_name = "depositDenom"];
inline void InsuranceFund::clear_deposit_denom() {
  _impl_.deposit_denom_.ClearToEmpty();
}
inline const std::string& InsuranceFund::deposit_denom() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.deposit_denom)
  return _internal_deposit_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_deposit_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.deposit_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.deposit_denom)
}
inline std::string* InsuranceFund::mutable_deposit_denom() {
  std::string* _s = _internal_mutable_deposit_denom();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.deposit_denom)
  return _s;
}
inline const std::string& InsuranceFund::_internal_deposit_denom() const {
  return _impl_.deposit_denom_.Get();
}
inline void InsuranceFund::_internal_set_deposit_denom(const std::string& value) {
  ;


  _impl_.deposit_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_deposit_denom() {
  ;
  return _impl_.deposit_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_deposit_denom() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.deposit_denom)
  return _impl_.deposit_denom_.Release();
}
inline void InsuranceFund::set_allocated_deposit_denom(std::string* value) {
  _impl_.deposit_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deposit_denom_.IsDefault()) {
          _impl_.deposit_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.deposit_denom)
}

// string pool_token_denom = 4 [json_name = "poolTokenDenom"];
inline void InsuranceFund::clear_pool_token_denom() {
  _impl_.pool_token_denom_.ClearToEmpty();
}
inline const std::string& InsuranceFund::pool_token_denom() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.pool_token_denom)
  return _internal_pool_token_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_pool_token_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.pool_token_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.pool_token_denom)
}
inline std::string* InsuranceFund::mutable_pool_token_denom() {
  std::string* _s = _internal_mutable_pool_token_denom();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.pool_token_denom)
  return _s;
}
inline const std::string& InsuranceFund::_internal_pool_token_denom() const {
  return _impl_.pool_token_denom_.Get();
}
inline void InsuranceFund::_internal_set_pool_token_denom(const std::string& value) {
  ;


  _impl_.pool_token_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_pool_token_denom() {
  ;
  return _impl_.pool_token_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_pool_token_denom() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.pool_token_denom)
  return _impl_.pool_token_denom_.Release();
}
inline void InsuranceFund::set_allocated_pool_token_denom(std::string* value) {
  _impl_.pool_token_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pool_token_denom_.IsDefault()) {
          _impl_.pool_token_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.pool_token_denom)
}

// sint64 redemption_notice_period_duration = 5 [json_name = "redemptionNoticePeriodDuration"];
inline void InsuranceFund::clear_redemption_notice_period_duration() {
  _impl_.redemption_notice_period_duration_ = ::int64_t{0};
}
inline ::int64_t InsuranceFund::redemption_notice_period_duration() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.redemption_notice_period_duration)
  return _internal_redemption_notice_period_duration();
}
inline void InsuranceFund::set_redemption_notice_period_duration(::int64_t value) {
  _internal_set_redemption_notice_period_duration(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.redemption_notice_period_duration)
}
inline ::int64_t InsuranceFund::_internal_redemption_notice_period_duration() const {
  return _impl_.redemption_notice_period_duration_;
}
inline void InsuranceFund::_internal_set_redemption_notice_period_duration(::int64_t value) {
  ;
  _impl_.redemption_notice_period_duration_ = value;
}

// string balance = 6 [json_name = "balance"];
inline void InsuranceFund::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& InsuranceFund::balance() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.balance)
}
inline std::string* InsuranceFund::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.balance)
  return _s;
}
inline const std::string& InsuranceFund::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void InsuranceFund::_internal_set_balance(const std::string& value) {
  ;


  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_balance() {
  ;
  return _impl_.balance_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_balance() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.balance)
  return _impl_.balance_.Release();
}
inline void InsuranceFund::set_allocated_balance(std::string* value) {
  _impl_.balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_.IsDefault()) {
          _impl_.balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.balance)
}

// string total_share = 7 [json_name = "totalShare"];
inline void InsuranceFund::clear_total_share() {
  _impl_.total_share_.ClearToEmpty();
}
inline const std::string& InsuranceFund::total_share() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.total_share)
  return _internal_total_share();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_total_share(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_share_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.total_share)
}
inline std::string* InsuranceFund::mutable_total_share() {
  std::string* _s = _internal_mutable_total_share();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.total_share)
  return _s;
}
inline const std::string& InsuranceFund::_internal_total_share() const {
  return _impl_.total_share_.Get();
}
inline void InsuranceFund::_internal_set_total_share(const std::string& value) {
  ;


  _impl_.total_share_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_total_share() {
  ;
  return _impl_.total_share_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_total_share() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.total_share)
  return _impl_.total_share_.Release();
}
inline void InsuranceFund::set_allocated_total_share(std::string* value) {
  _impl_.total_share_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_share_.IsDefault()) {
          _impl_.total_share_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.total_share)
}

// string oracle_base = 8 [json_name = "oracleBase"];
inline void InsuranceFund::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& InsuranceFund::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.oracle_base)
}
inline std::string* InsuranceFund::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.oracle_base)
  return _s;
}
inline const std::string& InsuranceFund::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void InsuranceFund::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void InsuranceFund::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.oracle_base)
}

// string oracle_quote = 9 [json_name = "oracleQuote"];
inline void InsuranceFund::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& InsuranceFund::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.oracle_quote)
}
inline std::string* InsuranceFund::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.oracle_quote)
  return _s;
}
inline const std::string& InsuranceFund::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void InsuranceFund::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void InsuranceFund::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.oracle_quote)
}

// string oracle_type = 10 [json_name = "oracleType"];
inline void InsuranceFund::clear_oracle_type() {
  _impl_.oracle_type_.ClearToEmpty();
}
inline const std::string& InsuranceFund::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.oracle_type)
  return _internal_oracle_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsuranceFund::set_oracle_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.oracle_type)
}
inline std::string* InsuranceFund::mutable_oracle_type() {
  std::string* _s = _internal_mutable_oracle_type();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.oracle_type)
  return _s;
}
inline const std::string& InsuranceFund::_internal_oracle_type() const {
  return _impl_.oracle_type_.Get();
}
inline void InsuranceFund::_internal_set_oracle_type(const std::string& value) {
  ;


  _impl_.oracle_type_.Set(value, GetArenaForAllocation());
}
inline std::string* InsuranceFund::_internal_mutable_oracle_type() {
  ;
  return _impl_.oracle_type_.Mutable( GetArenaForAllocation());
}
inline std::string* InsuranceFund::release_oracle_type() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.oracle_type)
  return _impl_.oracle_type_.Release();
}
inline void InsuranceFund::set_allocated_oracle_type(std::string* value) {
  _impl_.oracle_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_type_.IsDefault()) {
          _impl_.oracle_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.oracle_type)
}

// sint64 expiry = 11 [json_name = "expiry"];
inline void InsuranceFund::clear_expiry() {
  _impl_.expiry_ = ::int64_t{0};
}
inline ::int64_t InsuranceFund::expiry() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.expiry)
  return _internal_expiry();
}
inline void InsuranceFund::set_expiry(::int64_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.InsuranceFund.expiry)
}
inline ::int64_t InsuranceFund::_internal_expiry() const {
  return _impl_.expiry_;
}
inline void InsuranceFund::_internal_set_expiry(::int64_t value) {
  ;
  _impl_.expiry_ = value;
}

// .injective_insurance_rpc.TokenMeta deposit_token_meta = 12 [json_name = "depositTokenMeta"];
inline bool InsuranceFund::has_deposit_token_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deposit_token_meta_ != nullptr);
  return value;
}
inline void InsuranceFund::clear_deposit_token_meta() {
  if (_impl_.deposit_token_meta_ != nullptr) _impl_.deposit_token_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_insurance_rpc::TokenMeta& InsuranceFund::_internal_deposit_token_meta() const {
  const ::injective_insurance_rpc::TokenMeta* p = _impl_.deposit_token_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_insurance_rpc::TokenMeta&>(
      ::injective_insurance_rpc::_TokenMeta_default_instance_);
}
inline const ::injective_insurance_rpc::TokenMeta& InsuranceFund::deposit_token_meta() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.InsuranceFund.deposit_token_meta)
  return _internal_deposit_token_meta();
}
inline void InsuranceFund::unsafe_arena_set_allocated_deposit_token_meta(
    ::injective_insurance_rpc::TokenMeta* deposit_token_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deposit_token_meta_);
  }
  _impl_.deposit_token_meta_ = deposit_token_meta;
  if (deposit_token_meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_insurance_rpc.InsuranceFund.deposit_token_meta)
}
inline ::injective_insurance_rpc::TokenMeta* InsuranceFund::release_deposit_token_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_insurance_rpc::TokenMeta* temp = _impl_.deposit_token_meta_;
  _impl_.deposit_token_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_insurance_rpc::TokenMeta* InsuranceFund::unsafe_arena_release_deposit_token_meta() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.InsuranceFund.deposit_token_meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_insurance_rpc::TokenMeta* temp = _impl_.deposit_token_meta_;
  _impl_.deposit_token_meta_ = nullptr;
  return temp;
}
inline ::injective_insurance_rpc::TokenMeta* InsuranceFund::_internal_mutable_deposit_token_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deposit_token_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_insurance_rpc::TokenMeta>(GetArenaForAllocation());
    _impl_.deposit_token_meta_ = p;
  }
  return _impl_.deposit_token_meta_;
}
inline ::injective_insurance_rpc::TokenMeta* InsuranceFund::mutable_deposit_token_meta() {
  ::injective_insurance_rpc::TokenMeta* _msg = _internal_mutable_deposit_token_meta();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.InsuranceFund.deposit_token_meta)
  return _msg;
}
inline void InsuranceFund::set_allocated_deposit_token_meta(::injective_insurance_rpc::TokenMeta* deposit_token_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deposit_token_meta_;
  }
  if (deposit_token_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deposit_token_meta);
    if (message_arena != submessage_arena) {
      deposit_token_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deposit_token_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deposit_token_meta_ = deposit_token_meta;
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.InsuranceFund.deposit_token_meta)
}

// -------------------------------------------------------------------

// TokenMeta

// string name = 1 [json_name = "name"];
inline void TokenMeta::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TokenMeta::name() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.TokenMeta.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.TokenMeta.name)
}
inline std::string* TokenMeta::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.TokenMeta.name)
  return _s;
}
inline const std::string& TokenMeta::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TokenMeta::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_name() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.TokenMeta.name)
  return _impl_.name_.Release();
}
inline void TokenMeta::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.TokenMeta.name)
}

// string address = 2 [json_name = "address"];
inline void TokenMeta::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& TokenMeta::address() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.TokenMeta.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.TokenMeta.address)
}
inline std::string* TokenMeta::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.TokenMeta.address)
  return _s;
}
inline const std::string& TokenMeta::_internal_address() const {
  return _impl_.address_.Get();
}
inline void TokenMeta::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_address() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.TokenMeta.address)
  return _impl_.address_.Release();
}
inline void TokenMeta::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.TokenMeta.address)
}

// string symbol = 3 [json_name = "symbol"];
inline void TokenMeta::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& TokenMeta::symbol() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.TokenMeta.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.TokenMeta.symbol)
}
inline std::string* TokenMeta::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.TokenMeta.symbol)
  return _s;
}
inline const std::string& TokenMeta::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void TokenMeta::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_symbol() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.TokenMeta.symbol)
  return _impl_.symbol_.Release();
}
inline void TokenMeta::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.TokenMeta.symbol)
}

// string logo = 4 [json_name = "logo"];
inline void TokenMeta::clear_logo() {
  _impl_.logo_.ClearToEmpty();
}
inline const std::string& TokenMeta::logo() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.TokenMeta.logo)
  return _internal_logo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_logo(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.logo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.TokenMeta.logo)
}
inline std::string* TokenMeta::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.TokenMeta.logo)
  return _s;
}
inline const std::string& TokenMeta::_internal_logo() const {
  return _impl_.logo_.Get();
}
inline void TokenMeta::_internal_set_logo(const std::string& value) {
  ;


  _impl_.logo_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_logo() {
  ;
  return _impl_.logo_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_logo() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.TokenMeta.logo)
  return _impl_.logo_.Release();
}
inline void TokenMeta::set_allocated_logo(std::string* value) {
  _impl_.logo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.logo_.IsDefault()) {
          _impl_.logo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.TokenMeta.logo)
}

// sint32 decimals = 5 [json_name = "decimals"];
inline void TokenMeta::clear_decimals() {
  _impl_.decimals_ = 0;
}
inline ::int32_t TokenMeta::decimals() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.TokenMeta.decimals)
  return _internal_decimals();
}
inline void TokenMeta::set_decimals(::int32_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.TokenMeta.decimals)
}
inline ::int32_t TokenMeta::_internal_decimals() const {
  return _impl_.decimals_;
}
inline void TokenMeta::_internal_set_decimals(::int32_t value) {
  ;
  _impl_.decimals_ = value;
}

// sint64 updated_at = 6 [json_name = "updatedAt"];
inline void TokenMeta::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t TokenMeta::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.TokenMeta.updated_at)
  return _internal_updated_at();
}
inline void TokenMeta::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.TokenMeta.updated_at)
}
inline ::int64_t TokenMeta::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void TokenMeta::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// RedemptionsRequest

// string redeemer = 1 [json_name = "redeemer"];
inline void RedemptionsRequest::clear_redeemer() {
  _impl_.redeemer_.ClearToEmpty();
}
inline const std::string& RedemptionsRequest::redeemer() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionsRequest.redeemer)
  return _internal_redeemer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionsRequest::set_redeemer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.redeemer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionsRequest.redeemer)
}
inline std::string* RedemptionsRequest::mutable_redeemer() {
  std::string* _s = _internal_mutable_redeemer();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionsRequest.redeemer)
  return _s;
}
inline const std::string& RedemptionsRequest::_internal_redeemer() const {
  return _impl_.redeemer_.Get();
}
inline void RedemptionsRequest::_internal_set_redeemer(const std::string& value) {
  ;


  _impl_.redeemer_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionsRequest::_internal_mutable_redeemer() {
  ;
  return _impl_.redeemer_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionsRequest::release_redeemer() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionsRequest.redeemer)
  return _impl_.redeemer_.Release();
}
inline void RedemptionsRequest::set_allocated_redeemer(std::string* value) {
  _impl_.redeemer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redeemer_.IsDefault()) {
          _impl_.redeemer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionsRequest.redeemer)
}

// string redemption_denom = 2 [json_name = "redemptionDenom"];
inline void RedemptionsRequest::clear_redemption_denom() {
  _impl_.redemption_denom_.ClearToEmpty();
}
inline const std::string& RedemptionsRequest::redemption_denom() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionsRequest.redemption_denom)
  return _internal_redemption_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionsRequest::set_redemption_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.redemption_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionsRequest.redemption_denom)
}
inline std::string* RedemptionsRequest::mutable_redemption_denom() {
  std::string* _s = _internal_mutable_redemption_denom();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionsRequest.redemption_denom)
  return _s;
}
inline const std::string& RedemptionsRequest::_internal_redemption_denom() const {
  return _impl_.redemption_denom_.Get();
}
inline void RedemptionsRequest::_internal_set_redemption_denom(const std::string& value) {
  ;


  _impl_.redemption_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionsRequest::_internal_mutable_redemption_denom() {
  ;
  return _impl_.redemption_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionsRequest::release_redemption_denom() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionsRequest.redemption_denom)
  return _impl_.redemption_denom_.Release();
}
inline void RedemptionsRequest::set_allocated_redemption_denom(std::string* value) {
  _impl_.redemption_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redemption_denom_.IsDefault()) {
          _impl_.redemption_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionsRequest.redemption_denom)
}

// string status = 3 [json_name = "status"];
inline void RedemptionsRequest::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& RedemptionsRequest::status() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionsRequest.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionsRequest::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionsRequest.status)
}
inline std::string* RedemptionsRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionsRequest.status)
  return _s;
}
inline const std::string& RedemptionsRequest::_internal_status() const {
  return _impl_.status_.Get();
}
inline void RedemptionsRequest::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionsRequest::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionsRequest::release_status() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionsRequest.status)
  return _impl_.status_.Release();
}
inline void RedemptionsRequest::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionsRequest.status)
}

// -------------------------------------------------------------------

// RedemptionsResponse

// repeated .injective_insurance_rpc.RedemptionSchedule redemption_schedules = 1 [json_name = "redemptionSchedules"];
inline int RedemptionsResponse::_internal_redemption_schedules_size() const {
  return _impl_.redemption_schedules_.size();
}
inline int RedemptionsResponse::redemption_schedules_size() const {
  return _internal_redemption_schedules_size();
}
inline void RedemptionsResponse::clear_redemption_schedules() {
  _internal_mutable_redemption_schedules()->Clear();
}
inline ::injective_insurance_rpc::RedemptionSchedule* RedemptionsResponse::mutable_redemption_schedules(int index) {
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionsResponse.redemption_schedules)
  return _internal_mutable_redemption_schedules()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::RedemptionSchedule >*
RedemptionsResponse::mutable_redemption_schedules() {
  // @@protoc_insertion_point(field_mutable_list:injective_insurance_rpc.RedemptionsResponse.redemption_schedules)
  return _internal_mutable_redemption_schedules();
}
inline const ::injective_insurance_rpc::RedemptionSchedule& RedemptionsResponse::_internal_redemption_schedules(int index) const {
  return _internal_redemption_schedules().Get(index);
}
inline const ::injective_insurance_rpc::RedemptionSchedule& RedemptionsResponse::redemption_schedules(int index) const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionsResponse.redemption_schedules)
  return _internal_redemption_schedules(index);
}
inline ::injective_insurance_rpc::RedemptionSchedule* RedemptionsResponse::_internal_add_redemption_schedules() {
  return _internal_mutable_redemption_schedules()->Add();
}
inline ::injective_insurance_rpc::RedemptionSchedule* RedemptionsResponse::add_redemption_schedules() {
  ::injective_insurance_rpc::RedemptionSchedule* _add = _internal_add_redemption_schedules();
  // @@protoc_insertion_point(field_add:injective_insurance_rpc.RedemptionsResponse.redemption_schedules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_insurance_rpc::RedemptionSchedule >&
RedemptionsResponse::redemption_schedules() const {
  // @@protoc_insertion_point(field_list:injective_insurance_rpc.RedemptionsResponse.redemption_schedules)
  return _internal_redemption_schedules();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::RedemptionSchedule>&
RedemptionsResponse::_internal_redemption_schedules() const {
  return _impl_.redemption_schedules_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_insurance_rpc::RedemptionSchedule>*
RedemptionsResponse::_internal_mutable_redemption_schedules() {
  return &_impl_.redemption_schedules_;
}

// -------------------------------------------------------------------

// RedemptionSchedule

// uint64 redemption_id = 1 [json_name = "redemptionId"];
inline void RedemptionSchedule::clear_redemption_id() {
  _impl_.redemption_id_ = ::uint64_t{0u};
}
inline ::uint64_t RedemptionSchedule::redemption_id() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.redemption_id)
  return _internal_redemption_id();
}
inline void RedemptionSchedule::set_redemption_id(::uint64_t value) {
  _internal_set_redemption_id(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.redemption_id)
}
inline ::uint64_t RedemptionSchedule::_internal_redemption_id() const {
  return _impl_.redemption_id_;
}
inline void RedemptionSchedule::_internal_set_redemption_id(::uint64_t value) {
  ;
  _impl_.redemption_id_ = value;
}

// string status = 2 [json_name = "status"];
inline void RedemptionSchedule::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::status() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.status)
}
inline std::string* RedemptionSchedule::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionSchedule.status)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_status() const {
  return _impl_.status_.Get();
}
inline void RedemptionSchedule::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_status() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionSchedule.status)
  return _impl_.status_.Release();
}
inline void RedemptionSchedule::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionSchedule.status)
}

// string redeemer = 3 [json_name = "redeemer"];
inline void RedemptionSchedule::clear_redeemer() {
  _impl_.redeemer_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::redeemer() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.redeemer)
  return _internal_redeemer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_redeemer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.redeemer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.redeemer)
}
inline std::string* RedemptionSchedule::mutable_redeemer() {
  std::string* _s = _internal_mutable_redeemer();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionSchedule.redeemer)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_redeemer() const {
  return _impl_.redeemer_.Get();
}
inline void RedemptionSchedule::_internal_set_redeemer(const std::string& value) {
  ;


  _impl_.redeemer_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_redeemer() {
  ;
  return _impl_.redeemer_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_redeemer() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionSchedule.redeemer)
  return _impl_.redeemer_.Release();
}
inline void RedemptionSchedule::set_allocated_redeemer(std::string* value) {
  _impl_.redeemer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redeemer_.IsDefault()) {
          _impl_.redeemer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionSchedule.redeemer)
}

// sint64 claimable_redemption_time = 4 [json_name = "claimableRedemptionTime"];
inline void RedemptionSchedule::clear_claimable_redemption_time() {
  _impl_.claimable_redemption_time_ = ::int64_t{0};
}
inline ::int64_t RedemptionSchedule::claimable_redemption_time() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.claimable_redemption_time)
  return _internal_claimable_redemption_time();
}
inline void RedemptionSchedule::set_claimable_redemption_time(::int64_t value) {
  _internal_set_claimable_redemption_time(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.claimable_redemption_time)
}
inline ::int64_t RedemptionSchedule::_internal_claimable_redemption_time() const {
  return _impl_.claimable_redemption_time_;
}
inline void RedemptionSchedule::_internal_set_claimable_redemption_time(::int64_t value) {
  ;
  _impl_.claimable_redemption_time_ = value;
}

// string redemption_amount = 5 [json_name = "redemptionAmount"];
inline void RedemptionSchedule::clear_redemption_amount() {
  _impl_.redemption_amount_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::redemption_amount() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.redemption_amount)
  return _internal_redemption_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_redemption_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.redemption_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.redemption_amount)
}
inline std::string* RedemptionSchedule::mutable_redemption_amount() {
  std::string* _s = _internal_mutable_redemption_amount();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionSchedule.redemption_amount)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_redemption_amount() const {
  return _impl_.redemption_amount_.Get();
}
inline void RedemptionSchedule::_internal_set_redemption_amount(const std::string& value) {
  ;


  _impl_.redemption_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_redemption_amount() {
  ;
  return _impl_.redemption_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_redemption_amount() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionSchedule.redemption_amount)
  return _impl_.redemption_amount_.Release();
}
inline void RedemptionSchedule::set_allocated_redemption_amount(std::string* value) {
  _impl_.redemption_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redemption_amount_.IsDefault()) {
          _impl_.redemption_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionSchedule.redemption_amount)
}

// string redemption_denom = 6 [json_name = "redemptionDenom"];
inline void RedemptionSchedule::clear_redemption_denom() {
  _impl_.redemption_denom_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::redemption_denom() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.redemption_denom)
  return _internal_redemption_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_redemption_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.redemption_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.redemption_denom)
}
inline std::string* RedemptionSchedule::mutable_redemption_denom() {
  std::string* _s = _internal_mutable_redemption_denom();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionSchedule.redemption_denom)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_redemption_denom() const {
  return _impl_.redemption_denom_.Get();
}
inline void RedemptionSchedule::_internal_set_redemption_denom(const std::string& value) {
  ;


  _impl_.redemption_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_redemption_denom() {
  ;
  return _impl_.redemption_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_redemption_denom() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionSchedule.redemption_denom)
  return _impl_.redemption_denom_.Release();
}
inline void RedemptionSchedule::set_allocated_redemption_denom(std::string* value) {
  _impl_.redemption_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.redemption_denom_.IsDefault()) {
          _impl_.redemption_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionSchedule.redemption_denom)
}

// sint64 requested_at = 7 [json_name = "requestedAt"];
inline void RedemptionSchedule::clear_requested_at() {
  _impl_.requested_at_ = ::int64_t{0};
}
inline ::int64_t RedemptionSchedule::requested_at() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.requested_at)
  return _internal_requested_at();
}
inline void RedemptionSchedule::set_requested_at(::int64_t value) {
  _internal_set_requested_at(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.requested_at)
}
inline ::int64_t RedemptionSchedule::_internal_requested_at() const {
  return _impl_.requested_at_;
}
inline void RedemptionSchedule::_internal_set_requested_at(::int64_t value) {
  ;
  _impl_.requested_at_ = value;
}

// string disbursed_amount = 8 [json_name = "disbursedAmount"];
inline void RedemptionSchedule::clear_disbursed_amount() {
  _impl_.disbursed_amount_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::disbursed_amount() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.disbursed_amount)
  return _internal_disbursed_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_disbursed_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.disbursed_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.disbursed_amount)
}
inline std::string* RedemptionSchedule::mutable_disbursed_amount() {
  std::string* _s = _internal_mutable_disbursed_amount();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionSchedule.disbursed_amount)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_disbursed_amount() const {
  return _impl_.disbursed_amount_.Get();
}
inline void RedemptionSchedule::_internal_set_disbursed_amount(const std::string& value) {
  ;


  _impl_.disbursed_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_disbursed_amount() {
  ;
  return _impl_.disbursed_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_disbursed_amount() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionSchedule.disbursed_amount)
  return _impl_.disbursed_amount_.Release();
}
inline void RedemptionSchedule::set_allocated_disbursed_amount(std::string* value) {
  _impl_.disbursed_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.disbursed_amount_.IsDefault()) {
          _impl_.disbursed_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionSchedule.disbursed_amount)
}

// string disbursed_denom = 9 [json_name = "disbursedDenom"];
inline void RedemptionSchedule::clear_disbursed_denom() {
  _impl_.disbursed_denom_.ClearToEmpty();
}
inline const std::string& RedemptionSchedule::disbursed_denom() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.disbursed_denom)
  return _internal_disbursed_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedemptionSchedule::set_disbursed_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.disbursed_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.disbursed_denom)
}
inline std::string* RedemptionSchedule::mutable_disbursed_denom() {
  std::string* _s = _internal_mutable_disbursed_denom();
  // @@protoc_insertion_point(field_mutable:injective_insurance_rpc.RedemptionSchedule.disbursed_denom)
  return _s;
}
inline const std::string& RedemptionSchedule::_internal_disbursed_denom() const {
  return _impl_.disbursed_denom_.Get();
}
inline void RedemptionSchedule::_internal_set_disbursed_denom(const std::string& value) {
  ;


  _impl_.disbursed_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::_internal_mutable_disbursed_denom() {
  ;
  return _impl_.disbursed_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* RedemptionSchedule::release_disbursed_denom() {
  // @@protoc_insertion_point(field_release:injective_insurance_rpc.RedemptionSchedule.disbursed_denom)
  return _impl_.disbursed_denom_.Release();
}
inline void RedemptionSchedule::set_allocated_disbursed_denom(std::string* value) {
  _impl_.disbursed_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.disbursed_denom_.IsDefault()) {
          _impl_.disbursed_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_insurance_rpc.RedemptionSchedule.disbursed_denom)
}

// sint64 disbursed_at = 10 [json_name = "disbursedAt"];
inline void RedemptionSchedule::clear_disbursed_at() {
  _impl_.disbursed_at_ = ::int64_t{0};
}
inline ::int64_t RedemptionSchedule::disbursed_at() const {
  // @@protoc_insertion_point(field_get:injective_insurance_rpc.RedemptionSchedule.disbursed_at)
  return _internal_disbursed_at();
}
inline void RedemptionSchedule::set_disbursed_at(::int64_t value) {
  _internal_set_disbursed_at(value);
  // @@protoc_insertion_point(field_set:injective_insurance_rpc.RedemptionSchedule.disbursed_at)
}
inline ::int64_t RedemptionSchedule::_internal_disbursed_at() const {
  return _impl_.disbursed_at_;
}
inline void RedemptionSchedule::_internal_set_disbursed_at(::int64_t value) {
  ;
  _impl_.disbursed_at_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_insurance_rpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5finsurance_5frpc_2eproto_2epb_2eh
