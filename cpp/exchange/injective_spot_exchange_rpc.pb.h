// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_spot_exchange_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
namespace injective_spot_exchange_rpc {
class MarketRequest;
struct MarketRequestDefaultTypeInternal;
extern MarketRequestDefaultTypeInternal _MarketRequest_default_instance_;
class MarketResponse;
struct MarketResponseDefaultTypeInternal;
extern MarketResponseDefaultTypeInternal _MarketResponse_default_instance_;
class MarketsRequest;
struct MarketsRequestDefaultTypeInternal;
extern MarketsRequestDefaultTypeInternal _MarketsRequest_default_instance_;
class MarketsResponse;
struct MarketsResponseDefaultTypeInternal;
extern MarketsResponseDefaultTypeInternal _MarketsResponse_default_instance_;
class OrderbookLevelUpdates;
struct OrderbookLevelUpdatesDefaultTypeInternal;
extern OrderbookLevelUpdatesDefaultTypeInternal _OrderbookLevelUpdates_default_instance_;
class OrderbookRequest;
struct OrderbookRequestDefaultTypeInternal;
extern OrderbookRequestDefaultTypeInternal _OrderbookRequest_default_instance_;
class OrderbookResponse;
struct OrderbookResponseDefaultTypeInternal;
extern OrderbookResponseDefaultTypeInternal _OrderbookResponse_default_instance_;
class OrderbookV2Request;
struct OrderbookV2RequestDefaultTypeInternal;
extern OrderbookV2RequestDefaultTypeInternal _OrderbookV2Request_default_instance_;
class OrderbookV2Response;
struct OrderbookV2ResponseDefaultTypeInternal;
extern OrderbookV2ResponseDefaultTypeInternal _OrderbookV2Response_default_instance_;
class OrderbooksRequest;
struct OrderbooksRequestDefaultTypeInternal;
extern OrderbooksRequestDefaultTypeInternal _OrderbooksRequest_default_instance_;
class OrderbooksResponse;
struct OrderbooksResponseDefaultTypeInternal;
extern OrderbooksResponseDefaultTypeInternal _OrderbooksResponse_default_instance_;
class OrderbooksV2Request;
struct OrderbooksV2RequestDefaultTypeInternal;
extern OrderbooksV2RequestDefaultTypeInternal _OrderbooksV2Request_default_instance_;
class OrderbooksV2Response;
struct OrderbooksV2ResponseDefaultTypeInternal;
extern OrderbooksV2ResponseDefaultTypeInternal _OrderbooksV2Response_default_instance_;
class OrdersHistoryRequest;
struct OrdersHistoryRequestDefaultTypeInternal;
extern OrdersHistoryRequestDefaultTypeInternal _OrdersHistoryRequest_default_instance_;
class OrdersHistoryResponse;
struct OrdersHistoryResponseDefaultTypeInternal;
extern OrdersHistoryResponseDefaultTypeInternal _OrdersHistoryResponse_default_instance_;
class OrdersRequest;
struct OrdersRequestDefaultTypeInternal;
extern OrdersRequestDefaultTypeInternal _OrdersRequest_default_instance_;
class OrdersResponse;
struct OrdersResponseDefaultTypeInternal;
extern OrdersResponseDefaultTypeInternal _OrdersResponse_default_instance_;
class Paging;
struct PagingDefaultTypeInternal;
extern PagingDefaultTypeInternal _Paging_default_instance_;
class PriceLevel;
struct PriceLevelDefaultTypeInternal;
extern PriceLevelDefaultTypeInternal _PriceLevel_default_instance_;
class PriceLevelUpdate;
struct PriceLevelUpdateDefaultTypeInternal;
extern PriceLevelUpdateDefaultTypeInternal _PriceLevelUpdate_default_instance_;
class SingleSpotLimitOrderbook;
struct SingleSpotLimitOrderbookDefaultTypeInternal;
extern SingleSpotLimitOrderbookDefaultTypeInternal _SingleSpotLimitOrderbook_default_instance_;
class SingleSpotLimitOrderbookV2;
struct SingleSpotLimitOrderbookV2DefaultTypeInternal;
extern SingleSpotLimitOrderbookV2DefaultTypeInternal _SingleSpotLimitOrderbookV2_default_instance_;
class SpotLimitOrder;
struct SpotLimitOrderDefaultTypeInternal;
extern SpotLimitOrderDefaultTypeInternal _SpotLimitOrder_default_instance_;
class SpotLimitOrderbook;
struct SpotLimitOrderbookDefaultTypeInternal;
extern SpotLimitOrderbookDefaultTypeInternal _SpotLimitOrderbook_default_instance_;
class SpotLimitOrderbookV2;
struct SpotLimitOrderbookV2DefaultTypeInternal;
extern SpotLimitOrderbookV2DefaultTypeInternal _SpotLimitOrderbookV2_default_instance_;
class SpotMarketInfo;
struct SpotMarketInfoDefaultTypeInternal;
extern SpotMarketInfoDefaultTypeInternal _SpotMarketInfo_default_instance_;
class SpotOrderHistory;
struct SpotOrderHistoryDefaultTypeInternal;
extern SpotOrderHistoryDefaultTypeInternal _SpotOrderHistory_default_instance_;
class SpotTrade;
struct SpotTradeDefaultTypeInternal;
extern SpotTradeDefaultTypeInternal _SpotTrade_default_instance_;
class StreamMarketsRequest;
struct StreamMarketsRequestDefaultTypeInternal;
extern StreamMarketsRequestDefaultTypeInternal _StreamMarketsRequest_default_instance_;
class StreamMarketsResponse;
struct StreamMarketsResponseDefaultTypeInternal;
extern StreamMarketsResponseDefaultTypeInternal _StreamMarketsResponse_default_instance_;
class StreamOrderbookRequest;
struct StreamOrderbookRequestDefaultTypeInternal;
extern StreamOrderbookRequestDefaultTypeInternal _StreamOrderbookRequest_default_instance_;
class StreamOrderbookResponse;
struct StreamOrderbookResponseDefaultTypeInternal;
extern StreamOrderbookResponseDefaultTypeInternal _StreamOrderbookResponse_default_instance_;
class StreamOrderbookUpdateRequest;
struct StreamOrderbookUpdateRequestDefaultTypeInternal;
extern StreamOrderbookUpdateRequestDefaultTypeInternal _StreamOrderbookUpdateRequest_default_instance_;
class StreamOrderbookUpdateResponse;
struct StreamOrderbookUpdateResponseDefaultTypeInternal;
extern StreamOrderbookUpdateResponseDefaultTypeInternal _StreamOrderbookUpdateResponse_default_instance_;
class StreamOrderbookV2Request;
struct StreamOrderbookV2RequestDefaultTypeInternal;
extern StreamOrderbookV2RequestDefaultTypeInternal _StreamOrderbookV2Request_default_instance_;
class StreamOrderbookV2Response;
struct StreamOrderbookV2ResponseDefaultTypeInternal;
extern StreamOrderbookV2ResponseDefaultTypeInternal _StreamOrderbookV2Response_default_instance_;
class StreamOrdersHistoryRequest;
struct StreamOrdersHistoryRequestDefaultTypeInternal;
extern StreamOrdersHistoryRequestDefaultTypeInternal _StreamOrdersHistoryRequest_default_instance_;
class StreamOrdersHistoryResponse;
struct StreamOrdersHistoryResponseDefaultTypeInternal;
extern StreamOrdersHistoryResponseDefaultTypeInternal _StreamOrdersHistoryResponse_default_instance_;
class StreamOrdersRequest;
struct StreamOrdersRequestDefaultTypeInternal;
extern StreamOrdersRequestDefaultTypeInternal _StreamOrdersRequest_default_instance_;
class StreamOrdersResponse;
struct StreamOrdersResponseDefaultTypeInternal;
extern StreamOrdersResponseDefaultTypeInternal _StreamOrdersResponse_default_instance_;
class StreamTradesRequest;
struct StreamTradesRequestDefaultTypeInternal;
extern StreamTradesRequestDefaultTypeInternal _StreamTradesRequest_default_instance_;
class StreamTradesResponse;
struct StreamTradesResponseDefaultTypeInternal;
extern StreamTradesResponseDefaultTypeInternal _StreamTradesResponse_default_instance_;
class SubaccountOrdersListRequest;
struct SubaccountOrdersListRequestDefaultTypeInternal;
extern SubaccountOrdersListRequestDefaultTypeInternal _SubaccountOrdersListRequest_default_instance_;
class SubaccountOrdersListResponse;
struct SubaccountOrdersListResponseDefaultTypeInternal;
extern SubaccountOrdersListResponseDefaultTypeInternal _SubaccountOrdersListResponse_default_instance_;
class SubaccountTradesListRequest;
struct SubaccountTradesListRequestDefaultTypeInternal;
extern SubaccountTradesListRequestDefaultTypeInternal _SubaccountTradesListRequest_default_instance_;
class SubaccountTradesListResponse;
struct SubaccountTradesListResponseDefaultTypeInternal;
extern SubaccountTradesListResponseDefaultTypeInternal _SubaccountTradesListResponse_default_instance_;
class TokenMeta;
struct TokenMetaDefaultTypeInternal;
extern TokenMetaDefaultTypeInternal _TokenMeta_default_instance_;
class TradesRequest;
struct TradesRequestDefaultTypeInternal;
extern TradesRequestDefaultTypeInternal _TradesRequest_default_instance_;
class TradesResponse;
struct TradesResponseDefaultTypeInternal;
extern TradesResponseDefaultTypeInternal _TradesResponse_default_instance_;
}  // namespace injective_spot_exchange_rpc
PROTOBUF_NAMESPACE_OPEN
template <>
::injective_spot_exchange_rpc::MarketRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::MarketRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::MarketResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::MarketResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::MarketsRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::MarketsRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::MarketsResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::MarketsResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbookLevelUpdates* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbookLevelUpdates>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbookRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbookRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbookResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbookResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbookV2Request* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbookV2Request>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbookV2Response* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbookV2Response>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbooksRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbooksRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbooksResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbooksResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbooksV2Request* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbooksV2Request>(Arena*);
template <>
::injective_spot_exchange_rpc::OrderbooksV2Response* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbooksV2Response>(Arena*);
template <>
::injective_spot_exchange_rpc::OrdersHistoryRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrdersHistoryRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::OrdersHistoryResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrdersHistoryResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::OrdersRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrdersRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::OrdersResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::OrdersResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::Paging* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::Paging>(Arena*);
template <>
::injective_spot_exchange_rpc::PriceLevel* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::PriceLevel>(Arena*);
template <>
::injective_spot_exchange_rpc::PriceLevelUpdate* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::PriceLevelUpdate>(Arena*);
template <>
::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SingleSpotLimitOrderbook>(Arena*);
template <>
::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2>(Arena*);
template <>
::injective_spot_exchange_rpc::SpotLimitOrder* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrder>(Arena*);
template <>
::injective_spot_exchange_rpc::SpotLimitOrderbook* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbook>(Arena*);
template <>
::injective_spot_exchange_rpc::SpotLimitOrderbookV2* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbookV2>(Arena*);
template <>
::injective_spot_exchange_rpc::SpotMarketInfo* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SpotMarketInfo>(Arena*);
template <>
::injective_spot_exchange_rpc::SpotOrderHistory* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SpotOrderHistory>(Arena*);
template <>
::injective_spot_exchange_rpc::SpotTrade* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SpotTrade>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamMarketsRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamMarketsRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamMarketsResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamMarketsResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrderbookRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrderbookRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrderbookResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrderbookResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrderbookUpdateRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrderbookUpdateResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrderbookV2Request* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrderbookV2Request>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrderbookV2Response* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrderbookV2Response>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrdersHistoryRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrdersHistoryRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrdersHistoryResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrdersHistoryResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrdersRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrdersRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamOrdersResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamOrdersResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamTradesRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamTradesRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::StreamTradesResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::StreamTradesResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::SubaccountOrdersListRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SubaccountOrdersListRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::SubaccountOrdersListResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SubaccountOrdersListResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::SubaccountTradesListRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SubaccountTradesListRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::SubaccountTradesListResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::SubaccountTradesListResponse>(Arena*);
template <>
::injective_spot_exchange_rpc::TokenMeta* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::TokenMeta>(Arena*);
template <>
::injective_spot_exchange_rpc::TradesRequest* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::TradesRequest>(Arena*);
template <>
::injective_spot_exchange_rpc::TradesResponse* Arena::CreateMaybeMessage<::injective_spot_exchange_rpc::TradesResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective_spot_exchange_rpc {

// ===================================================================


// -------------------------------------------------------------------

class MarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.MarketsRequest) */ {
 public:
  inline MarketsRequest() : MarketsRequest(nullptr) {}
  ~MarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketsRequest(const MarketsRequest& from);
  MarketsRequest(MarketsRequest&& from) noexcept
    : MarketsRequest() {
    *this = ::std::move(from);
  }

  inline MarketsRequest& operator=(const MarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketsRequest& operator=(MarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketsRequest* internal_default_instance() {
    return reinterpret_cast<const MarketsRequest*>(
               &_MarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MarketsRequest& a, MarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketsRequest& from) {
    MarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.MarketsRequest";
  }
  protected:
  explicit MarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketStatusFieldNumber = 1,
    kBaseDenomFieldNumber = 2,
    kQuoteDenomFieldNumber = 3,
  };
  // string market_status = 1 [json_name = "marketStatus"];
  void clear_market_status() ;
  const std::string& market_status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_status(Arg_&& arg, Args_... args);
  std::string* mutable_market_status();
  PROTOBUF_NODISCARD std::string* release_market_status();
  void set_allocated_market_status(std::string* ptr);

  private:
  const std::string& _internal_market_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_status(
      const std::string& value);
  std::string* _internal_mutable_market_status();

  public:
  // string base_denom = 2 [json_name = "baseDenom"];
  void clear_base_denom() ;
  const std::string& base_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_denom(Arg_&& arg, Args_... args);
  std::string* mutable_base_denom();
  PROTOBUF_NODISCARD std::string* release_base_denom();
  void set_allocated_base_denom(std::string* ptr);

  private:
  const std::string& _internal_base_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_denom(
      const std::string& value);
  std::string* _internal_mutable_base_denom();

  public:
  // string quote_denom = 3 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.MarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class MarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.MarketsResponse) */ {
 public:
  inline MarketsResponse() : MarketsResponse(nullptr) {}
  ~MarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketsResponse(const MarketsResponse& from);
  MarketsResponse(MarketsResponse&& from) noexcept
    : MarketsResponse() {
    *this = ::std::move(from);
  }

  inline MarketsResponse& operator=(const MarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketsResponse& operator=(MarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketsResponse* internal_default_instance() {
    return reinterpret_cast<const MarketsResponse*>(
               &_MarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MarketsResponse& a, MarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketsResponse& from) {
    MarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.MarketsResponse";
  }
  protected:
  explicit MarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketsFieldNumber = 1,
  };
  // repeated .injective_spot_exchange_rpc.SpotMarketInfo markets = 1 [json_name = "markets"];
  int markets_size() const;
  private:
  int _internal_markets_size() const;

  public:
  void clear_markets() ;
  ::injective_spot_exchange_rpc::SpotMarketInfo* mutable_markets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotMarketInfo >*
      mutable_markets();
  private:
  const ::injective_spot_exchange_rpc::SpotMarketInfo& _internal_markets(int index) const;
  ::injective_spot_exchange_rpc::SpotMarketInfo* _internal_add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotMarketInfo>& _internal_markets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotMarketInfo>* _internal_mutable_markets();
  public:
  const ::injective_spot_exchange_rpc::SpotMarketInfo& markets(int index) const;
  ::injective_spot_exchange_rpc::SpotMarketInfo* add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotMarketInfo >&
      markets() const;
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.MarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotMarketInfo > markets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SpotMarketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SpotMarketInfo) */ {
 public:
  inline SpotMarketInfo() : SpotMarketInfo(nullptr) {}
  ~SpotMarketInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotMarketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotMarketInfo(const SpotMarketInfo& from);
  SpotMarketInfo(SpotMarketInfo&& from) noexcept
    : SpotMarketInfo() {
    *this = ::std::move(from);
  }

  inline SpotMarketInfo& operator=(const SpotMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotMarketInfo& operator=(SpotMarketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotMarketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotMarketInfo* internal_default_instance() {
    return reinterpret_cast<const SpotMarketInfo*>(
               &_SpotMarketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SpotMarketInfo& a, SpotMarketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotMarketInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotMarketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotMarketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotMarketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotMarketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotMarketInfo& from) {
    SpotMarketInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotMarketInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SpotMarketInfo";
  }
  protected:
  explicit SpotMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kMarketStatusFieldNumber = 2,
    kTickerFieldNumber = 3,
    kBaseDenomFieldNumber = 4,
    kQuoteDenomFieldNumber = 6,
    kMakerFeeRateFieldNumber = 8,
    kTakerFeeRateFieldNumber = 9,
    kServiceProviderFeeFieldNumber = 10,
    kMinPriceTickSizeFieldNumber = 11,
    kMinQuantityTickSizeFieldNumber = 12,
    kBaseTokenMetaFieldNumber = 5,
    kQuoteTokenMetaFieldNumber = 7,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string market_status = 2 [json_name = "marketStatus"];
  void clear_market_status() ;
  const std::string& market_status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_status(Arg_&& arg, Args_... args);
  std::string* mutable_market_status();
  PROTOBUF_NODISCARD std::string* release_market_status();
  void set_allocated_market_status(std::string* ptr);

  private:
  const std::string& _internal_market_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_status(
      const std::string& value);
  std::string* _internal_mutable_market_status();

  public:
  // string ticker = 3 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string base_denom = 4 [json_name = "baseDenom"];
  void clear_base_denom() ;
  const std::string& base_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_denom(Arg_&& arg, Args_... args);
  std::string* mutable_base_denom();
  PROTOBUF_NODISCARD std::string* release_base_denom();
  void set_allocated_base_denom(std::string* ptr);

  private:
  const std::string& _internal_base_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_denom(
      const std::string& value);
  std::string* _internal_mutable_base_denom();

  public:
  // string quote_denom = 6 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string maker_fee_rate = 8 [json_name = "makerFeeRate"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 9 [json_name = "takerFeeRate"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string service_provider_fee = 10 [json_name = "serviceProviderFee"];
  void clear_service_provider_fee() ;
  const std::string& service_provider_fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_provider_fee(Arg_&& arg, Args_... args);
  std::string* mutable_service_provider_fee();
  PROTOBUF_NODISCARD std::string* release_service_provider_fee();
  void set_allocated_service_provider_fee(std::string* ptr);

  private:
  const std::string& _internal_service_provider_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_provider_fee(
      const std::string& value);
  std::string* _internal_mutable_service_provider_fee();

  public:
  // string min_price_tick_size = 11 [json_name = "minPriceTickSize"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 12 [json_name = "minQuantityTickSize"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective_spot_exchange_rpc.TokenMeta base_token_meta = 5 [json_name = "baseTokenMeta"];
  bool has_base_token_meta() const;
  void clear_base_token_meta() ;
  const ::injective_spot_exchange_rpc::TokenMeta& base_token_meta() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::TokenMeta* release_base_token_meta();
  ::injective_spot_exchange_rpc::TokenMeta* mutable_base_token_meta();
  void set_allocated_base_token_meta(::injective_spot_exchange_rpc::TokenMeta* base_token_meta);
  private:
  const ::injective_spot_exchange_rpc::TokenMeta& _internal_base_token_meta() const;
  ::injective_spot_exchange_rpc::TokenMeta* _internal_mutable_base_token_meta();
  public:
  void unsafe_arena_set_allocated_base_token_meta(
      ::injective_spot_exchange_rpc::TokenMeta* base_token_meta);
  ::injective_spot_exchange_rpc::TokenMeta* unsafe_arena_release_base_token_meta();
  // .injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7 [json_name = "quoteTokenMeta"];
  bool has_quote_token_meta() const;
  void clear_quote_token_meta() ;
  const ::injective_spot_exchange_rpc::TokenMeta& quote_token_meta() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::TokenMeta* release_quote_token_meta();
  ::injective_spot_exchange_rpc::TokenMeta* mutable_quote_token_meta();
  void set_allocated_quote_token_meta(::injective_spot_exchange_rpc::TokenMeta* quote_token_meta);
  private:
  const ::injective_spot_exchange_rpc::TokenMeta& _internal_quote_token_meta() const;
  ::injective_spot_exchange_rpc::TokenMeta* _internal_mutable_quote_token_meta();
  public:
  void unsafe_arena_set_allocated_quote_token_meta(
      ::injective_spot_exchange_rpc::TokenMeta* quote_token_meta);
  ::injective_spot_exchange_rpc::TokenMeta* unsafe_arena_release_quote_token_meta();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SpotMarketInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_provider_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::injective_spot_exchange_rpc::TokenMeta* base_token_meta_;
    ::injective_spot_exchange_rpc::TokenMeta* quote_token_meta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class TokenMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.TokenMeta) */ {
 public:
  inline TokenMeta() : TokenMeta(nullptr) {}
  ~TokenMeta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenMeta(const TokenMeta& from);
  TokenMeta(TokenMeta&& from) noexcept
    : TokenMeta() {
    *this = ::std::move(from);
  }

  inline TokenMeta& operator=(const TokenMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenMeta& operator=(TokenMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenMeta* internal_default_instance() {
    return reinterpret_cast<const TokenMeta*>(
               &_TokenMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TokenMeta& a, TokenMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenMeta& from) {
    TokenMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.TokenMeta";
  }
  protected:
  explicit TokenMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kSymbolFieldNumber = 3,
    kLogoFieldNumber = 4,
    kUpdatedAtFieldNumber = 6,
    kDecimalsFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string symbol = 3 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string logo = 4 [json_name = "logo"];
  void clear_logo() ;
  const std::string& logo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_logo(Arg_&& arg, Args_... args);
  std::string* mutable_logo();
  PROTOBUF_NODISCARD std::string* release_logo();
  void set_allocated_logo(std::string* ptr);

  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(
      const std::string& value);
  std::string* _internal_mutable_logo();

  public:
  // sint64 updated_at = 6 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // sint32 decimals = 5 [json_name = "decimals"];
  void clear_decimals() ;
  ::int32_t decimals() const;
  void set_decimals(::int32_t value);

  private:
  ::int32_t _internal_decimals() const;
  void _internal_set_decimals(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.TokenMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
    ::int64_t updated_at_;
    ::int32_t decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class MarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.MarketRequest) */ {
 public:
  inline MarketRequest() : MarketRequest(nullptr) {}
  ~MarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketRequest(const MarketRequest& from);
  MarketRequest(MarketRequest&& from) noexcept
    : MarketRequest() {
    *this = ::std::move(from);
  }

  inline MarketRequest& operator=(const MarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketRequest& operator=(MarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketRequest* internal_default_instance() {
    return reinterpret_cast<const MarketRequest*>(
               &_MarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MarketRequest& a, MarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketRequest& from) {
    MarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.MarketRequest";
  }
  protected:
  explicit MarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.MarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class MarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.MarketResponse) */ {
 public:
  inline MarketResponse() : MarketResponse(nullptr) {}
  ~MarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketResponse(const MarketResponse& from);
  MarketResponse(MarketResponse&& from) noexcept
    : MarketResponse() {
    *this = ::std::move(from);
  }

  inline MarketResponse& operator=(const MarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketResponse& operator=(MarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketResponse* internal_default_instance() {
    return reinterpret_cast<const MarketResponse*>(
               &_MarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MarketResponse& a, MarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketResponse& from) {
    MarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.MarketResponse";
  }
  protected:
  explicit MarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective_spot_exchange_rpc::SpotMarketInfo& market() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotMarketInfo* release_market();
  ::injective_spot_exchange_rpc::SpotMarketInfo* mutable_market();
  void set_allocated_market(::injective_spot_exchange_rpc::SpotMarketInfo* market);
  private:
  const ::injective_spot_exchange_rpc::SpotMarketInfo& _internal_market() const;
  ::injective_spot_exchange_rpc::SpotMarketInfo* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective_spot_exchange_rpc::SpotMarketInfo* market);
  ::injective_spot_exchange_rpc::SpotMarketInfo* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.MarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_spot_exchange_rpc::SpotMarketInfo* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamMarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamMarketsRequest) */ {
 public:
  inline StreamMarketsRequest() : StreamMarketsRequest(nullptr) {}
  ~StreamMarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamMarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamMarketsRequest(const StreamMarketsRequest& from);
  StreamMarketsRequest(StreamMarketsRequest&& from) noexcept
    : StreamMarketsRequest() {
    *this = ::std::move(from);
  }

  inline StreamMarketsRequest& operator=(const StreamMarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMarketsRequest& operator=(StreamMarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamMarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamMarketsRequest* internal_default_instance() {
    return reinterpret_cast<const StreamMarketsRequest*>(
               &_StreamMarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StreamMarketsRequest& a, StreamMarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamMarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamMarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamMarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamMarketsRequest& from) {
    StreamMarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamMarketsRequest";
  }
  protected:
  explicit StreamMarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamMarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamMarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamMarketsResponse) */ {
 public:
  inline StreamMarketsResponse() : StreamMarketsResponse(nullptr) {}
  ~StreamMarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamMarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamMarketsResponse(const StreamMarketsResponse& from);
  StreamMarketsResponse(StreamMarketsResponse&& from) noexcept
    : StreamMarketsResponse() {
    *this = ::std::move(from);
  }

  inline StreamMarketsResponse& operator=(const StreamMarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMarketsResponse& operator=(StreamMarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamMarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamMarketsResponse* internal_default_instance() {
    return reinterpret_cast<const StreamMarketsResponse*>(
               &_StreamMarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamMarketsResponse& a, StreamMarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamMarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamMarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamMarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamMarketsResponse& from) {
    StreamMarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamMarketsResponse";
  }
  protected:
  explicit StreamMarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective_spot_exchange_rpc::SpotMarketInfo& market() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotMarketInfo* release_market();
  ::injective_spot_exchange_rpc::SpotMarketInfo* mutable_market();
  void set_allocated_market(::injective_spot_exchange_rpc::SpotMarketInfo* market);
  private:
  const ::injective_spot_exchange_rpc::SpotMarketInfo& _internal_market() const;
  ::injective_spot_exchange_rpc::SpotMarketInfo* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective_spot_exchange_rpc::SpotMarketInfo* market);
  ::injective_spot_exchange_rpc::SpotMarketInfo* unsafe_arena_release_market();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamMarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_spot_exchange_rpc::SpotMarketInfo* market_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbookRequest) */ {
 public:
  inline OrderbookRequest() : OrderbookRequest(nullptr) {}
  ~OrderbookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookRequest(const OrderbookRequest& from);
  OrderbookRequest(OrderbookRequest&& from) noexcept
    : OrderbookRequest() {
    *this = ::std::move(from);
  }

  inline OrderbookRequest& operator=(const OrderbookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookRequest& operator=(OrderbookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookRequest* internal_default_instance() {
    return reinterpret_cast<const OrderbookRequest*>(
               &_OrderbookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OrderbookRequest& a, OrderbookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookRequest& from) {
    OrderbookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbookRequest";
  }
  protected:
  explicit OrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbookResponse) */ {
 public:
  inline OrderbookResponse() : OrderbookResponse(nullptr) {}
  ~OrderbookResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookResponse(const OrderbookResponse& from);
  OrderbookResponse(OrderbookResponse&& from) noexcept
    : OrderbookResponse() {
    *this = ::std::move(from);
  }

  inline OrderbookResponse& operator=(const OrderbookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookResponse& operator=(OrderbookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookResponse* internal_default_instance() {
    return reinterpret_cast<const OrderbookResponse*>(
               &_OrderbookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OrderbookResponse& a, OrderbookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookResponse& from) {
    OrderbookResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbookResponse";
  }
  protected:
  explicit OrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbookFieldNumber = 1,
  };
  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook& orderbook() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotLimitOrderbook* release_orderbook();
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* mutable_orderbook();
  void set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook);
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook& _internal_orderbook() const;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook);
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SpotLimitOrderbook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SpotLimitOrderbook) */ {
 public:
  inline SpotLimitOrderbook() : SpotLimitOrderbook(nullptr) {}
  ~SpotLimitOrderbook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotLimitOrderbook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotLimitOrderbook(const SpotLimitOrderbook& from);
  SpotLimitOrderbook(SpotLimitOrderbook&& from) noexcept
    : SpotLimitOrderbook() {
    *this = ::std::move(from);
  }

  inline SpotLimitOrderbook& operator=(const SpotLimitOrderbook& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotLimitOrderbook& operator=(SpotLimitOrderbook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotLimitOrderbook& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotLimitOrderbook* internal_default_instance() {
    return reinterpret_cast<const SpotLimitOrderbook*>(
               &_SpotLimitOrderbook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SpotLimitOrderbook& a, SpotLimitOrderbook& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotLimitOrderbook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotLimitOrderbook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotLimitOrderbook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotLimitOrderbook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotLimitOrderbook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotLimitOrderbook& from) {
    SpotLimitOrderbook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotLimitOrderbook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SpotLimitOrderbook";
  }
  protected:
  explicit SpotLimitOrderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysFieldNumber = 1,
    kSellsFieldNumber = 2,
  };
  // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;

  public:
  void clear_buys() ;
  ::injective_spot_exchange_rpc::PriceLevel* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
      mutable_buys();
  private:
  const ::injective_spot_exchange_rpc::PriceLevel& _internal_buys(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* _internal_add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>& _internal_buys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>* _internal_mutable_buys();
  public:
  const ::injective_spot_exchange_rpc::PriceLevel& buys(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
      buys() const;
  // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;

  public:
  void clear_sells() ;
  ::injective_spot_exchange_rpc::PriceLevel* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
      mutable_sells();
  private:
  const ::injective_spot_exchange_rpc::PriceLevel& _internal_sells(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* _internal_add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>& _internal_sells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>* _internal_mutable_sells();
  public:
  const ::injective_spot_exchange_rpc::PriceLevel& sells(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
      sells() const;
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SpotLimitOrderbook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel > buys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel > sells_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PriceLevel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.PriceLevel) */ {
 public:
  inline PriceLevel() : PriceLevel(nullptr) {}
  ~PriceLevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceLevel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceLevel(const PriceLevel& from);
  PriceLevel(PriceLevel&& from) noexcept
    : PriceLevel() {
    *this = ::std::move(from);
  }

  inline PriceLevel& operator=(const PriceLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceLevel& operator=(PriceLevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceLevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceLevel* internal_default_instance() {
    return reinterpret_cast<const PriceLevel*>(
               &_PriceLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PriceLevel& a, PriceLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceLevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceLevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceLevel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceLevel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceLevel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceLevel& from) {
    PriceLevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceLevel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.PriceLevel";
  }
  protected:
  explicit PriceLevel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string price = 1 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.PriceLevel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookV2Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbookV2Request) */ {
 public:
  inline OrderbookV2Request() : OrderbookV2Request(nullptr) {}
  ~OrderbookV2Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookV2Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookV2Request(const OrderbookV2Request& from);
  OrderbookV2Request(OrderbookV2Request&& from) noexcept
    : OrderbookV2Request() {
    *this = ::std::move(from);
  }

  inline OrderbookV2Request& operator=(const OrderbookV2Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookV2Request& operator=(OrderbookV2Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookV2Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookV2Request* internal_default_instance() {
    return reinterpret_cast<const OrderbookV2Request*>(
               &_OrderbookV2Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OrderbookV2Request& a, OrderbookV2Request& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookV2Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookV2Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookV2Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookV2Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookV2Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookV2Request& from) {
    OrderbookV2Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookV2Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbookV2Request";
  }
  protected:
  explicit OrderbookV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbookV2Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookV2Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbookV2Response) */ {
 public:
  inline OrderbookV2Response() : OrderbookV2Response(nullptr) {}
  ~OrderbookV2Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookV2Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookV2Response(const OrderbookV2Response& from);
  OrderbookV2Response(OrderbookV2Response&& from) noexcept
    : OrderbookV2Response() {
    *this = ::std::move(from);
  }

  inline OrderbookV2Response& operator=(const OrderbookV2Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookV2Response& operator=(OrderbookV2Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookV2Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookV2Response* internal_default_instance() {
    return reinterpret_cast<const OrderbookV2Response*>(
               &_OrderbookV2Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(OrderbookV2Response& a, OrderbookV2Response& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookV2Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookV2Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookV2Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookV2Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookV2Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookV2Response& from) {
    OrderbookV2Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookV2Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbookV2Response";
  }
  protected:
  explicit OrderbookV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbookFieldNumber = 1,
  };
  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& orderbook() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* release_orderbook();
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* mutable_orderbook();
  void set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook);
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& _internal_orderbook() const;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook);
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbookV2Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SpotLimitOrderbookV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SpotLimitOrderbookV2) */ {
 public:
  inline SpotLimitOrderbookV2() : SpotLimitOrderbookV2(nullptr) {}
  ~SpotLimitOrderbookV2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotLimitOrderbookV2(const SpotLimitOrderbookV2& from);
  SpotLimitOrderbookV2(SpotLimitOrderbookV2&& from) noexcept
    : SpotLimitOrderbookV2() {
    *this = ::std::move(from);
  }

  inline SpotLimitOrderbookV2& operator=(const SpotLimitOrderbookV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotLimitOrderbookV2& operator=(SpotLimitOrderbookV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotLimitOrderbookV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotLimitOrderbookV2* internal_default_instance() {
    return reinterpret_cast<const SpotLimitOrderbookV2*>(
               &_SpotLimitOrderbookV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SpotLimitOrderbookV2& a, SpotLimitOrderbookV2& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotLimitOrderbookV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotLimitOrderbookV2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotLimitOrderbookV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotLimitOrderbookV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotLimitOrderbookV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotLimitOrderbookV2& from) {
    SpotLimitOrderbookV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotLimitOrderbookV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SpotLimitOrderbookV2";
  }
  protected:
  explicit SpotLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysFieldNumber = 1,
    kSellsFieldNumber = 2,
    kSequenceFieldNumber = 3,
  };
  // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;

  public:
  void clear_buys() ;
  ::injective_spot_exchange_rpc::PriceLevel* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
      mutable_buys();
  private:
  const ::injective_spot_exchange_rpc::PriceLevel& _internal_buys(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* _internal_add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>& _internal_buys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>* _internal_mutable_buys();
  public:
  const ::injective_spot_exchange_rpc::PriceLevel& buys(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
      buys() const;
  // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;

  public:
  void clear_sells() ;
  ::injective_spot_exchange_rpc::PriceLevel* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
      mutable_sells();
  private:
  const ::injective_spot_exchange_rpc::PriceLevel& _internal_sells(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* _internal_add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>& _internal_sells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>* _internal_mutable_sells();
  public:
  const ::injective_spot_exchange_rpc::PriceLevel& sells(int index) const;
  ::injective_spot_exchange_rpc::PriceLevel* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
      sells() const;
  // uint64 sequence = 3 [json_name = "sequence"];
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SpotLimitOrderbookV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel > buys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel > sells_;
    ::uint64_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbooksRequest) */ {
 public:
  inline OrderbooksRequest() : OrderbooksRequest(nullptr) {}
  ~OrderbooksRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksRequest(const OrderbooksRequest& from);
  OrderbooksRequest(OrderbooksRequest&& from) noexcept
    : OrderbooksRequest() {
    *this = ::std::move(from);
  }

  inline OrderbooksRequest& operator=(const OrderbooksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksRequest& operator=(OrderbooksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksRequest* internal_default_instance() {
    return reinterpret_cast<const OrderbooksRequest*>(
               &_OrderbooksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(OrderbooksRequest& a, OrderbooksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksRequest& from) {
    OrderbooksRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbooksRequest";
  }
  protected:
  explicit OrderbooksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbooksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbooksResponse) */ {
 public:
  inline OrderbooksResponse() : OrderbooksResponse(nullptr) {}
  ~OrderbooksResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksResponse(const OrderbooksResponse& from);
  OrderbooksResponse(OrderbooksResponse&& from) noexcept
    : OrderbooksResponse() {
    *this = ::std::move(from);
  }

  inline OrderbooksResponse& operator=(const OrderbooksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksResponse& operator=(OrderbooksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksResponse* internal_default_instance() {
    return reinterpret_cast<const OrderbooksResponse*>(
               &_OrderbooksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(OrderbooksResponse& a, OrderbooksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksResponse& from) {
    OrderbooksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbooksResponse";
  }
  protected:
  explicit OrderbooksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbooksFieldNumber = 1,
  };
  // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbook orderbooks = 1 [json_name = "orderbooks"];
  int orderbooks_size() const;
  private:
  int _internal_orderbooks_size() const;

  public:
  void clear_orderbooks() ;
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* mutable_orderbooks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook >*
      mutable_orderbooks();
  private:
  const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook& _internal_orderbooks(int index) const;
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* _internal_add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbook>& _internal_orderbooks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbook>* _internal_mutable_orderbooks();
  public:
  const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook& orderbooks(int index) const;
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook >&
      orderbooks() const;
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbooksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook > orderbooks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SingleSpotLimitOrderbook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SingleSpotLimitOrderbook) */ {
 public:
  inline SingleSpotLimitOrderbook() : SingleSpotLimitOrderbook(nullptr) {}
  ~SingleSpotLimitOrderbook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SingleSpotLimitOrderbook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleSpotLimitOrderbook(const SingleSpotLimitOrderbook& from);
  SingleSpotLimitOrderbook(SingleSpotLimitOrderbook&& from) noexcept
    : SingleSpotLimitOrderbook() {
    *this = ::std::move(from);
  }

  inline SingleSpotLimitOrderbook& operator=(const SingleSpotLimitOrderbook& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleSpotLimitOrderbook& operator=(SingleSpotLimitOrderbook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleSpotLimitOrderbook& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleSpotLimitOrderbook* internal_default_instance() {
    return reinterpret_cast<const SingleSpotLimitOrderbook*>(
               &_SingleSpotLimitOrderbook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SingleSpotLimitOrderbook& a, SingleSpotLimitOrderbook& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleSpotLimitOrderbook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleSpotLimitOrderbook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleSpotLimitOrderbook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleSpotLimitOrderbook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleSpotLimitOrderbook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleSpotLimitOrderbook& from) {
    SingleSpotLimitOrderbook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleSpotLimitOrderbook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SingleSpotLimitOrderbook";
  }
  protected:
  explicit SingleSpotLimitOrderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kOrderbookFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 2 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook& orderbook() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotLimitOrderbook* release_orderbook();
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* mutable_orderbook();
  void set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook);
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook& _internal_orderbook() const;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook);
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SingleSpotLimitOrderbook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksV2Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbooksV2Request) */ {
 public:
  inline OrderbooksV2Request() : OrderbooksV2Request(nullptr) {}
  ~OrderbooksV2Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksV2Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksV2Request(const OrderbooksV2Request& from);
  OrderbooksV2Request(OrderbooksV2Request&& from) noexcept
    : OrderbooksV2Request() {
    *this = ::std::move(from);
  }

  inline OrderbooksV2Request& operator=(const OrderbooksV2Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksV2Request& operator=(OrderbooksV2Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksV2Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksV2Request* internal_default_instance() {
    return reinterpret_cast<const OrderbooksV2Request*>(
               &_OrderbooksV2Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OrderbooksV2Request& a, OrderbooksV2Request& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksV2Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksV2Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksV2Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksV2Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksV2Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksV2Request& from) {
    OrderbooksV2Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksV2Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbooksV2Request";
  }
  protected:
  explicit OrderbooksV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbooksV2Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksV2Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbooksV2Response) */ {
 public:
  inline OrderbooksV2Response() : OrderbooksV2Response(nullptr) {}
  ~OrderbooksV2Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksV2Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksV2Response(const OrderbooksV2Response& from);
  OrderbooksV2Response(OrderbooksV2Response&& from) noexcept
    : OrderbooksV2Response() {
    *this = ::std::move(from);
  }

  inline OrderbooksV2Response& operator=(const OrderbooksV2Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksV2Response& operator=(OrderbooksV2Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksV2Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksV2Response* internal_default_instance() {
    return reinterpret_cast<const OrderbooksV2Response*>(
               &_OrderbooksV2Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OrderbooksV2Response& a, OrderbooksV2Response& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksV2Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksV2Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksV2Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksV2Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksV2Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksV2Response& from) {
    OrderbooksV2Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksV2Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbooksV2Response";
  }
  protected:
  explicit OrderbooksV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbooksFieldNumber = 1,
  };
  // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1 [json_name = "orderbooks"];
  int orderbooks_size() const;
  private:
  int _internal_orderbooks_size() const;

  public:
  void clear_orderbooks() ;
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* mutable_orderbooks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2 >*
      mutable_orderbooks();
  private:
  const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2& _internal_orderbooks(int index) const;
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* _internal_add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2>& _internal_orderbooks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2>* _internal_mutable_orderbooks();
  public:
  const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2& orderbooks(int index) const;
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2 >&
      orderbooks() const;
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbooksV2Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2 > orderbooks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SingleSpotLimitOrderbookV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2) */ {
 public:
  inline SingleSpotLimitOrderbookV2() : SingleSpotLimitOrderbookV2(nullptr) {}
  ~SingleSpotLimitOrderbookV2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SingleSpotLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleSpotLimitOrderbookV2(const SingleSpotLimitOrderbookV2& from);
  SingleSpotLimitOrderbookV2(SingleSpotLimitOrderbookV2&& from) noexcept
    : SingleSpotLimitOrderbookV2() {
    *this = ::std::move(from);
  }

  inline SingleSpotLimitOrderbookV2& operator=(const SingleSpotLimitOrderbookV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleSpotLimitOrderbookV2& operator=(SingleSpotLimitOrderbookV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleSpotLimitOrderbookV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleSpotLimitOrderbookV2* internal_default_instance() {
    return reinterpret_cast<const SingleSpotLimitOrderbookV2*>(
               &_SingleSpotLimitOrderbookV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SingleSpotLimitOrderbookV2& a, SingleSpotLimitOrderbookV2& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleSpotLimitOrderbookV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleSpotLimitOrderbookV2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleSpotLimitOrderbookV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleSpotLimitOrderbookV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleSpotLimitOrderbookV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleSpotLimitOrderbookV2& from) {
    SingleSpotLimitOrderbookV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleSpotLimitOrderbookV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2";
  }
  protected:
  explicit SingleSpotLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kOrderbookFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& orderbook() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* release_orderbook();
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* mutable_orderbook();
  void set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook);
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& _internal_orderbook() const;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook);
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrderbookRequest) */ {
 public:
  inline StreamOrderbookRequest() : StreamOrderbookRequest(nullptr) {}
  ~StreamOrderbookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookRequest(const StreamOrderbookRequest& from);
  StreamOrderbookRequest(StreamOrderbookRequest&& from) noexcept
    : StreamOrderbookRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookRequest& operator=(const StreamOrderbookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookRequest& operator=(StreamOrderbookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookRequest*>(
               &_StreamOrderbookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StreamOrderbookRequest& a, StreamOrderbookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookRequest& from) {
    StreamOrderbookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrderbookRequest";
  }
  protected:
  explicit StreamOrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrderbookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrderbookResponse) */ {
 public:
  inline StreamOrderbookResponse() : StreamOrderbookResponse(nullptr) {}
  ~StreamOrderbookResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookResponse(const StreamOrderbookResponse& from);
  StreamOrderbookResponse(StreamOrderbookResponse&& from) noexcept
    : StreamOrderbookResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookResponse& operator=(const StreamOrderbookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookResponse& operator=(StreamOrderbookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookResponse*>(
               &_StreamOrderbookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StreamOrderbookResponse& a, StreamOrderbookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookResponse& from) {
    StreamOrderbookResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrderbookResponse";
  }
  protected:
  explicit StreamOrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketIdFieldNumber = 4,
    kOrderbookFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // string market_id = 4 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook& orderbook() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotLimitOrderbook* release_orderbook();
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* mutable_orderbook();
  void set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook);
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook& _internal_orderbook() const;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook);
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* unsafe_arena_release_orderbook();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrderbookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookV2Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrderbookV2Request) */ {
 public:
  inline StreamOrderbookV2Request() : StreamOrderbookV2Request(nullptr) {}
  ~StreamOrderbookV2Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookV2Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookV2Request(const StreamOrderbookV2Request& from);
  StreamOrderbookV2Request(StreamOrderbookV2Request&& from) noexcept
    : StreamOrderbookV2Request() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookV2Request& operator=(const StreamOrderbookV2Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookV2Request& operator=(StreamOrderbookV2Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookV2Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookV2Request* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookV2Request*>(
               &_StreamOrderbookV2Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StreamOrderbookV2Request& a, StreamOrderbookV2Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookV2Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookV2Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookV2Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookV2Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookV2Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookV2Request& from) {
    StreamOrderbookV2Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookV2Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrderbookV2Request";
  }
  protected:
  explicit StreamOrderbookV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrderbookV2Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookV2Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrderbookV2Response) */ {
 public:
  inline StreamOrderbookV2Response() : StreamOrderbookV2Response(nullptr) {}
  ~StreamOrderbookV2Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookV2Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookV2Response(const StreamOrderbookV2Response& from);
  StreamOrderbookV2Response(StreamOrderbookV2Response&& from) noexcept
    : StreamOrderbookV2Response() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookV2Response& operator=(const StreamOrderbookV2Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookV2Response& operator=(StreamOrderbookV2Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookV2Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookV2Response* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookV2Response*>(
               &_StreamOrderbookV2Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StreamOrderbookV2Response& a, StreamOrderbookV2Response& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookV2Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookV2Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookV2Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookV2Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookV2Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookV2Response& from) {
    StreamOrderbookV2Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookV2Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrderbookV2Response";
  }
  protected:
  explicit StreamOrderbookV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketIdFieldNumber = 4,
    kOrderbookFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // string market_id = 4 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& orderbook() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* release_orderbook();
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* mutable_orderbook();
  void set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook);
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& _internal_orderbook() const;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook);
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* unsafe_arena_release_orderbook();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrderbookV2Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest) */ {
 public:
  inline StreamOrderbookUpdateRequest() : StreamOrderbookUpdateRequest(nullptr) {}
  ~StreamOrderbookUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookUpdateRequest(const StreamOrderbookUpdateRequest& from);
  StreamOrderbookUpdateRequest(StreamOrderbookUpdateRequest&& from) noexcept
    : StreamOrderbookUpdateRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookUpdateRequest& operator=(const StreamOrderbookUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookUpdateRequest& operator=(StreamOrderbookUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookUpdateRequest*>(
               &_StreamOrderbookUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(StreamOrderbookUpdateRequest& a, StreamOrderbookUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookUpdateRequest& from) {
    StreamOrderbookUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrderbookUpdateRequest";
  }
  protected:
  explicit StreamOrderbookUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse) */ {
 public:
  inline StreamOrderbookUpdateResponse() : StreamOrderbookUpdateResponse(nullptr) {}
  ~StreamOrderbookUpdateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookUpdateResponse(const StreamOrderbookUpdateResponse& from);
  StreamOrderbookUpdateResponse(StreamOrderbookUpdateResponse&& from) noexcept
    : StreamOrderbookUpdateResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookUpdateResponse& operator=(const StreamOrderbookUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookUpdateResponse& operator=(StreamOrderbookUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookUpdateResponse*>(
               &_StreamOrderbookUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(StreamOrderbookUpdateResponse& a, StreamOrderbookUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookUpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookUpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookUpdateResponse& from) {
    StreamOrderbookUpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrderbookUpdateResponse";
  }
  protected:
  explicit StreamOrderbookUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketIdFieldNumber = 4,
    kOrderbookLevelUpdatesFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // string market_id = 4 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1 [json_name = "orderbookLevelUpdates"];
  bool has_orderbook_level_updates() const;
  void clear_orderbook_level_updates() ;
  const ::injective_spot_exchange_rpc::OrderbookLevelUpdates& orderbook_level_updates() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::OrderbookLevelUpdates* release_orderbook_level_updates();
  ::injective_spot_exchange_rpc::OrderbookLevelUpdates* mutable_orderbook_level_updates();
  void set_allocated_orderbook_level_updates(::injective_spot_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates);
  private:
  const ::injective_spot_exchange_rpc::OrderbookLevelUpdates& _internal_orderbook_level_updates() const;
  ::injective_spot_exchange_rpc::OrderbookLevelUpdates* _internal_mutable_orderbook_level_updates();
  public:
  void unsafe_arena_set_allocated_orderbook_level_updates(
      ::injective_spot_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates);
  ::injective_spot_exchange_rpc::OrderbookLevelUpdates* unsafe_arena_release_orderbook_level_updates();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_spot_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookLevelUpdates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrderbookLevelUpdates) */ {
 public:
  inline OrderbookLevelUpdates() : OrderbookLevelUpdates(nullptr) {}
  ~OrderbookLevelUpdates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookLevelUpdates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookLevelUpdates(const OrderbookLevelUpdates& from);
  OrderbookLevelUpdates(OrderbookLevelUpdates&& from) noexcept
    : OrderbookLevelUpdates() {
    *this = ::std::move(from);
  }

  inline OrderbookLevelUpdates& operator=(const OrderbookLevelUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookLevelUpdates& operator=(OrderbookLevelUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookLevelUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookLevelUpdates* internal_default_instance() {
    return reinterpret_cast<const OrderbookLevelUpdates*>(
               &_OrderbookLevelUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(OrderbookLevelUpdates& a, OrderbookLevelUpdates& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookLevelUpdates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookLevelUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookLevelUpdates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookLevelUpdates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookLevelUpdates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookLevelUpdates& from) {
    OrderbookLevelUpdates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookLevelUpdates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrderbookLevelUpdates";
  }
  protected:
  explicit OrderbookLevelUpdates(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysFieldNumber = 3,
    kSellsFieldNumber = 4,
    kMarketIdFieldNumber = 1,
    kSequenceFieldNumber = 2,
    kUpdatedAtFieldNumber = 5,
  };
  // repeated .injective_spot_exchange_rpc.PriceLevelUpdate buys = 3 [json_name = "buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;

  public:
  void clear_buys() ;
  ::injective_spot_exchange_rpc::PriceLevelUpdate* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >*
      mutable_buys();
  private:
  const ::injective_spot_exchange_rpc::PriceLevelUpdate& _internal_buys(int index) const;
  ::injective_spot_exchange_rpc::PriceLevelUpdate* _internal_add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>& _internal_buys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>* _internal_mutable_buys();
  public:
  const ::injective_spot_exchange_rpc::PriceLevelUpdate& buys(int index) const;
  ::injective_spot_exchange_rpc::PriceLevelUpdate* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >&
      buys() const;
  // repeated .injective_spot_exchange_rpc.PriceLevelUpdate sells = 4 [json_name = "sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;

  public:
  void clear_sells() ;
  ::injective_spot_exchange_rpc::PriceLevelUpdate* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >*
      mutable_sells();
  private:
  const ::injective_spot_exchange_rpc::PriceLevelUpdate& _internal_sells(int index) const;
  ::injective_spot_exchange_rpc::PriceLevelUpdate* _internal_add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>& _internal_sells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>* _internal_mutable_sells();
  public:
  const ::injective_spot_exchange_rpc::PriceLevelUpdate& sells(int index) const;
  ::injective_spot_exchange_rpc::PriceLevelUpdate* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >&
      sells() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // uint64 sequence = 2 [json_name = "sequence"];
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // sint64 updated_at = 5 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrderbookLevelUpdates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate > buys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate > sells_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::uint64_t sequence_;
    ::int64_t updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PriceLevelUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.PriceLevelUpdate) */ {
 public:
  inline PriceLevelUpdate() : PriceLevelUpdate(nullptr) {}
  ~PriceLevelUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceLevelUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceLevelUpdate(const PriceLevelUpdate& from);
  PriceLevelUpdate(PriceLevelUpdate&& from) noexcept
    : PriceLevelUpdate() {
    *this = ::std::move(from);
  }

  inline PriceLevelUpdate& operator=(const PriceLevelUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceLevelUpdate& operator=(PriceLevelUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceLevelUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceLevelUpdate* internal_default_instance() {
    return reinterpret_cast<const PriceLevelUpdate*>(
               &_PriceLevelUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PriceLevelUpdate& a, PriceLevelUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceLevelUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceLevelUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceLevelUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceLevelUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceLevelUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceLevelUpdate& from) {
    PriceLevelUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceLevelUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.PriceLevelUpdate";
  }
  protected:
  explicit PriceLevelUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kIsActiveFieldNumber = 3,
  };
  // string price = 1 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // sint64 timestamp = 4 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // bool is_active = 3 [json_name = "isActive"];
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.PriceLevelUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::int64_t timestamp_;
    bool is_active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrdersRequest) */ {
 public:
  inline OrdersRequest() : OrdersRequest(nullptr) {}
  ~OrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersRequest(const OrdersRequest& from);
  OrdersRequest(OrdersRequest&& from) noexcept
    : OrdersRequest() {
    *this = ::std::move(from);
  }

  inline OrdersRequest& operator=(const OrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersRequest& operator=(OrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersRequest* internal_default_instance() {
    return reinterpret_cast<const OrdersRequest*>(
               &_OrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(OrdersRequest& a, OrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersRequest& from) {
    OrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrdersRequest";
  }
  protected:
  explicit OrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 8,
    kMarketIdFieldNumber = 1,
    kOrderSideFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kSkipFieldNumber = 4,
    kStartTimeFieldNumber = 6,
    kEndTimeFieldNumber = 7,
    kLimitFieldNumber = 5,
    kIncludeInactiveFieldNumber = 9,
    kSubaccountTotalOrdersFieldNumber = 10,
  };
  // repeated string market_ids = 8 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string order_side = 2 [json_name = "orderSide"];
  void clear_order_side() ;
  const std::string& order_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_side(Arg_&& arg, Args_... args);
  std::string* mutable_order_side();
  PROTOBUF_NODISCARD std::string* release_order_side();
  void set_allocated_order_side(std::string* ptr);

  private:
  const std::string& _internal_order_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_side(
      const std::string& value);
  std::string* _internal_mutable_order_side();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 6 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 7 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 5 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // bool include_inactive = 9 [json_name = "includeInactive"];
  void clear_include_inactive() ;
  bool include_inactive() const;
  void set_include_inactive(bool value);

  private:
  bool _internal_include_inactive() const;
  void _internal_set_include_inactive(bool value);

  public:
  // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
  void clear_subaccount_total_orders() ;
  bool subaccount_total_orders() const;
  void set_subaccount_total_orders(bool value);

  private:
  bool _internal_subaccount_total_orders() const;
  void _internal_set_subaccount_total_orders(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    bool include_inactive_;
    bool subaccount_total_orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrdersResponse) */ {
 public:
  inline OrdersResponse() : OrdersResponse(nullptr) {}
  ~OrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersResponse(const OrdersResponse& from);
  OrdersResponse(OrdersResponse&& from) noexcept
    : OrdersResponse() {
    *this = ::std::move(from);
  }

  inline OrdersResponse& operator=(const OrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersResponse& operator=(OrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersResponse* internal_default_instance() {
    return reinterpret_cast<const OrdersResponse*>(
               &_OrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(OrdersResponse& a, OrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersResponse& from) {
    OrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrdersResponse";
  }
  protected:
  explicit OrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective_spot_exchange_rpc::SpotLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >*
      mutable_orders();
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrder& _internal_orders(int index) const;
  ::injective_spot_exchange_rpc::SpotLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective_spot_exchange_rpc::SpotLimitOrder& orders(int index) const;
  ::injective_spot_exchange_rpc::SpotLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >&
      orders() const;
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_spot_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::Paging* release_paging();
  ::injective_spot_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging);
  private:
  const ::injective_spot_exchange_rpc::Paging& _internal_paging() const;
  ::injective_spot_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_spot_exchange_rpc::Paging* paging);
  ::injective_spot_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder > orders_;
    ::injective_spot_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SpotLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SpotLimitOrder) */ {
 public:
  inline SpotLimitOrder() : SpotLimitOrder(nullptr) {}
  ~SpotLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotLimitOrder(const SpotLimitOrder& from);
  SpotLimitOrder(SpotLimitOrder&& from) noexcept
    : SpotLimitOrder() {
    *this = ::std::move(from);
  }

  inline SpotLimitOrder& operator=(const SpotLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotLimitOrder& operator=(SpotLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotLimitOrder* internal_default_instance() {
    return reinterpret_cast<const SpotLimitOrder*>(
               &_SpotLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SpotLimitOrder& a, SpotLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotLimitOrder& from) {
    SpotLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SpotLimitOrder";
  }
  protected:
  explicit SpotLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kOrderSideFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kSubaccountIdFieldNumber = 4,
    kPriceFieldNumber = 5,
    kQuantityFieldNumber = 6,
    kUnfilledQuantityFieldNumber = 7,
    kTriggerPriceFieldNumber = 8,
    kFeeRecipientFieldNumber = 9,
    kStateFieldNumber = 10,
    kCreatedAtFieldNumber = 11,
    kUpdatedAtFieldNumber = 12,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string order_side = 2 [json_name = "orderSide"];
  void clear_order_side() ;
  const std::string& order_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_side(Arg_&& arg, Args_... args);
  std::string* mutable_order_side();
  PROTOBUF_NODISCARD std::string* release_order_side();
  void set_allocated_order_side(std::string* ptr);

  private:
  const std::string& _internal_order_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_side(
      const std::string& value);
  std::string* _internal_mutable_order_side();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string price = 5 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 6 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string unfilled_quantity = 7 [json_name = "unfilledQuantity"];
  void clear_unfilled_quantity() ;
  const std::string& unfilled_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unfilled_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_unfilled_quantity();
  PROTOBUF_NODISCARD std::string* release_unfilled_quantity();
  void set_allocated_unfilled_quantity(std::string* ptr);

  private:
  const std::string& _internal_unfilled_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unfilled_quantity(
      const std::string& value);
  std::string* _internal_mutable_unfilled_quantity();

  public:
  // string trigger_price = 8 [json_name = "triggerPrice"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // string fee_recipient = 9 [json_name = "feeRecipient"];
  void clear_fee_recipient() ;
  const std::string& fee_recipient() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_fee_recipient();
  PROTOBUF_NODISCARD std::string* release_fee_recipient();
  void set_allocated_fee_recipient(std::string* ptr);

  private:
  const std::string& _internal_fee_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_recipient(
      const std::string& value);
  std::string* _internal_mutable_fee_recipient();

  public:
  // string state = 10 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // sint64 created_at = 11 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // sint64 updated_at = 12 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SpotLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unfilled_quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_recipient_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class Paging final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.Paging) */ {
 public:
  inline Paging() : Paging(nullptr) {}
  ~Paging() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Paging(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Paging(const Paging& from);
  Paging(Paging&& from) noexcept
    : Paging() {
    *this = ::std::move(from);
  }

  inline Paging& operator=(const Paging& from) {
    CopyFrom(from);
    return *this;
  }
  inline Paging& operator=(Paging&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Paging& default_instance() {
    return *internal_default_instance();
  }
  static inline const Paging* internal_default_instance() {
    return reinterpret_cast<const Paging*>(
               &_Paging_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Paging& a, Paging& b) {
    a.Swap(&b);
  }
  inline void Swap(Paging* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Paging* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Paging* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Paging>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Paging& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Paging& from) {
    Paging::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Paging* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.Paging";
  }
  protected:
  explicit Paging(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kCountBySubaccountFieldNumber = 4,
  };
  // sint64 total = 1 [json_name = "total"];
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // sint32 from = 2 [json_name = "from"];
  void clear_from() ;
  ::int32_t from() const;
  void set_from(::int32_t value);

  private:
  ::int32_t _internal_from() const;
  void _internal_set_from(::int32_t value);

  public:
  // sint32 to = 3 [json_name = "to"];
  void clear_to() ;
  ::int32_t to() const;
  void set_to(::int32_t value);

  private:
  ::int32_t _internal_to() const;
  void _internal_set_to(::int32_t value);

  public:
  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  void clear_count_by_subaccount() ;
  ::int64_t count_by_subaccount() const;
  void set_count_by_subaccount(::int64_t value);

  private:
  ::int64_t _internal_count_by_subaccount() const;
  void _internal_set_count_by_subaccount(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.Paging)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t total_;
    ::int32_t from_;
    ::int32_t to_;
    ::int64_t count_by_subaccount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrdersRequest) */ {
 public:
  inline StreamOrdersRequest() : StreamOrdersRequest(nullptr) {}
  ~StreamOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersRequest(const StreamOrdersRequest& from);
  StreamOrdersRequest(StreamOrdersRequest&& from) noexcept
    : StreamOrdersRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrdersRequest& operator=(const StreamOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersRequest& operator=(StreamOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersRequest*>(
               &_StreamOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(StreamOrdersRequest& a, StreamOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersRequest& from) {
    StreamOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrdersRequest";
  }
  protected:
  explicit StreamOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 8,
    kMarketIdFieldNumber = 1,
    kOrderSideFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kSkipFieldNumber = 4,
    kStartTimeFieldNumber = 6,
    kEndTimeFieldNumber = 7,
    kLimitFieldNumber = 5,
    kIncludeInactiveFieldNumber = 9,
    kSubaccountTotalOrdersFieldNumber = 10,
  };
  // repeated string market_ids = 8 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string order_side = 2 [json_name = "orderSide"];
  void clear_order_side() ;
  const std::string& order_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_side(Arg_&& arg, Args_... args);
  std::string* mutable_order_side();
  PROTOBUF_NODISCARD std::string* release_order_side();
  void set_allocated_order_side(std::string* ptr);

  private:
  const std::string& _internal_order_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_side(
      const std::string& value);
  std::string* _internal_mutable_order_side();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 6 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 7 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 5 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // bool include_inactive = 9 [json_name = "includeInactive"];
  void clear_include_inactive() ;
  bool include_inactive() const;
  void set_include_inactive(bool value);

  private:
  bool _internal_include_inactive() const;
  void _internal_set_include_inactive(bool value);

  public:
  // bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
  void clear_subaccount_total_orders() ;
  bool subaccount_total_orders() const;
  void set_subaccount_total_orders(bool value);

  private:
  bool _internal_subaccount_total_orders() const;
  void _internal_set_subaccount_total_orders(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    bool include_inactive_;
    bool subaccount_total_orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrdersResponse) */ {
 public:
  inline StreamOrdersResponse() : StreamOrdersResponse(nullptr) {}
  ~StreamOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersResponse(const StreamOrdersResponse& from);
  StreamOrdersResponse(StreamOrdersResponse&& from) noexcept
    : StreamOrdersResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrdersResponse& operator=(const StreamOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersResponse& operator=(StreamOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersResponse*>(
               &_StreamOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(StreamOrdersResponse& a, StreamOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersResponse& from) {
    StreamOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrdersResponse";
  }
  protected:
  explicit StreamOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kOrderFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_spot_exchange_rpc.SpotLimitOrder order = 1 [json_name = "order"];
  bool has_order() const;
  void clear_order() ;
  const ::injective_spot_exchange_rpc::SpotLimitOrder& order() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotLimitOrder* release_order();
  ::injective_spot_exchange_rpc::SpotLimitOrder* mutable_order();
  void set_allocated_order(::injective_spot_exchange_rpc::SpotLimitOrder* order);
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrder& _internal_order() const;
  ::injective_spot_exchange_rpc::SpotLimitOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective_spot_exchange_rpc::SpotLimitOrder* order);
  ::injective_spot_exchange_rpc::SpotLimitOrder* unsafe_arena_release_order();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_spot_exchange_rpc::SpotLimitOrder* order_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class TradesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.TradesRequest) */ {
 public:
  inline TradesRequest() : TradesRequest(nullptr) {}
  ~TradesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradesRequest(const TradesRequest& from);
  TradesRequest(TradesRequest&& from) noexcept
    : TradesRequest() {
    *this = ::std::move(from);
  }

  inline TradesRequest& operator=(const TradesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradesRequest& operator=(TradesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradesRequest* internal_default_instance() {
    return reinterpret_cast<const TradesRequest*>(
               &_TradesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(TradesRequest& a, TradesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TradesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradesRequest& from) {
    TradesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.TradesRequest";
  }
  protected:
  explicit TradesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 9,
    kSubaccountIdsFieldNumber = 10,
    kExecutionTypesFieldNumber = 11,
    kMarketIdFieldNumber = 1,
    kExecutionSideFieldNumber = 2,
    kDirectionFieldNumber = 3,
    kSubaccountIdFieldNumber = 4,
    kSkipFieldNumber = 5,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kLimitFieldNumber = 6,
  };
  // repeated string market_ids = 9 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  int subaccount_ids_size() const;
  private:
  int _internal_subaccount_ids_size() const;

  public:
  void clear_subaccount_ids() ;
  const std::string& subaccount_ids(int index) const;
  std::string* mutable_subaccount_ids(int index);
  void set_subaccount_ids(int index, const std::string& value);
  void set_subaccount_ids(int index, std::string&& value);
  void set_subaccount_ids(int index, const char* value);
  void set_subaccount_ids(int index, const char* value, std::size_t size);
  void set_subaccount_ids(int index, absl::string_view value);
  std::string* add_subaccount_ids();
  void add_subaccount_ids(const std::string& value);
  void add_subaccount_ids(std::string&& value);
  void add_subaccount_ids(const char* value);
  void add_subaccount_ids(const char* value, std::size_t size);
  void add_subaccount_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subaccount_ids();

  private:
  const std::string& _internal_subaccount_ids(int index) const;
  std::string* _internal_add_subaccount_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subaccount_ids();

  public:
  // repeated string execution_types = 11 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string execution_side = 2 [json_name = "executionSide"];
  void clear_execution_side() ;
  const std::string& execution_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_side(Arg_&& arg, Args_... args);
  std::string* mutable_execution_side();
  PROTOBUF_NODISCARD std::string* release_execution_side();
  void set_allocated_execution_side(std::string* ptr);

  private:
  const std::string& _internal_execution_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_side(
      const std::string& value);
  std::string* _internal_mutable_execution_side();

  public:
  // string direction = 3 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // uint64 skip = 5 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 7 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 8 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 6 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.TradesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subaccount_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class TradesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.TradesResponse) */ {
 public:
  inline TradesResponse() : TradesResponse(nullptr) {}
  ~TradesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradesResponse(const TradesResponse& from);
  TradesResponse(TradesResponse&& from) noexcept
    : TradesResponse() {
    *this = ::std::move(from);
  }

  inline TradesResponse& operator=(const TradesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradesResponse& operator=(TradesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradesResponse* internal_default_instance() {
    return reinterpret_cast<const TradesResponse*>(
               &_TradesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TradesResponse& a, TradesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TradesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradesResponse& from) {
    TradesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.TradesResponse";
  }
  protected:
  explicit TradesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradesFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
  int trades_size() const;
  private:
  int _internal_trades_size() const;

  public:
  void clear_trades() ;
  ::injective_spot_exchange_rpc::SpotTrade* mutable_trades(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >*
      mutable_trades();
  private:
  const ::injective_spot_exchange_rpc::SpotTrade& _internal_trades(int index) const;
  ::injective_spot_exchange_rpc::SpotTrade* _internal_add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>& _internal_trades() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>* _internal_mutable_trades();
  public:
  const ::injective_spot_exchange_rpc::SpotTrade& trades(int index) const;
  ::injective_spot_exchange_rpc::SpotTrade* add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >&
      trades() const;
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_spot_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::Paging* release_paging();
  ::injective_spot_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging);
  private:
  const ::injective_spot_exchange_rpc::Paging& _internal_paging() const;
  ::injective_spot_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_spot_exchange_rpc::Paging* paging);
  ::injective_spot_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.TradesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade > trades_;
    ::injective_spot_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SpotTrade final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SpotTrade) */ {
 public:
  inline SpotTrade() : SpotTrade(nullptr) {}
  ~SpotTrade() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotTrade(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotTrade(const SpotTrade& from);
  SpotTrade(SpotTrade&& from) noexcept
    : SpotTrade() {
    *this = ::std::move(from);
  }

  inline SpotTrade& operator=(const SpotTrade& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotTrade& operator=(SpotTrade&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotTrade& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotTrade* internal_default_instance() {
    return reinterpret_cast<const SpotTrade*>(
               &_SpotTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SpotTrade& a, SpotTrade& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotTrade* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotTrade* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotTrade* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotTrade>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotTrade& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotTrade& from) {
    SpotTrade::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotTrade* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SpotTrade";
  }
  protected:
  explicit SpotTrade(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kTradeExecutionTypeFieldNumber = 4,
    kTradeDirectionFieldNumber = 5,
    kFeeFieldNumber = 7,
    kFeeRecipientFieldNumber = 9,
    kTradeIdFieldNumber = 10,
    kExecutionSideFieldNumber = 11,
    kPriceFieldNumber = 6,
    kExecutedAtFieldNumber = 8,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string trade_execution_type = 4 [json_name = "tradeExecutionType"];
  void clear_trade_execution_type() ;
  const std::string& trade_execution_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trade_execution_type(Arg_&& arg, Args_... args);
  std::string* mutable_trade_execution_type();
  PROTOBUF_NODISCARD std::string* release_trade_execution_type();
  void set_allocated_trade_execution_type(std::string* ptr);

  private:
  const std::string& _internal_trade_execution_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trade_execution_type(
      const std::string& value);
  std::string* _internal_mutable_trade_execution_type();

  public:
  // string trade_direction = 5 [json_name = "tradeDirection"];
  void clear_trade_direction() ;
  const std::string& trade_direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trade_direction(Arg_&& arg, Args_... args);
  std::string* mutable_trade_direction();
  PROTOBUF_NODISCARD std::string* release_trade_direction();
  void set_allocated_trade_direction(std::string* ptr);

  private:
  const std::string& _internal_trade_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trade_direction(
      const std::string& value);
  std::string* _internal_mutable_trade_direction();

  public:
  // string fee = 7 [json_name = "fee"];
  void clear_fee() ;
  const std::string& fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee(Arg_&& arg, Args_... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* ptr);

  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(
      const std::string& value);
  std::string* _internal_mutable_fee();

  public:
  // string fee_recipient = 9 [json_name = "feeRecipient"];
  void clear_fee_recipient() ;
  const std::string& fee_recipient() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_fee_recipient();
  PROTOBUF_NODISCARD std::string* release_fee_recipient();
  void set_allocated_fee_recipient(std::string* ptr);

  private:
  const std::string& _internal_fee_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_recipient(
      const std::string& value);
  std::string* _internal_mutable_fee_recipient();

  public:
  // string trade_id = 10 [json_name = "tradeId"];
  void clear_trade_id() ;
  const std::string& trade_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trade_id(Arg_&& arg, Args_... args);
  std::string* mutable_trade_id();
  PROTOBUF_NODISCARD std::string* release_trade_id();
  void set_allocated_trade_id(std::string* ptr);

  private:
  const std::string& _internal_trade_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trade_id(
      const std::string& value);
  std::string* _internal_mutable_trade_id();

  public:
  // string execution_side = 11 [json_name = "executionSide"];
  void clear_execution_side() ;
  const std::string& execution_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_side(Arg_&& arg, Args_... args);
  std::string* mutable_execution_side();
  PROTOBUF_NODISCARD std::string* release_execution_side();
  void set_allocated_execution_side(std::string* ptr);

  private:
  const std::string& _internal_execution_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_side(
      const std::string& value);
  std::string* _internal_mutable_execution_side();

  public:
  // .injective_spot_exchange_rpc.PriceLevel price = 6 [json_name = "price"];
  bool has_price() const;
  void clear_price() ;
  const ::injective_spot_exchange_rpc::PriceLevel& price() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::PriceLevel* release_price();
  ::injective_spot_exchange_rpc::PriceLevel* mutable_price();
  void set_allocated_price(::injective_spot_exchange_rpc::PriceLevel* price);
  private:
  const ::injective_spot_exchange_rpc::PriceLevel& _internal_price() const;
  ::injective_spot_exchange_rpc::PriceLevel* _internal_mutable_price();
  public:
  void unsafe_arena_set_allocated_price(
      ::injective_spot_exchange_rpc::PriceLevel* price);
  ::injective_spot_exchange_rpc::PriceLevel* unsafe_arena_release_price();
  // sint64 executed_at = 8 [json_name = "executedAt"];
  void clear_executed_at() ;
  ::int64_t executed_at() const;
  void set_executed_at(::int64_t value);

  private:
  ::int64_t _internal_executed_at() const;
  void _internal_set_executed_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SpotTrade)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trade_execution_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trade_direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_recipient_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trade_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_side_;
    ::injective_spot_exchange_rpc::PriceLevel* price_;
    ::int64_t executed_at_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamTradesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamTradesRequest) */ {
 public:
  inline StreamTradesRequest() : StreamTradesRequest(nullptr) {}
  ~StreamTradesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTradesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamTradesRequest(const StreamTradesRequest& from);
  StreamTradesRequest(StreamTradesRequest&& from) noexcept
    : StreamTradesRequest() {
    *this = ::std::move(from);
  }

  inline StreamTradesRequest& operator=(const StreamTradesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTradesRequest& operator=(StreamTradesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTradesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTradesRequest* internal_default_instance() {
    return reinterpret_cast<const StreamTradesRequest*>(
               &_StreamTradesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(StreamTradesRequest& a, StreamTradesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamTradesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTradesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTradesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamTradesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamTradesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamTradesRequest& from) {
    StreamTradesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamTradesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamTradesRequest";
  }
  protected:
  explicit StreamTradesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 9,
    kSubaccountIdsFieldNumber = 10,
    kExecutionTypesFieldNumber = 11,
    kMarketIdFieldNumber = 1,
    kExecutionSideFieldNumber = 2,
    kDirectionFieldNumber = 3,
    kSubaccountIdFieldNumber = 4,
    kSkipFieldNumber = 5,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kLimitFieldNumber = 6,
  };
  // repeated string market_ids = 9 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  int subaccount_ids_size() const;
  private:
  int _internal_subaccount_ids_size() const;

  public:
  void clear_subaccount_ids() ;
  const std::string& subaccount_ids(int index) const;
  std::string* mutable_subaccount_ids(int index);
  void set_subaccount_ids(int index, const std::string& value);
  void set_subaccount_ids(int index, std::string&& value);
  void set_subaccount_ids(int index, const char* value);
  void set_subaccount_ids(int index, const char* value, std::size_t size);
  void set_subaccount_ids(int index, absl::string_view value);
  std::string* add_subaccount_ids();
  void add_subaccount_ids(const std::string& value);
  void add_subaccount_ids(std::string&& value);
  void add_subaccount_ids(const char* value);
  void add_subaccount_ids(const char* value, std::size_t size);
  void add_subaccount_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subaccount_ids();

  private:
  const std::string& _internal_subaccount_ids(int index) const;
  std::string* _internal_add_subaccount_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subaccount_ids();

  public:
  // repeated string execution_types = 11 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string execution_side = 2 [json_name = "executionSide"];
  void clear_execution_side() ;
  const std::string& execution_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_side(Arg_&& arg, Args_... args);
  std::string* mutable_execution_side();
  PROTOBUF_NODISCARD std::string* release_execution_side();
  void set_allocated_execution_side(std::string* ptr);

  private:
  const std::string& _internal_execution_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_side(
      const std::string& value);
  std::string* _internal_mutable_execution_side();

  public:
  // string direction = 3 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // uint64 skip = 5 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 7 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 8 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 6 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamTradesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subaccount_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamTradesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamTradesResponse) */ {
 public:
  inline StreamTradesResponse() : StreamTradesResponse(nullptr) {}
  ~StreamTradesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTradesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamTradesResponse(const StreamTradesResponse& from);
  StreamTradesResponse(StreamTradesResponse&& from) noexcept
    : StreamTradesResponse() {
    *this = ::std::move(from);
  }

  inline StreamTradesResponse& operator=(const StreamTradesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTradesResponse& operator=(StreamTradesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTradesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTradesResponse* internal_default_instance() {
    return reinterpret_cast<const StreamTradesResponse*>(
               &_StreamTradesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(StreamTradesResponse& a, StreamTradesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamTradesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTradesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTradesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamTradesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamTradesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamTradesResponse& from) {
    StreamTradesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamTradesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamTradesResponse";
  }
  protected:
  explicit StreamTradesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kTradeFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_spot_exchange_rpc.SpotTrade trade = 1 [json_name = "trade"];
  bool has_trade() const;
  void clear_trade() ;
  const ::injective_spot_exchange_rpc::SpotTrade& trade() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotTrade* release_trade();
  ::injective_spot_exchange_rpc::SpotTrade* mutable_trade();
  void set_allocated_trade(::injective_spot_exchange_rpc::SpotTrade* trade);
  private:
  const ::injective_spot_exchange_rpc::SpotTrade& _internal_trade() const;
  ::injective_spot_exchange_rpc::SpotTrade* _internal_mutable_trade();
  public:
  void unsafe_arena_set_allocated_trade(
      ::injective_spot_exchange_rpc::SpotTrade* trade);
  ::injective_spot_exchange_rpc::SpotTrade* unsafe_arena_release_trade();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamTradesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_spot_exchange_rpc::SpotTrade* trade_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrdersListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SubaccountOrdersListRequest) */ {
 public:
  inline SubaccountOrdersListRequest() : SubaccountOrdersListRequest(nullptr) {}
  ~SubaccountOrdersListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrdersListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrdersListRequest(const SubaccountOrdersListRequest& from);
  SubaccountOrdersListRequest(SubaccountOrdersListRequest&& from) noexcept
    : SubaccountOrdersListRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountOrdersListRequest& operator=(const SubaccountOrdersListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrdersListRequest& operator=(SubaccountOrdersListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrdersListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrdersListRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrdersListRequest*>(
               &_SubaccountOrdersListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SubaccountOrdersListRequest& a, SubaccountOrdersListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrdersListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrdersListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrdersListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrdersListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrdersListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrdersListRequest& from) {
    SubaccountOrdersListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrdersListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SubaccountOrdersListRequest";
  }
  protected:
  explicit SubaccountOrdersListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSkipFieldNumber = 3,
    kLimitFieldNumber = 4,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SubaccountOrdersListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrdersListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SubaccountOrdersListResponse) */ {
 public:
  inline SubaccountOrdersListResponse() : SubaccountOrdersListResponse(nullptr) {}
  ~SubaccountOrdersListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrdersListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrdersListResponse(const SubaccountOrdersListResponse& from);
  SubaccountOrdersListResponse(SubaccountOrdersListResponse&& from) noexcept
    : SubaccountOrdersListResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountOrdersListResponse& operator=(const SubaccountOrdersListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrdersListResponse& operator=(SubaccountOrdersListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrdersListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrdersListResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrdersListResponse*>(
               &_SubaccountOrdersListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SubaccountOrdersListResponse& a, SubaccountOrdersListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrdersListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrdersListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrdersListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrdersListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrdersListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrdersListResponse& from) {
    SubaccountOrdersListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrdersListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SubaccountOrdersListResponse";
  }
  protected:
  explicit SubaccountOrdersListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective_spot_exchange_rpc::SpotLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >*
      mutable_orders();
  private:
  const ::injective_spot_exchange_rpc::SpotLimitOrder& _internal_orders(int index) const;
  ::injective_spot_exchange_rpc::SpotLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective_spot_exchange_rpc::SpotLimitOrder& orders(int index) const;
  ::injective_spot_exchange_rpc::SpotLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >&
      orders() const;
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_spot_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::Paging* release_paging();
  ::injective_spot_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging);
  private:
  const ::injective_spot_exchange_rpc::Paging& _internal_paging() const;
  ::injective_spot_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_spot_exchange_rpc::Paging* paging);
  ::injective_spot_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SubaccountOrdersListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder > orders_;
    ::injective_spot_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountTradesListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SubaccountTradesListRequest) */ {
 public:
  inline SubaccountTradesListRequest() : SubaccountTradesListRequest(nullptr) {}
  ~SubaccountTradesListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountTradesListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountTradesListRequest(const SubaccountTradesListRequest& from);
  SubaccountTradesListRequest(SubaccountTradesListRequest&& from) noexcept
    : SubaccountTradesListRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountTradesListRequest& operator=(const SubaccountTradesListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountTradesListRequest& operator=(SubaccountTradesListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountTradesListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountTradesListRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountTradesListRequest*>(
               &_SubaccountTradesListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SubaccountTradesListRequest& a, SubaccountTradesListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountTradesListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountTradesListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountTradesListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountTradesListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountTradesListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountTradesListRequest& from) {
    SubaccountTradesListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountTradesListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SubaccountTradesListRequest";
  }
  protected:
  explicit SubaccountTradesListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kExecutionTypeFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kSkipFieldNumber = 5,
    kLimitFieldNumber = 6,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string execution_type = 3 [json_name = "executionType"];
  void clear_execution_type() ;
  const std::string& execution_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_type(Arg_&& arg, Args_... args);
  std::string* mutable_execution_type();
  PROTOBUF_NODISCARD std::string* release_execution_type();
  void set_allocated_execution_type(std::string* ptr);

  private:
  const std::string& _internal_execution_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_type(
      const std::string& value);
  std::string* _internal_mutable_execution_type();

  public:
  // string direction = 4 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // uint64 skip = 5 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 6 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SubaccountTradesListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountTradesListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SubaccountTradesListResponse) */ {
 public:
  inline SubaccountTradesListResponse() : SubaccountTradesListResponse(nullptr) {}
  ~SubaccountTradesListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountTradesListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountTradesListResponse(const SubaccountTradesListResponse& from);
  SubaccountTradesListResponse(SubaccountTradesListResponse&& from) noexcept
    : SubaccountTradesListResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountTradesListResponse& operator=(const SubaccountTradesListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountTradesListResponse& operator=(SubaccountTradesListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountTradesListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountTradesListResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountTradesListResponse*>(
               &_SubaccountTradesListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SubaccountTradesListResponse& a, SubaccountTradesListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountTradesListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountTradesListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountTradesListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountTradesListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountTradesListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountTradesListResponse& from) {
    SubaccountTradesListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountTradesListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SubaccountTradesListResponse";
  }
  protected:
  explicit SubaccountTradesListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradesFieldNumber = 1,
  };
  // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
  int trades_size() const;
  private:
  int _internal_trades_size() const;

  public:
  void clear_trades() ;
  ::injective_spot_exchange_rpc::SpotTrade* mutable_trades(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >*
      mutable_trades();
  private:
  const ::injective_spot_exchange_rpc::SpotTrade& _internal_trades(int index) const;
  ::injective_spot_exchange_rpc::SpotTrade* _internal_add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>& _internal_trades() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>* _internal_mutable_trades();
  public:
  const ::injective_spot_exchange_rpc::SpotTrade& trades(int index) const;
  ::injective_spot_exchange_rpc::SpotTrade* add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >&
      trades() const;
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SubaccountTradesListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade > trades_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrdersHistoryRequest) */ {
 public:
  inline OrdersHistoryRequest() : OrdersHistoryRequest(nullptr) {}
  ~OrdersHistoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersHistoryRequest(const OrdersHistoryRequest& from);
  OrdersHistoryRequest(OrdersHistoryRequest&& from) noexcept
    : OrdersHistoryRequest() {
    *this = ::std::move(from);
  }

  inline OrdersHistoryRequest& operator=(const OrdersHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersHistoryRequest& operator=(OrdersHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const OrdersHistoryRequest*>(
               &_OrdersHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(OrdersHistoryRequest& a, OrdersHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersHistoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersHistoryRequest& from) {
    OrdersHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrdersHistoryRequest";
  }
  protected:
  explicit OrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderTypesFieldNumber = 5,
    kExecutionTypesFieldNumber = 10,
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kDirectionFieldNumber = 6,
    kStateFieldNumber = 9,
    kSkipFieldNumber = 3,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kLimitFieldNumber = 4,
  };
  // repeated string order_types = 5 [json_name = "orderTypes"];
  int order_types_size() const;
  private:
  int _internal_order_types_size() const;

  public:
  void clear_order_types() ;
  const std::string& order_types(int index) const;
  std::string* mutable_order_types(int index);
  void set_order_types(int index, const std::string& value);
  void set_order_types(int index, std::string&& value);
  void set_order_types(int index, const char* value);
  void set_order_types(int index, const char* value, std::size_t size);
  void set_order_types(int index, absl::string_view value);
  std::string* add_order_types();
  void add_order_types(const std::string& value);
  void add_order_types(std::string&& value);
  void add_order_types(const char* value);
  void add_order_types(const char* value, std::size_t size);
  void add_order_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_types();

  private:
  const std::string& _internal_order_types(int index) const;
  std::string* _internal_add_order_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_types();

  public:
  // repeated string execution_types = 10 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string direction = 6 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string state = 9 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 7 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 8 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrdersHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.OrdersHistoryResponse) */ {
 public:
  inline OrdersHistoryResponse() : OrdersHistoryResponse(nullptr) {}
  ~OrdersHistoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersHistoryResponse(const OrdersHistoryResponse& from);
  OrdersHistoryResponse(OrdersHistoryResponse&& from) noexcept
    : OrdersHistoryResponse() {
    *this = ::std::move(from);
  }

  inline OrdersHistoryResponse& operator=(const OrdersHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersHistoryResponse& operator=(OrdersHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const OrdersHistoryResponse*>(
               &_OrdersHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(OrdersHistoryResponse& a, OrdersHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersHistoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersHistoryResponse& from) {
    OrdersHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.OrdersHistoryResponse";
  }
  protected:
  explicit OrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_spot_exchange_rpc.SpotOrderHistory orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective_spot_exchange_rpc::SpotOrderHistory* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotOrderHistory >*
      mutable_orders();
  private:
  const ::injective_spot_exchange_rpc::SpotOrderHistory& _internal_orders(int index) const;
  ::injective_spot_exchange_rpc::SpotOrderHistory* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotOrderHistory>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotOrderHistory>* _internal_mutable_orders();
  public:
  const ::injective_spot_exchange_rpc::SpotOrderHistory& orders(int index) const;
  ::injective_spot_exchange_rpc::SpotOrderHistory* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotOrderHistory >&
      orders() const;
  // .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_spot_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::Paging* release_paging();
  ::injective_spot_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging);
  private:
  const ::injective_spot_exchange_rpc::Paging& _internal_paging() const;
  ::injective_spot_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_spot_exchange_rpc::Paging* paging);
  ::injective_spot_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.OrdersHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotOrderHistory > orders_;
    ::injective_spot_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SpotOrderHistory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.SpotOrderHistory) */ {
 public:
  inline SpotOrderHistory() : SpotOrderHistory(nullptr) {}
  ~SpotOrderHistory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotOrderHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotOrderHistory(const SpotOrderHistory& from);
  SpotOrderHistory(SpotOrderHistory&& from) noexcept
    : SpotOrderHistory() {
    *this = ::std::move(from);
  }

  inline SpotOrderHistory& operator=(const SpotOrderHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotOrderHistory& operator=(SpotOrderHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotOrderHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotOrderHistory* internal_default_instance() {
    return reinterpret_cast<const SpotOrderHistory*>(
               &_SpotOrderHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(SpotOrderHistory& a, SpotOrderHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotOrderHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotOrderHistory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotOrderHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotOrderHistory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotOrderHistory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotOrderHistory& from) {
    SpotOrderHistory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotOrderHistory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.SpotOrderHistory";
  }
  protected:
  explicit SpotOrderHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSubaccountIdFieldNumber = 4,
    kExecutionTypeFieldNumber = 5,
    kOrderTypeFieldNumber = 6,
    kPriceFieldNumber = 7,
    kTriggerPriceFieldNumber = 8,
    kQuantityFieldNumber = 9,
    kFilledQuantityFieldNumber = 10,
    kStateFieldNumber = 11,
    kDirectionFieldNumber = 14,
    kCreatedAtFieldNumber = 12,
    kUpdatedAtFieldNumber = 13,
    kIsActiveFieldNumber = 3,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string execution_type = 5 [json_name = "executionType"];
  void clear_execution_type() ;
  const std::string& execution_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_type(Arg_&& arg, Args_... args);
  std::string* mutable_execution_type();
  PROTOBUF_NODISCARD std::string* release_execution_type();
  void set_allocated_execution_type(std::string* ptr);

  private:
  const std::string& _internal_execution_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_type(
      const std::string& value);
  std::string* _internal_mutable_execution_type();

  public:
  // string order_type = 6 [json_name = "orderType"];
  void clear_order_type() ;
  const std::string& order_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  std::string* mutable_order_type();
  PROTOBUF_NODISCARD std::string* release_order_type();
  void set_allocated_order_type(std::string* ptr);

  private:
  const std::string& _internal_order_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(
      const std::string& value);
  std::string* _internal_mutable_order_type();

  public:
  // string price = 7 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string trigger_price = 8 [json_name = "triggerPrice"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // string quantity = 9 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string filled_quantity = 10 [json_name = "filledQuantity"];
  void clear_filled_quantity() ;
  const std::string& filled_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filled_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_filled_quantity();
  PROTOBUF_NODISCARD std::string* release_filled_quantity();
  void set_allocated_filled_quantity(std::string* ptr);

  private:
  const std::string& _internal_filled_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filled_quantity(
      const std::string& value);
  std::string* _internal_mutable_filled_quantity();

  public:
  // string state = 11 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string direction = 14 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // sint64 created_at = 12 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // sint64 updated_at = 13 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // bool is_active = 3 [json_name = "isActive"];
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.SpotOrderHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filled_quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    bool is_active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrdersHistoryRequest) */ {
 public:
  inline StreamOrdersHistoryRequest() : StreamOrdersHistoryRequest(nullptr) {}
  ~StreamOrdersHistoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersHistoryRequest(const StreamOrdersHistoryRequest& from);
  StreamOrdersHistoryRequest(StreamOrdersHistoryRequest&& from) noexcept
    : StreamOrdersHistoryRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrdersHistoryRequest& operator=(const StreamOrdersHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersHistoryRequest& operator=(StreamOrdersHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersHistoryRequest*>(
               &_StreamOrdersHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(StreamOrdersHistoryRequest& a, StreamOrdersHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersHistoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersHistoryRequest& from) {
    StreamOrdersHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrdersHistoryRequest";
  }
  protected:
  explicit StreamOrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderTypesFieldNumber = 3,
    kExecutionTypesFieldNumber = 6,
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kDirectionFieldNumber = 4,
    kStateFieldNumber = 5,
  };
  // repeated string order_types = 3 [json_name = "orderTypes"];
  int order_types_size() const;
  private:
  int _internal_order_types_size() const;

  public:
  void clear_order_types() ;
  const std::string& order_types(int index) const;
  std::string* mutable_order_types(int index);
  void set_order_types(int index, const std::string& value);
  void set_order_types(int index, std::string&& value);
  void set_order_types(int index, const char* value);
  void set_order_types(int index, const char* value, std::size_t size);
  void set_order_types(int index, absl::string_view value);
  std::string* add_order_types();
  void add_order_types(const std::string& value);
  void add_order_types(std::string&& value);
  void add_order_types(const char* value);
  void add_order_types(const char* value, std::size_t size);
  void add_order_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_types();

  private:
  const std::string& _internal_order_types(int index) const;
  std::string* _internal_add_order_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_types();

  public:
  // repeated string execution_types = 6 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string direction = 4 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string state = 5 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrdersHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_spot_exchange_rpc.StreamOrdersHistoryResponse) */ {
 public:
  inline StreamOrdersHistoryResponse() : StreamOrdersHistoryResponse(nullptr) {}
  ~StreamOrdersHistoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersHistoryResponse(const StreamOrdersHistoryResponse& from);
  StreamOrdersHistoryResponse(StreamOrdersHistoryResponse&& from) noexcept
    : StreamOrdersHistoryResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrdersHistoryResponse& operator=(const StreamOrdersHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersHistoryResponse& operator=(StreamOrdersHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersHistoryResponse*>(
               &_StreamOrdersHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(StreamOrdersHistoryResponse& a, StreamOrdersHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersHistoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersHistoryResponse& from) {
    StreamOrdersHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_spot_exchange_rpc.StreamOrdersHistoryResponse";
  }
  protected:
  explicit StreamOrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kOrderFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_spot_exchange_rpc.SpotOrderHistory order = 1 [json_name = "order"];
  bool has_order() const;
  void clear_order() ;
  const ::injective_spot_exchange_rpc::SpotOrderHistory& order() const;
  PROTOBUF_NODISCARD ::injective_spot_exchange_rpc::SpotOrderHistory* release_order();
  ::injective_spot_exchange_rpc::SpotOrderHistory* mutable_order();
  void set_allocated_order(::injective_spot_exchange_rpc::SpotOrderHistory* order);
  private:
  const ::injective_spot_exchange_rpc::SpotOrderHistory& _internal_order() const;
  ::injective_spot_exchange_rpc::SpotOrderHistory* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective_spot_exchange_rpc::SpotOrderHistory* order);
  ::injective_spot_exchange_rpc::SpotOrderHistory* unsafe_arena_release_order();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_spot_exchange_rpc.StreamOrdersHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_spot_exchange_rpc::SpotOrderHistory* order_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MarketsRequest

// string market_status = 1 [json_name = "marketStatus"];
inline void MarketsRequest::clear_market_status() {
  _impl_.market_status_.ClearToEmpty();
}
inline const std::string& MarketsRequest::market_status() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.MarketsRequest.market_status)
  return _internal_market_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketsRequest::set_market_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.MarketsRequest.market_status)
}
inline std::string* MarketsRequest::mutable_market_status() {
  std::string* _s = _internal_mutable_market_status();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.MarketsRequest.market_status)
  return _s;
}
inline const std::string& MarketsRequest::_internal_market_status() const {
  return _impl_.market_status_.Get();
}
inline void MarketsRequest::_internal_set_market_status(const std::string& value) {
  ;


  _impl_.market_status_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketsRequest::_internal_mutable_market_status() {
  ;
  return _impl_.market_status_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketsRequest::release_market_status() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.MarketsRequest.market_status)
  return _impl_.market_status_.Release();
}
inline void MarketsRequest::set_allocated_market_status(std::string* value) {
  _impl_.market_status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_status_.IsDefault()) {
          _impl_.market_status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.MarketsRequest.market_status)
}

// string base_denom = 2 [json_name = "baseDenom"];
inline void MarketsRequest::clear_base_denom() {
  _impl_.base_denom_.ClearToEmpty();
}
inline const std::string& MarketsRequest::base_denom() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.MarketsRequest.base_denom)
  return _internal_base_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketsRequest::set_base_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.MarketsRequest.base_denom)
}
inline std::string* MarketsRequest::mutable_base_denom() {
  std::string* _s = _internal_mutable_base_denom();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.MarketsRequest.base_denom)
  return _s;
}
inline const std::string& MarketsRequest::_internal_base_denom() const {
  return _impl_.base_denom_.Get();
}
inline void MarketsRequest::_internal_set_base_denom(const std::string& value) {
  ;


  _impl_.base_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketsRequest::_internal_mutable_base_denom() {
  ;
  return _impl_.base_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketsRequest::release_base_denom() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.MarketsRequest.base_denom)
  return _impl_.base_denom_.Release();
}
inline void MarketsRequest::set_allocated_base_denom(std::string* value) {
  _impl_.base_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_denom_.IsDefault()) {
          _impl_.base_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.MarketsRequest.base_denom)
}

// string quote_denom = 3 [json_name = "quoteDenom"];
inline void MarketsRequest::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& MarketsRequest::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.MarketsRequest.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketsRequest::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.MarketsRequest.quote_denom)
}
inline std::string* MarketsRequest::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.MarketsRequest.quote_denom)
  return _s;
}
inline const std::string& MarketsRequest::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void MarketsRequest::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketsRequest::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketsRequest::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.MarketsRequest.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void MarketsRequest::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.MarketsRequest.quote_denom)
}

// -------------------------------------------------------------------

// MarketsResponse

// repeated .injective_spot_exchange_rpc.SpotMarketInfo markets = 1 [json_name = "markets"];
inline int MarketsResponse::_internal_markets_size() const {
  return _impl_.markets_.size();
}
inline int MarketsResponse::markets_size() const {
  return _internal_markets_size();
}
inline void MarketsResponse::clear_markets() {
  _internal_mutable_markets()->Clear();
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* MarketsResponse::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.MarketsResponse.markets)
  return _internal_mutable_markets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotMarketInfo >*
MarketsResponse::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.MarketsResponse.markets)
  return _internal_mutable_markets();
}
inline const ::injective_spot_exchange_rpc::SpotMarketInfo& MarketsResponse::_internal_markets(int index) const {
  return _internal_markets().Get(index);
}
inline const ::injective_spot_exchange_rpc::SpotMarketInfo& MarketsResponse::markets(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.MarketsResponse.markets)
  return _internal_markets(index);
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* MarketsResponse::_internal_add_markets() {
  return _internal_mutable_markets()->Add();
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* MarketsResponse::add_markets() {
  ::injective_spot_exchange_rpc::SpotMarketInfo* _add = _internal_add_markets();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.MarketsResponse.markets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotMarketInfo >&
MarketsResponse::markets() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.MarketsResponse.markets)
  return _internal_markets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotMarketInfo>&
MarketsResponse::_internal_markets() const {
  return _impl_.markets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotMarketInfo>*
MarketsResponse::_internal_mutable_markets() {
  return &_impl_.markets_;
}

// -------------------------------------------------------------------

// SpotMarketInfo

// string market_id = 1 [json_name = "marketId"];
inline void SpotMarketInfo::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.market_id)
}
inline std::string* SpotMarketInfo::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.market_id)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SpotMarketInfo::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.market_id)
  return _impl_.market_id_.Release();
}
inline void SpotMarketInfo::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.market_id)
}

// string market_status = 2 [json_name = "marketStatus"];
inline void SpotMarketInfo::clear_market_status() {
  _impl_.market_status_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::market_status() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.market_status)
  return _internal_market_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_market_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.market_status)
}
inline std::string* SpotMarketInfo::mutable_market_status() {
  std::string* _s = _internal_mutable_market_status();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.market_status)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_market_status() const {
  return _impl_.market_status_.Get();
}
inline void SpotMarketInfo::_internal_set_market_status(const std::string& value) {
  ;


  _impl_.market_status_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_market_status() {
  ;
  return _impl_.market_status_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_market_status() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.market_status)
  return _impl_.market_status_.Release();
}
inline void SpotMarketInfo::set_allocated_market_status(std::string* value) {
  _impl_.market_status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_status_.IsDefault()) {
          _impl_.market_status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.market_status)
}

// string ticker = 3 [json_name = "ticker"];
inline void SpotMarketInfo::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::ticker() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.ticker)
}
inline std::string* SpotMarketInfo::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.ticker)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void SpotMarketInfo::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_ticker() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.ticker)
  return _impl_.ticker_.Release();
}
inline void SpotMarketInfo::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.ticker)
}

// string base_denom = 4 [json_name = "baseDenom"];
inline void SpotMarketInfo::clear_base_denom() {
  _impl_.base_denom_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::base_denom() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.base_denom)
  return _internal_base_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_base_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.base_denom)
}
inline std::string* SpotMarketInfo::mutable_base_denom() {
  std::string* _s = _internal_mutable_base_denom();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.base_denom)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_base_denom() const {
  return _impl_.base_denom_.Get();
}
inline void SpotMarketInfo::_internal_set_base_denom(const std::string& value) {
  ;


  _impl_.base_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_base_denom() {
  ;
  return _impl_.base_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_base_denom() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.base_denom)
  return _impl_.base_denom_.Release();
}
inline void SpotMarketInfo::set_allocated_base_denom(std::string* value) {
  _impl_.base_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_denom_.IsDefault()) {
          _impl_.base_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.base_denom)
}

// .injective_spot_exchange_rpc.TokenMeta base_token_meta = 5 [json_name = "baseTokenMeta"];
inline bool SpotMarketInfo::has_base_token_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_token_meta_ != nullptr);
  return value;
}
inline void SpotMarketInfo::clear_base_token_meta() {
  if (_impl_.base_token_meta_ != nullptr) _impl_.base_token_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::TokenMeta& SpotMarketInfo::_internal_base_token_meta() const {
  const ::injective_spot_exchange_rpc::TokenMeta* p = _impl_.base_token_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::TokenMeta&>(
      ::injective_spot_exchange_rpc::_TokenMeta_default_instance_);
}
inline const ::injective_spot_exchange_rpc::TokenMeta& SpotMarketInfo::base_token_meta() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.base_token_meta)
  return _internal_base_token_meta();
}
inline void SpotMarketInfo::unsafe_arena_set_allocated_base_token_meta(
    ::injective_spot_exchange_rpc::TokenMeta* base_token_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_token_meta_);
  }
  _impl_.base_token_meta_ = base_token_meta;
  if (base_token_meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.base_token_meta)
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::release_base_token_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::TokenMeta* temp = _impl_.base_token_meta_;
  _impl_.base_token_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::unsafe_arena_release_base_token_meta() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.base_token_meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::TokenMeta* temp = _impl_.base_token_meta_;
  _impl_.base_token_meta_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::_internal_mutable_base_token_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.base_token_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::TokenMeta>(GetArenaForAllocation());
    _impl_.base_token_meta_ = p;
  }
  return _impl_.base_token_meta_;
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::mutable_base_token_meta() {
  ::injective_spot_exchange_rpc::TokenMeta* _msg = _internal_mutable_base_token_meta();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.base_token_meta)
  return _msg;
}
inline void SpotMarketInfo::set_allocated_base_token_meta(::injective_spot_exchange_rpc::TokenMeta* base_token_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_token_meta_;
  }
  if (base_token_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base_token_meta);
    if (message_arena != submessage_arena) {
      base_token_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_token_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.base_token_meta_ = base_token_meta;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.base_token_meta)
}

// string quote_denom = 6 [json_name = "quoteDenom"];
inline void SpotMarketInfo::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.quote_denom)
}
inline std::string* SpotMarketInfo::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.quote_denom)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void SpotMarketInfo::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void SpotMarketInfo::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.quote_denom)
}

// .injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7 [json_name = "quoteTokenMeta"];
inline bool SpotMarketInfo::has_quote_token_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quote_token_meta_ != nullptr);
  return value;
}
inline void SpotMarketInfo::clear_quote_token_meta() {
  if (_impl_.quote_token_meta_ != nullptr) _impl_.quote_token_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective_spot_exchange_rpc::TokenMeta& SpotMarketInfo::_internal_quote_token_meta() const {
  const ::injective_spot_exchange_rpc::TokenMeta* p = _impl_.quote_token_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::TokenMeta&>(
      ::injective_spot_exchange_rpc::_TokenMeta_default_instance_);
}
inline const ::injective_spot_exchange_rpc::TokenMeta& SpotMarketInfo::quote_token_meta() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.quote_token_meta)
  return _internal_quote_token_meta();
}
inline void SpotMarketInfo::unsafe_arena_set_allocated_quote_token_meta(
    ::injective_spot_exchange_rpc::TokenMeta* quote_token_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quote_token_meta_);
  }
  _impl_.quote_token_meta_ = quote_token_meta;
  if (quote_token_meta) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.quote_token_meta)
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::release_quote_token_meta() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_spot_exchange_rpc::TokenMeta* temp = _impl_.quote_token_meta_;
  _impl_.quote_token_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::unsafe_arena_release_quote_token_meta() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.quote_token_meta)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_spot_exchange_rpc::TokenMeta* temp = _impl_.quote_token_meta_;
  _impl_.quote_token_meta_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::_internal_mutable_quote_token_meta() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.quote_token_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::TokenMeta>(GetArenaForAllocation());
    _impl_.quote_token_meta_ = p;
  }
  return _impl_.quote_token_meta_;
}
inline ::injective_spot_exchange_rpc::TokenMeta* SpotMarketInfo::mutable_quote_token_meta() {
  ::injective_spot_exchange_rpc::TokenMeta* _msg = _internal_mutable_quote_token_meta();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.quote_token_meta)
  return _msg;
}
inline void SpotMarketInfo::set_allocated_quote_token_meta(::injective_spot_exchange_rpc::TokenMeta* quote_token_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quote_token_meta_;
  }
  if (quote_token_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quote_token_meta);
    if (message_arena != submessage_arena) {
      quote_token_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quote_token_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.quote_token_meta_ = quote_token_meta;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.quote_token_meta)
}

// string maker_fee_rate = 8 [json_name = "makerFeeRate"];
inline void SpotMarketInfo::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.maker_fee_rate)
}
inline std::string* SpotMarketInfo::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.maker_fee_rate)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void SpotMarketInfo::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void SpotMarketInfo::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.maker_fee_rate)
}

// string taker_fee_rate = 9 [json_name = "takerFeeRate"];
inline void SpotMarketInfo::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.taker_fee_rate)
}
inline std::string* SpotMarketInfo::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.taker_fee_rate)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void SpotMarketInfo::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void SpotMarketInfo::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.taker_fee_rate)
}

// string service_provider_fee = 10 [json_name = "serviceProviderFee"];
inline void SpotMarketInfo::clear_service_provider_fee() {
  _impl_.service_provider_fee_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::service_provider_fee() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.service_provider_fee)
  return _internal_service_provider_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_service_provider_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.service_provider_fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.service_provider_fee)
}
inline std::string* SpotMarketInfo::mutable_service_provider_fee() {
  std::string* _s = _internal_mutable_service_provider_fee();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.service_provider_fee)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_service_provider_fee() const {
  return _impl_.service_provider_fee_.Get();
}
inline void SpotMarketInfo::_internal_set_service_provider_fee(const std::string& value) {
  ;


  _impl_.service_provider_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_service_provider_fee() {
  ;
  return _impl_.service_provider_fee_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_service_provider_fee() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.service_provider_fee)
  return _impl_.service_provider_fee_.Release();
}
inline void SpotMarketInfo::set_allocated_service_provider_fee(std::string* value) {
  _impl_.service_provider_fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_provider_fee_.IsDefault()) {
          _impl_.service_provider_fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.service_provider_fee)
}

// string min_price_tick_size = 11 [json_name = "minPriceTickSize"];
inline void SpotMarketInfo::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.min_price_tick_size)
}
inline std::string* SpotMarketInfo::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.min_price_tick_size)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void SpotMarketInfo::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void SpotMarketInfo::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.min_price_tick_size)
}

// string min_quantity_tick_size = 12 [json_name = "minQuantityTickSize"];
inline void SpotMarketInfo::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarketInfo::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotMarketInfo.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketInfo::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotMarketInfo.min_quantity_tick_size)
}
inline std::string* SpotMarketInfo::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotMarketInfo.min_quantity_tick_size)
  return _s;
}
inline const std::string& SpotMarketInfo::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void SpotMarketInfo::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketInfo::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotMarketInfo.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void SpotMarketInfo::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotMarketInfo.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// TokenMeta

// string name = 1 [json_name = "name"];
inline void TokenMeta::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TokenMeta::name() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TokenMeta.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TokenMeta.name)
}
inline std::string* TokenMeta::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TokenMeta.name)
  return _s;
}
inline const std::string& TokenMeta::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TokenMeta::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_name() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TokenMeta.name)
  return _impl_.name_.Release();
}
inline void TokenMeta::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TokenMeta.name)
}

// string address = 2 [json_name = "address"];
inline void TokenMeta::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& TokenMeta::address() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TokenMeta.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TokenMeta.address)
}
inline std::string* TokenMeta::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TokenMeta.address)
  return _s;
}
inline const std::string& TokenMeta::_internal_address() const {
  return _impl_.address_.Get();
}
inline void TokenMeta::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_address() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TokenMeta.address)
  return _impl_.address_.Release();
}
inline void TokenMeta::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TokenMeta.address)
}

// string symbol = 3 [json_name = "symbol"];
inline void TokenMeta::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& TokenMeta::symbol() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TokenMeta.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TokenMeta.symbol)
}
inline std::string* TokenMeta::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TokenMeta.symbol)
  return _s;
}
inline const std::string& TokenMeta::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void TokenMeta::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_symbol() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TokenMeta.symbol)
  return _impl_.symbol_.Release();
}
inline void TokenMeta::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TokenMeta.symbol)
}

// string logo = 4 [json_name = "logo"];
inline void TokenMeta::clear_logo() {
  _impl_.logo_.ClearToEmpty();
}
inline const std::string& TokenMeta::logo() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TokenMeta.logo)
  return _internal_logo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_logo(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.logo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TokenMeta.logo)
}
inline std::string* TokenMeta::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TokenMeta.logo)
  return _s;
}
inline const std::string& TokenMeta::_internal_logo() const {
  return _impl_.logo_.Get();
}
inline void TokenMeta::_internal_set_logo(const std::string& value) {
  ;


  _impl_.logo_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_logo() {
  ;
  return _impl_.logo_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_logo() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TokenMeta.logo)
  return _impl_.logo_.Release();
}
inline void TokenMeta::set_allocated_logo(std::string* value) {
  _impl_.logo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.logo_.IsDefault()) {
          _impl_.logo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TokenMeta.logo)
}

// sint32 decimals = 5 [json_name = "decimals"];
inline void TokenMeta::clear_decimals() {
  _impl_.decimals_ = 0;
}
inline ::int32_t TokenMeta::decimals() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TokenMeta.decimals)
  return _internal_decimals();
}
inline void TokenMeta::set_decimals(::int32_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TokenMeta.decimals)
}
inline ::int32_t TokenMeta::_internal_decimals() const {
  return _impl_.decimals_;
}
inline void TokenMeta::_internal_set_decimals(::int32_t value) {
  ;
  _impl_.decimals_ = value;
}

// sint64 updated_at = 6 [json_name = "updatedAt"];
inline void TokenMeta::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t TokenMeta::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TokenMeta.updated_at)
  return _internal_updated_at();
}
inline void TokenMeta::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TokenMeta.updated_at)
}
inline ::int64_t TokenMeta::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void TokenMeta::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// MarketRequest

// string market_id = 1 [json_name = "marketId"];
inline void MarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.MarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.MarketRequest.market_id)
}
inline std::string* MarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.MarketRequest.market_id)
  return _s;
}
inline const std::string& MarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.MarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void MarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.MarketRequest.market_id)
}

// -------------------------------------------------------------------

// MarketResponse

// .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
inline bool MarketResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline void MarketResponse::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotMarketInfo& MarketResponse::_internal_market() const {
  const ::injective_spot_exchange_rpc::SpotMarketInfo* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotMarketInfo&>(
      ::injective_spot_exchange_rpc::_SpotMarketInfo_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotMarketInfo& MarketResponse::market() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.MarketResponse.market)
  return _internal_market();
}
inline void MarketResponse::unsafe_arena_set_allocated_market(
    ::injective_spot_exchange_rpc::SpotMarketInfo* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.MarketResponse.market)
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* MarketResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* MarketResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.MarketResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* MarketResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotMarketInfo>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* MarketResponse::mutable_market() {
  ::injective_spot_exchange_rpc::SpotMarketInfo* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.MarketResponse.market)
  return _msg;
}
inline void MarketResponse::set_allocated_market(::injective_spot_exchange_rpc::SpotMarketInfo* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.MarketResponse.market)
}

// -------------------------------------------------------------------

// StreamMarketsRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamMarketsRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamMarketsRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamMarketsRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamMarketsRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
  return _s;
}
inline const std::string& StreamMarketsRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamMarketsRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamMarketsRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline void StreamMarketsRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamMarketsRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamMarketsRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamMarketsRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamMarketsRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamMarketsRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamMarketsRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamMarketsRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamMarketsResponse

// .injective_spot_exchange_rpc.SpotMarketInfo market = 1 [json_name = "market"];
inline bool StreamMarketsResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline void StreamMarketsResponse::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotMarketInfo& StreamMarketsResponse::_internal_market() const {
  const ::injective_spot_exchange_rpc::SpotMarketInfo* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotMarketInfo&>(
      ::injective_spot_exchange_rpc::_SpotMarketInfo_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotMarketInfo& StreamMarketsResponse::market() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamMarketsResponse.market)
  return _internal_market();
}
inline void StreamMarketsResponse::unsafe_arena_set_allocated_market(
    ::injective_spot_exchange_rpc::SpotMarketInfo* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.StreamMarketsResponse.market)
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* StreamMarketsResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* StreamMarketsResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamMarketsResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* StreamMarketsResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotMarketInfo>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective_spot_exchange_rpc::SpotMarketInfo* StreamMarketsResponse::mutable_market() {
  ::injective_spot_exchange_rpc::SpotMarketInfo* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamMarketsResponse.market)
  return _msg;
}
inline void StreamMarketsResponse::set_allocated_market(::injective_spot_exchange_rpc::SpotMarketInfo* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamMarketsResponse.market)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamMarketsResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamMarketsResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamMarketsResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamMarketsResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamMarketsResponse.operation_type)
}
inline std::string* StreamMarketsResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamMarketsResponse.operation_type)
  return _s;
}
inline const std::string& StreamMarketsResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamMarketsResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamMarketsResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamMarketsResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamMarketsResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamMarketsResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamMarketsResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamMarketsResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamMarketsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamMarketsResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamMarketsResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamMarketsResponse.timestamp)
}
inline ::int64_t StreamMarketsResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamMarketsResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// OrderbookRequest

// string market_id = 1 [json_name = "marketId"];
inline void OrderbookRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderbookRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbookRequest.market_id)
}
inline std::string* OrderbookRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbookRequest.market_id)
  return _s;
}
inline const std::string& OrderbookRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderbookRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrderbookRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderbookRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrderbookRequest.market_id)
}

// -------------------------------------------------------------------

// OrderbookResponse

// .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
inline bool OrderbookResponse::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void OrderbookResponse::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbook& OrderbookResponse::_internal_orderbook() const {
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotLimitOrderbook&>(
      ::injective_spot_exchange_rpc::_SpotLimitOrderbook_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbook& OrderbookResponse::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookResponse.orderbook)
  return _internal_orderbook();
}
inline void OrderbookResponse::unsafe_arena_set_allocated_orderbook(
    ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.OrderbookResponse.orderbook)
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* OrderbookResponse::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* OrderbookResponse::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrderbookResponse.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* OrderbookResponse::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbook>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* OrderbookResponse::mutable_orderbook() {
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbookResponse.orderbook)
  return _msg;
}
inline void OrderbookResponse::set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrderbookResponse.orderbook)
}

// -------------------------------------------------------------------

// SpotLimitOrderbook

// repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
inline int SpotLimitOrderbook::_internal_buys_size() const {
  return _impl_.buys_.size();
}
inline int SpotLimitOrderbook::buys_size() const {
  return _internal_buys_size();
}
inline void SpotLimitOrderbook::clear_buys() {
  _internal_mutable_buys()->Clear();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbook::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrderbook.buys)
  return _internal_mutable_buys()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
SpotLimitOrderbook::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.SpotLimitOrderbook.buys)
  return _internal_mutable_buys();
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbook::_internal_buys(int index) const {
  return _internal_buys().Get(index);
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbook::buys(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrderbook.buys)
  return _internal_buys(index);
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbook::_internal_add_buys() {
  return _internal_mutable_buys()->Add();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbook::add_buys() {
  ::injective_spot_exchange_rpc::PriceLevel* _add = _internal_add_buys();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.SpotLimitOrderbook.buys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
SpotLimitOrderbook::buys() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.SpotLimitOrderbook.buys)
  return _internal_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>&
SpotLimitOrderbook::_internal_buys() const {
  return _impl_.buys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>*
SpotLimitOrderbook::_internal_mutable_buys() {
  return &_impl_.buys_;
}

// repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
inline int SpotLimitOrderbook::_internal_sells_size() const {
  return _impl_.sells_.size();
}
inline int SpotLimitOrderbook::sells_size() const {
  return _internal_sells_size();
}
inline void SpotLimitOrderbook::clear_sells() {
  _internal_mutable_sells()->Clear();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbook::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrderbook.sells)
  return _internal_mutable_sells()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
SpotLimitOrderbook::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.SpotLimitOrderbook.sells)
  return _internal_mutable_sells();
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbook::_internal_sells(int index) const {
  return _internal_sells().Get(index);
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbook::sells(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrderbook.sells)
  return _internal_sells(index);
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbook::_internal_add_sells() {
  return _internal_mutable_sells()->Add();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbook::add_sells() {
  ::injective_spot_exchange_rpc::PriceLevel* _add = _internal_add_sells();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.SpotLimitOrderbook.sells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
SpotLimitOrderbook::sells() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.SpotLimitOrderbook.sells)
  return _internal_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>&
SpotLimitOrderbook::_internal_sells() const {
  return _impl_.sells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>*
SpotLimitOrderbook::_internal_mutable_sells() {
  return &_impl_.sells_;
}

// -------------------------------------------------------------------

// PriceLevel

// string price = 1 [json_name = "price"];
inline void PriceLevel::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceLevel::price() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.PriceLevel.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevel::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.PriceLevel.price)
}
inline std::string* PriceLevel::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.PriceLevel.price)
  return _s;
}
inline const std::string& PriceLevel::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceLevel::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevel::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevel::release_price() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.PriceLevel.price)
  return _impl_.price_.Release();
}
inline void PriceLevel::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.PriceLevel.price)
}

// string quantity = 2 [json_name = "quantity"];
inline void PriceLevel::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& PriceLevel::quantity() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.PriceLevel.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevel::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.PriceLevel.quantity)
}
inline std::string* PriceLevel::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.PriceLevel.quantity)
  return _s;
}
inline const std::string& PriceLevel::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void PriceLevel::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevel::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevel::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.PriceLevel.quantity)
  return _impl_.quantity_.Release();
}
inline void PriceLevel::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.PriceLevel.quantity)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void PriceLevel::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t PriceLevel::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.PriceLevel.timestamp)
  return _internal_timestamp();
}
inline void PriceLevel::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.PriceLevel.timestamp)
}
inline ::int64_t PriceLevel::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void PriceLevel::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// OrderbookV2Request

// string market_id = 1 [json_name = "marketId"];
inline void OrderbookV2Request::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderbookV2Request::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookV2Request.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookV2Request::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbookV2Request.market_id)
}
inline std::string* OrderbookV2Request::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbookV2Request.market_id)
  return _s;
}
inline const std::string& OrderbookV2Request::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderbookV2Request::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookV2Request::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookV2Request::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrderbookV2Request.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderbookV2Request::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrderbookV2Request.market_id)
}

// -------------------------------------------------------------------

// OrderbookV2Response

// .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
inline bool OrderbookV2Response::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void OrderbookV2Response::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& OrderbookV2Response::_internal_orderbook() const {
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2&>(
      ::injective_spot_exchange_rpc::_SpotLimitOrderbookV2_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& OrderbookV2Response::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookV2Response.orderbook)
  return _internal_orderbook();
}
inline void OrderbookV2Response::unsafe_arena_set_allocated_orderbook(
    ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.OrderbookV2Response.orderbook)
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* OrderbookV2Response::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* OrderbookV2Response::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrderbookV2Response.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* OrderbookV2Response::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbookV2>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* OrderbookV2Response::mutable_orderbook() {
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbookV2Response.orderbook)
  return _msg;
}
inline void OrderbookV2Response::set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrderbookV2Response.orderbook)
}

// -------------------------------------------------------------------

// SpotLimitOrderbookV2

// repeated .injective_spot_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
inline int SpotLimitOrderbookV2::_internal_buys_size() const {
  return _impl_.buys_.size();
}
inline int SpotLimitOrderbookV2::buys_size() const {
  return _internal_buys_size();
}
inline void SpotLimitOrderbookV2::clear_buys() {
  _internal_mutable_buys()->Clear();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbookV2::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrderbookV2.buys)
  return _internal_mutable_buys()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
SpotLimitOrderbookV2::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.SpotLimitOrderbookV2.buys)
  return _internal_mutable_buys();
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbookV2::_internal_buys(int index) const {
  return _internal_buys().Get(index);
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbookV2::buys(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrderbookV2.buys)
  return _internal_buys(index);
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbookV2::_internal_add_buys() {
  return _internal_mutable_buys()->Add();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbookV2::add_buys() {
  ::injective_spot_exchange_rpc::PriceLevel* _add = _internal_add_buys();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.SpotLimitOrderbookV2.buys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
SpotLimitOrderbookV2::buys() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.SpotLimitOrderbookV2.buys)
  return _internal_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>&
SpotLimitOrderbookV2::_internal_buys() const {
  return _impl_.buys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>*
SpotLimitOrderbookV2::_internal_mutable_buys() {
  return &_impl_.buys_;
}

// repeated .injective_spot_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
inline int SpotLimitOrderbookV2::_internal_sells_size() const {
  return _impl_.sells_.size();
}
inline int SpotLimitOrderbookV2::sells_size() const {
  return _internal_sells_size();
}
inline void SpotLimitOrderbookV2::clear_sells() {
  _internal_mutable_sells()->Clear();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbookV2::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrderbookV2.sells)
  return _internal_mutable_sells()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >*
SpotLimitOrderbookV2::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.SpotLimitOrderbookV2.sells)
  return _internal_mutable_sells();
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbookV2::_internal_sells(int index) const {
  return _internal_sells().Get(index);
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotLimitOrderbookV2::sells(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrderbookV2.sells)
  return _internal_sells(index);
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbookV2::_internal_add_sells() {
  return _internal_mutable_sells()->Add();
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotLimitOrderbookV2::add_sells() {
  ::injective_spot_exchange_rpc::PriceLevel* _add = _internal_add_sells();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.SpotLimitOrderbookV2.sells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevel >&
SpotLimitOrderbookV2::sells() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.SpotLimitOrderbookV2.sells)
  return _internal_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>&
SpotLimitOrderbookV2::_internal_sells() const {
  return _impl_.sells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevel>*
SpotLimitOrderbookV2::_internal_mutable_sells() {
  return &_impl_.sells_;
}

// uint64 sequence = 3 [json_name = "sequence"];
inline void SpotLimitOrderbookV2::clear_sequence() {
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t SpotLimitOrderbookV2::sequence() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrderbookV2.sequence)
  return _internal_sequence();
}
inline void SpotLimitOrderbookV2::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrderbookV2.sequence)
}
inline ::uint64_t SpotLimitOrderbookV2::_internal_sequence() const {
  return _impl_.sequence_;
}
inline void SpotLimitOrderbookV2::_internal_set_sequence(::uint64_t value) {
  ;
  _impl_.sequence_ = value;
}

// -------------------------------------------------------------------

// OrderbooksRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int OrderbooksRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int OrderbooksRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void OrderbooksRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* OrderbooksRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
  return _s;
}
inline const std::string& OrderbooksRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* OrderbooksRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void OrderbooksRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrderbooksRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& OrderbooksRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* OrderbooksRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrderbooksRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// OrderbooksResponse

// repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbook orderbooks = 1 [json_name = "orderbooks"];
inline int OrderbooksResponse::_internal_orderbooks_size() const {
  return _impl_.orderbooks_.size();
}
inline int OrderbooksResponse::orderbooks_size() const {
  return _internal_orderbooks_size();
}
inline void OrderbooksResponse::clear_orderbooks() {
  _internal_mutable_orderbooks()->Clear();
}
inline ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* OrderbooksResponse::mutable_orderbooks(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_mutable_orderbooks()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook >*
OrderbooksResponse::mutable_orderbooks() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_mutable_orderbooks();
}
inline const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook& OrderbooksResponse::_internal_orderbooks(int index) const {
  return _internal_orderbooks().Get(index);
}
inline const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook& OrderbooksResponse::orderbooks(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_orderbooks(index);
}
inline ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* OrderbooksResponse::_internal_add_orderbooks() {
  return _internal_mutable_orderbooks()->Add();
}
inline ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* OrderbooksResponse::add_orderbooks() {
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook* _add = _internal_add_orderbooks();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbooksResponse.orderbooks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbook >&
OrderbooksResponse::orderbooks() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_orderbooks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbook>&
OrderbooksResponse::_internal_orderbooks() const {
  return _impl_.orderbooks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbook>*
OrderbooksResponse::_internal_mutable_orderbooks() {
  return &_impl_.orderbooks_;
}

// -------------------------------------------------------------------

// SingleSpotLimitOrderbook

// string market_id = 1 [json_name = "marketId"];
inline void SingleSpotLimitOrderbook::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SingleSpotLimitOrderbook::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleSpotLimitOrderbook::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.market_id)
}
inline std::string* SingleSpotLimitOrderbook::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.market_id)
  return _s;
}
inline const std::string& SingleSpotLimitOrderbook::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SingleSpotLimitOrderbook::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleSpotLimitOrderbook::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleSpotLimitOrderbook::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.market_id)
  return _impl_.market_id_.Release();
}
inline void SingleSpotLimitOrderbook::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.market_id)
}

// .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 2 [json_name = "orderbook"];
inline bool SingleSpotLimitOrderbook::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void SingleSpotLimitOrderbook::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbook& SingleSpotLimitOrderbook::_internal_orderbook() const {
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotLimitOrderbook&>(
      ::injective_spot_exchange_rpc::_SpotLimitOrderbook_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbook& SingleSpotLimitOrderbook::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.orderbook)
  return _internal_orderbook();
}
inline void SingleSpotLimitOrderbook::unsafe_arena_set_allocated_orderbook(
    ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.orderbook)
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* SingleSpotLimitOrderbook::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* SingleSpotLimitOrderbook::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* SingleSpotLimitOrderbook::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbook>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* SingleSpotLimitOrderbook::mutable_orderbook() {
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.orderbook)
  return _msg;
}
inline void SingleSpotLimitOrderbook::set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SingleSpotLimitOrderbook.orderbook)
}

// -------------------------------------------------------------------

// OrderbooksV2Request

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int OrderbooksV2Request::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int OrderbooksV2Request::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void OrderbooksV2Request::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* OrderbooksV2Request::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
  return _s;
}
inline const std::string& OrderbooksV2Request::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_market_ids(index);
}
inline std::string* OrderbooksV2Request::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void OrderbooksV2Request::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksV2Request::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrderbooksV2Request::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& OrderbooksV2Request::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* OrderbooksV2Request::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksV2Request::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrderbooksV2Request::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// OrderbooksV2Response

// repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1 [json_name = "orderbooks"];
inline int OrderbooksV2Response::_internal_orderbooks_size() const {
  return _impl_.orderbooks_.size();
}
inline int OrderbooksV2Response::orderbooks_size() const {
  return _internal_orderbooks_size();
}
inline void OrderbooksV2Response::clear_orderbooks() {
  _internal_mutable_orderbooks()->Clear();
}
inline ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* OrderbooksV2Response::mutable_orderbooks(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_mutable_orderbooks()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2 >*
OrderbooksV2Response::mutable_orderbooks() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_mutable_orderbooks();
}
inline const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2& OrderbooksV2Response::_internal_orderbooks(int index) const {
  return _internal_orderbooks().Get(index);
}
inline const ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2& OrderbooksV2Response::orderbooks(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_orderbooks(index);
}
inline ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* OrderbooksV2Response::_internal_add_orderbooks() {
  return _internal_mutable_orderbooks()->Add();
}
inline ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* OrderbooksV2Response::add_orderbooks() {
  ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2* _add = _internal_add_orderbooks();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2 >&
OrderbooksV2Response::orderbooks() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_orderbooks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2>&
OrderbooksV2Response::_internal_orderbooks() const {
  return _impl_.orderbooks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SingleSpotLimitOrderbookV2>*
OrderbooksV2Response::_internal_mutable_orderbooks() {
  return &_impl_.orderbooks_;
}

// -------------------------------------------------------------------

// SingleSpotLimitOrderbookV2

// string market_id = 1 [json_name = "marketId"];
inline void SingleSpotLimitOrderbookV2::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SingleSpotLimitOrderbookV2::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleSpotLimitOrderbookV2::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.market_id)
}
inline std::string* SingleSpotLimitOrderbookV2::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.market_id)
  return _s;
}
inline const std::string& SingleSpotLimitOrderbookV2::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SingleSpotLimitOrderbookV2::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleSpotLimitOrderbookV2::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleSpotLimitOrderbookV2::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.market_id)
  return _impl_.market_id_.Release();
}
inline void SingleSpotLimitOrderbookV2::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.market_id)
}

// .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2 [json_name = "orderbook"];
inline bool SingleSpotLimitOrderbookV2::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void SingleSpotLimitOrderbookV2::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& SingleSpotLimitOrderbookV2::_internal_orderbook() const {
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2&>(
      ::injective_spot_exchange_rpc::_SpotLimitOrderbookV2_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& SingleSpotLimitOrderbookV2::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.orderbook)
  return _internal_orderbook();
}
inline void SingleSpotLimitOrderbookV2::unsafe_arena_set_allocated_orderbook(
    ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.orderbook)
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* SingleSpotLimitOrderbookV2::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* SingleSpotLimitOrderbookV2::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* SingleSpotLimitOrderbookV2::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbookV2>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* SingleSpotLimitOrderbookV2::mutable_orderbook() {
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.orderbook)
  return _msg;
}
inline void SingleSpotLimitOrderbookV2::set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2.orderbook)
}

// -------------------------------------------------------------------

// StreamOrderbookRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamOrderbookRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrderbookRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrderbookRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrderbookRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _s;
}
inline const std::string& StreamOrderbookRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrderbookRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrderbookRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrderbookRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrderbookRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrderbookRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrderbookRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamOrderbookResponse

// .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1 [json_name = "orderbook"];
inline bool StreamOrderbookResponse::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void StreamOrderbookResponse::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbook& StreamOrderbookResponse::_internal_orderbook() const {
  const ::injective_spot_exchange_rpc::SpotLimitOrderbook* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotLimitOrderbook&>(
      ::injective_spot_exchange_rpc::_SpotLimitOrderbook_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbook& StreamOrderbookResponse::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookResponse.orderbook)
  return _internal_orderbook();
}
inline void StreamOrderbookResponse::unsafe_arena_set_allocated_orderbook(
    ::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.StreamOrderbookResponse.orderbook)
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* StreamOrderbookResponse::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* StreamOrderbookResponse::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookResponse.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* StreamOrderbookResponse::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbook>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbook* StreamOrderbookResponse::mutable_orderbook() {
  ::injective_spot_exchange_rpc::SpotLimitOrderbook* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookResponse.orderbook)
  return _msg;
}
inline void StreamOrderbookResponse::set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbook* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookResponse.orderbook)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrderbookResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrderbookResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookResponse.operation_type)
}
inline std::string* StreamOrderbookResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrderbookResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrderbookResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrderbookResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrderbookResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrderbookResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrderbookResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookResponse.timestamp)
}
inline ::int64_t StreamOrderbookResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrderbookResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string market_id = 4 [json_name = "marketId"];
inline void StreamOrderbookResponse::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrderbookResponse::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookResponse.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookResponse::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookResponse.market_id)
}
inline std::string* StreamOrderbookResponse::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookResponse.market_id)
  return _s;
}
inline const std::string& StreamOrderbookResponse::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrderbookResponse::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookResponse.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrderbookResponse::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookResponse.market_id)
}

// -------------------------------------------------------------------

// StreamOrderbookV2Request

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamOrderbookV2Request::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrderbookV2Request::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrderbookV2Request::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrderbookV2Request::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _s;
}
inline const std::string& StreamOrderbookV2Request::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrderbookV2Request::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrderbookV2Request::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookV2Request::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrderbookV2Request::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrderbookV2Request::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrderbookV2Request::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookV2Request::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrderbookV2Request::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamOrderbookV2Response

// .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
inline bool StreamOrderbookV2Response::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void StreamOrderbookV2Response::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& StreamOrderbookV2Response::_internal_orderbook() const {
  const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2&>(
      ::injective_spot_exchange_rpc::_SpotLimitOrderbookV2_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrderbookV2& StreamOrderbookV2Response::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookV2Response.orderbook)
  return _internal_orderbook();
}
inline void StreamOrderbookV2Response::unsafe_arena_set_allocated_orderbook(
    ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.StreamOrderbookV2Response.orderbook)
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* StreamOrderbookV2Response::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* StreamOrderbookV2Response::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookV2Response.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* StreamOrderbookV2Response::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrderbookV2>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* StreamOrderbookV2Response::mutable_orderbook() {
  ::injective_spot_exchange_rpc::SpotLimitOrderbookV2* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookV2Response.orderbook)
  return _msg;
}
inline void StreamOrderbookV2Response::set_allocated_orderbook(::injective_spot_exchange_rpc::SpotLimitOrderbookV2* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookV2Response.orderbook)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrderbookV2Response::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrderbookV2Response::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookV2Response.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookV2Response::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookV2Response.operation_type)
}
inline std::string* StreamOrderbookV2Response::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookV2Response.operation_type)
  return _s;
}
inline const std::string& StreamOrderbookV2Response::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrderbookV2Response::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookV2Response.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrderbookV2Response::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookV2Response.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrderbookV2Response::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrderbookV2Response::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookV2Response.timestamp)
  return _internal_timestamp();
}
inline void StreamOrderbookV2Response::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookV2Response.timestamp)
}
inline ::int64_t StreamOrderbookV2Response::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrderbookV2Response::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string market_id = 4 [json_name = "marketId"];
inline void StreamOrderbookV2Response::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrderbookV2Response::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookV2Response.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookV2Response::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookV2Response.market_id)
}
inline std::string* StreamOrderbookV2Response::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookV2Response.market_id)
  return _s;
}
inline const std::string& StreamOrderbookV2Response::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrderbookV2Response::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookV2Response.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrderbookV2Response::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookV2Response.market_id)
}

// -------------------------------------------------------------------

// StreamOrderbookUpdateRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamOrderbookUpdateRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrderbookUpdateRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrderbookUpdateRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrderbookUpdateRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _s;
}
inline const std::string& StreamOrderbookUpdateRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrderbookUpdateRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookUpdateRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrderbookUpdateRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrderbookUpdateRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrderbookUpdateRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookUpdateRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrderbookUpdateRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamOrderbookUpdateResponse

// .injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1 [json_name = "orderbookLevelUpdates"];
inline bool StreamOrderbookUpdateResponse::has_orderbook_level_updates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_level_updates_ != nullptr);
  return value;
}
inline void StreamOrderbookUpdateResponse::clear_orderbook_level_updates() {
  if (_impl_.orderbook_level_updates_ != nullptr) _impl_.orderbook_level_updates_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::OrderbookLevelUpdates& StreamOrderbookUpdateResponse::_internal_orderbook_level_updates() const {
  const ::injective_spot_exchange_rpc::OrderbookLevelUpdates* p = _impl_.orderbook_level_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::OrderbookLevelUpdates&>(
      ::injective_spot_exchange_rpc::_OrderbookLevelUpdates_default_instance_);
}
inline const ::injective_spot_exchange_rpc::OrderbookLevelUpdates& StreamOrderbookUpdateResponse::orderbook_level_updates() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
  return _internal_orderbook_level_updates();
}
inline void StreamOrderbookUpdateResponse::unsafe_arena_set_allocated_orderbook_level_updates(
    ::injective_spot_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_level_updates_);
  }
  _impl_.orderbook_level_updates_ = orderbook_level_updates;
  if (orderbook_level_updates) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
}
inline ::injective_spot_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::release_orderbook_level_updates() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::OrderbookLevelUpdates* temp = _impl_.orderbook_level_updates_;
  _impl_.orderbook_level_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::unsafe_arena_release_orderbook_level_updates() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::OrderbookLevelUpdates* temp = _impl_.orderbook_level_updates_;
  _impl_.orderbook_level_updates_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::_internal_mutable_orderbook_level_updates() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_level_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::OrderbookLevelUpdates>(GetArenaForAllocation());
    _impl_.orderbook_level_updates_ = p;
  }
  return _impl_.orderbook_level_updates_;
}
inline ::injective_spot_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::mutable_orderbook_level_updates() {
  ::injective_spot_exchange_rpc::OrderbookLevelUpdates* _msg = _internal_mutable_orderbook_level_updates();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
  return _msg;
}
inline void StreamOrderbookUpdateResponse::set_allocated_orderbook_level_updates(::injective_spot_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_level_updates_;
  }
  if (orderbook_level_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook_level_updates);
    if (message_arena != submessage_arena) {
      orderbook_level_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook_level_updates, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_level_updates_ = orderbook_level_updates;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrderbookUpdateResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrderbookUpdateResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookUpdateResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
}
inline std::string* StreamOrderbookUpdateResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrderbookUpdateResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrderbookUpdateResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrderbookUpdateResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrderbookUpdateResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrderbookUpdateResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrderbookUpdateResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.timestamp)
}
inline ::int64_t StreamOrderbookUpdateResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrderbookUpdateResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string market_id = 4 [json_name = "marketId"];
inline void StreamOrderbookUpdateResponse::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrderbookUpdateResponse::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookUpdateResponse::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
}
inline std::string* StreamOrderbookUpdateResponse::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
  return _s;
}
inline const std::string& StreamOrderbookUpdateResponse::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrderbookUpdateResponse::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrderbookUpdateResponse::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
}

// -------------------------------------------------------------------

// OrderbookLevelUpdates

// string market_id = 1 [json_name = "marketId"];
inline void OrderbookLevelUpdates::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderbookLevelUpdates::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookLevelUpdates.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookLevelUpdates::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbookLevelUpdates.market_id)
}
inline std::string* OrderbookLevelUpdates::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbookLevelUpdates.market_id)
  return _s;
}
inline const std::string& OrderbookLevelUpdates::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderbookLevelUpdates::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookLevelUpdates::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookLevelUpdates::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrderbookLevelUpdates.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderbookLevelUpdates::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrderbookLevelUpdates.market_id)
}

// uint64 sequence = 2 [json_name = "sequence"];
inline void OrderbookLevelUpdates::clear_sequence() {
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t OrderbookLevelUpdates::sequence() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookLevelUpdates.sequence)
  return _internal_sequence();
}
inline void OrderbookLevelUpdates::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbookLevelUpdates.sequence)
}
inline ::uint64_t OrderbookLevelUpdates::_internal_sequence() const {
  return _impl_.sequence_;
}
inline void OrderbookLevelUpdates::_internal_set_sequence(::uint64_t value) {
  ;
  _impl_.sequence_ = value;
}

// repeated .injective_spot_exchange_rpc.PriceLevelUpdate buys = 3 [json_name = "buys"];
inline int OrderbookLevelUpdates::_internal_buys_size() const {
  return _impl_.buys_.size();
}
inline int OrderbookLevelUpdates::buys_size() const {
  return _internal_buys_size();
}
inline void OrderbookLevelUpdates::clear_buys() {
  _internal_mutable_buys()->Clear();
}
inline ::injective_spot_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_mutable_buys()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >*
OrderbookLevelUpdates::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_mutable_buys();
}
inline const ::injective_spot_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::_internal_buys(int index) const {
  return _internal_buys().Get(index);
}
inline const ::injective_spot_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::buys(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_buys(index);
}
inline ::injective_spot_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::_internal_add_buys() {
  return _internal_mutable_buys()->Add();
}
inline ::injective_spot_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::add_buys() {
  ::injective_spot_exchange_rpc::PriceLevelUpdate* _add = _internal_add_buys();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbookLevelUpdates.buys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >&
OrderbookLevelUpdates::buys() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>&
OrderbookLevelUpdates::_internal_buys() const {
  return _impl_.buys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>*
OrderbookLevelUpdates::_internal_mutable_buys() {
  return &_impl_.buys_;
}

// repeated .injective_spot_exchange_rpc.PriceLevelUpdate sells = 4 [json_name = "sells"];
inline int OrderbookLevelUpdates::_internal_sells_size() const {
  return _impl_.sells_.size();
}
inline int OrderbookLevelUpdates::sells_size() const {
  return _internal_sells_size();
}
inline void OrderbookLevelUpdates::clear_sells() {
  _internal_mutable_sells()->Clear();
}
inline ::injective_spot_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_mutable_sells()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >*
OrderbookLevelUpdates::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_mutable_sells();
}
inline const ::injective_spot_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::_internal_sells(int index) const {
  return _internal_sells().Get(index);
}
inline const ::injective_spot_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::sells(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_sells(index);
}
inline ::injective_spot_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::_internal_add_sells() {
  return _internal_mutable_sells()->Add();
}
inline ::injective_spot_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::add_sells() {
  ::injective_spot_exchange_rpc::PriceLevelUpdate* _add = _internal_add_sells();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrderbookLevelUpdates.sells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::PriceLevelUpdate >&
OrderbookLevelUpdates::sells() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>&
OrderbookLevelUpdates::_internal_sells() const {
  return _impl_.sells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::PriceLevelUpdate>*
OrderbookLevelUpdates::_internal_mutable_sells() {
  return &_impl_.sells_;
}

// sint64 updated_at = 5 [json_name = "updatedAt"];
inline void OrderbookLevelUpdates::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t OrderbookLevelUpdates::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrderbookLevelUpdates.updated_at)
  return _internal_updated_at();
}
inline void OrderbookLevelUpdates::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrderbookLevelUpdates.updated_at)
}
inline ::int64_t OrderbookLevelUpdates::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void OrderbookLevelUpdates::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// PriceLevelUpdate

// string price = 1 [json_name = "price"];
inline void PriceLevelUpdate::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceLevelUpdate::price() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.PriceLevelUpdate.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevelUpdate::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.PriceLevelUpdate.price)
}
inline std::string* PriceLevelUpdate::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.PriceLevelUpdate.price)
  return _s;
}
inline const std::string& PriceLevelUpdate::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceLevelUpdate::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::release_price() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.PriceLevelUpdate.price)
  return _impl_.price_.Release();
}
inline void PriceLevelUpdate::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.PriceLevelUpdate.price)
}

// string quantity = 2 [json_name = "quantity"];
inline void PriceLevelUpdate::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& PriceLevelUpdate::quantity() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.PriceLevelUpdate.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevelUpdate::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.PriceLevelUpdate.quantity)
}
inline std::string* PriceLevelUpdate::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.PriceLevelUpdate.quantity)
  return _s;
}
inline const std::string& PriceLevelUpdate::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void PriceLevelUpdate::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.PriceLevelUpdate.quantity)
  return _impl_.quantity_.Release();
}
inline void PriceLevelUpdate::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.PriceLevelUpdate.quantity)
}

// bool is_active = 3 [json_name = "isActive"];
inline void PriceLevelUpdate::clear_is_active() {
  _impl_.is_active_ = false;
}
inline bool PriceLevelUpdate::is_active() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.PriceLevelUpdate.is_active)
  return _internal_is_active();
}
inline void PriceLevelUpdate::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.PriceLevelUpdate.is_active)
}
inline bool PriceLevelUpdate::_internal_is_active() const {
  return _impl_.is_active_;
}
inline void PriceLevelUpdate::_internal_set_is_active(bool value) {
  ;
  _impl_.is_active_ = value;
}

// sint64 timestamp = 4 [json_name = "timestamp"];
inline void PriceLevelUpdate::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t PriceLevelUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.PriceLevelUpdate.timestamp)
  return _internal_timestamp();
}
inline void PriceLevelUpdate::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.PriceLevelUpdate.timestamp)
}
inline ::int64_t PriceLevelUpdate::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void PriceLevelUpdate::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// OrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void OrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.market_id)
}
inline std::string* OrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersRequest.market_id)
  return _s;
}
inline const std::string& OrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void OrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersRequest.market_id)
}

// string order_side = 2 [json_name = "orderSide"];
inline void OrdersRequest::clear_order_side() {
  _impl_.order_side_.ClearToEmpty();
}
inline const std::string& OrdersRequest::order_side() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.order_side)
  return _internal_order_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_order_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.order_side)
}
inline std::string* OrdersRequest::mutable_order_side() {
  std::string* _s = _internal_mutable_order_side();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersRequest.order_side)
  return _s;
}
inline const std::string& OrdersRequest::_internal_order_side() const {
  return _impl_.order_side_.Get();
}
inline void OrdersRequest::_internal_set_order_side(const std::string& value) {
  ;


  _impl_.order_side_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_order_side() {
  ;
  return _impl_.order_side_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_order_side() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersRequest.order_side)
  return _impl_.order_side_.Release();
}
inline void OrdersRequest::set_allocated_order_side(std::string* value) {
  _impl_.order_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_side_.IsDefault()) {
          _impl_.order_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersRequest.order_side)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void OrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& OrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.subaccount_id)
}
inline std::string* OrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& OrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void OrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void OrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersRequest.subaccount_id)
}

// uint64 skip = 4 [json_name = "skip"];
inline void OrdersRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t OrdersRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.skip)
  return _internal_skip();
}
inline void OrdersRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.skip)
}
inline ::uint64_t OrdersRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void OrdersRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 5 [json_name = "limit"];
inline void OrdersRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t OrdersRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.limit)
  return _internal_limit();
}
inline void OrdersRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.limit)
}
inline ::int32_t OrdersRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void OrdersRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 6 [json_name = "startTime"];
inline void OrdersRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t OrdersRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.start_time)
  return _internal_start_time();
}
inline void OrdersRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.start_time)
}
inline ::int64_t OrdersRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void OrdersRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 7 [json_name = "endTime"];
inline void OrdersRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t OrdersRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.end_time)
  return _internal_end_time();
}
inline void OrdersRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.end_time)
}
inline ::int64_t OrdersRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void OrdersRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 8 [json_name = "marketIds"];
inline int OrdersRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int OrdersRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void OrdersRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* OrdersRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.OrdersRequest.market_ids)
  return _s;
}
inline const std::string& OrdersRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* OrdersRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void OrdersRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.OrdersRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrdersRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrdersRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrdersRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& OrdersRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* OrdersRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrdersRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// bool include_inactive = 9 [json_name = "includeInactive"];
inline void OrdersRequest::clear_include_inactive() {
  _impl_.include_inactive_ = false;
}
inline bool OrdersRequest::include_inactive() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.include_inactive)
  return _internal_include_inactive();
}
inline void OrdersRequest::set_include_inactive(bool value) {
  _internal_set_include_inactive(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.include_inactive)
}
inline bool OrdersRequest::_internal_include_inactive() const {
  return _impl_.include_inactive_;
}
inline void OrdersRequest::_internal_set_include_inactive(bool value) {
  ;
  _impl_.include_inactive_ = value;
}

// bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
inline void OrdersRequest::clear_subaccount_total_orders() {
  _impl_.subaccount_total_orders_ = false;
}
inline bool OrdersRequest::subaccount_total_orders() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersRequest.subaccount_total_orders)
  return _internal_subaccount_total_orders();
}
inline void OrdersRequest::set_subaccount_total_orders(bool value) {
  _internal_set_subaccount_total_orders(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersRequest.subaccount_total_orders)
}
inline bool OrdersRequest::_internal_subaccount_total_orders() const {
  return _impl_.subaccount_total_orders_;
}
inline void OrdersRequest::_internal_set_subaccount_total_orders(bool value) {
  ;
  _impl_.subaccount_total_orders_ = value;
}

// -------------------------------------------------------------------

// OrdersResponse

// repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
inline int OrdersResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int OrdersResponse::orders_size() const {
  return _internal_orders_size();
}
inline void OrdersResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* OrdersResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >*
OrdersResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrdersResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrder& OrdersResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrder& OrdersResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersResponse.orders)
  return _internal_orders(index);
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* OrdersResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* OrdersResponse::add_orders() {
  ::injective_spot_exchange_rpc::SpotLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >&
OrdersResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrdersResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>&
OrdersResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>*
OrdersResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool OrdersResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void OrdersResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::Paging& OrdersResponse::_internal_paging() const {
  const ::injective_spot_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::Paging&>(
      ::injective_spot_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_spot_exchange_rpc::Paging& OrdersResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersResponse.paging)
  return _internal_paging();
}
inline void OrdersResponse::unsafe_arena_set_allocated_paging(
    ::injective_spot_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.OrdersResponse.paging)
}
inline ::injective_spot_exchange_rpc::Paging* OrdersResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* OrdersResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* OrdersResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_spot_exchange_rpc::Paging* OrdersResponse::mutable_paging() {
  ::injective_spot_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersResponse.paging)
  return _msg;
}
inline void OrdersResponse::set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersResponse.paging)
}

// -------------------------------------------------------------------

// SpotLimitOrder

// string order_hash = 1 [json_name = "orderHash"];
inline void SpotLimitOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.order_hash)
}
inline std::string* SpotLimitOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.order_hash)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void SpotLimitOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void SpotLimitOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.order_hash)
}

// string order_side = 2 [json_name = "orderSide"];
inline void SpotLimitOrder::clear_order_side() {
  _impl_.order_side_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::order_side() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.order_side)
  return _internal_order_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_order_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.order_side)
}
inline std::string* SpotLimitOrder::mutable_order_side() {
  std::string* _s = _internal_mutable_order_side();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.order_side)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_order_side() const {
  return _impl_.order_side_.Get();
}
inline void SpotLimitOrder::_internal_set_order_side(const std::string& value) {
  ;


  _impl_.order_side_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_order_side() {
  ;
  return _impl_.order_side_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_order_side() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.order_side)
  return _impl_.order_side_.Release();
}
inline void SpotLimitOrder::set_allocated_order_side(std::string* value) {
  _impl_.order_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_side_.IsDefault()) {
          _impl_.order_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.order_side)
}

// string market_id = 3 [json_name = "marketId"];
inline void SpotLimitOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.market_id)
}
inline std::string* SpotLimitOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.market_id)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SpotLimitOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void SpotLimitOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.market_id)
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void SpotLimitOrder::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.subaccount_id)
}
inline std::string* SpotLimitOrder::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.subaccount_id)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SpotLimitOrder::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SpotLimitOrder::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.subaccount_id)
}

// string price = 5 [json_name = "price"];
inline void SpotLimitOrder::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::price() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.price)
}
inline std::string* SpotLimitOrder::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.price)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_price() const {
  return _impl_.price_.Get();
}
inline void SpotLimitOrder::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_price() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.price)
  return _impl_.price_.Release();
}
inline void SpotLimitOrder::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.price)
}

// string quantity = 6 [json_name = "quantity"];
inline void SpotLimitOrder::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::quantity() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.quantity)
}
inline std::string* SpotLimitOrder::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.quantity)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void SpotLimitOrder::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.quantity)
  return _impl_.quantity_.Release();
}
inline void SpotLimitOrder::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.quantity)
}

// string unfilled_quantity = 7 [json_name = "unfilledQuantity"];
inline void SpotLimitOrder::clear_unfilled_quantity() {
  _impl_.unfilled_quantity_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::unfilled_quantity() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.unfilled_quantity)
  return _internal_unfilled_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_unfilled_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.unfilled_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.unfilled_quantity)
}
inline std::string* SpotLimitOrder::mutable_unfilled_quantity() {
  std::string* _s = _internal_mutable_unfilled_quantity();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.unfilled_quantity)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_unfilled_quantity() const {
  return _impl_.unfilled_quantity_.Get();
}
inline void SpotLimitOrder::_internal_set_unfilled_quantity(const std::string& value) {
  ;


  _impl_.unfilled_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_unfilled_quantity() {
  ;
  return _impl_.unfilled_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_unfilled_quantity() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.unfilled_quantity)
  return _impl_.unfilled_quantity_.Release();
}
inline void SpotLimitOrder::set_allocated_unfilled_quantity(std::string* value) {
  _impl_.unfilled_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unfilled_quantity_.IsDefault()) {
          _impl_.unfilled_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.unfilled_quantity)
}

// string trigger_price = 8 [json_name = "triggerPrice"];
inline void SpotLimitOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.trigger_price)
}
inline std::string* SpotLimitOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.trigger_price)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void SpotLimitOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void SpotLimitOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.trigger_price)
}

// string fee_recipient = 9 [json_name = "feeRecipient"];
inline void SpotLimitOrder::clear_fee_recipient() {
  _impl_.fee_recipient_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::fee_recipient() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.fee_recipient)
  return _internal_fee_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_fee_recipient(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.fee_recipient)
}
inline std::string* SpotLimitOrder::mutable_fee_recipient() {
  std::string* _s = _internal_mutable_fee_recipient();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.fee_recipient)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_fee_recipient() const {
  return _impl_.fee_recipient_.Get();
}
inline void SpotLimitOrder::_internal_set_fee_recipient(const std::string& value) {
  ;


  _impl_.fee_recipient_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_fee_recipient() {
  ;
  return _impl_.fee_recipient_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_fee_recipient() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.fee_recipient)
  return _impl_.fee_recipient_.Release();
}
inline void SpotLimitOrder::set_allocated_fee_recipient(std::string* value) {
  _impl_.fee_recipient_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_recipient_.IsDefault()) {
          _impl_.fee_recipient_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.fee_recipient)
}

// string state = 10 [json_name = "state"];
inline void SpotLimitOrder::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& SpotLimitOrder::state() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotLimitOrder::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.state)
}
inline std::string* SpotLimitOrder::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotLimitOrder.state)
  return _s;
}
inline const std::string& SpotLimitOrder::_internal_state() const {
  return _impl_.state_.Get();
}
inline void SpotLimitOrder::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotLimitOrder::release_state() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotLimitOrder.state)
  return _impl_.state_.Release();
}
inline void SpotLimitOrder::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotLimitOrder.state)
}

// sint64 created_at = 11 [json_name = "createdAt"];
inline void SpotLimitOrder::clear_created_at() {
  _impl_.created_at_ = ::int64_t{0};
}
inline ::int64_t SpotLimitOrder::created_at() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.created_at)
  return _internal_created_at();
}
inline void SpotLimitOrder::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.created_at)
}
inline ::int64_t SpotLimitOrder::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void SpotLimitOrder::_internal_set_created_at(::int64_t value) {
  ;
  _impl_.created_at_ = value;
}

// sint64 updated_at = 12 [json_name = "updatedAt"];
inline void SpotLimitOrder::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t SpotLimitOrder::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotLimitOrder.updated_at)
  return _internal_updated_at();
}
inline void SpotLimitOrder::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotLimitOrder.updated_at)
}
inline ::int64_t SpotLimitOrder::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void SpotLimitOrder::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// Paging

// sint64 total = 1 [json_name = "total"];
inline void Paging::clear_total() {
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t Paging::total() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.Paging.total)
  return _internal_total();
}
inline void Paging::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.Paging.total)
}
inline ::int64_t Paging::_internal_total() const {
  return _impl_.total_;
}
inline void Paging::_internal_set_total(::int64_t value) {
  ;
  _impl_.total_ = value;
}

// sint32 from = 2 [json_name = "from"];
inline void Paging::clear_from() {
  _impl_.from_ = 0;
}
inline ::int32_t Paging::from() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.Paging.from)
  return _internal_from();
}
inline void Paging::set_from(::int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.Paging.from)
}
inline ::int32_t Paging::_internal_from() const {
  return _impl_.from_;
}
inline void Paging::_internal_set_from(::int32_t value) {
  ;
  _impl_.from_ = value;
}

// sint32 to = 3 [json_name = "to"];
inline void Paging::clear_to() {
  _impl_.to_ = 0;
}
inline ::int32_t Paging::to() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.Paging.to)
  return _internal_to();
}
inline void Paging::set_to(::int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.Paging.to)
}
inline ::int32_t Paging::_internal_to() const {
  return _impl_.to_;
}
inline void Paging::_internal_set_to(::int32_t value) {
  ;
  _impl_.to_ = value;
}

// sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
inline void Paging::clear_count_by_subaccount() {
  _impl_.count_by_subaccount_ = ::int64_t{0};
}
inline ::int64_t Paging::count_by_subaccount() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.Paging.count_by_subaccount)
  return _internal_count_by_subaccount();
}
inline void Paging::set_count_by_subaccount(::int64_t value) {
  _internal_set_count_by_subaccount(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.Paging.count_by_subaccount)
}
inline ::int64_t Paging::_internal_count_by_subaccount() const {
  return _impl_.count_by_subaccount_;
}
inline void Paging::_internal_set_count_by_subaccount(::int64_t value) {
  ;
  _impl_.count_by_subaccount_ = value;
}

// -------------------------------------------------------------------

// StreamOrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void StreamOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.market_id)
}
inline std::string* StreamOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersRequest.market_id)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersRequest.market_id)
}

// string order_side = 2 [json_name = "orderSide"];
inline void StreamOrdersRequest::clear_order_side() {
  _impl_.order_side_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::order_side() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.order_side)
  return _internal_order_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_order_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.order_side)
}
inline std::string* StreamOrdersRequest::mutable_order_side() {
  std::string* _s = _internal_mutable_order_side();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersRequest.order_side)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_order_side() const {
  return _impl_.order_side_.Get();
}
inline void StreamOrdersRequest::_internal_set_order_side(const std::string& value) {
  ;


  _impl_.order_side_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_order_side() {
  ;
  return _impl_.order_side_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_order_side() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersRequest.order_side)
  return _impl_.order_side_.Release();
}
inline void StreamOrdersRequest::set_allocated_order_side(std::string* value) {
  _impl_.order_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_side_.IsDefault()) {
          _impl_.order_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersRequest.order_side)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void StreamOrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_id)
}
inline std::string* StreamOrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamOrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamOrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_id)
}

// uint64 skip = 4 [json_name = "skip"];
inline void StreamOrdersRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t StreamOrdersRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.skip)
  return _internal_skip();
}
inline void StreamOrdersRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.skip)
}
inline ::uint64_t StreamOrdersRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void StreamOrdersRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 5 [json_name = "limit"];
inline void StreamOrdersRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t StreamOrdersRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.limit)
  return _internal_limit();
}
inline void StreamOrdersRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.limit)
}
inline ::int32_t StreamOrdersRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void StreamOrdersRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 6 [json_name = "startTime"];
inline void StreamOrdersRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.start_time)
  return _internal_start_time();
}
inline void StreamOrdersRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.start_time)
}
inline ::int64_t StreamOrdersRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void StreamOrdersRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 7 [json_name = "endTime"];
inline void StreamOrdersRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.end_time)
  return _internal_end_time();
}
inline void StreamOrdersRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.end_time)
}
inline ::int64_t StreamOrdersRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void StreamOrdersRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 8 [json_name = "marketIds"];
inline int StreamOrdersRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrdersRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrdersRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrdersRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
  return _s;
}
inline const std::string& StreamOrdersRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrdersRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrdersRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrdersRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrdersRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrdersRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrdersRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// bool include_inactive = 9 [json_name = "includeInactive"];
inline void StreamOrdersRequest::clear_include_inactive() {
  _impl_.include_inactive_ = false;
}
inline bool StreamOrdersRequest::include_inactive() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.include_inactive)
  return _internal_include_inactive();
}
inline void StreamOrdersRequest::set_include_inactive(bool value) {
  _internal_set_include_inactive(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.include_inactive)
}
inline bool StreamOrdersRequest::_internal_include_inactive() const {
  return _impl_.include_inactive_;
}
inline void StreamOrdersRequest::_internal_set_include_inactive(bool value) {
  ;
  _impl_.include_inactive_ = value;
}

// bool subaccount_total_orders = 10 [json_name = "subaccountTotalOrders"];
inline void StreamOrdersRequest::clear_subaccount_total_orders() {
  _impl_.subaccount_total_orders_ = false;
}
inline bool StreamOrdersRequest::subaccount_total_orders() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_total_orders)
  return _internal_subaccount_total_orders();
}
inline void StreamOrdersRequest::set_subaccount_total_orders(bool value) {
  _internal_set_subaccount_total_orders(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersRequest.subaccount_total_orders)
}
inline bool StreamOrdersRequest::_internal_subaccount_total_orders() const {
  return _impl_.subaccount_total_orders_;
}
inline void StreamOrdersRequest::_internal_set_subaccount_total_orders(bool value) {
  ;
  _impl_.subaccount_total_orders_ = value;
}

// -------------------------------------------------------------------

// StreamOrdersResponse

// .injective_spot_exchange_rpc.SpotLimitOrder order = 1 [json_name = "order"];
inline bool StreamOrdersResponse::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline void StreamOrdersResponse::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrder& StreamOrdersResponse::_internal_order() const {
  const ::injective_spot_exchange_rpc::SpotLimitOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotLimitOrder&>(
      ::injective_spot_exchange_rpc::_SpotLimitOrder_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrder& StreamOrdersResponse::order() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersResponse.order)
  return _internal_order();
}
inline void StreamOrdersResponse::unsafe_arena_set_allocated_order(
    ::injective_spot_exchange_rpc::SpotLimitOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.StreamOrdersResponse.order)
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* StreamOrdersResponse::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* StreamOrdersResponse::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersResponse.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotLimitOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* StreamOrdersResponse::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotLimitOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* StreamOrdersResponse::mutable_order() {
  ::injective_spot_exchange_rpc::SpotLimitOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersResponse.order)
  return _msg;
}
inline void StreamOrdersResponse::set_allocated_order(::injective_spot_exchange_rpc::SpotLimitOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersResponse.order)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrdersResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrdersResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersResponse.operation_type)
}
inline std::string* StreamOrdersResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrdersResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrdersResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrdersResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrdersResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrdersResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersResponse.timestamp)
}
inline ::int64_t StreamOrdersResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrdersResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// TradesRequest

// string market_id = 1 [json_name = "marketId"];
inline void TradesRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& TradesRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.market_id)
}
inline std::string* TradesRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesRequest.market_id)
  return _s;
}
inline const std::string& TradesRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void TradesRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TradesRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void TradesRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TradesRequest.market_id)
}

// string execution_side = 2 [json_name = "executionSide"];
inline void TradesRequest::clear_execution_side() {
  _impl_.execution_side_.ClearToEmpty();
}
inline const std::string& TradesRequest::execution_side() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.execution_side)
  return _internal_execution_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_execution_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.execution_side)
}
inline std::string* TradesRequest::mutable_execution_side() {
  std::string* _s = _internal_mutable_execution_side();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesRequest.execution_side)
  return _s;
}
inline const std::string& TradesRequest::_internal_execution_side() const {
  return _impl_.execution_side_.Get();
}
inline void TradesRequest::_internal_set_execution_side(const std::string& value) {
  ;


  _impl_.execution_side_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_execution_side() {
  ;
  return _impl_.execution_side_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_execution_side() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TradesRequest.execution_side)
  return _impl_.execution_side_.Release();
}
inline void TradesRequest::set_allocated_execution_side(std::string* value) {
  _impl_.execution_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_side_.IsDefault()) {
          _impl_.execution_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TradesRequest.execution_side)
}

// string direction = 3 [json_name = "direction"];
inline void TradesRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& TradesRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.direction)
}
inline std::string* TradesRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesRequest.direction)
  return _s;
}
inline const std::string& TradesRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void TradesRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TradesRequest.direction)
  return _impl_.direction_.Release();
}
inline void TradesRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TradesRequest.direction)
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void TradesRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& TradesRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.subaccount_id)
}
inline std::string* TradesRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesRequest.subaccount_id)
  return _s;
}
inline const std::string& TradesRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void TradesRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TradesRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void TradesRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TradesRequest.subaccount_id)
}

// uint64 skip = 5 [json_name = "skip"];
inline void TradesRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t TradesRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.skip)
  return _internal_skip();
}
inline void TradesRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.skip)
}
inline ::uint64_t TradesRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void TradesRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 6 [json_name = "limit"];
inline void TradesRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t TradesRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.limit)
  return _internal_limit();
}
inline void TradesRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.limit)
}
inline ::int32_t TradesRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void TradesRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 7 [json_name = "startTime"];
inline void TradesRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t TradesRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.start_time)
  return _internal_start_time();
}
inline void TradesRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.start_time)
}
inline ::int64_t TradesRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void TradesRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 8 [json_name = "endTime"];
inline void TradesRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t TradesRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.end_time)
  return _internal_end_time();
}
inline void TradesRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.end_time)
}
inline ::int64_t TradesRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void TradesRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 9 [json_name = "marketIds"];
inline int TradesRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int TradesRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void TradesRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* TradesRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.TradesRequest.market_ids)
  return _s;
}
inline const std::string& TradesRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* TradesRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void TradesRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.TradesRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.TradesRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradesRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.TradesRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& TradesRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* TradesRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradesRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
inline int TradesRequest::_internal_subaccount_ids_size() const {
  return _impl_.subaccount_ids_.size();
}
inline int TradesRequest::subaccount_ids_size() const {
  return _internal_subaccount_ids_size();
}
inline void TradesRequest::clear_subaccount_ids() {
  _internal_mutable_subaccount_ids()->Clear();
}
inline std::string* TradesRequest::add_subaccount_ids() {
  std::string* _s = _internal_add_subaccount_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
  return _s;
}
inline const std::string& TradesRequest::subaccount_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_subaccount_ids(index);
}
inline std::string* TradesRequest::mutable_subaccount_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids()->Mutable(index);
}
inline void TradesRequest::set_subaccount_ids(int index, const std::string& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, std::string&& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, absl::string_view value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(const std::string& value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(std::string&& value) {
  _internal_mutable_subaccount_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(const char* value, std::size_t size) {
  _internal_mutable_subaccount_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(absl::string_view value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::subaccount_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_subaccount_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradesRequest::mutable_subaccount_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids();
}
inline const std::string& TradesRequest::_internal_subaccount_ids(int index) const {
  return _internal_subaccount_ids().Get(index);
}
inline std::string* TradesRequest::_internal_add_subaccount_ids() {
  return _internal_mutable_subaccount_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::_internal_subaccount_ids() const {
  return _impl_.subaccount_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradesRequest::_internal_mutable_subaccount_ids() {
  return &_impl_.subaccount_ids_;
}

// repeated string execution_types = 11 [json_name = "executionTypes"];
inline int TradesRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int TradesRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void TradesRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* TradesRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.TradesRequest.execution_types)
  return _s;
}
inline const std::string& TradesRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* TradesRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void TradesRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.TradesRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.TradesRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradesRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.TradesRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& TradesRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* TradesRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradesRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// TradesResponse

// repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
inline int TradesResponse::_internal_trades_size() const {
  return _impl_.trades_.size();
}
inline int TradesResponse::trades_size() const {
  return _internal_trades_size();
}
inline void TradesResponse::clear_trades() {
  _internal_mutable_trades()->Clear();
}
inline ::injective_spot_exchange_rpc::SpotTrade* TradesResponse::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesResponse.trades)
  return _internal_mutable_trades()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >*
TradesResponse::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.TradesResponse.trades)
  return _internal_mutable_trades();
}
inline const ::injective_spot_exchange_rpc::SpotTrade& TradesResponse::_internal_trades(int index) const {
  return _internal_trades().Get(index);
}
inline const ::injective_spot_exchange_rpc::SpotTrade& TradesResponse::trades(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesResponse.trades)
  return _internal_trades(index);
}
inline ::injective_spot_exchange_rpc::SpotTrade* TradesResponse::_internal_add_trades() {
  return _internal_mutable_trades()->Add();
}
inline ::injective_spot_exchange_rpc::SpotTrade* TradesResponse::add_trades() {
  ::injective_spot_exchange_rpc::SpotTrade* _add = _internal_add_trades();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.TradesResponse.trades)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >&
TradesResponse::trades() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.TradesResponse.trades)
  return _internal_trades();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>&
TradesResponse::_internal_trades() const {
  return _impl_.trades_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>*
TradesResponse::_internal_mutable_trades() {
  return &_impl_.trades_;
}

// .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool TradesResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void TradesResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::Paging& TradesResponse::_internal_paging() const {
  const ::injective_spot_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::Paging&>(
      ::injective_spot_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_spot_exchange_rpc::Paging& TradesResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.TradesResponse.paging)
  return _internal_paging();
}
inline void TradesResponse::unsafe_arena_set_allocated_paging(
    ::injective_spot_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.TradesResponse.paging)
}
inline ::injective_spot_exchange_rpc::Paging* TradesResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* TradesResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.TradesResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* TradesResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_spot_exchange_rpc::Paging* TradesResponse::mutable_paging() {
  ::injective_spot_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.TradesResponse.paging)
  return _msg;
}
inline void TradesResponse::set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.TradesResponse.paging)
}

// -------------------------------------------------------------------

// SpotTrade

// string order_hash = 1 [json_name = "orderHash"];
inline void SpotTrade::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& SpotTrade::order_hash() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.order_hash)
}
inline std::string* SpotTrade::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.order_hash)
  return _s;
}
inline const std::string& SpotTrade::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void SpotTrade::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.order_hash)
  return _impl_.order_hash_.Release();
}
inline void SpotTrade::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.order_hash)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void SpotTrade::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SpotTrade::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.subaccount_id)
}
inline std::string* SpotTrade::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.subaccount_id)
  return _s;
}
inline const std::string& SpotTrade::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SpotTrade::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SpotTrade::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.subaccount_id)
}

// string market_id = 3 [json_name = "marketId"];
inline void SpotTrade::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SpotTrade::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.market_id)
}
inline std::string* SpotTrade::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.market_id)
  return _s;
}
inline const std::string& SpotTrade::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SpotTrade::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.market_id)
  return _impl_.market_id_.Release();
}
inline void SpotTrade::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.market_id)
}

// string trade_execution_type = 4 [json_name = "tradeExecutionType"];
inline void SpotTrade::clear_trade_execution_type() {
  _impl_.trade_execution_type_.ClearToEmpty();
}
inline const std::string& SpotTrade::trade_execution_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.trade_execution_type)
  return _internal_trade_execution_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_trade_execution_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trade_execution_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.trade_execution_type)
}
inline std::string* SpotTrade::mutable_trade_execution_type() {
  std::string* _s = _internal_mutable_trade_execution_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.trade_execution_type)
  return _s;
}
inline const std::string& SpotTrade::_internal_trade_execution_type() const {
  return _impl_.trade_execution_type_.Get();
}
inline void SpotTrade::_internal_set_trade_execution_type(const std::string& value) {
  ;


  _impl_.trade_execution_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_trade_execution_type() {
  ;
  return _impl_.trade_execution_type_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_trade_execution_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.trade_execution_type)
  return _impl_.trade_execution_type_.Release();
}
inline void SpotTrade::set_allocated_trade_execution_type(std::string* value) {
  _impl_.trade_execution_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trade_execution_type_.IsDefault()) {
          _impl_.trade_execution_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.trade_execution_type)
}

// string trade_direction = 5 [json_name = "tradeDirection"];
inline void SpotTrade::clear_trade_direction() {
  _impl_.trade_direction_.ClearToEmpty();
}
inline const std::string& SpotTrade::trade_direction() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.trade_direction)
  return _internal_trade_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_trade_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trade_direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.trade_direction)
}
inline std::string* SpotTrade::mutable_trade_direction() {
  std::string* _s = _internal_mutable_trade_direction();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.trade_direction)
  return _s;
}
inline const std::string& SpotTrade::_internal_trade_direction() const {
  return _impl_.trade_direction_.Get();
}
inline void SpotTrade::_internal_set_trade_direction(const std::string& value) {
  ;


  _impl_.trade_direction_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_trade_direction() {
  ;
  return _impl_.trade_direction_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_trade_direction() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.trade_direction)
  return _impl_.trade_direction_.Release();
}
inline void SpotTrade::set_allocated_trade_direction(std::string* value) {
  _impl_.trade_direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trade_direction_.IsDefault()) {
          _impl_.trade_direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.trade_direction)
}

// .injective_spot_exchange_rpc.PriceLevel price = 6 [json_name = "price"];
inline bool SpotTrade::has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.price_ != nullptr);
  return value;
}
inline void SpotTrade::clear_price() {
  if (_impl_.price_ != nullptr) _impl_.price_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotTrade::_internal_price() const {
  const ::injective_spot_exchange_rpc::PriceLevel* p = _impl_.price_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::PriceLevel&>(
      ::injective_spot_exchange_rpc::_PriceLevel_default_instance_);
}
inline const ::injective_spot_exchange_rpc::PriceLevel& SpotTrade::price() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.price)
  return _internal_price();
}
inline void SpotTrade::unsafe_arena_set_allocated_price(
    ::injective_spot_exchange_rpc::PriceLevel* price) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_);
  }
  _impl_.price_ = price;
  if (price) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.SpotTrade.price)
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotTrade::release_price() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::PriceLevel* temp = _impl_.price_;
  _impl_.price_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotTrade::unsafe_arena_release_price() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.price)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::PriceLevel* temp = _impl_.price_;
  _impl_.price_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotTrade::_internal_mutable_price() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.price_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::PriceLevel>(GetArenaForAllocation());
    _impl_.price_ = p;
  }
  return _impl_.price_;
}
inline ::injective_spot_exchange_rpc::PriceLevel* SpotTrade::mutable_price() {
  ::injective_spot_exchange_rpc::PriceLevel* _msg = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.price)
  return _msg;
}
inline void SpotTrade::set_allocated_price(::injective_spot_exchange_rpc::PriceLevel* price) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.price_;
  }
  if (price) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price);
    if (message_arena != submessage_arena) {
      price = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.price_ = price;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.price)
}

// string fee = 7 [json_name = "fee"];
inline void SpotTrade::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& SpotTrade::fee() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.fee)
  return _internal_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.fee)
}
inline std::string* SpotTrade::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.fee)
  return _s;
}
inline const std::string& SpotTrade::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void SpotTrade::_internal_set_fee(const std::string& value) {
  ;


  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_fee() {
  ;
  return _impl_.fee_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_fee() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.fee)
  return _impl_.fee_.Release();
}
inline void SpotTrade::set_allocated_fee(std::string* value) {
  _impl_.fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_.IsDefault()) {
          _impl_.fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.fee)
}

// sint64 executed_at = 8 [json_name = "executedAt"];
inline void SpotTrade::clear_executed_at() {
  _impl_.executed_at_ = ::int64_t{0};
}
inline ::int64_t SpotTrade::executed_at() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.executed_at)
  return _internal_executed_at();
}
inline void SpotTrade::set_executed_at(::int64_t value) {
  _internal_set_executed_at(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.executed_at)
}
inline ::int64_t SpotTrade::_internal_executed_at() const {
  return _impl_.executed_at_;
}
inline void SpotTrade::_internal_set_executed_at(::int64_t value) {
  ;
  _impl_.executed_at_ = value;
}

// string fee_recipient = 9 [json_name = "feeRecipient"];
inline void SpotTrade::clear_fee_recipient() {
  _impl_.fee_recipient_.ClearToEmpty();
}
inline const std::string& SpotTrade::fee_recipient() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.fee_recipient)
  return _internal_fee_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_fee_recipient(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.fee_recipient)
}
inline std::string* SpotTrade::mutable_fee_recipient() {
  std::string* _s = _internal_mutable_fee_recipient();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.fee_recipient)
  return _s;
}
inline const std::string& SpotTrade::_internal_fee_recipient() const {
  return _impl_.fee_recipient_.Get();
}
inline void SpotTrade::_internal_set_fee_recipient(const std::string& value) {
  ;


  _impl_.fee_recipient_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_fee_recipient() {
  ;
  return _impl_.fee_recipient_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_fee_recipient() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.fee_recipient)
  return _impl_.fee_recipient_.Release();
}
inline void SpotTrade::set_allocated_fee_recipient(std::string* value) {
  _impl_.fee_recipient_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_recipient_.IsDefault()) {
          _impl_.fee_recipient_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.fee_recipient)
}

// string trade_id = 10 [json_name = "tradeId"];
inline void SpotTrade::clear_trade_id() {
  _impl_.trade_id_.ClearToEmpty();
}
inline const std::string& SpotTrade::trade_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.trade_id)
  return _internal_trade_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_trade_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trade_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.trade_id)
}
inline std::string* SpotTrade::mutable_trade_id() {
  std::string* _s = _internal_mutable_trade_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.trade_id)
  return _s;
}
inline const std::string& SpotTrade::_internal_trade_id() const {
  return _impl_.trade_id_.Get();
}
inline void SpotTrade::_internal_set_trade_id(const std::string& value) {
  ;


  _impl_.trade_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_trade_id() {
  ;
  return _impl_.trade_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_trade_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.trade_id)
  return _impl_.trade_id_.Release();
}
inline void SpotTrade::set_allocated_trade_id(std::string* value) {
  _impl_.trade_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trade_id_.IsDefault()) {
          _impl_.trade_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.trade_id)
}

// string execution_side = 11 [json_name = "executionSide"];
inline void SpotTrade::clear_execution_side() {
  _impl_.execution_side_.ClearToEmpty();
}
inline const std::string& SpotTrade::execution_side() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotTrade.execution_side)
  return _internal_execution_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotTrade::set_execution_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotTrade.execution_side)
}
inline std::string* SpotTrade::mutable_execution_side() {
  std::string* _s = _internal_mutable_execution_side();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotTrade.execution_side)
  return _s;
}
inline const std::string& SpotTrade::_internal_execution_side() const {
  return _impl_.execution_side_.Get();
}
inline void SpotTrade::_internal_set_execution_side(const std::string& value) {
  ;


  _impl_.execution_side_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotTrade::_internal_mutable_execution_side() {
  ;
  return _impl_.execution_side_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotTrade::release_execution_side() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotTrade.execution_side)
  return _impl_.execution_side_.Release();
}
inline void SpotTrade::set_allocated_execution_side(std::string* value) {
  _impl_.execution_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_side_.IsDefault()) {
          _impl_.execution_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotTrade.execution_side)
}

// -------------------------------------------------------------------

// StreamTradesRequest

// string market_id = 1 [json_name = "marketId"];
inline void StreamTradesRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.market_id)
}
inline std::string* StreamTradesRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesRequest.market_id)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamTradesRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamTradesRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamTradesRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamTradesRequest.market_id)
}

// string execution_side = 2 [json_name = "executionSide"];
inline void StreamTradesRequest::clear_execution_side() {
  _impl_.execution_side_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::execution_side() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.execution_side)
  return _internal_execution_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_execution_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.execution_side)
}
inline std::string* StreamTradesRequest::mutable_execution_side() {
  std::string* _s = _internal_mutable_execution_side();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesRequest.execution_side)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_execution_side() const {
  return _impl_.execution_side_.Get();
}
inline void StreamTradesRequest::_internal_set_execution_side(const std::string& value) {
  ;


  _impl_.execution_side_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_execution_side() {
  ;
  return _impl_.execution_side_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_execution_side() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamTradesRequest.execution_side)
  return _impl_.execution_side_.Release();
}
inline void StreamTradesRequest::set_allocated_execution_side(std::string* value) {
  _impl_.execution_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_side_.IsDefault()) {
          _impl_.execution_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamTradesRequest.execution_side)
}

// string direction = 3 [json_name = "direction"];
inline void StreamTradesRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.direction)
}
inline std::string* StreamTradesRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesRequest.direction)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void StreamTradesRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamTradesRequest.direction)
  return _impl_.direction_.Release();
}
inline void StreamTradesRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamTradesRequest.direction)
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void StreamTradesRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_id)
}
inline std::string* StreamTradesRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamTradesRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamTradesRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_id)
}

// uint64 skip = 5 [json_name = "skip"];
inline void StreamTradesRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t StreamTradesRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.skip)
  return _internal_skip();
}
inline void StreamTradesRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.skip)
}
inline ::uint64_t StreamTradesRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void StreamTradesRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 6 [json_name = "limit"];
inline void StreamTradesRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t StreamTradesRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.limit)
  return _internal_limit();
}
inline void StreamTradesRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.limit)
}
inline ::int32_t StreamTradesRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void StreamTradesRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 7 [json_name = "startTime"];
inline void StreamTradesRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t StreamTradesRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.start_time)
  return _internal_start_time();
}
inline void StreamTradesRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.start_time)
}
inline ::int64_t StreamTradesRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void StreamTradesRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 8 [json_name = "endTime"];
inline void StreamTradesRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t StreamTradesRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.end_time)
  return _internal_end_time();
}
inline void StreamTradesRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.end_time)
}
inline ::int64_t StreamTradesRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void StreamTradesRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 9 [json_name = "marketIds"];
inline int StreamTradesRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamTradesRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamTradesRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamTradesRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
  return _s;
}
inline const std::string& StreamTradesRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamTradesRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamTradesRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamTradesRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamTradesRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamTradesRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamTradesRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
inline int StreamTradesRequest::_internal_subaccount_ids_size() const {
  return _impl_.subaccount_ids_.size();
}
inline int StreamTradesRequest::subaccount_ids_size() const {
  return _internal_subaccount_ids_size();
}
inline void StreamTradesRequest::clear_subaccount_ids() {
  _internal_mutable_subaccount_ids()->Clear();
}
inline std::string* StreamTradesRequest::add_subaccount_ids() {
  std::string* _s = _internal_add_subaccount_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _s;
}
inline const std::string& StreamTradesRequest::subaccount_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_subaccount_ids(index);
}
inline std::string* StreamTradesRequest::mutable_subaccount_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids()->Mutable(index);
}
inline void StreamTradesRequest::set_subaccount_ids(int index, const std::string& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, std::string&& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, absl::string_view value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(const std::string& value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(std::string&& value) {
  _internal_mutable_subaccount_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(const char* value, std::size_t size) {
  _internal_mutable_subaccount_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(absl::string_view value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::subaccount_ids() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_subaccount_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamTradesRequest::mutable_subaccount_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids();
}
inline const std::string& StreamTradesRequest::_internal_subaccount_ids(int index) const {
  return _internal_subaccount_ids().Get(index);
}
inline std::string* StreamTradesRequest::_internal_add_subaccount_ids() {
  return _internal_mutable_subaccount_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::_internal_subaccount_ids() const {
  return _impl_.subaccount_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamTradesRequest::_internal_mutable_subaccount_ids() {
  return &_impl_.subaccount_ids_;
}

// repeated string execution_types = 11 [json_name = "executionTypes"];
inline int StreamTradesRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int StreamTradesRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void StreamTradesRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* StreamTradesRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
  return _s;
}
inline const std::string& StreamTradesRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* StreamTradesRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void StreamTradesRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamTradesRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& StreamTradesRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* StreamTradesRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamTradesRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// StreamTradesResponse

// .injective_spot_exchange_rpc.SpotTrade trade = 1 [json_name = "trade"];
inline bool StreamTradesResponse::has_trade() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trade_ != nullptr);
  return value;
}
inline void StreamTradesResponse::clear_trade() {
  if (_impl_.trade_ != nullptr) _impl_.trade_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotTrade& StreamTradesResponse::_internal_trade() const {
  const ::injective_spot_exchange_rpc::SpotTrade* p = _impl_.trade_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotTrade&>(
      ::injective_spot_exchange_rpc::_SpotTrade_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotTrade& StreamTradesResponse::trade() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesResponse.trade)
  return _internal_trade();
}
inline void StreamTradesResponse::unsafe_arena_set_allocated_trade(
    ::injective_spot_exchange_rpc::SpotTrade* trade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trade_);
  }
  _impl_.trade_ = trade;
  if (trade) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.StreamTradesResponse.trade)
}
inline ::injective_spot_exchange_rpc::SpotTrade* StreamTradesResponse::release_trade() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotTrade* temp = _impl_.trade_;
  _impl_.trade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotTrade* StreamTradesResponse::unsafe_arena_release_trade() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamTradesResponse.trade)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotTrade* temp = _impl_.trade_;
  _impl_.trade_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotTrade* StreamTradesResponse::_internal_mutable_trade() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotTrade>(GetArenaForAllocation());
    _impl_.trade_ = p;
  }
  return _impl_.trade_;
}
inline ::injective_spot_exchange_rpc::SpotTrade* StreamTradesResponse::mutable_trade() {
  ::injective_spot_exchange_rpc::SpotTrade* _msg = _internal_mutable_trade();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesResponse.trade)
  return _msg;
}
inline void StreamTradesResponse::set_allocated_trade(::injective_spot_exchange_rpc::SpotTrade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trade_;
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trade);
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamTradesResponse.trade)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamTradesResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamTradesResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesResponse.operation_type)
}
inline std::string* StreamTradesResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamTradesResponse.operation_type)
  return _s;
}
inline const std::string& StreamTradesResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamTradesResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamTradesResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamTradesResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamTradesResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamTradesResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamTradesResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamTradesResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamTradesResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamTradesResponse.timestamp)
}
inline ::int64_t StreamTradesResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamTradesResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// SubaccountOrdersListRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountOrdersListRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountOrdersListRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrdersListRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
}
inline std::string* SubaccountOrdersListRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountOrdersListRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountOrdersListRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountOrdersListRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void SubaccountOrdersListRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SubaccountOrdersListRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountOrdersListRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrdersListRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountOrdersListRequest.market_id)
}
inline std::string* SubaccountOrdersListRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountOrdersListRequest.market_id)
  return _s;
}
inline const std::string& SubaccountOrdersListRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SubaccountOrdersListRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SubaccountOrdersListRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void SubaccountOrdersListRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SubaccountOrdersListRequest.market_id)
}

// uint64 skip = 3 [json_name = "skip"];
inline void SubaccountOrdersListRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t SubaccountOrdersListRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountOrdersListRequest.skip)
  return _internal_skip();
}
inline void SubaccountOrdersListRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountOrdersListRequest.skip)
}
inline ::uint64_t SubaccountOrdersListRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void SubaccountOrdersListRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void SubaccountOrdersListRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t SubaccountOrdersListRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountOrdersListRequest.limit)
  return _internal_limit();
}
inline void SubaccountOrdersListRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountOrdersListRequest.limit)
}
inline ::int32_t SubaccountOrdersListRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void SubaccountOrdersListRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// SubaccountOrdersListResponse

// repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1 [json_name = "orders"];
inline int SubaccountOrdersListResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int SubaccountOrdersListResponse::orders_size() const {
  return _internal_orders_size();
}
inline void SubaccountOrdersListResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* SubaccountOrdersListResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >*
SubaccountOrdersListResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrder& SubaccountOrdersListResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective_spot_exchange_rpc::SpotLimitOrder& SubaccountOrdersListResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_orders(index);
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* SubaccountOrdersListResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective_spot_exchange_rpc::SpotLimitOrder* SubaccountOrdersListResponse::add_orders() {
  ::injective_spot_exchange_rpc::SpotLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotLimitOrder >&
SubaccountOrdersListResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>&
SubaccountOrdersListResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotLimitOrder>*
SubaccountOrdersListResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool SubaccountOrdersListResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void SubaccountOrdersListResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::Paging& SubaccountOrdersListResponse::_internal_paging() const {
  const ::injective_spot_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::Paging&>(
      ::injective_spot_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_spot_exchange_rpc::Paging& SubaccountOrdersListResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountOrdersListResponse.paging)
  return _internal_paging();
}
inline void SubaccountOrdersListResponse::unsafe_arena_set_allocated_paging(
    ::injective_spot_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.SubaccountOrdersListResponse.paging)
}
inline ::injective_spot_exchange_rpc::Paging* SubaccountOrdersListResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* SubaccountOrdersListResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SubaccountOrdersListResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* SubaccountOrdersListResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_spot_exchange_rpc::Paging* SubaccountOrdersListResponse::mutable_paging() {
  ::injective_spot_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountOrdersListResponse.paging)
  return _msg;
}
inline void SubaccountOrdersListResponse::set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SubaccountOrdersListResponse.paging)
}

// -------------------------------------------------------------------

// SubaccountTradesListRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountTradesListRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
}
inline std::string* SubaccountTradesListRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void SubaccountTradesListRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountTradesListRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountTradesListRequest.market_id)
}
inline std::string* SubaccountTradesListRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountTradesListRequest.market_id)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SubaccountTradesListRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SubaccountTradesListRequest.market_id)
}

// string execution_type = 3 [json_name = "executionType"];
inline void SubaccountTradesListRequest::clear_execution_type() {
  _impl_.execution_type_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::execution_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountTradesListRequest.execution_type)
  return _internal_execution_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_execution_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountTradesListRequest.execution_type)
}
inline std::string* SubaccountTradesListRequest::mutable_execution_type() {
  std::string* _s = _internal_mutable_execution_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountTradesListRequest.execution_type)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_execution_type() const {
  return _impl_.execution_type_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_execution_type(const std::string& value) {
  ;


  _impl_.execution_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_execution_type() {
  ;
  return _impl_.execution_type_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_execution_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SubaccountTradesListRequest.execution_type)
  return _impl_.execution_type_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_execution_type(std::string* value) {
  _impl_.execution_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_type_.IsDefault()) {
          _impl_.execution_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SubaccountTradesListRequest.execution_type)
}

// string direction = 4 [json_name = "direction"];
inline void SubaccountTradesListRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountTradesListRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountTradesListRequest.direction)
}
inline std::string* SubaccountTradesListRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountTradesListRequest.direction)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SubaccountTradesListRequest.direction)
  return _impl_.direction_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SubaccountTradesListRequest.direction)
}

// uint64 skip = 5 [json_name = "skip"];
inline void SubaccountTradesListRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t SubaccountTradesListRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountTradesListRequest.skip)
  return _internal_skip();
}
inline void SubaccountTradesListRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountTradesListRequest.skip)
}
inline ::uint64_t SubaccountTradesListRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void SubaccountTradesListRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 6 [json_name = "limit"];
inline void SubaccountTradesListRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t SubaccountTradesListRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountTradesListRequest.limit)
  return _internal_limit();
}
inline void SubaccountTradesListRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SubaccountTradesListRequest.limit)
}
inline ::int32_t SubaccountTradesListRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void SubaccountTradesListRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// SubaccountTradesListResponse

// repeated .injective_spot_exchange_rpc.SpotTrade trades = 1 [json_name = "trades"];
inline int SubaccountTradesListResponse::_internal_trades_size() const {
  return _impl_.trades_.size();
}
inline int SubaccountTradesListResponse::trades_size() const {
  return _internal_trades_size();
}
inline void SubaccountTradesListResponse::clear_trades() {
  _internal_mutable_trades()->Clear();
}
inline ::injective_spot_exchange_rpc::SpotTrade* SubaccountTradesListResponse::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_mutable_trades()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >*
SubaccountTradesListResponse::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_mutable_trades();
}
inline const ::injective_spot_exchange_rpc::SpotTrade& SubaccountTradesListResponse::_internal_trades(int index) const {
  return _internal_trades().Get(index);
}
inline const ::injective_spot_exchange_rpc::SpotTrade& SubaccountTradesListResponse::trades(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_trades(index);
}
inline ::injective_spot_exchange_rpc::SpotTrade* SubaccountTradesListResponse::_internal_add_trades() {
  return _internal_mutable_trades()->Add();
}
inline ::injective_spot_exchange_rpc::SpotTrade* SubaccountTradesListResponse::add_trades() {
  ::injective_spot_exchange_rpc::SpotTrade* _add = _internal_add_trades();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.SubaccountTradesListResponse.trades)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotTrade >&
SubaccountTradesListResponse::trades() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_trades();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>&
SubaccountTradesListResponse::_internal_trades() const {
  return _impl_.trades_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotTrade>*
SubaccountTradesListResponse::_internal_mutable_trades() {
  return &_impl_.trades_;
}

// -------------------------------------------------------------------

// OrdersHistoryRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void OrdersHistoryRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.subaccount_id)
}
inline std::string* OrdersHistoryRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.subaccount_id)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void OrdersHistoryRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersHistoryRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void OrdersHistoryRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersHistoryRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void OrdersHistoryRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.market_id)
}
inline std::string* OrdersHistoryRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.market_id)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrdersHistoryRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersHistoryRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void OrdersHistoryRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersHistoryRequest.market_id)
}

// uint64 skip = 3 [json_name = "skip"];
inline void OrdersHistoryRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t OrdersHistoryRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.skip)
  return _internal_skip();
}
inline void OrdersHistoryRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.skip)
}
inline ::uint64_t OrdersHistoryRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void OrdersHistoryRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void OrdersHistoryRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t OrdersHistoryRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.limit)
  return _internal_limit();
}
inline void OrdersHistoryRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.limit)
}
inline ::int32_t OrdersHistoryRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void OrdersHistoryRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// repeated string order_types = 5 [json_name = "orderTypes"];
inline int OrdersHistoryRequest::_internal_order_types_size() const {
  return _impl_.order_types_.size();
}
inline int OrdersHistoryRequest::order_types_size() const {
  return _internal_order_types_size();
}
inline void OrdersHistoryRequest::clear_order_types() {
  _internal_mutable_order_types()->Clear();
}
inline std::string* OrdersHistoryRequest::add_order_types() {
  std::string* _s = _internal_add_order_types();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
  return _s;
}
inline const std::string& OrdersHistoryRequest::order_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_order_types(index);
}
inline std::string* OrdersHistoryRequest::mutable_order_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_mutable_order_types()->Mutable(index);
}
inline void OrdersHistoryRequest::set_order_types(int index, const std::string& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, std::string&& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, absl::string_view value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(const std::string& value) {
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(std::string&& value) {
  _internal_mutable_order_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(const char* value, std::size_t size) {
  _internal_mutable_order_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(absl::string_view value) {
  _internal_mutable_order_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::order_types() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_order_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrdersHistoryRequest::mutable_order_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_mutable_order_types();
}
inline const std::string& OrdersHistoryRequest::_internal_order_types(int index) const {
  return _internal_order_types().Get(index);
}
inline std::string* OrdersHistoryRequest::_internal_add_order_types() {
  return _internal_mutable_order_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::_internal_order_types() const {
  return _impl_.order_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrdersHistoryRequest::_internal_mutable_order_types() {
  return &_impl_.order_types_;
}

// string direction = 6 [json_name = "direction"];
inline void OrdersHistoryRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.direction)
}
inline std::string* OrdersHistoryRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.direction)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void OrdersHistoryRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersHistoryRequest.direction)
  return _impl_.direction_.Release();
}
inline void OrdersHistoryRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersHistoryRequest.direction)
}

// sint64 start_time = 7 [json_name = "startTime"];
inline void OrdersHistoryRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t OrdersHistoryRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.start_time)
  return _internal_start_time();
}
inline void OrdersHistoryRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.start_time)
}
inline ::int64_t OrdersHistoryRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void OrdersHistoryRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 8 [json_name = "endTime"];
inline void OrdersHistoryRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t OrdersHistoryRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.end_time)
  return _internal_end_time();
}
inline void OrdersHistoryRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.end_time)
}
inline ::int64_t OrdersHistoryRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void OrdersHistoryRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// string state = 9 [json_name = "state"];
inline void OrdersHistoryRequest::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::state() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.state)
}
inline std::string* OrdersHistoryRequest::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.state)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_state() const {
  return _impl_.state_.Get();
}
inline void OrdersHistoryRequest::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_state() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersHistoryRequest.state)
  return _impl_.state_.Release();
}
inline void OrdersHistoryRequest::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersHistoryRequest.state)
}

// repeated string execution_types = 10 [json_name = "executionTypes"];
inline int OrdersHistoryRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int OrdersHistoryRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void OrdersHistoryRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* OrdersHistoryRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _s;
}
inline const std::string& OrdersHistoryRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* OrdersHistoryRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void OrdersHistoryRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrdersHistoryRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& OrdersHistoryRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* OrdersHistoryRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrdersHistoryRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// OrdersHistoryResponse

// repeated .injective_spot_exchange_rpc.SpotOrderHistory orders = 1 [json_name = "orders"];
inline int OrdersHistoryResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int OrdersHistoryResponse::orders_size() const {
  return _internal_orders_size();
}
inline void OrdersHistoryResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective_spot_exchange_rpc::SpotOrderHistory* OrdersHistoryResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotOrderHistory >*
OrdersHistoryResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective_spot_exchange_rpc::SpotOrderHistory& OrdersHistoryResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective_spot_exchange_rpc::SpotOrderHistory& OrdersHistoryResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_orders(index);
}
inline ::injective_spot_exchange_rpc::SpotOrderHistory* OrdersHistoryResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective_spot_exchange_rpc::SpotOrderHistory* OrdersHistoryResponse::add_orders() {
  ::injective_spot_exchange_rpc::SpotOrderHistory* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.OrdersHistoryResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_spot_exchange_rpc::SpotOrderHistory >&
OrdersHistoryResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotOrderHistory>&
OrdersHistoryResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_spot_exchange_rpc::SpotOrderHistory>*
OrdersHistoryResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// .injective_spot_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool OrdersHistoryResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void OrdersHistoryResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::Paging& OrdersHistoryResponse::_internal_paging() const {
  const ::injective_spot_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::Paging&>(
      ::injective_spot_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_spot_exchange_rpc::Paging& OrdersHistoryResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.OrdersHistoryResponse.paging)
  return _internal_paging();
}
inline void OrdersHistoryResponse::unsafe_arena_set_allocated_paging(
    ::injective_spot_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.OrdersHistoryResponse.paging)
}
inline ::injective_spot_exchange_rpc::Paging* OrdersHistoryResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* OrdersHistoryResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.OrdersHistoryResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::Paging* OrdersHistoryResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_spot_exchange_rpc::Paging* OrdersHistoryResponse::mutable_paging() {
  ::injective_spot_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.OrdersHistoryResponse.paging)
  return _msg;
}
inline void OrdersHistoryResponse::set_allocated_paging(::injective_spot_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.OrdersHistoryResponse.paging)
}

// -------------------------------------------------------------------

// SpotOrderHistory

// string order_hash = 1 [json_name = "orderHash"];
inline void SpotOrderHistory::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::order_hash() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.order_hash)
}
inline std::string* SpotOrderHistory::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.order_hash)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void SpotOrderHistory::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.order_hash)
  return _impl_.order_hash_.Release();
}
inline void SpotOrderHistory::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.order_hash)
}

// string market_id = 2 [json_name = "marketId"];
inline void SpotOrderHistory::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.market_id)
}
inline std::string* SpotOrderHistory::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.market_id)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SpotOrderHistory::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.market_id)
  return _impl_.market_id_.Release();
}
inline void SpotOrderHistory::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.market_id)
}

// bool is_active = 3 [json_name = "isActive"];
inline void SpotOrderHistory::clear_is_active() {
  _impl_.is_active_ = false;
}
inline bool SpotOrderHistory::is_active() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.is_active)
  return _internal_is_active();
}
inline void SpotOrderHistory::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.is_active)
}
inline bool SpotOrderHistory::_internal_is_active() const {
  return _impl_.is_active_;
}
inline void SpotOrderHistory::_internal_set_is_active(bool value) {
  ;
  _impl_.is_active_ = value;
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void SpotOrderHistory::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.subaccount_id)
}
inline std::string* SpotOrderHistory::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.subaccount_id)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SpotOrderHistory::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SpotOrderHistory::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.subaccount_id)
}

// string execution_type = 5 [json_name = "executionType"];
inline void SpotOrderHistory::clear_execution_type() {
  _impl_.execution_type_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::execution_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.execution_type)
  return _internal_execution_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_execution_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.execution_type)
}
inline std::string* SpotOrderHistory::mutable_execution_type() {
  std::string* _s = _internal_mutable_execution_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.execution_type)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_execution_type() const {
  return _impl_.execution_type_.Get();
}
inline void SpotOrderHistory::_internal_set_execution_type(const std::string& value) {
  ;


  _impl_.execution_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_execution_type() {
  ;
  return _impl_.execution_type_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_execution_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.execution_type)
  return _impl_.execution_type_.Release();
}
inline void SpotOrderHistory::set_allocated_execution_type(std::string* value) {
  _impl_.execution_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_type_.IsDefault()) {
          _impl_.execution_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.execution_type)
}

// string order_type = 6 [json_name = "orderType"];
inline void SpotOrderHistory::clear_order_type() {
  _impl_.order_type_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::order_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_order_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.order_type)
}
inline std::string* SpotOrderHistory::mutable_order_type() {
  std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.order_type)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_order_type() const {
  return _impl_.order_type_.Get();
}
inline void SpotOrderHistory::_internal_set_order_type(const std::string& value) {
  ;


  _impl_.order_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_order_type() {
  ;
  return _impl_.order_type_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_order_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.order_type)
  return _impl_.order_type_.Release();
}
inline void SpotOrderHistory::set_allocated_order_type(std::string* value) {
  _impl_.order_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_type_.IsDefault()) {
          _impl_.order_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.order_type)
}

// string price = 7 [json_name = "price"];
inline void SpotOrderHistory::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::price() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.price)
}
inline std::string* SpotOrderHistory::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.price)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_price() const {
  return _impl_.price_.Get();
}
inline void SpotOrderHistory::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_price() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.price)
  return _impl_.price_.Release();
}
inline void SpotOrderHistory::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.price)
}

// string trigger_price = 8 [json_name = "triggerPrice"];
inline void SpotOrderHistory::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.trigger_price)
}
inline std::string* SpotOrderHistory::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.trigger_price)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void SpotOrderHistory::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void SpotOrderHistory::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.trigger_price)
}

// string quantity = 9 [json_name = "quantity"];
inline void SpotOrderHistory::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::quantity() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.quantity)
}
inline std::string* SpotOrderHistory::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.quantity)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void SpotOrderHistory::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.quantity)
  return _impl_.quantity_.Release();
}
inline void SpotOrderHistory::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.quantity)
}

// string filled_quantity = 10 [json_name = "filledQuantity"];
inline void SpotOrderHistory::clear_filled_quantity() {
  _impl_.filled_quantity_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::filled_quantity() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.filled_quantity)
  return _internal_filled_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_filled_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.filled_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.filled_quantity)
}
inline std::string* SpotOrderHistory::mutable_filled_quantity() {
  std::string* _s = _internal_mutable_filled_quantity();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.filled_quantity)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_filled_quantity() const {
  return _impl_.filled_quantity_.Get();
}
inline void SpotOrderHistory::_internal_set_filled_quantity(const std::string& value) {
  ;


  _impl_.filled_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_filled_quantity() {
  ;
  return _impl_.filled_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_filled_quantity() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.filled_quantity)
  return _impl_.filled_quantity_.Release();
}
inline void SpotOrderHistory::set_allocated_filled_quantity(std::string* value) {
  _impl_.filled_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filled_quantity_.IsDefault()) {
          _impl_.filled_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.filled_quantity)
}

// string state = 11 [json_name = "state"];
inline void SpotOrderHistory::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::state() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.state)
}
inline std::string* SpotOrderHistory::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.state)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_state() const {
  return _impl_.state_.Get();
}
inline void SpotOrderHistory::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_state() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.state)
  return _impl_.state_.Release();
}
inline void SpotOrderHistory::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.state)
}

// sint64 created_at = 12 [json_name = "createdAt"];
inline void SpotOrderHistory::clear_created_at() {
  _impl_.created_at_ = ::int64_t{0};
}
inline ::int64_t SpotOrderHistory::created_at() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.created_at)
  return _internal_created_at();
}
inline void SpotOrderHistory::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.created_at)
}
inline ::int64_t SpotOrderHistory::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void SpotOrderHistory::_internal_set_created_at(::int64_t value) {
  ;
  _impl_.created_at_ = value;
}

// sint64 updated_at = 13 [json_name = "updatedAt"];
inline void SpotOrderHistory::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t SpotOrderHistory::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.updated_at)
  return _internal_updated_at();
}
inline void SpotOrderHistory::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.updated_at)
}
inline ::int64_t SpotOrderHistory::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void SpotOrderHistory::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// string direction = 14 [json_name = "direction"];
inline void SpotOrderHistory::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& SpotOrderHistory::direction() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.SpotOrderHistory.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotOrderHistory::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.SpotOrderHistory.direction)
}
inline std::string* SpotOrderHistory::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.SpotOrderHistory.direction)
  return _s;
}
inline const std::string& SpotOrderHistory::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void SpotOrderHistory::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotOrderHistory::release_direction() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.SpotOrderHistory.direction)
  return _impl_.direction_.Release();
}
inline void SpotOrderHistory::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.SpotOrderHistory.direction)
}

// -------------------------------------------------------------------

// StreamOrdersHistoryRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void StreamOrdersHistoryRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
}
inline std::string* StreamOrdersHistoryRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void StreamOrdersHistoryRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.market_id)
}
inline std::string* StreamOrdersHistoryRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.market_id)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.market_id)
}

// repeated string order_types = 3 [json_name = "orderTypes"];
inline int StreamOrdersHistoryRequest::_internal_order_types_size() const {
  return _impl_.order_types_.size();
}
inline int StreamOrdersHistoryRequest::order_types_size() const {
  return _internal_order_types_size();
}
inline void StreamOrdersHistoryRequest::clear_order_types() {
  _internal_mutable_order_types()->Clear();
}
inline std::string* StreamOrdersHistoryRequest::add_order_types() {
  std::string* _s = _internal_add_order_types();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::order_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_order_types(index);
}
inline std::string* StreamOrdersHistoryRequest::mutable_order_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_mutable_order_types()->Mutable(index);
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, const std::string& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, std::string&& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, absl::string_view value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(const std::string& value) {
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(std::string&& value) {
  _internal_mutable_order_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(const char* value, std::size_t size) {
  _internal_mutable_order_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(absl::string_view value) {
  _internal_mutable_order_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::order_types() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_order_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrdersHistoryRequest::mutable_order_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_mutable_order_types();
}
inline const std::string& StreamOrdersHistoryRequest::_internal_order_types(int index) const {
  return _internal_order_types().Get(index);
}
inline std::string* StreamOrdersHistoryRequest::_internal_add_order_types() {
  return _internal_mutable_order_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::_internal_order_types() const {
  return _impl_.order_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrdersHistoryRequest::_internal_mutable_order_types() {
  return &_impl_.order_types_;
}

// string direction = 4 [json_name = "direction"];
inline void StreamOrdersHistoryRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.direction)
}
inline std::string* StreamOrdersHistoryRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.direction)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.direction)
  return _impl_.direction_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.direction)
}

// string state = 5 [json_name = "state"];
inline void StreamOrdersHistoryRequest::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::state() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.state)
}
inline std::string* StreamOrdersHistoryRequest::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.state)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_state() const {
  return _impl_.state_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_state() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.state)
  return _impl_.state_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.state)
}

// repeated string execution_types = 6 [json_name = "executionTypes"];
inline int StreamOrdersHistoryRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int StreamOrdersHistoryRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void StreamOrdersHistoryRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* StreamOrdersHistoryRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* StreamOrdersHistoryRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrdersHistoryRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_spot_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& StreamOrdersHistoryRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* StreamOrdersHistoryRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrdersHistoryRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// StreamOrdersHistoryResponse

// .injective_spot_exchange_rpc.SpotOrderHistory order = 1 [json_name = "order"];
inline bool StreamOrdersHistoryResponse::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline void StreamOrdersHistoryResponse::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_spot_exchange_rpc::SpotOrderHistory& StreamOrdersHistoryResponse::_internal_order() const {
  const ::injective_spot_exchange_rpc::SpotOrderHistory* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_spot_exchange_rpc::SpotOrderHistory&>(
      ::injective_spot_exchange_rpc::_SpotOrderHistory_default_instance_);
}
inline const ::injective_spot_exchange_rpc::SpotOrderHistory& StreamOrdersHistoryResponse::order() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.order)
  return _internal_order();
}
inline void StreamOrdersHistoryResponse::unsafe_arena_set_allocated_order(
    ::injective_spot_exchange_rpc::SpotOrderHistory* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.order)
}
inline ::injective_spot_exchange_rpc::SpotOrderHistory* StreamOrdersHistoryResponse::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotOrderHistory* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotOrderHistory* StreamOrdersHistoryResponse::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_spot_exchange_rpc::SpotOrderHistory* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective_spot_exchange_rpc::SpotOrderHistory* StreamOrdersHistoryResponse::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_spot_exchange_rpc::SpotOrderHistory>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective_spot_exchange_rpc::SpotOrderHistory* StreamOrdersHistoryResponse::mutable_order() {
  ::injective_spot_exchange_rpc::SpotOrderHistory* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.order)
  return _msg;
}
inline void StreamOrdersHistoryResponse::set_allocated_order(::injective_spot_exchange_rpc::SpotOrderHistory* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.order)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrdersHistoryResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
}
inline std::string* StreamOrdersHistoryResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrdersHistoryResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrdersHistoryResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrdersHistoryResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrdersHistoryResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersHistoryResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrdersHistoryResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_spot_exchange_rpc.StreamOrdersHistoryResponse.timestamp)
}
inline ::int64_t StreamOrdersHistoryResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrdersHistoryResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_spot_exchange_rpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fspot_5fexchange_5frpc_2eproto_2epb_2eh
