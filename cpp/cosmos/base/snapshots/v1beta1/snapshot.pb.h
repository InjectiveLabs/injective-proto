// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/base/snapshots/v1beta1/snapshot.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
namespace cosmos {
namespace base {
namespace snapshots {
namespace v1beta1 {
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Snapshot;
struct SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class SnapshotExtensionMeta;
struct SnapshotExtensionMetaDefaultTypeInternal;
extern SnapshotExtensionMetaDefaultTypeInternal _SnapshotExtensionMeta_default_instance_;
class SnapshotExtensionPayload;
struct SnapshotExtensionPayloadDefaultTypeInternal;
extern SnapshotExtensionPayloadDefaultTypeInternal _SnapshotExtensionPayload_default_instance_;
class SnapshotIAVLItem;
struct SnapshotIAVLItemDefaultTypeInternal;
extern SnapshotIAVLItemDefaultTypeInternal _SnapshotIAVLItem_default_instance_;
class SnapshotItem;
struct SnapshotItemDefaultTypeInternal;
extern SnapshotItemDefaultTypeInternal _SnapshotItem_default_instance_;
class SnapshotKVItem;
struct SnapshotKVItemDefaultTypeInternal;
extern SnapshotKVItemDefaultTypeInternal _SnapshotKVItem_default_instance_;
class SnapshotSchema;
struct SnapshotSchemaDefaultTypeInternal;
extern SnapshotSchemaDefaultTypeInternal _SnapshotSchema_default_instance_;
class SnapshotStoreItem;
struct SnapshotStoreItemDefaultTypeInternal;
extern SnapshotStoreItemDefaultTypeInternal _SnapshotStoreItem_default_instance_;
}  // namespace v1beta1
}  // namespace snapshots
}  // namespace base
}  // namespace cosmos
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmos::base::snapshots::v1beta1::Metadata* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::Metadata>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::Snapshot* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::Snapshot>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::SnapshotItem* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::SnapshotItem>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::SnapshotKVItem* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::SnapshotKVItem>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::SnapshotSchema* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::SnapshotSchema>(Arena*);
template <>
::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* Arena::CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::SnapshotStoreItem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmos {
namespace base {
namespace snapshots {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class Snapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.Snapshot) */ {
 public:
  inline Snapshot() : Snapshot(nullptr) {}
  ~Snapshot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Snapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Snapshot(const Snapshot& from);
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Snapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Snapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Snapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Snapshot& from) {
    Snapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.Snapshot";
  }
  protected:
  explicit Snapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 4,
    kMetadataFieldNumber = 5,
    kHeightFieldNumber = 1,
    kFormatFieldNumber = 2,
    kChunksFieldNumber = 3,
  };
  // bytes hash = 4 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // .cosmos.base.snapshots.v1beta1.Metadata metadata = 5 [json_name = "metadata", (.gogoproto.nullable) = false];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::cosmos::base::snapshots::v1beta1::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::cosmos::base::snapshots::v1beta1::Metadata* release_metadata();
  ::cosmos::base::snapshots::v1beta1::Metadata* mutable_metadata();
  void set_allocated_metadata(::cosmos::base::snapshots::v1beta1::Metadata* metadata);
  private:
  const ::cosmos::base::snapshots::v1beta1::Metadata& _internal_metadata() const;
  ::cosmos::base::snapshots::v1beta1::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::cosmos::base::snapshots::v1beta1::Metadata* metadata);
  ::cosmos::base::snapshots::v1beta1::Metadata* unsafe_arena_release_metadata();
  // uint64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // uint32 format = 2 [json_name = "format"];
  void clear_format() ;
  ::uint32_t format() const;
  void set_format(::uint32_t value);

  private:
  ::uint32_t _internal_format() const;
  void _internal_set_format(::uint32_t value);

  public:
  // uint32 chunks = 3 [json_name = "chunks"];
  void clear_chunks() ;
  ::uint32_t chunks() const;
  void set_chunks(::uint32_t value);

  private:
  ::uint32_t _internal_chunks() const;
  void _internal_set_chunks(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.Snapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::cosmos::base::snapshots::v1beta1::Metadata* metadata_;
    ::uint64_t height_;
    ::uint32_t format_;
    ::uint32_t chunks_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metadata& from) {
    Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkHashesFieldNumber = 1,
  };
  // repeated bytes chunk_hashes = 1 [json_name = "chunkHashes"];
  int chunk_hashes_size() const;
  private:
  int _internal_chunk_hashes_size() const;

  public:
  void clear_chunk_hashes() ;
  const std::string& chunk_hashes(int index) const;
  std::string* mutable_chunk_hashes(int index);
  void set_chunk_hashes(int index, const std::string& value);
  void set_chunk_hashes(int index, std::string&& value);
  void set_chunk_hashes(int index, const char* value);
  void set_chunk_hashes(int index, const void* value, std::size_t size);
  void set_chunk_hashes(int index, absl::string_view value);
  std::string* add_chunk_hashes();
  void add_chunk_hashes(const std::string& value);
  void add_chunk_hashes(std::string&& value);
  void add_chunk_hashes(const char* value);
  void add_chunk_hashes(const void* value, std::size_t size);
  void add_chunk_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& chunk_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_chunk_hashes();

  private:
  const std::string& _internal_chunk_hashes(int index) const;
  std::string* _internal_add_chunk_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_chunk_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_chunk_hashes();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> chunk_hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class SnapshotItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.SnapshotItem) */ {
 public:
  inline SnapshotItem() : SnapshotItem(nullptr) {}
  ~SnapshotItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotItem(const SnapshotItem& from);
  SnapshotItem(SnapshotItem&& from) noexcept
    : SnapshotItem() {
    *this = ::std::move(from);
  }

  inline SnapshotItem& operator=(const SnapshotItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotItem& operator=(SnapshotItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotItem& default_instance() {
    return *internal_default_instance();
  }
  enum ItemCase {
    kStore = 1,
    kIavl = 2,
    kExtension = 3,
    kExtensionPayload = 4,
    kKv = 5,
    kSchema = 6,
    ITEM_NOT_SET = 0,
  };

  static inline const SnapshotItem* internal_default_instance() {
    return reinterpret_cast<const SnapshotItem*>(
               &_SnapshotItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SnapshotItem& a, SnapshotItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotItem& from) {
    SnapshotItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.SnapshotItem";
  }
  protected:
  explicit SnapshotItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreFieldNumber = 1,
    kIavlFieldNumber = 2,
    kExtensionFieldNumber = 3,
    kExtensionPayloadFieldNumber = 4,
    kKvFieldNumber = 5,
    kSchemaFieldNumber = 6,
  };
  // .cosmos.base.snapshots.v1beta1.SnapshotStoreItem store = 1 [json_name = "store"];
  bool has_store() const;
  private:
  bool _internal_has_store() const;

  public:
  void clear_store() ;
  const ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem& store() const;
  PROTOBUF_NODISCARD ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* release_store();
  ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* mutable_store();
  void set_allocated_store(::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* store);
  private:
  const ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem& _internal_store() const;
  ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* _internal_mutable_store();
  public:
  void unsafe_arena_set_allocated_store(
      ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* store);
  ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* unsafe_arena_release_store();
  // .cosmos.base.snapshots.v1beta1.SnapshotIAVLItem iavl = 2 [json_name = "iavl", (.gogoproto.customname) = "IAVL"];
  bool has_iavl() const;
  private:
  bool _internal_has_iavl() const;

  public:
  void clear_iavl() ;
  const ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem& iavl() const;
  PROTOBUF_NODISCARD ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* release_iavl();
  ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* mutable_iavl();
  void set_allocated_iavl(::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* iavl);
  private:
  const ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem& _internal_iavl() const;
  ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* _internal_mutable_iavl();
  public:
  void unsafe_arena_set_allocated_iavl(
      ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* iavl);
  ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* unsafe_arena_release_iavl();
  // .cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta extension = 3 [json_name = "extension"];
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;

  public:
  void clear_extension() ;
  const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta& extension() const;
  PROTOBUF_NODISCARD ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* release_extension();
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* mutable_extension();
  void set_allocated_extension(::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* extension);
  private:
  const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta& _internal_extension() const;
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* _internal_mutable_extension();
  public:
  void unsafe_arena_set_allocated_extension(
      ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* extension);
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* unsafe_arena_release_extension();
  // .cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload extension_payload = 4 [json_name = "extensionPayload"];
  bool has_extension_payload() const;
  private:
  bool _internal_has_extension_payload() const;

  public:
  void clear_extension_payload() ;
  const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload& extension_payload() const;
  PROTOBUF_NODISCARD ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* release_extension_payload();
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* mutable_extension_payload();
  void set_allocated_extension_payload(::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* extension_payload);
  private:
  const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload& _internal_extension_payload() const;
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* _internal_mutable_extension_payload();
  public:
  void unsafe_arena_set_allocated_extension_payload(
      ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* extension_payload);
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* unsafe_arena_release_extension_payload();
  // .cosmos.base.snapshots.v1beta1.SnapshotKVItem kv = 5 [json_name = "kv", deprecated = true, (.gogoproto.customname) = "KV"];
  [[deprecated]]  bool has_kv() const;
  private:
  bool _internal_has_kv() const;

  public:
  [[deprecated]]  void clear_kv() ;
  [[deprecated]] const ::cosmos::base::snapshots::v1beta1::SnapshotKVItem& kv() const;
  [[deprecated]] PROTOBUF_NODISCARD ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* release_kv();
  [[deprecated]] ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* mutable_kv();
  [[deprecated]] void set_allocated_kv(::cosmos::base::snapshots::v1beta1::SnapshotKVItem* kv);
  private:
  const ::cosmos::base::snapshots::v1beta1::SnapshotKVItem& _internal_kv() const;
  ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* _internal_mutable_kv();
  public:
  [[deprecated]] void unsafe_arena_set_allocated_kv(
      ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* kv);
  [[deprecated]] ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* unsafe_arena_release_kv();
  // .cosmos.base.snapshots.v1beta1.SnapshotSchema schema = 6 [json_name = "schema", deprecated = true];
  [[deprecated]]  bool has_schema() const;
  private:
  bool _internal_has_schema() const;

  public:
  [[deprecated]]  void clear_schema() ;
  [[deprecated]] const ::cosmos::base::snapshots::v1beta1::SnapshotSchema& schema() const;
  [[deprecated]] PROTOBUF_NODISCARD ::cosmos::base::snapshots::v1beta1::SnapshotSchema* release_schema();
  [[deprecated]] ::cosmos::base::snapshots::v1beta1::SnapshotSchema* mutable_schema();
  [[deprecated]] void set_allocated_schema(::cosmos::base::snapshots::v1beta1::SnapshotSchema* schema);
  private:
  const ::cosmos::base::snapshots::v1beta1::SnapshotSchema& _internal_schema() const;
  ::cosmos::base::snapshots::v1beta1::SnapshotSchema* _internal_mutable_schema();
  public:
  [[deprecated]] void unsafe_arena_set_allocated_schema(
      ::cosmos::base::snapshots::v1beta1::SnapshotSchema* schema);
  [[deprecated]] ::cosmos::base::snapshots::v1beta1::SnapshotSchema* unsafe_arena_release_schema();
  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.SnapshotItem)
 private:
  class _Internal;
  void set_has_store();
  void set_has_iavl();
  void set_has_extension();
  void set_has_extension_payload();
  void set_has_kv();
  void set_has_schema();

  inline bool has_item() const;
  inline void clear_has_item();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ItemUnion {
      constexpr ItemUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* store_;
      ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* iavl_;
      ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* extension_;
      ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* extension_payload_;
      ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* kv_;
      ::cosmos::base::snapshots::v1beta1::SnapshotSchema* schema_;
    } item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class SnapshotStoreItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.SnapshotStoreItem) */ {
 public:
  inline SnapshotStoreItem() : SnapshotStoreItem(nullptr) {}
  ~SnapshotStoreItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotStoreItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotStoreItem(const SnapshotStoreItem& from);
  SnapshotStoreItem(SnapshotStoreItem&& from) noexcept
    : SnapshotStoreItem() {
    *this = ::std::move(from);
  }

  inline SnapshotStoreItem& operator=(const SnapshotStoreItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotStoreItem& operator=(SnapshotStoreItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotStoreItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotStoreItem* internal_default_instance() {
    return reinterpret_cast<const SnapshotStoreItem*>(
               &_SnapshotStoreItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SnapshotStoreItem& a, SnapshotStoreItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotStoreItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotStoreItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotStoreItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotStoreItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotStoreItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotStoreItem& from) {
    SnapshotStoreItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotStoreItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.SnapshotStoreItem";
  }
  protected:
  explicit SnapshotStoreItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.SnapshotStoreItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class SnapshotIAVLItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem) */ {
 public:
  inline SnapshotIAVLItem() : SnapshotIAVLItem(nullptr) {}
  ~SnapshotIAVLItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotIAVLItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotIAVLItem(const SnapshotIAVLItem& from);
  SnapshotIAVLItem(SnapshotIAVLItem&& from) noexcept
    : SnapshotIAVLItem() {
    *this = ::std::move(from);
  }

  inline SnapshotIAVLItem& operator=(const SnapshotIAVLItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotIAVLItem& operator=(SnapshotIAVLItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotIAVLItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotIAVLItem* internal_default_instance() {
    return reinterpret_cast<const SnapshotIAVLItem*>(
               &_SnapshotIAVLItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SnapshotIAVLItem& a, SnapshotIAVLItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotIAVLItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotIAVLItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotIAVLItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotIAVLItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotIAVLItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotIAVLItem& from) {
    SnapshotIAVLItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotIAVLItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.SnapshotIAVLItem";
  }
  protected:
  explicit SnapshotIAVLItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kVersionFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // int64 version = 3 [json_name = "version"];
  void clear_version() ;
  ::int64_t version() const;
  void set_version(::int64_t value);

  private:
  ::int64_t _internal_version() const;
  void _internal_set_version(::int64_t value);

  public:
  // int32 height = 4 [json_name = "height"];
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::int64_t version_;
    ::int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class SnapshotExtensionMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta) */ {
 public:
  inline SnapshotExtensionMeta() : SnapshotExtensionMeta(nullptr) {}
  ~SnapshotExtensionMeta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotExtensionMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotExtensionMeta(const SnapshotExtensionMeta& from);
  SnapshotExtensionMeta(SnapshotExtensionMeta&& from) noexcept
    : SnapshotExtensionMeta() {
    *this = ::std::move(from);
  }

  inline SnapshotExtensionMeta& operator=(const SnapshotExtensionMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotExtensionMeta& operator=(SnapshotExtensionMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotExtensionMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotExtensionMeta* internal_default_instance() {
    return reinterpret_cast<const SnapshotExtensionMeta*>(
               &_SnapshotExtensionMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SnapshotExtensionMeta& a, SnapshotExtensionMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotExtensionMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotExtensionMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotExtensionMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotExtensionMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotExtensionMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotExtensionMeta& from) {
    SnapshotExtensionMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotExtensionMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta";
  }
  protected:
  explicit SnapshotExtensionMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint32 format = 2 [json_name = "format"];
  void clear_format() ;
  ::uint32_t format() const;
  void set_format(::uint32_t value);

  private:
  ::uint32_t _internal_format() const;
  void _internal_set_format(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::uint32_t format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class SnapshotExtensionPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload) */ {
 public:
  inline SnapshotExtensionPayload() : SnapshotExtensionPayload(nullptr) {}
  ~SnapshotExtensionPayload() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotExtensionPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotExtensionPayload(const SnapshotExtensionPayload& from);
  SnapshotExtensionPayload(SnapshotExtensionPayload&& from) noexcept
    : SnapshotExtensionPayload() {
    *this = ::std::move(from);
  }

  inline SnapshotExtensionPayload& operator=(const SnapshotExtensionPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotExtensionPayload& operator=(SnapshotExtensionPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotExtensionPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotExtensionPayload* internal_default_instance() {
    return reinterpret_cast<const SnapshotExtensionPayload*>(
               &_SnapshotExtensionPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SnapshotExtensionPayload& a, SnapshotExtensionPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotExtensionPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotExtensionPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotExtensionPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotExtensionPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotExtensionPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotExtensionPayload& from) {
    SnapshotExtensionPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotExtensionPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload";
  }
  protected:
  explicit SnapshotExtensionPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // bytes payload = 1 [json_name = "payload"];
  void clear_payload() ;
  const std::string& payload() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* ptr);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class SnapshotKVItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.SnapshotKVItem) */ {
 public:
  inline SnapshotKVItem() : SnapshotKVItem(nullptr) {}
  ~SnapshotKVItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotKVItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotKVItem(const SnapshotKVItem& from);
  SnapshotKVItem(SnapshotKVItem&& from) noexcept
    : SnapshotKVItem() {
    *this = ::std::move(from);
  }

  inline SnapshotKVItem& operator=(const SnapshotKVItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotKVItem& operator=(SnapshotKVItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotKVItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotKVItem* internal_default_instance() {
    return reinterpret_cast<const SnapshotKVItem*>(
               &_SnapshotKVItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SnapshotKVItem& a, SnapshotKVItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotKVItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotKVItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotKVItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotKVItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotKVItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotKVItem& from) {
    SnapshotKVItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotKVItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.SnapshotKVItem";
  }
  protected:
  explicit SnapshotKVItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.SnapshotKVItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};// -------------------------------------------------------------------

class SnapshotSchema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.base.snapshots.v1beta1.SnapshotSchema) */ {
 public:
  inline SnapshotSchema() : SnapshotSchema(nullptr) {}
  ~SnapshotSchema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotSchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotSchema(const SnapshotSchema& from);
  SnapshotSchema(SnapshotSchema&& from) noexcept
    : SnapshotSchema() {
    *this = ::std::move(from);
  }

  inline SnapshotSchema& operator=(const SnapshotSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotSchema& operator=(SnapshotSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotSchema* internal_default_instance() {
    return reinterpret_cast<const SnapshotSchema*>(
               &_SnapshotSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SnapshotSchema& a, SnapshotSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotSchema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotSchema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotSchema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotSchema& from) {
    SnapshotSchema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotSchema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.base.snapshots.v1beta1.SnapshotSchema";
  }
  protected:
  explicit SnapshotSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated bytes keys = 1 [json_name = "keys"];
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, std::size_t size);
  void set_keys(int index, absl::string_view value);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, std::size_t size);
  void add_keys(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();

  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_keys();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.base.snapshots.v1beta1.SnapshotSchema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Snapshot

// uint64 height = 1 [json_name = "height"];
inline void Snapshot::clear_height() {
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t Snapshot::height() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.Snapshot.height)
  return _internal_height();
}
inline void Snapshot::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.Snapshot.height)
}
inline ::uint64_t Snapshot::_internal_height() const {
  return _impl_.height_;
}
inline void Snapshot::_internal_set_height(::uint64_t value) {
  ;
  _impl_.height_ = value;
}

// uint32 format = 2 [json_name = "format"];
inline void Snapshot::clear_format() {
  _impl_.format_ = 0u;
}
inline ::uint32_t Snapshot::format() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.Snapshot.format)
  return _internal_format();
}
inline void Snapshot::set_format(::uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.Snapshot.format)
}
inline ::uint32_t Snapshot::_internal_format() const {
  return _impl_.format_;
}
inline void Snapshot::_internal_set_format(::uint32_t value) {
  ;
  _impl_.format_ = value;
}

// uint32 chunks = 3 [json_name = "chunks"];
inline void Snapshot::clear_chunks() {
  _impl_.chunks_ = 0u;
}
inline ::uint32_t Snapshot::chunks() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.Snapshot.chunks)
  return _internal_chunks();
}
inline void Snapshot::set_chunks(::uint32_t value) {
  _internal_set_chunks(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.Snapshot.chunks)
}
inline ::uint32_t Snapshot::_internal_chunks() const {
  return _impl_.chunks_;
}
inline void Snapshot::_internal_set_chunks(::uint32_t value) {
  ;
  _impl_.chunks_ = value;
}

// bytes hash = 4 [json_name = "hash"];
inline void Snapshot::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& Snapshot::hash() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.Snapshot.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Snapshot::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.Snapshot.hash)
}
inline std::string* Snapshot::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.Snapshot.hash)
  return _s;
}
inline const std::string& Snapshot::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void Snapshot::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Snapshot::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* Snapshot::release_hash() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.Snapshot.hash)
  return _impl_.hash_.Release();
}
inline void Snapshot::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.Snapshot.hash)
}

// .cosmos.base.snapshots.v1beta1.Metadata metadata = 5 [json_name = "metadata", (.gogoproto.nullable) = false];
inline bool Snapshot::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void Snapshot::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::base::snapshots::v1beta1::Metadata& Snapshot::_internal_metadata() const {
  const ::cosmos::base::snapshots::v1beta1::Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::snapshots::v1beta1::Metadata&>(
      ::cosmos::base::snapshots::v1beta1::_Metadata_default_instance_);
}
inline const ::cosmos::base::snapshots::v1beta1::Metadata& Snapshot::metadata() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.Snapshot.metadata)
  return _internal_metadata();
}
inline void Snapshot::unsafe_arena_set_allocated_metadata(
    ::cosmos::base::snapshots::v1beta1::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.base.snapshots.v1beta1.Snapshot.metadata)
}
inline ::cosmos::base::snapshots::v1beta1::Metadata* Snapshot::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::snapshots::v1beta1::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::snapshots::v1beta1::Metadata* Snapshot::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.Snapshot.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::snapshots::v1beta1::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::cosmos::base::snapshots::v1beta1::Metadata* Snapshot::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::snapshots::v1beta1::Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::cosmos::base::snapshots::v1beta1::Metadata* Snapshot::mutable_metadata() {
  ::cosmos::base::snapshots::v1beta1::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.Snapshot.metadata)
  return _msg;
}
inline void Snapshot::set_allocated_metadata(::cosmos::base::snapshots::v1beta1::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.Snapshot.metadata)
}

// -------------------------------------------------------------------

// Metadata

// repeated bytes chunk_hashes = 1 [json_name = "chunkHashes"];
inline int Metadata::_internal_chunk_hashes_size() const {
  return _impl_.chunk_hashes_.size();
}
inline int Metadata::chunk_hashes_size() const {
  return _internal_chunk_hashes_size();
}
inline void Metadata::clear_chunk_hashes() {
  _internal_mutable_chunk_hashes()->Clear();
}
inline std::string* Metadata::add_chunk_hashes() {
  std::string* _s = _internal_add_chunk_hashes();
  // @@protoc_insertion_point(field_add_mutable:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
  return _s;
}
inline const std::string& Metadata::chunk_hashes(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
  return _internal_chunk_hashes(index);
}
inline std::string* Metadata::mutable_chunk_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
  return _internal_mutable_chunk_hashes()->Mutable(index);
}
inline void Metadata::set_chunk_hashes(int index, const std::string& value) {
  _internal_mutable_chunk_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::set_chunk_hashes(int index, std::string&& value) {
  _internal_mutable_chunk_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::set_chunk_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_chunk_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::set_chunk_hashes(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_chunk_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::set_chunk_hashes(int index, absl::string_view value) {
  _internal_mutable_chunk_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::add_chunk_hashes(const std::string& value) {
  _internal_mutable_chunk_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::add_chunk_hashes(std::string&& value) {
  _internal_mutable_chunk_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::add_chunk_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_chunk_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::add_chunk_hashes(const void* value, std::size_t size) {
  _internal_mutable_chunk_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline void Metadata::add_chunk_hashes(absl::string_view value) {
  _internal_mutable_chunk_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Metadata::chunk_hashes() const {
  // @@protoc_insertion_point(field_list:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
  return _internal_chunk_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Metadata::mutable_chunk_hashes() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.base.snapshots.v1beta1.Metadata.chunk_hashes)
  return _internal_mutable_chunk_hashes();
}
inline const std::string& Metadata::_internal_chunk_hashes(int index) const {
  return _internal_chunk_hashes().Get(index);
}
inline std::string* Metadata::_internal_add_chunk_hashes() {
  return _internal_mutable_chunk_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Metadata::_internal_chunk_hashes() const {
  return _impl_.chunk_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Metadata::_internal_mutable_chunk_hashes() {
  return &_impl_.chunk_hashes_;
}

// -------------------------------------------------------------------

// SnapshotItem

// .cosmos.base.snapshots.v1beta1.SnapshotStoreItem store = 1 [json_name = "store"];
inline bool SnapshotItem::has_store() const {
  return item_case() == kStore;
}
inline bool SnapshotItem::_internal_has_store() const {
  return item_case() == kStore;
}
inline void SnapshotItem::set_has_store() {
  _impl_._oneof_case_[0] = kStore;
}
inline void SnapshotItem::clear_store() {
  if (item_case() == kStore) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.store_;
    }
    clear_has_item();
  }
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* SnapshotItem::release_store() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotItem.store)
  if (item_case() == kStore) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* temp = _impl_.item_.store_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.store_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem& SnapshotItem::_internal_store() const {
  return item_case() == kStore
      ? *_impl_.item_.store_
      : reinterpret_cast<::cosmos::base::snapshots::v1beta1::SnapshotStoreItem&>(::cosmos::base::snapshots::v1beta1::_SnapshotStoreItem_default_instance_);
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem& SnapshotItem::store() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotItem.store)
  return _internal_store();
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* SnapshotItem::unsafe_arena_release_store() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.base.snapshots.v1beta1.SnapshotItem.store)
  if (item_case() == kStore) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* temp = _impl_.item_.store_;
    _impl_.item_.store_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SnapshotItem::unsafe_arena_set_allocated_store(::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* store) {
  clear_item();
  if (store) {
    set_has_store();
    _impl_.item_.store_ = store;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotItem.store)
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* SnapshotItem::_internal_mutable_store() {
  if (item_case() != kStore) {
    clear_item();
    set_has_store();
    _impl_.item_.store_ = CreateMaybeMessage< ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem >(GetArenaForAllocation());
  }
  return _impl_.item_.store_;
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* SnapshotItem::mutable_store() {
  ::cosmos::base::snapshots::v1beta1::SnapshotStoreItem* _msg = _internal_mutable_store();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotItem.store)
  return _msg;
}

// .cosmos.base.snapshots.v1beta1.SnapshotIAVLItem iavl = 2 [json_name = "iavl", (.gogoproto.customname) = "IAVL"];
inline bool SnapshotItem::has_iavl() const {
  return item_case() == kIavl;
}
inline bool SnapshotItem::_internal_has_iavl() const {
  return item_case() == kIavl;
}
inline void SnapshotItem::set_has_iavl() {
  _impl_._oneof_case_[0] = kIavl;
}
inline void SnapshotItem::clear_iavl() {
  if (item_case() == kIavl) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.iavl_;
    }
    clear_has_item();
  }
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* SnapshotItem::release_iavl() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotItem.iavl)
  if (item_case() == kIavl) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* temp = _impl_.item_.iavl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.iavl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem& SnapshotItem::_internal_iavl() const {
  return item_case() == kIavl
      ? *_impl_.item_.iavl_
      : reinterpret_cast<::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem&>(::cosmos::base::snapshots::v1beta1::_SnapshotIAVLItem_default_instance_);
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem& SnapshotItem::iavl() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotItem.iavl)
  return _internal_iavl();
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* SnapshotItem::unsafe_arena_release_iavl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.base.snapshots.v1beta1.SnapshotItem.iavl)
  if (item_case() == kIavl) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* temp = _impl_.item_.iavl_;
    _impl_.item_.iavl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SnapshotItem::unsafe_arena_set_allocated_iavl(::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* iavl) {
  clear_item();
  if (iavl) {
    set_has_iavl();
    _impl_.item_.iavl_ = iavl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotItem.iavl)
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* SnapshotItem::_internal_mutable_iavl() {
  if (item_case() != kIavl) {
    clear_item();
    set_has_iavl();
    _impl_.item_.iavl_ = CreateMaybeMessage< ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem >(GetArenaForAllocation());
  }
  return _impl_.item_.iavl_;
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* SnapshotItem::mutable_iavl() {
  ::cosmos::base::snapshots::v1beta1::SnapshotIAVLItem* _msg = _internal_mutable_iavl();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotItem.iavl)
  return _msg;
}

// .cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta extension = 3 [json_name = "extension"];
inline bool SnapshotItem::has_extension() const {
  return item_case() == kExtension;
}
inline bool SnapshotItem::_internal_has_extension() const {
  return item_case() == kExtension;
}
inline void SnapshotItem::set_has_extension() {
  _impl_._oneof_case_[0] = kExtension;
}
inline void SnapshotItem::clear_extension() {
  if (item_case() == kExtension) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.extension_;
    }
    clear_has_item();
  }
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* SnapshotItem::release_extension() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotItem.extension)
  if (item_case() == kExtension) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* temp = _impl_.item_.extension_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.extension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta& SnapshotItem::_internal_extension() const {
  return item_case() == kExtension
      ? *_impl_.item_.extension_
      : reinterpret_cast<::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta&>(::cosmos::base::snapshots::v1beta1::_SnapshotExtensionMeta_default_instance_);
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta& SnapshotItem::extension() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotItem.extension)
  return _internal_extension();
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* SnapshotItem::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.base.snapshots.v1beta1.SnapshotItem.extension)
  if (item_case() == kExtension) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* temp = _impl_.item_.extension_;
    _impl_.item_.extension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SnapshotItem::unsafe_arena_set_allocated_extension(::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* extension) {
  clear_item();
  if (extension) {
    set_has_extension();
    _impl_.item_.extension_ = extension;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotItem.extension)
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* SnapshotItem::_internal_mutable_extension() {
  if (item_case() != kExtension) {
    clear_item();
    set_has_extension();
    _impl_.item_.extension_ = CreateMaybeMessage< ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta >(GetArenaForAllocation());
  }
  return _impl_.item_.extension_;
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* SnapshotItem::mutable_extension() {
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionMeta* _msg = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotItem.extension)
  return _msg;
}

// .cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload extension_payload = 4 [json_name = "extensionPayload"];
inline bool SnapshotItem::has_extension_payload() const {
  return item_case() == kExtensionPayload;
}
inline bool SnapshotItem::_internal_has_extension_payload() const {
  return item_case() == kExtensionPayload;
}
inline void SnapshotItem::set_has_extension_payload() {
  _impl_._oneof_case_[0] = kExtensionPayload;
}
inline void SnapshotItem::clear_extension_payload() {
  if (item_case() == kExtensionPayload) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.extension_payload_;
    }
    clear_has_item();
  }
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* SnapshotItem::release_extension_payload() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotItem.extension_payload)
  if (item_case() == kExtensionPayload) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* temp = _impl_.item_.extension_payload_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.extension_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload& SnapshotItem::_internal_extension_payload() const {
  return item_case() == kExtensionPayload
      ? *_impl_.item_.extension_payload_
      : reinterpret_cast<::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload&>(::cosmos::base::snapshots::v1beta1::_SnapshotExtensionPayload_default_instance_);
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload& SnapshotItem::extension_payload() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotItem.extension_payload)
  return _internal_extension_payload();
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* SnapshotItem::unsafe_arena_release_extension_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.base.snapshots.v1beta1.SnapshotItem.extension_payload)
  if (item_case() == kExtensionPayload) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* temp = _impl_.item_.extension_payload_;
    _impl_.item_.extension_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SnapshotItem::unsafe_arena_set_allocated_extension_payload(::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* extension_payload) {
  clear_item();
  if (extension_payload) {
    set_has_extension_payload();
    _impl_.item_.extension_payload_ = extension_payload;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotItem.extension_payload)
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* SnapshotItem::_internal_mutable_extension_payload() {
  if (item_case() != kExtensionPayload) {
    clear_item();
    set_has_extension_payload();
    _impl_.item_.extension_payload_ = CreateMaybeMessage< ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload >(GetArenaForAllocation());
  }
  return _impl_.item_.extension_payload_;
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* SnapshotItem::mutable_extension_payload() {
  ::cosmos::base::snapshots::v1beta1::SnapshotExtensionPayload* _msg = _internal_mutable_extension_payload();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotItem.extension_payload)
  return _msg;
}

// .cosmos.base.snapshots.v1beta1.SnapshotKVItem kv = 5 [json_name = "kv", deprecated = true, (.gogoproto.customname) = "KV"];
inline bool SnapshotItem::has_kv() const {
  return item_case() == kKv;
}
inline bool SnapshotItem::_internal_has_kv() const {
  return item_case() == kKv;
}
inline void SnapshotItem::set_has_kv() {
  _impl_._oneof_case_[0] = kKv;
}
inline void SnapshotItem::clear_kv() {
  if (item_case() == kKv) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.kv_;
    }
    clear_has_item();
  }
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* SnapshotItem::release_kv() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotItem.kv)
  if (item_case() == kKv) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* temp = _impl_.item_.kv_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.kv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotKVItem& SnapshotItem::_internal_kv() const {
  return item_case() == kKv
      ? *_impl_.item_.kv_
      : reinterpret_cast<::cosmos::base::snapshots::v1beta1::SnapshotKVItem&>(::cosmos::base::snapshots::v1beta1::_SnapshotKVItem_default_instance_);
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotKVItem& SnapshotItem::kv() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotItem.kv)
  return _internal_kv();
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* SnapshotItem::unsafe_arena_release_kv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.base.snapshots.v1beta1.SnapshotItem.kv)
  if (item_case() == kKv) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* temp = _impl_.item_.kv_;
    _impl_.item_.kv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SnapshotItem::unsafe_arena_set_allocated_kv(::cosmos::base::snapshots::v1beta1::SnapshotKVItem* kv) {
  clear_item();
  if (kv) {
    set_has_kv();
    _impl_.item_.kv_ = kv;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotItem.kv)
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* SnapshotItem::_internal_mutable_kv() {
  if (item_case() != kKv) {
    clear_item();
    set_has_kv();
    _impl_.item_.kv_ = CreateMaybeMessage< ::cosmos::base::snapshots::v1beta1::SnapshotKVItem >(GetArenaForAllocation());
  }
  return _impl_.item_.kv_;
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* SnapshotItem::mutable_kv() {
  ::cosmos::base::snapshots::v1beta1::SnapshotKVItem* _msg = _internal_mutable_kv();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotItem.kv)
  return _msg;
}

// .cosmos.base.snapshots.v1beta1.SnapshotSchema schema = 6 [json_name = "schema", deprecated = true];
inline bool SnapshotItem::has_schema() const {
  return item_case() == kSchema;
}
inline bool SnapshotItem::_internal_has_schema() const {
  return item_case() == kSchema;
}
inline void SnapshotItem::set_has_schema() {
  _impl_._oneof_case_[0] = kSchema;
}
inline void SnapshotItem::clear_schema() {
  if (item_case() == kSchema) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.schema_;
    }
    clear_has_item();
  }
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotSchema* SnapshotItem::release_schema() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotItem.schema)
  if (item_case() == kSchema) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotSchema* temp = _impl_.item_.schema_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotSchema& SnapshotItem::_internal_schema() const {
  return item_case() == kSchema
      ? *_impl_.item_.schema_
      : reinterpret_cast<::cosmos::base::snapshots::v1beta1::SnapshotSchema&>(::cosmos::base::snapshots::v1beta1::_SnapshotSchema_default_instance_);
}
inline const ::cosmos::base::snapshots::v1beta1::SnapshotSchema& SnapshotItem::schema() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotItem.schema)
  return _internal_schema();
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotSchema* SnapshotItem::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.base.snapshots.v1beta1.SnapshotItem.schema)
  if (item_case() == kSchema) {
    clear_has_item();
    ::cosmos::base::snapshots::v1beta1::SnapshotSchema* temp = _impl_.item_.schema_;
    _impl_.item_.schema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SnapshotItem::unsafe_arena_set_allocated_schema(::cosmos::base::snapshots::v1beta1::SnapshotSchema* schema) {
  clear_item();
  if (schema) {
    set_has_schema();
    _impl_.item_.schema_ = schema;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotItem.schema)
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotSchema* SnapshotItem::_internal_mutable_schema() {
  if (item_case() != kSchema) {
    clear_item();
    set_has_schema();
    _impl_.item_.schema_ = CreateMaybeMessage< ::cosmos::base::snapshots::v1beta1::SnapshotSchema >(GetArenaForAllocation());
  }
  return _impl_.item_.schema_;
}
inline ::cosmos::base::snapshots::v1beta1::SnapshotSchema* SnapshotItem::mutable_schema() {
  ::cosmos::base::snapshots::v1beta1::SnapshotSchema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotItem.schema)
  return _msg;
}

inline bool SnapshotItem::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void SnapshotItem::clear_has_item() {
  _impl_._oneof_case_[0] = ITEM_NOT_SET;
}
inline SnapshotItem::ItemCase SnapshotItem::item_case() const {
  return SnapshotItem::ItemCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SnapshotStoreItem

// string name = 1 [json_name = "name"];
inline void SnapshotStoreItem::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SnapshotStoreItem::name() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotStoreItem.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotStoreItem::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotStoreItem.name)
}
inline std::string* SnapshotStoreItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotStoreItem.name)
  return _s;
}
inline const std::string& SnapshotStoreItem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SnapshotStoreItem::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotStoreItem::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotStoreItem::release_name() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotStoreItem.name)
  return _impl_.name_.Release();
}
inline void SnapshotStoreItem::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotStoreItem.name)
}

// -------------------------------------------------------------------

// SnapshotIAVLItem

// bytes key = 1 [json_name = "key"];
inline void SnapshotIAVLItem::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SnapshotIAVLItem::key() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotIAVLItem::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.key)
}
inline std::string* SnapshotIAVLItem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.key)
  return _s;
}
inline const std::string& SnapshotIAVLItem::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SnapshotIAVLItem::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotIAVLItem::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotIAVLItem::release_key() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.key)
  return _impl_.key_.Release();
}
inline void SnapshotIAVLItem::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.key)
}

// bytes value = 2 [json_name = "value"];
inline void SnapshotIAVLItem::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SnapshotIAVLItem::value() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotIAVLItem::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.value)
}
inline std::string* SnapshotIAVLItem::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.value)
  return _s;
}
inline const std::string& SnapshotIAVLItem::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SnapshotIAVLItem::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotIAVLItem::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotIAVLItem::release_value() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.value)
  return _impl_.value_.Release();
}
inline void SnapshotIAVLItem::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.value)
}

// int64 version = 3 [json_name = "version"];
inline void SnapshotIAVLItem::clear_version() {
  _impl_.version_ = ::int64_t{0};
}
inline ::int64_t SnapshotIAVLItem::version() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.version)
  return _internal_version();
}
inline void SnapshotIAVLItem::set_version(::int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.version)
}
inline ::int64_t SnapshotIAVLItem::_internal_version() const {
  return _impl_.version_;
}
inline void SnapshotIAVLItem::_internal_set_version(::int64_t value) {
  ;
  _impl_.version_ = value;
}

// int32 height = 4 [json_name = "height"];
inline void SnapshotIAVLItem::clear_height() {
  _impl_.height_ = 0;
}
inline ::int32_t SnapshotIAVLItem::height() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.height)
  return _internal_height();
}
inline void SnapshotIAVLItem::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotIAVLItem.height)
}
inline ::int32_t SnapshotIAVLItem::_internal_height() const {
  return _impl_.height_;
}
inline void SnapshotIAVLItem::_internal_set_height(::int32_t value) {
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// SnapshotExtensionMeta

// string name = 1 [json_name = "name"];
inline void SnapshotExtensionMeta::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SnapshotExtensionMeta::name() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotExtensionMeta::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta.name)
}
inline std::string* SnapshotExtensionMeta::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta.name)
  return _s;
}
inline const std::string& SnapshotExtensionMeta::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SnapshotExtensionMeta::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotExtensionMeta::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotExtensionMeta::release_name() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta.name)
  return _impl_.name_.Release();
}
inline void SnapshotExtensionMeta::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta.name)
}

// uint32 format = 2 [json_name = "format"];
inline void SnapshotExtensionMeta::clear_format() {
  _impl_.format_ = 0u;
}
inline ::uint32_t SnapshotExtensionMeta::format() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta.format)
  return _internal_format();
}
inline void SnapshotExtensionMeta::set_format(::uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotExtensionMeta.format)
}
inline ::uint32_t SnapshotExtensionMeta::_internal_format() const {
  return _impl_.format_;
}
inline void SnapshotExtensionMeta::_internal_set_format(::uint32_t value) {
  ;
  _impl_.format_ = value;
}

// -------------------------------------------------------------------

// SnapshotExtensionPayload

// bytes payload = 1 [json_name = "payload"];
inline void SnapshotExtensionPayload::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& SnapshotExtensionPayload::payload() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotExtensionPayload::set_payload(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload.payload)
}
inline std::string* SnapshotExtensionPayload::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload.payload)
  return _s;
}
inline const std::string& SnapshotExtensionPayload::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void SnapshotExtensionPayload::_internal_set_payload(const std::string& value) {
  ;


  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotExtensionPayload::_internal_mutable_payload() {
  ;
  return _impl_.payload_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotExtensionPayload::release_payload() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload.payload)
  return _impl_.payload_.Release();
}
inline void SnapshotExtensionPayload::set_allocated_payload(std::string* value) {
  _impl_.payload_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotExtensionPayload.payload)
}

// -------------------------------------------------------------------

// SnapshotKVItem

// bytes key = 1 [json_name = "key"];
inline void SnapshotKVItem::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SnapshotKVItem::key() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotKVItem.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotKVItem::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotKVItem.key)
}
inline std::string* SnapshotKVItem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotKVItem.key)
  return _s;
}
inline const std::string& SnapshotKVItem::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SnapshotKVItem::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotKVItem::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotKVItem::release_key() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotKVItem.key)
  return _impl_.key_.Release();
}
inline void SnapshotKVItem::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotKVItem.key)
}

// bytes value = 2 [json_name = "value"];
inline void SnapshotKVItem::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SnapshotKVItem::value() const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotKVItem.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotKVItem::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotKVItem.value)
}
inline std::string* SnapshotKVItem::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotKVItem.value)
  return _s;
}
inline const std::string& SnapshotKVItem::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SnapshotKVItem::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotKVItem::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SnapshotKVItem::release_value() {
  // @@protoc_insertion_point(field_release:cosmos.base.snapshots.v1beta1.SnapshotKVItem.value)
  return _impl_.value_.Release();
}
inline void SnapshotKVItem::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.base.snapshots.v1beta1.SnapshotKVItem.value)
}

// -------------------------------------------------------------------

// SnapshotSchema

// repeated bytes keys = 1 [json_name = "keys"];
inline int SnapshotSchema::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int SnapshotSchema::keys_size() const {
  return _internal_keys_size();
}
inline void SnapshotSchema::clear_keys() {
  _internal_mutable_keys()->Clear();
}
inline std::string* SnapshotSchema::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
  return _s;
}
inline const std::string& SnapshotSchema::keys(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
  return _internal_keys(index);
}
inline std::string* SnapshotSchema::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline void SnapshotSchema::set_keys(int index, const std::string& value) {
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::set_keys(int index, std::string&& value) {
  _internal_mutable_keys()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::set_keys(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::set_keys(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_keys()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::set_keys(int index, absl::string_view value) {
  _internal_mutable_keys()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::add_keys(const std::string& value) {
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::add_keys(std::string&& value) {
  _internal_mutable_keys()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::add_keys(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::add_keys(const void* value, std::size_t size) {
  _internal_mutable_keys()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline void SnapshotSchema::add_keys(absl::string_view value) {
  _internal_mutable_keys()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotSchema::keys() const {
  // @@protoc_insertion_point(field_list:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
  return _internal_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SnapshotSchema::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.base.snapshots.v1beta1.SnapshotSchema.keys)
  return _internal_mutable_keys();
}
inline const std::string& SnapshotSchema::_internal_keys(int index) const {
  return _internal_keys().Get(index);
}
inline std::string* SnapshotSchema::_internal_add_keys() {
  return _internal_mutable_keys()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotSchema::_internal_keys() const {
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SnapshotSchema::_internal_mutable_keys() {
  return &_impl_.keys_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace snapshots
}  // namespace base
}  // namespace cosmos


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmos_2fbase_2fsnapshots_2fv1beta1_2fsnapshot_2eproto_2epb_2eh
