// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/ics23/v1/proofs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmos_2fics23_2fv1_2fproofs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmos_2fics23_2fv1_2fproofs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmos_2fics23_2fv1_2fproofs_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto;
namespace cosmos {
namespace ics23 {
namespace v1 {
class BatchEntry;
struct BatchEntryDefaultTypeInternal;
extern BatchEntryDefaultTypeInternal _BatchEntry_default_instance_;
class BatchProof;
struct BatchProofDefaultTypeInternal;
extern BatchProofDefaultTypeInternal _BatchProof_default_instance_;
class CommitmentProof;
struct CommitmentProofDefaultTypeInternal;
extern CommitmentProofDefaultTypeInternal _CommitmentProof_default_instance_;
class CompressedBatchEntry;
struct CompressedBatchEntryDefaultTypeInternal;
extern CompressedBatchEntryDefaultTypeInternal _CompressedBatchEntry_default_instance_;
class CompressedBatchProof;
struct CompressedBatchProofDefaultTypeInternal;
extern CompressedBatchProofDefaultTypeInternal _CompressedBatchProof_default_instance_;
class CompressedExistenceProof;
struct CompressedExistenceProofDefaultTypeInternal;
extern CompressedExistenceProofDefaultTypeInternal _CompressedExistenceProof_default_instance_;
class CompressedNonExistenceProof;
struct CompressedNonExistenceProofDefaultTypeInternal;
extern CompressedNonExistenceProofDefaultTypeInternal _CompressedNonExistenceProof_default_instance_;
class ExistenceProof;
struct ExistenceProofDefaultTypeInternal;
extern ExistenceProofDefaultTypeInternal _ExistenceProof_default_instance_;
class InnerOp;
struct InnerOpDefaultTypeInternal;
extern InnerOpDefaultTypeInternal _InnerOp_default_instance_;
class InnerSpec;
struct InnerSpecDefaultTypeInternal;
extern InnerSpecDefaultTypeInternal _InnerSpec_default_instance_;
class LeafOp;
struct LeafOpDefaultTypeInternal;
extern LeafOpDefaultTypeInternal _LeafOp_default_instance_;
class NonExistenceProof;
struct NonExistenceProofDefaultTypeInternal;
extern NonExistenceProofDefaultTypeInternal _NonExistenceProof_default_instance_;
class ProofSpec;
struct ProofSpecDefaultTypeInternal;
extern ProofSpecDefaultTypeInternal _ProofSpec_default_instance_;
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmos::ics23::v1::BatchEntry* Arena::CreateMaybeMessage<::cosmos::ics23::v1::BatchEntry>(Arena*);
template <>
::cosmos::ics23::v1::BatchProof* Arena::CreateMaybeMessage<::cosmos::ics23::v1::BatchProof>(Arena*);
template <>
::cosmos::ics23::v1::CommitmentProof* Arena::CreateMaybeMessage<::cosmos::ics23::v1::CommitmentProof>(Arena*);
template <>
::cosmos::ics23::v1::CompressedBatchEntry* Arena::CreateMaybeMessage<::cosmos::ics23::v1::CompressedBatchEntry>(Arena*);
template <>
::cosmos::ics23::v1::CompressedBatchProof* Arena::CreateMaybeMessage<::cosmos::ics23::v1::CompressedBatchProof>(Arena*);
template <>
::cosmos::ics23::v1::CompressedExistenceProof* Arena::CreateMaybeMessage<::cosmos::ics23::v1::CompressedExistenceProof>(Arena*);
template <>
::cosmos::ics23::v1::CompressedNonExistenceProof* Arena::CreateMaybeMessage<::cosmos::ics23::v1::CompressedNonExistenceProof>(Arena*);
template <>
::cosmos::ics23::v1::ExistenceProof* Arena::CreateMaybeMessage<::cosmos::ics23::v1::ExistenceProof>(Arena*);
template <>
::cosmos::ics23::v1::InnerOp* Arena::CreateMaybeMessage<::cosmos::ics23::v1::InnerOp>(Arena*);
template <>
::cosmos::ics23::v1::InnerSpec* Arena::CreateMaybeMessage<::cosmos::ics23::v1::InnerSpec>(Arena*);
template <>
::cosmos::ics23::v1::LeafOp* Arena::CreateMaybeMessage<::cosmos::ics23::v1::LeafOp>(Arena*);
template <>
::cosmos::ics23::v1::NonExistenceProof* Arena::CreateMaybeMessage<::cosmos::ics23::v1::NonExistenceProof>(Arena*);
template <>
::cosmos::ics23::v1::ProofSpec* Arena::CreateMaybeMessage<::cosmos::ics23::v1::ProofSpec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmos {
namespace ics23 {
namespace v1 {
enum HashOp : int {
  NO_HASH = 0,
  SHA256 = 1,
  SHA512 = 2,
  KECCAK = 3,
  RIPEMD160 = 4,
  BITCOIN = 5,
  SHA512_256 = 6,
  HashOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HashOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HashOp_IsValid(int value);
constexpr HashOp HashOp_MIN = static_cast<HashOp>(0);
constexpr HashOp HashOp_MAX = static_cast<HashOp>(6);
constexpr int HashOp_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
HashOp_descriptor();
template <typename T>
const std::string& HashOp_Name(T value) {
  static_assert(std::is_same<T, HashOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HashOp_Name().");
  return HashOp_Name(static_cast<HashOp>(value));
}
template <>
inline const std::string& HashOp_Name(HashOp value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<HashOp_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool HashOp_Parse(absl::string_view name, HashOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HashOp>(
      HashOp_descriptor(), name, value);
}
enum LengthOp : int {
  NO_PREFIX = 0,
  VAR_PROTO = 1,
  VAR_RLP = 2,
  FIXED32_BIG = 3,
  FIXED32_LITTLE = 4,
  FIXED64_BIG = 5,
  FIXED64_LITTLE = 6,
  REQUIRE_32_BYTES = 7,
  REQUIRE_64_BYTES = 8,
  LengthOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LengthOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LengthOp_IsValid(int value);
constexpr LengthOp LengthOp_MIN = static_cast<LengthOp>(0);
constexpr LengthOp LengthOp_MAX = static_cast<LengthOp>(8);
constexpr int LengthOp_ARRAYSIZE = 8 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
LengthOp_descriptor();
template <typename T>
const std::string& LengthOp_Name(T value) {
  static_assert(std::is_same<T, LengthOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LengthOp_Name().");
  return LengthOp_Name(static_cast<LengthOp>(value));
}
template <>
inline const std::string& LengthOp_Name(LengthOp value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<LengthOp_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool LengthOp_Parse(absl::string_view name, LengthOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LengthOp>(
      LengthOp_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ExistenceProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.ExistenceProof) */ {
 public:
  inline ExistenceProof() : ExistenceProof(nullptr) {}
  ~ExistenceProof() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExistenceProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExistenceProof(const ExistenceProof& from);
  ExistenceProof(ExistenceProof&& from) noexcept
    : ExistenceProof() {
    *this = ::std::move(from);
  }

  inline ExistenceProof& operator=(const ExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExistenceProof& operator=(ExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExistenceProof* internal_default_instance() {
    return reinterpret_cast<const ExistenceProof*>(
               &_ExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExistenceProof& a, ExistenceProof& b) {
    a.Swap(&b);
  }
  inline void Swap(ExistenceProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExistenceProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExistenceProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExistenceProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExistenceProof& from) {
    ExistenceProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExistenceProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.ExistenceProof";
  }
  protected:
  explicit ExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 4,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kLeafFieldNumber = 3,
  };
  // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::cosmos::ics23::v1::InnerOp* mutable_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >*
      mutable_path();
  private:
  const ::cosmos::ics23::v1::InnerOp& _internal_path(int index) const;
  ::cosmos::ics23::v1::InnerOp* _internal_add_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& _internal_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* _internal_mutable_path();
  public:
  const ::cosmos::ics23::v1::InnerOp& path(int index) const;
  ::cosmos::ics23::v1::InnerOp* add_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >&
      path() const;
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  bool has_leaf() const;
  void clear_leaf() ;
  const ::cosmos::ics23::v1::LeafOp& leaf() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::LeafOp* release_leaf();
  ::cosmos::ics23::v1::LeafOp* mutable_leaf();
  void set_allocated_leaf(::cosmos::ics23::v1::LeafOp* leaf);
  private:
  const ::cosmos::ics23::v1::LeafOp& _internal_leaf() const;
  ::cosmos::ics23::v1::LeafOp* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::cosmos::ics23::v1::LeafOp* leaf);
  ::cosmos::ics23::v1::LeafOp* unsafe_arena_release_leaf();
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.ExistenceProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp > path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::cosmos::ics23::v1::LeafOp* leaf_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class NonExistenceProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.NonExistenceProof) */ {
 public:
  inline NonExistenceProof() : NonExistenceProof(nullptr) {}
  ~NonExistenceProof() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NonExistenceProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NonExistenceProof(const NonExistenceProof& from);
  NonExistenceProof(NonExistenceProof&& from) noexcept
    : NonExistenceProof() {
    *this = ::std::move(from);
  }

  inline NonExistenceProof& operator=(const NonExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonExistenceProof& operator=(NonExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NonExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const NonExistenceProof* internal_default_instance() {
    return reinterpret_cast<const NonExistenceProof*>(
               &_NonExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NonExistenceProof& a, NonExistenceProof& b) {
    a.Swap(&b);
  }
  inline void Swap(NonExistenceProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NonExistenceProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NonExistenceProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NonExistenceProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NonExistenceProof& from) {
    NonExistenceProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NonExistenceProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.NonExistenceProof";
  }
  protected:
  explicit NonExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
  bool has_left() const;
  void clear_left() ;
  const ::cosmos::ics23::v1::ExistenceProof& left() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_left();
  ::cosmos::ics23::v1::ExistenceProof* mutable_left();
  void set_allocated_left(::cosmos::ics23::v1::ExistenceProof* left);
  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_left() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::cosmos::ics23::v1::ExistenceProof* left);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_left();
  // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
  bool has_right() const;
  void clear_right() ;
  const ::cosmos::ics23::v1::ExistenceProof& right() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_right();
  ::cosmos::ics23::v1::ExistenceProof* mutable_right();
  void set_allocated_right(::cosmos::ics23::v1::ExistenceProof* right);
  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_right() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::cosmos::ics23::v1::ExistenceProof* right);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_right();
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.NonExistenceProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::cosmos::ics23::v1::ExistenceProof* left_;
    ::cosmos::ics23::v1::ExistenceProof* right_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class CommitmentProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CommitmentProof) */ {
 public:
  inline CommitmentProof() : CommitmentProof(nullptr) {}
  ~CommitmentProof() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommitmentProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitmentProof(const CommitmentProof& from);
  CommitmentProof(CommitmentProof&& from) noexcept
    : CommitmentProof() {
    *this = ::std::move(from);
  }

  inline CommitmentProof& operator=(const CommitmentProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitmentProof& operator=(CommitmentProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitmentProof& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kExist = 1,
    kNonexist = 2,
    kBatch = 3,
    kCompressed = 4,
    PROOF_NOT_SET = 0,
  };

  static inline const CommitmentProof* internal_default_instance() {
    return reinterpret_cast<const CommitmentProof*>(
               &_CommitmentProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CommitmentProof& a, CommitmentProof& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitmentProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitmentProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitmentProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitmentProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommitmentProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommitmentProof& from) {
    CommitmentProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitmentProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.CommitmentProof";
  }
  protected:
  explicit CommitmentProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExistFieldNumber = 1,
    kNonexistFieldNumber = 2,
    kBatchFieldNumber = 3,
    kCompressedFieldNumber = 4,
  };
  // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
  bool has_exist() const;
  private:
  bool _internal_has_exist() const;

  public:
  void clear_exist() ;
  const ::cosmos::ics23::v1::ExistenceProof& exist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_exist();
  ::cosmos::ics23::v1::ExistenceProof* mutable_exist();
  void set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist);
  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_exist() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_exist();
  public:
  void unsafe_arena_set_allocated_exist(
      ::cosmos::ics23::v1::ExistenceProof* exist);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_exist();
  // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
  bool has_nonexist() const;
  private:
  bool _internal_has_nonexist() const;

  public:
  void clear_nonexist() ;
  const ::cosmos::ics23::v1::NonExistenceProof& nonexist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::NonExistenceProof* release_nonexist();
  ::cosmos::ics23::v1::NonExistenceProof* mutable_nonexist();
  void set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist);
  private:
  const ::cosmos::ics23::v1::NonExistenceProof& _internal_nonexist() const;
  ::cosmos::ics23::v1::NonExistenceProof* _internal_mutable_nonexist();
  public:
  void unsafe_arena_set_allocated_nonexist(
      ::cosmos::ics23::v1::NonExistenceProof* nonexist);
  ::cosmos::ics23::v1::NonExistenceProof* unsafe_arena_release_nonexist();
  // .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
  bool has_batch() const;
  private:
  bool _internal_has_batch() const;

  public:
  void clear_batch() ;
  const ::cosmos::ics23::v1::BatchProof& batch() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::BatchProof* release_batch();
  ::cosmos::ics23::v1::BatchProof* mutable_batch();
  void set_allocated_batch(::cosmos::ics23::v1::BatchProof* batch);
  private:
  const ::cosmos::ics23::v1::BatchProof& _internal_batch() const;
  ::cosmos::ics23::v1::BatchProof* _internal_mutable_batch();
  public:
  void unsafe_arena_set_allocated_batch(
      ::cosmos::ics23::v1::BatchProof* batch);
  ::cosmos::ics23::v1::BatchProof* unsafe_arena_release_batch();
  // .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
  bool has_compressed() const;
  private:
  bool _internal_has_compressed() const;

  public:
  void clear_compressed() ;
  const ::cosmos::ics23::v1::CompressedBatchProof& compressed() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedBatchProof* release_compressed();
  ::cosmos::ics23::v1::CompressedBatchProof* mutable_compressed();
  void set_allocated_compressed(::cosmos::ics23::v1::CompressedBatchProof* compressed);
  private:
  const ::cosmos::ics23::v1::CompressedBatchProof& _internal_compressed() const;
  ::cosmos::ics23::v1::CompressedBatchProof* _internal_mutable_compressed();
  public:
  void unsafe_arena_set_allocated_compressed(
      ::cosmos::ics23::v1::CompressedBatchProof* compressed);
  ::cosmos::ics23::v1::CompressedBatchProof* unsafe_arena_release_compressed();
  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CommitmentProof)
 private:
  class _Internal;
  void set_has_exist();
  void set_has_nonexist();
  void set_has_batch();
  void set_has_compressed();

  inline bool has_proof() const;
  inline void clear_has_proof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cosmos::ics23::v1::ExistenceProof* exist_;
      ::cosmos::ics23::v1::NonExistenceProof* nonexist_;
      ::cosmos::ics23::v1::BatchProof* batch_;
      ::cosmos::ics23::v1::CompressedBatchProof* compressed_;
    } proof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class LeafOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.LeafOp) */ {
 public:
  inline LeafOp() : LeafOp(nullptr) {}
  ~LeafOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeafOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeafOp(const LeafOp& from);
  LeafOp(LeafOp&& from) noexcept
    : LeafOp() {
    *this = ::std::move(from);
  }

  inline LeafOp& operator=(const LeafOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeafOp& operator=(LeafOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeafOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeafOp* internal_default_instance() {
    return reinterpret_cast<const LeafOp*>(
               &_LeafOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LeafOp& a, LeafOp& b) {
    a.Swap(&b);
  }
  inline void Swap(LeafOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeafOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeafOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeafOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeafOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeafOp& from) {
    LeafOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.LeafOp";
  }
  protected:
  explicit LeafOp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 5,
    kHashFieldNumber = 1,
    kPrehashKeyFieldNumber = 2,
    kPrehashValueFieldNumber = 3,
    kLengthFieldNumber = 4,
  };
  // bytes prefix = 5 [json_name = "prefix"];
  void clear_prefix() ;
  const std::string& prefix() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* ptr);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  void clear_hash() ;
  ::cosmos::ics23::v1::HashOp hash() const;
  void set_hash(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_hash() const;
  void _internal_set_hash(::cosmos::ics23::v1::HashOp value);

  public:
  // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
  void clear_prehash_key() ;
  ::cosmos::ics23::v1::HashOp prehash_key() const;
  void set_prehash_key(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_prehash_key() const;
  void _internal_set_prehash_key(::cosmos::ics23::v1::HashOp value);

  public:
  // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
  void clear_prehash_value() ;
  ::cosmos::ics23::v1::HashOp prehash_value() const;
  void set_prehash_value(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_prehash_value() const;
  void _internal_set_prehash_value(::cosmos::ics23::v1::HashOp value);

  public:
  // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
  void clear_length() ;
  ::cosmos::ics23::v1::LengthOp length() const;
  void set_length(::cosmos::ics23::v1::LengthOp value);

  private:
  ::cosmos::ics23::v1::LengthOp _internal_length() const;
  void _internal_set_length(::cosmos::ics23::v1::LengthOp value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.LeafOp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
    int hash_;
    int prehash_key_;
    int prehash_value_;
    int length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class InnerOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.InnerOp) */ {
 public:
  inline InnerOp() : InnerOp(nullptr) {}
  ~InnerOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InnerOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerOp(const InnerOp& from);
  InnerOp(InnerOp&& from) noexcept
    : InnerOp() {
    *this = ::std::move(from);
  }

  inline InnerOp& operator=(const InnerOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerOp& operator=(InnerOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerOp* internal_default_instance() {
    return reinterpret_cast<const InnerOp*>(
               &_InnerOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InnerOp& a, InnerOp& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InnerOp& from) {
    InnerOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.InnerOp";
  }
  protected:
  explicit InnerOp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 2,
    kSuffixFieldNumber = 3,
    kHashFieldNumber = 1,
  };
  // bytes prefix = 2 [json_name = "prefix"];
  void clear_prefix() ;
  const std::string& prefix() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* ptr);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // bytes suffix = 3 [json_name = "suffix"];
  void clear_suffix() ;
  const std::string& suffix() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  std::string* mutable_suffix();
  PROTOBUF_NODISCARD std::string* release_suffix();
  void set_allocated_suffix(std::string* ptr);

  private:
  const std::string& _internal_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
      const std::string& value);
  std::string* _internal_mutable_suffix();

  public:
  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  void clear_hash() ;
  ::cosmos::ics23::v1::HashOp hash() const;
  void set_hash(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_hash() const;
  void _internal_set_hash(::cosmos::ics23::v1::HashOp value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.InnerOp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suffix_;
    int hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class ProofSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.ProofSpec) */ {
 public:
  inline ProofSpec() : ProofSpec(nullptr) {}
  ~ProofSpec() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProofSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProofSpec(const ProofSpec& from);
  ProofSpec(ProofSpec&& from) noexcept
    : ProofSpec() {
    *this = ::std::move(from);
  }

  inline ProofSpec& operator=(const ProofSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProofSpec& operator=(ProofSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProofSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProofSpec* internal_default_instance() {
    return reinterpret_cast<const ProofSpec*>(
               &_ProofSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProofSpec& a, ProofSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ProofSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProofSpec* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProofSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProofSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProofSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProofSpec& from) {
    ProofSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProofSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.ProofSpec";
  }
  protected:
  explicit ProofSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeafSpecFieldNumber = 1,
    kInnerSpecFieldNumber = 2,
    kMaxDepthFieldNumber = 3,
    kMinDepthFieldNumber = 4,
    kPrehashKeyBeforeComparisonFieldNumber = 5,
  };
  // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
  bool has_leaf_spec() const;
  void clear_leaf_spec() ;
  const ::cosmos::ics23::v1::LeafOp& leaf_spec() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::LeafOp* release_leaf_spec();
  ::cosmos::ics23::v1::LeafOp* mutable_leaf_spec();
  void set_allocated_leaf_spec(::cosmos::ics23::v1::LeafOp* leaf_spec);
  private:
  const ::cosmos::ics23::v1::LeafOp& _internal_leaf_spec() const;
  ::cosmos::ics23::v1::LeafOp* _internal_mutable_leaf_spec();
  public:
  void unsafe_arena_set_allocated_leaf_spec(
      ::cosmos::ics23::v1::LeafOp* leaf_spec);
  ::cosmos::ics23::v1::LeafOp* unsafe_arena_release_leaf_spec();
  // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
  bool has_inner_spec() const;
  void clear_inner_spec() ;
  const ::cosmos::ics23::v1::InnerSpec& inner_spec() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::InnerSpec* release_inner_spec();
  ::cosmos::ics23::v1::InnerSpec* mutable_inner_spec();
  void set_allocated_inner_spec(::cosmos::ics23::v1::InnerSpec* inner_spec);
  private:
  const ::cosmos::ics23::v1::InnerSpec& _internal_inner_spec() const;
  ::cosmos::ics23::v1::InnerSpec* _internal_mutable_inner_spec();
  public:
  void unsafe_arena_set_allocated_inner_spec(
      ::cosmos::ics23::v1::InnerSpec* inner_spec);
  ::cosmos::ics23::v1::InnerSpec* unsafe_arena_release_inner_spec();
  // int32 max_depth = 3 [json_name = "maxDepth"];
  void clear_max_depth() ;
  ::int32_t max_depth() const;
  void set_max_depth(::int32_t value);

  private:
  ::int32_t _internal_max_depth() const;
  void _internal_set_max_depth(::int32_t value);

  public:
  // int32 min_depth = 4 [json_name = "minDepth"];
  void clear_min_depth() ;
  ::int32_t min_depth() const;
  void set_min_depth(::int32_t value);

  private:
  ::int32_t _internal_min_depth() const;
  void _internal_set_min_depth(::int32_t value);

  public:
  // bool prehash_key_before_comparison = 5 [json_name = "prehashKeyBeforeComparison"];
  void clear_prehash_key_before_comparison() ;
  bool prehash_key_before_comparison() const;
  void set_prehash_key_before_comparison(bool value);

  private:
  bool _internal_prehash_key_before_comparison() const;
  void _internal_set_prehash_key_before_comparison(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.ProofSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cosmos::ics23::v1::LeafOp* leaf_spec_;
    ::cosmos::ics23::v1::InnerSpec* inner_spec_;
    ::int32_t max_depth_;
    ::int32_t min_depth_;
    bool prehash_key_before_comparison_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class InnerSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.InnerSpec) */ {
 public:
  inline InnerSpec() : InnerSpec(nullptr) {}
  ~InnerSpec() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InnerSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerSpec(const InnerSpec& from);
  InnerSpec(InnerSpec&& from) noexcept
    : InnerSpec() {
    *this = ::std::move(from);
  }

  inline InnerSpec& operator=(const InnerSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerSpec& operator=(InnerSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerSpec* internal_default_instance() {
    return reinterpret_cast<const InnerSpec*>(
               &_InnerSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InnerSpec& a, InnerSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerSpec* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InnerSpec& from) {
    InnerSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.InnerSpec";
  }
  protected:
  explicit InnerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildOrderFieldNumber = 1,
    kEmptyChildFieldNumber = 5,
    kChildSizeFieldNumber = 2,
    kMinPrefixLengthFieldNumber = 3,
    kMaxPrefixLengthFieldNumber = 4,
    kHashFieldNumber = 6,
  };
  // repeated int32 child_order = 1 [json_name = "childOrder"];
  int child_order_size() const;
  private:
  int _internal_child_order_size() const;

  public:
  void clear_child_order() ;
  ::int32_t child_order(int index) const;
  void set_child_order(int index, ::int32_t value);
  void add_child_order(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& child_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_child_order();

  private:
  ::int32_t _internal_child_order(int index) const;
  void _internal_add_child_order(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_child_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_child_order();

  public:
  // bytes empty_child = 5 [json_name = "emptyChild"];
  void clear_empty_child() ;
  const std::string& empty_child() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_empty_child(Arg_&& arg, Args_... args);
  std::string* mutable_empty_child();
  PROTOBUF_NODISCARD std::string* release_empty_child();
  void set_allocated_empty_child(std::string* ptr);

  private:
  const std::string& _internal_empty_child() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_empty_child(
      const std::string& value);
  std::string* _internal_mutable_empty_child();

  public:
  // int32 child_size = 2 [json_name = "childSize"];
  void clear_child_size() ;
  ::int32_t child_size() const;
  void set_child_size(::int32_t value);

  private:
  ::int32_t _internal_child_size() const;
  void _internal_set_child_size(::int32_t value);

  public:
  // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
  void clear_min_prefix_length() ;
  ::int32_t min_prefix_length() const;
  void set_min_prefix_length(::int32_t value);

  private:
  ::int32_t _internal_min_prefix_length() const;
  void _internal_set_min_prefix_length(::int32_t value);

  public:
  // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
  void clear_max_prefix_length() ;
  ::int32_t max_prefix_length() const;
  void set_max_prefix_length(::int32_t value);

  private:
  ::int32_t _internal_max_prefix_length() const;
  void _internal_set_max_prefix_length(::int32_t value);

  public:
  // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
  void clear_hash() ;
  ::cosmos::ics23::v1::HashOp hash() const;
  void set_hash(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_hash() const;
  void _internal_set_hash(::cosmos::ics23::v1::HashOp value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.InnerSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> child_order_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _child_order_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr empty_child_;
    ::int32_t child_size_;
    ::int32_t min_prefix_length_;
    ::int32_t max_prefix_length_;
    int hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class BatchProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.BatchProof) */ {
 public:
  inline BatchProof() : BatchProof(nullptr) {}
  ~BatchProof() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BatchProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchProof(const BatchProof& from);
  BatchProof(BatchProof&& from) noexcept
    : BatchProof() {
    *this = ::std::move(from);
  }

  inline BatchProof& operator=(const BatchProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchProof& operator=(BatchProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchProof* internal_default_instance() {
    return reinterpret_cast<const BatchProof*>(
               &_BatchProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BatchProof& a, BatchProof& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchProof& from) {
    BatchProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.BatchProof";
  }
  protected:
  explicit BatchProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::ics23::v1::BatchEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::BatchEntry >*
      mutable_entries();
  private:
  const ::cosmos::ics23::v1::BatchEntry& _internal_entries(int index) const;
  ::cosmos::ics23::v1::BatchEntry* _internal_add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>& _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::ics23::v1::BatchEntry& entries(int index) const;
  ::cosmos::ics23::v1::BatchEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::BatchEntry >&
      entries() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.BatchProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::BatchEntry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class BatchEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.BatchEntry) */ {
 public:
  inline BatchEntry() : BatchEntry(nullptr) {}
  ~BatchEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BatchEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchEntry(const BatchEntry& from);
  BatchEntry(BatchEntry&& from) noexcept
    : BatchEntry() {
    *this = ::std::move(from);
  }

  inline BatchEntry& operator=(const BatchEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchEntry& operator=(BatchEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchEntry& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kExist = 1,
    kNonexist = 2,
    PROOF_NOT_SET = 0,
  };

  static inline const BatchEntry* internal_default_instance() {
    return reinterpret_cast<const BatchEntry*>(
               &_BatchEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BatchEntry& a, BatchEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchEntry& from) {
    BatchEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.BatchEntry";
  }
  protected:
  explicit BatchEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExistFieldNumber = 1,
    kNonexistFieldNumber = 2,
  };
  // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
  bool has_exist() const;
  private:
  bool _internal_has_exist() const;

  public:
  void clear_exist() ;
  const ::cosmos::ics23::v1::ExistenceProof& exist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_exist();
  ::cosmos::ics23::v1::ExistenceProof* mutable_exist();
  void set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist);
  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_exist() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_exist();
  public:
  void unsafe_arena_set_allocated_exist(
      ::cosmos::ics23::v1::ExistenceProof* exist);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_exist();
  // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
  bool has_nonexist() const;
  private:
  bool _internal_has_nonexist() const;

  public:
  void clear_nonexist() ;
  const ::cosmos::ics23::v1::NonExistenceProof& nonexist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::NonExistenceProof* release_nonexist();
  ::cosmos::ics23::v1::NonExistenceProof* mutable_nonexist();
  void set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist);
  private:
  const ::cosmos::ics23::v1::NonExistenceProof& _internal_nonexist() const;
  ::cosmos::ics23::v1::NonExistenceProof* _internal_mutable_nonexist();
  public:
  void unsafe_arena_set_allocated_nonexist(
      ::cosmos::ics23::v1::NonExistenceProof* nonexist);
  ::cosmos::ics23::v1::NonExistenceProof* unsafe_arena_release_nonexist();
  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.BatchEntry)
 private:
  class _Internal;
  void set_has_exist();
  void set_has_nonexist();

  inline bool has_proof() const;
  inline void clear_has_proof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cosmos::ics23::v1::ExistenceProof* exist_;
      ::cosmos::ics23::v1::NonExistenceProof* nonexist_;
    } proof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class CompressedBatchProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedBatchProof) */ {
 public:
  inline CompressedBatchProof() : CompressedBatchProof(nullptr) {}
  ~CompressedBatchProof() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedBatchProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedBatchProof(const CompressedBatchProof& from);
  CompressedBatchProof(CompressedBatchProof&& from) noexcept
    : CompressedBatchProof() {
    *this = ::std::move(from);
  }

  inline CompressedBatchProof& operator=(const CompressedBatchProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedBatchProof& operator=(CompressedBatchProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedBatchProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedBatchProof* internal_default_instance() {
    return reinterpret_cast<const CompressedBatchProof*>(
               &_CompressedBatchProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CompressedBatchProof& a, CompressedBatchProof& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedBatchProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedBatchProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedBatchProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedBatchProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedBatchProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedBatchProof& from) {
    CompressedBatchProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedBatchProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.CompressedBatchProof";
  }
  protected:
  explicit CompressedBatchProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kLookupInnersFieldNumber = 2,
  };
  // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::ics23::v1::CompressedBatchEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::CompressedBatchEntry >*
      mutable_entries();
  private:
  const ::cosmos::ics23::v1::CompressedBatchEntry& _internal_entries(int index) const;
  ::cosmos::ics23::v1::CompressedBatchEntry* _internal_add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>& _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::ics23::v1::CompressedBatchEntry& entries(int index) const;
  ::cosmos::ics23::v1::CompressedBatchEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::CompressedBatchEntry >&
      entries() const;
  // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
  int lookup_inners_size() const;
  private:
  int _internal_lookup_inners_size() const;

  public:
  void clear_lookup_inners() ;
  ::cosmos::ics23::v1::InnerOp* mutable_lookup_inners(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >*
      mutable_lookup_inners();
  private:
  const ::cosmos::ics23::v1::InnerOp& _internal_lookup_inners(int index) const;
  ::cosmos::ics23::v1::InnerOp* _internal_add_lookup_inners();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& _internal_lookup_inners() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* _internal_mutable_lookup_inners();
  public:
  const ::cosmos::ics23::v1::InnerOp& lookup_inners(int index) const;
  ::cosmos::ics23::v1::InnerOp* add_lookup_inners();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >&
      lookup_inners() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedBatchProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::CompressedBatchEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp > lookup_inners_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class CompressedBatchEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedBatchEntry) */ {
 public:
  inline CompressedBatchEntry() : CompressedBatchEntry(nullptr) {}
  ~CompressedBatchEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedBatchEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedBatchEntry(const CompressedBatchEntry& from);
  CompressedBatchEntry(CompressedBatchEntry&& from) noexcept
    : CompressedBatchEntry() {
    *this = ::std::move(from);
  }

  inline CompressedBatchEntry& operator=(const CompressedBatchEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedBatchEntry& operator=(CompressedBatchEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedBatchEntry& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kExist = 1,
    kNonexist = 2,
    PROOF_NOT_SET = 0,
  };

  static inline const CompressedBatchEntry* internal_default_instance() {
    return reinterpret_cast<const CompressedBatchEntry*>(
               &_CompressedBatchEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CompressedBatchEntry& a, CompressedBatchEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedBatchEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedBatchEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedBatchEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedBatchEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedBatchEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedBatchEntry& from) {
    CompressedBatchEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedBatchEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.CompressedBatchEntry";
  }
  protected:
  explicit CompressedBatchEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExistFieldNumber = 1,
    kNonexistFieldNumber = 2,
  };
  // .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
  bool has_exist() const;
  private:
  bool _internal_has_exist() const;

  public:
  void clear_exist() ;
  const ::cosmos::ics23::v1::CompressedExistenceProof& exist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedExistenceProof* release_exist();
  ::cosmos::ics23::v1::CompressedExistenceProof* mutable_exist();
  void set_allocated_exist(::cosmos::ics23::v1::CompressedExistenceProof* exist);
  private:
  const ::cosmos::ics23::v1::CompressedExistenceProof& _internal_exist() const;
  ::cosmos::ics23::v1::CompressedExistenceProof* _internal_mutable_exist();
  public:
  void unsafe_arena_set_allocated_exist(
      ::cosmos::ics23::v1::CompressedExistenceProof* exist);
  ::cosmos::ics23::v1::CompressedExistenceProof* unsafe_arena_release_exist();
  // .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
  bool has_nonexist() const;
  private:
  bool _internal_has_nonexist() const;

  public:
  void clear_nonexist() ;
  const ::cosmos::ics23::v1::CompressedNonExistenceProof& nonexist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedNonExistenceProof* release_nonexist();
  ::cosmos::ics23::v1::CompressedNonExistenceProof* mutable_nonexist();
  void set_allocated_nonexist(::cosmos::ics23::v1::CompressedNonExistenceProof* nonexist);
  private:
  const ::cosmos::ics23::v1::CompressedNonExistenceProof& _internal_nonexist() const;
  ::cosmos::ics23::v1::CompressedNonExistenceProof* _internal_mutable_nonexist();
  public:
  void unsafe_arena_set_allocated_nonexist(
      ::cosmos::ics23::v1::CompressedNonExistenceProof* nonexist);
  ::cosmos::ics23::v1::CompressedNonExistenceProof* unsafe_arena_release_nonexist();
  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedBatchEntry)
 private:
  class _Internal;
  void set_has_exist();
  void set_has_nonexist();

  inline bool has_proof() const;
  inline void clear_has_proof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cosmos::ics23::v1::CompressedExistenceProof* exist_;
      ::cosmos::ics23::v1::CompressedNonExistenceProof* nonexist_;
    } proof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class CompressedExistenceProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedExistenceProof) */ {
 public:
  inline CompressedExistenceProof() : CompressedExistenceProof(nullptr) {}
  ~CompressedExistenceProof() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedExistenceProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedExistenceProof(const CompressedExistenceProof& from);
  CompressedExistenceProof(CompressedExistenceProof&& from) noexcept
    : CompressedExistenceProof() {
    *this = ::std::move(from);
  }

  inline CompressedExistenceProof& operator=(const CompressedExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedExistenceProof& operator=(CompressedExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedExistenceProof* internal_default_instance() {
    return reinterpret_cast<const CompressedExistenceProof*>(
               &_CompressedExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CompressedExistenceProof& a, CompressedExistenceProof& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedExistenceProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedExistenceProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedExistenceProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedExistenceProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedExistenceProof& from) {
    CompressedExistenceProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedExistenceProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.CompressedExistenceProof";
  }
  protected:
  explicit CompressedExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 4,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kLeafFieldNumber = 3,
  };
  // repeated int32 path = 4 [json_name = "path"];
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::int32_t path(int index) const;
  void set_path(int index, ::int32_t value);
  void add_path(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_path();

  private:
  ::int32_t _internal_path(int index) const;
  void _internal_add_path(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_path();

  public:
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  bool has_leaf() const;
  void clear_leaf() ;
  const ::cosmos::ics23::v1::LeafOp& leaf() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::LeafOp* release_leaf();
  ::cosmos::ics23::v1::LeafOp* mutable_leaf();
  void set_allocated_leaf(::cosmos::ics23::v1::LeafOp* leaf);
  private:
  const ::cosmos::ics23::v1::LeafOp& _internal_leaf() const;
  ::cosmos::ics23::v1::LeafOp* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::cosmos::ics23::v1::LeafOp* leaf);
  ::cosmos::ics23::v1::LeafOp* unsafe_arena_release_leaf();
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedExistenceProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _path_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::cosmos::ics23::v1::LeafOp* leaf_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};// -------------------------------------------------------------------

class CompressedNonExistenceProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedNonExistenceProof) */ {
 public:
  inline CompressedNonExistenceProof() : CompressedNonExistenceProof(nullptr) {}
  ~CompressedNonExistenceProof() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedNonExistenceProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedNonExistenceProof(const CompressedNonExistenceProof& from);
  CompressedNonExistenceProof(CompressedNonExistenceProof&& from) noexcept
    : CompressedNonExistenceProof() {
    *this = ::std::move(from);
  }

  inline CompressedNonExistenceProof& operator=(const CompressedNonExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedNonExistenceProof& operator=(CompressedNonExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedNonExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedNonExistenceProof* internal_default_instance() {
    return reinterpret_cast<const CompressedNonExistenceProof*>(
               &_CompressedNonExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CompressedNonExistenceProof& a, CompressedNonExistenceProof& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedNonExistenceProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedNonExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedNonExistenceProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedNonExistenceProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedNonExistenceProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedNonExistenceProof& from) {
    CompressedNonExistenceProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedNonExistenceProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.ics23.v1.CompressedNonExistenceProof";
  }
  protected:
  explicit CompressedNonExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
  bool has_left() const;
  void clear_left() ;
  const ::cosmos::ics23::v1::CompressedExistenceProof& left() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedExistenceProof* release_left();
  ::cosmos::ics23::v1::CompressedExistenceProof* mutable_left();
  void set_allocated_left(::cosmos::ics23::v1::CompressedExistenceProof* left);
  private:
  const ::cosmos::ics23::v1::CompressedExistenceProof& _internal_left() const;
  ::cosmos::ics23::v1::CompressedExistenceProof* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::cosmos::ics23::v1::CompressedExistenceProof* left);
  ::cosmos::ics23::v1::CompressedExistenceProof* unsafe_arena_release_left();
  // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
  bool has_right() const;
  void clear_right() ;
  const ::cosmos::ics23::v1::CompressedExistenceProof& right() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedExistenceProof* release_right();
  ::cosmos::ics23::v1::CompressedExistenceProof* mutable_right();
  void set_allocated_right(::cosmos::ics23::v1::CompressedExistenceProof* right);
  private:
  const ::cosmos::ics23::v1::CompressedExistenceProof& _internal_right() const;
  ::cosmos::ics23::v1::CompressedExistenceProof* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::cosmos::ics23::v1::CompressedExistenceProof* right);
  ::cosmos::ics23::v1::CompressedExistenceProof* unsafe_arena_release_right();
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedNonExistenceProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::cosmos::ics23::v1::CompressedExistenceProof* left_;
    ::cosmos::ics23::v1::CompressedExistenceProof* right_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ExistenceProof

// bytes key = 1 [json_name = "key"];
inline void ExistenceProof::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ExistenceProof::key() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ExistenceProof.key)
}
inline std::string* ExistenceProof::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.key)
  return _s;
}
inline const std::string& ExistenceProof::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ExistenceProof::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ExistenceProof::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* ExistenceProof::release_key() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ExistenceProof.key)
  return _impl_.key_.Release();
}
inline void ExistenceProof::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ExistenceProof.key)
}

// bytes value = 2 [json_name = "value"];
inline void ExistenceProof::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ExistenceProof::value() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExistenceProof::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ExistenceProof.value)
}
inline std::string* ExistenceProof::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.value)
  return _s;
}
inline const std::string& ExistenceProof::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ExistenceProof::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ExistenceProof::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* ExistenceProof::release_value() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ExistenceProof.value)
  return _impl_.value_.Release();
}
inline void ExistenceProof::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ExistenceProof.value)
}

// .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
inline bool ExistenceProof::has_leaf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.leaf_ != nullptr);
  return value;
}
inline void ExistenceProof::clear_leaf() {
  if (_impl_.leaf_ != nullptr) _impl_.leaf_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::LeafOp& ExistenceProof::_internal_leaf() const {
  const ::cosmos::ics23::v1::LeafOp* p = _impl_.leaf_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::LeafOp&>(
      ::cosmos::ics23::v1::_LeafOp_default_instance_);
}
inline const ::cosmos::ics23::v1::LeafOp& ExistenceProof::leaf() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.leaf)
  return _internal_leaf();
}
inline void ExistenceProof::unsafe_arena_set_allocated_leaf(
    ::cosmos::ics23::v1::LeafOp* leaf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leaf_);
  }
  _impl_.leaf_ = leaf;
  if (leaf) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.ExistenceProof.leaf)
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::release_leaf() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ExistenceProof.leaf)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::_internal_mutable_leaf() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.leaf_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::LeafOp>(GetArenaForAllocation());
    _impl_.leaf_ = p;
  }
  return _impl_.leaf_;
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::mutable_leaf() {
  ::cosmos::ics23::v1::LeafOp* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.leaf)
  return _msg;
}
inline void ExistenceProof::set_allocated_leaf(::cosmos::ics23::v1::LeafOp* leaf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.leaf_;
  }
  if (leaf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(leaf);
    if (message_arena != submessage_arena) {
      leaf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leaf, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leaf_ = leaf;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ExistenceProof.leaf)
}

// repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
inline int ExistenceProof::_internal_path_size() const {
  return _impl_.path_.size();
}
inline int ExistenceProof::path_size() const {
  return _internal_path_size();
}
inline void ExistenceProof::clear_path() {
  _internal_mutable_path()->Clear();
}
inline ::cosmos::ics23::v1::InnerOp* ExistenceProof::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >*
ExistenceProof::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.ExistenceProof.path)
  return _internal_mutable_path();
}
inline const ::cosmos::ics23::v1::InnerOp& ExistenceProof::_internal_path(int index) const {
  return _internal_path().Get(index);
}
inline const ::cosmos::ics23::v1::InnerOp& ExistenceProof::path(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.path)
  return _internal_path(index);
}
inline ::cosmos::ics23::v1::InnerOp* ExistenceProof::_internal_add_path() {
  return _internal_mutable_path()->Add();
}
inline ::cosmos::ics23::v1::InnerOp* ExistenceProof::add_path() {
  ::cosmos::ics23::v1::InnerOp* _add = _internal_add_path();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.ExistenceProof.path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >&
ExistenceProof::path() const {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.ExistenceProof.path)
  return _internal_path();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>&
ExistenceProof::_internal_path() const {
  return _impl_.path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>*
ExistenceProof::_internal_mutable_path() {
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// NonExistenceProof

// bytes key = 1 [json_name = "key"];
inline void NonExistenceProof::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& NonExistenceProof::key() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.NonExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NonExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.NonExistenceProof.key)
}
inline std::string* NonExistenceProof::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.NonExistenceProof.key)
  return _s;
}
inline const std::string& NonExistenceProof::_internal_key() const {
  return _impl_.key_.Get();
}
inline void NonExistenceProof::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* NonExistenceProof::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* NonExistenceProof::release_key() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.NonExistenceProof.key)
  return _impl_.key_.Release();
}
inline void NonExistenceProof::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.NonExistenceProof.key)
}

// .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
inline bool NonExistenceProof::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void NonExistenceProof::clear_left() {
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::_internal_left() const {
  const ::cosmos::ics23::v1::ExistenceProof* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::ExistenceProof&>(
      ::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::left() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.NonExistenceProof.left)
  return _internal_left();
}
inline void NonExistenceProof::unsafe_arena_set_allocated_left(
    ::cosmos::ics23::v1::ExistenceProof* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.NonExistenceProof.left)
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::release_left() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.NonExistenceProof.left)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::_internal_mutable_left() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::ExistenceProof>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::mutable_left() {
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.NonExistenceProof.left)
  return _msg;
}
inline void NonExistenceProof::set_allocated_left(::cosmos::ics23::v1::ExistenceProof* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.NonExistenceProof.left)
}

// .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
inline bool NonExistenceProof::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void NonExistenceProof::clear_right() {
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::_internal_right() const {
  const ::cosmos::ics23::v1::ExistenceProof* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::ExistenceProof&>(
      ::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::right() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.NonExistenceProof.right)
  return _internal_right();
}
inline void NonExistenceProof::unsafe_arena_set_allocated_right(
    ::cosmos::ics23::v1::ExistenceProof* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = right;
  if (right) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.NonExistenceProof.right)
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::release_right() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.NonExistenceProof.right)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::_internal_mutable_right() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::ExistenceProof>(GetArenaForAllocation());
    _impl_.right_ = p;
  }
  return _impl_.right_;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::mutable_right() {
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.NonExistenceProof.right)
  return _msg;
}
inline void NonExistenceProof::set_allocated_right(::cosmos::ics23::v1::ExistenceProof* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.right_ = right;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.NonExistenceProof.right)
}

// -------------------------------------------------------------------

// CommitmentProof

// .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
inline bool CommitmentProof::has_exist() const {
  return proof_case() == kExist;
}
inline bool CommitmentProof::_internal_has_exist() const {
  return proof_case() == kExist;
}
inline void CommitmentProof::set_has_exist() {
  _impl_._oneof_case_[0] = kExist;
}
inline void CommitmentProof::clear_exist() {
  if (proof_case() == kExist) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.exist_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::release_exist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.proof_.exist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::ExistenceProof& CommitmentProof::_internal_exist() const {
  return proof_case() == kExist
      ? *_impl_.proof_.exist_
      : reinterpret_cast<::cosmos::ics23::v1::ExistenceProof&>(::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& CommitmentProof::exist() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.exist)
  return _internal_exist();
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::unsafe_arena_release_exist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.proof_.exist_;
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist) {
  clear_proof();
  if (exist) {
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.exist)
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::_internal_mutable_exist() {
  if (proof_case() != kExist) {
    clear_proof();
    set_has_exist();
    _impl_.proof_.exist_ = CreateMaybeMessage< ::cosmos::ics23::v1::ExistenceProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.exist_;
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::mutable_exist() {
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_exist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.exist)
  return _msg;
}

// .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
inline bool CommitmentProof::has_nonexist() const {
  return proof_case() == kNonexist;
}
inline bool CommitmentProof::_internal_has_nonexist() const {
  return proof_case() == kNonexist;
}
inline void CommitmentProof::set_has_nonexist() {
  _impl_._oneof_case_[0] = kNonexist;
}
inline void CommitmentProof::clear_nonexist() {
  if (proof_case() == kNonexist) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.nonexist_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::release_nonexist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    ::cosmos::ics23::v1::NonExistenceProof* temp = _impl_.proof_.nonexist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::NonExistenceProof& CommitmentProof::_internal_nonexist() const {
  return proof_case() == kNonexist
      ? *_impl_.proof_.nonexist_
      : reinterpret_cast<::cosmos::ics23::v1::NonExistenceProof&>(::cosmos::ics23::v1::_NonExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::NonExistenceProof& CommitmentProof::nonexist() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.nonexist)
  return _internal_nonexist();
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::unsafe_arena_release_nonexist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    ::cosmos::ics23::v1::NonExistenceProof* temp = _impl_.proof_.nonexist_;
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist) {
  clear_proof();
  if (nonexist) {
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.nonexist)
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::_internal_mutable_nonexist() {
  if (proof_case() != kNonexist) {
    clear_proof();
    set_has_nonexist();
    _impl_.proof_.nonexist_ = CreateMaybeMessage< ::cosmos::ics23::v1::NonExistenceProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.nonexist_;
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::mutable_nonexist() {
  ::cosmos::ics23::v1::NonExistenceProof* _msg = _internal_mutable_nonexist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.nonexist)
  return _msg;
}

// .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
inline bool CommitmentProof::has_batch() const {
  return proof_case() == kBatch;
}
inline bool CommitmentProof::_internal_has_batch() const {
  return proof_case() == kBatch;
}
inline void CommitmentProof::set_has_batch() {
  _impl_._oneof_case_[0] = kBatch;
}
inline void CommitmentProof::clear_batch() {
  if (proof_case() == kBatch) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.batch_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::release_batch() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.batch)
  if (proof_case() == kBatch) {
    clear_has_proof();
    ::cosmos::ics23::v1::BatchProof* temp = _impl_.proof_.batch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::BatchProof& CommitmentProof::_internal_batch() const {
  return proof_case() == kBatch
      ? *_impl_.proof_.batch_
      : reinterpret_cast<::cosmos::ics23::v1::BatchProof&>(::cosmos::ics23::v1::_BatchProof_default_instance_);
}
inline const ::cosmos::ics23::v1::BatchProof& CommitmentProof::batch() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.batch)
  return _internal_batch();
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::unsafe_arena_release_batch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.batch)
  if (proof_case() == kBatch) {
    clear_has_proof();
    ::cosmos::ics23::v1::BatchProof* temp = _impl_.proof_.batch_;
    _impl_.proof_.batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_batch(::cosmos::ics23::v1::BatchProof* batch) {
  clear_proof();
  if (batch) {
    set_has_batch();
    _impl_.proof_.batch_ = batch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.batch)
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::_internal_mutable_batch() {
  if (proof_case() != kBatch) {
    clear_proof();
    set_has_batch();
    _impl_.proof_.batch_ = CreateMaybeMessage< ::cosmos::ics23::v1::BatchProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.batch_;
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::mutable_batch() {
  ::cosmos::ics23::v1::BatchProof* _msg = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.batch)
  return _msg;
}

// .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
inline bool CommitmentProof::has_compressed() const {
  return proof_case() == kCompressed;
}
inline bool CommitmentProof::_internal_has_compressed() const {
  return proof_case() == kCompressed;
}
inline void CommitmentProof::set_has_compressed() {
  _impl_._oneof_case_[0] = kCompressed;
}
inline void CommitmentProof::clear_compressed() {
  if (proof_case() == kCompressed) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.compressed_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::release_compressed() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.compressed)
  if (proof_case() == kCompressed) {
    clear_has_proof();
    ::cosmos::ics23::v1::CompressedBatchProof* temp = _impl_.proof_.compressed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.compressed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::CompressedBatchProof& CommitmentProof::_internal_compressed() const {
  return proof_case() == kCompressed
      ? *_impl_.proof_.compressed_
      : reinterpret_cast<::cosmos::ics23::v1::CompressedBatchProof&>(::cosmos::ics23::v1::_CompressedBatchProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedBatchProof& CommitmentProof::compressed() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.compressed)
  return _internal_compressed();
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::unsafe_arena_release_compressed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.compressed)
  if (proof_case() == kCompressed) {
    clear_has_proof();
    ::cosmos::ics23::v1::CompressedBatchProof* temp = _impl_.proof_.compressed_;
    _impl_.proof_.compressed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_compressed(::cosmos::ics23::v1::CompressedBatchProof* compressed) {
  clear_proof();
  if (compressed) {
    set_has_compressed();
    _impl_.proof_.compressed_ = compressed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.compressed)
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::_internal_mutable_compressed() {
  if (proof_case() != kCompressed) {
    clear_proof();
    set_has_compressed();
    _impl_.proof_.compressed_ = CreateMaybeMessage< ::cosmos::ics23::v1::CompressedBatchProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.compressed_;
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::mutable_compressed() {
  ::cosmos::ics23::v1::CompressedBatchProof* _msg = _internal_mutable_compressed();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.compressed)
  return _msg;
}

inline bool CommitmentProof::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void CommitmentProof::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline CommitmentProof::ProofCase CommitmentProof::proof_case() const {
  return CommitmentProof::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LeafOp

// .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
inline void LeafOp::clear_hash() {
  _impl_.hash_ = 0;
}
inline ::cosmos::ics23::v1::HashOp LeafOp::hash() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.hash)
  return _internal_hash();
}
inline void LeafOp::set_hash(::cosmos::ics23::v1::HashOp value) {
   _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.hash)
}
inline ::cosmos::ics23::v1::HashOp LeafOp::_internal_hash() const {
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.hash_);
}
inline void LeafOp::_internal_set_hash(::cosmos::ics23::v1::HashOp value) {
  ;
  _impl_.hash_ = value;
}

// .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
inline void LeafOp::clear_prehash_key() {
  _impl_.prehash_key_ = 0;
}
inline ::cosmos::ics23::v1::HashOp LeafOp::prehash_key() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.prehash_key)
  return _internal_prehash_key();
}
inline void LeafOp::set_prehash_key(::cosmos::ics23::v1::HashOp value) {
   _internal_set_prehash_key(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.prehash_key)
}
inline ::cosmos::ics23::v1::HashOp LeafOp::_internal_prehash_key() const {
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.prehash_key_);
}
inline void LeafOp::_internal_set_prehash_key(::cosmos::ics23::v1::HashOp value) {
  ;
  _impl_.prehash_key_ = value;
}

// .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
inline void LeafOp::clear_prehash_value() {
  _impl_.prehash_value_ = 0;
}
inline ::cosmos::ics23::v1::HashOp LeafOp::prehash_value() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.prehash_value)
  return _internal_prehash_value();
}
inline void LeafOp::set_prehash_value(::cosmos::ics23::v1::HashOp value) {
   _internal_set_prehash_value(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.prehash_value)
}
inline ::cosmos::ics23::v1::HashOp LeafOp::_internal_prehash_value() const {
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.prehash_value_);
}
inline void LeafOp::_internal_set_prehash_value(::cosmos::ics23::v1::HashOp value) {
  ;
  _impl_.prehash_value_ = value;
}

// .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
inline void LeafOp::clear_length() {
  _impl_.length_ = 0;
}
inline ::cosmos::ics23::v1::LengthOp LeafOp::length() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.length)
  return _internal_length();
}
inline void LeafOp::set_length(::cosmos::ics23::v1::LengthOp value) {
   _internal_set_length(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.length)
}
inline ::cosmos::ics23::v1::LengthOp LeafOp::_internal_length() const {
  return static_cast<::cosmos::ics23::v1::LengthOp>(_impl_.length_);
}
inline void LeafOp::_internal_set_length(::cosmos::ics23::v1::LengthOp value) {
  ;
  _impl_.length_ = value;
}

// bytes prefix = 5 [json_name = "prefix"];
inline void LeafOp::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& LeafOp::prefix() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LeafOp::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.prefix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.prefix)
}
inline std::string* LeafOp::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.LeafOp.prefix)
  return _s;
}
inline const std::string& LeafOp::_internal_prefix() const {
  return _impl_.prefix_.Get();
}
inline void LeafOp::_internal_set_prefix(const std::string& value) {
  ;


  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* LeafOp::_internal_mutable_prefix() {
  ;
  return _impl_.prefix_.Mutable( GetArenaForAllocation());
}
inline std::string* LeafOp::release_prefix() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.LeafOp.prefix)
  return _impl_.prefix_.Release();
}
inline void LeafOp::set_allocated_prefix(std::string* value) {
  _impl_.prefix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prefix_.IsDefault()) {
          _impl_.prefix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.LeafOp.prefix)
}

// -------------------------------------------------------------------

// InnerOp

// .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
inline void InnerOp::clear_hash() {
  _impl_.hash_ = 0;
}
inline ::cosmos::ics23::v1::HashOp InnerOp::hash() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerOp.hash)
  return _internal_hash();
}
inline void InnerOp::set_hash(::cosmos::ics23::v1::HashOp value) {
   _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerOp.hash)
}
inline ::cosmos::ics23::v1::HashOp InnerOp::_internal_hash() const {
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.hash_);
}
inline void InnerOp::_internal_set_hash(::cosmos::ics23::v1::HashOp value) {
  ;
  _impl_.hash_ = value;
}

// bytes prefix = 2 [json_name = "prefix"];
inline void InnerOp::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& InnerOp::prefix() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerOp.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InnerOp::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.prefix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerOp.prefix)
}
inline std::string* InnerOp::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.InnerOp.prefix)
  return _s;
}
inline const std::string& InnerOp::_internal_prefix() const {
  return _impl_.prefix_.Get();
}
inline void InnerOp::_internal_set_prefix(const std::string& value) {
  ;


  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* InnerOp::_internal_mutable_prefix() {
  ;
  return _impl_.prefix_.Mutable( GetArenaForAllocation());
}
inline std::string* InnerOp::release_prefix() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.InnerOp.prefix)
  return _impl_.prefix_.Release();
}
inline void InnerOp::set_allocated_prefix(std::string* value) {
  _impl_.prefix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prefix_.IsDefault()) {
          _impl_.prefix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.InnerOp.prefix)
}

// bytes suffix = 3 [json_name = "suffix"];
inline void InnerOp::clear_suffix() {
  _impl_.suffix_.ClearToEmpty();
}
inline const std::string& InnerOp::suffix() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerOp.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InnerOp::set_suffix(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.suffix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerOp.suffix)
}
inline std::string* InnerOp::mutable_suffix() {
  std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.InnerOp.suffix)
  return _s;
}
inline const std::string& InnerOp::_internal_suffix() const {
  return _impl_.suffix_.Get();
}
inline void InnerOp::_internal_set_suffix(const std::string& value) {
  ;


  _impl_.suffix_.Set(value, GetArenaForAllocation());
}
inline std::string* InnerOp::_internal_mutable_suffix() {
  ;
  return _impl_.suffix_.Mutable( GetArenaForAllocation());
}
inline std::string* InnerOp::release_suffix() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.InnerOp.suffix)
  return _impl_.suffix_.Release();
}
inline void InnerOp::set_allocated_suffix(std::string* value) {
  _impl_.suffix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.suffix_.IsDefault()) {
          _impl_.suffix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.InnerOp.suffix)
}

// -------------------------------------------------------------------

// ProofSpec

// .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
inline bool ProofSpec::has_leaf_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.leaf_spec_ != nullptr);
  return value;
}
inline void ProofSpec::clear_leaf_spec() {
  if (_impl_.leaf_spec_ != nullptr) _impl_.leaf_spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::LeafOp& ProofSpec::_internal_leaf_spec() const {
  const ::cosmos::ics23::v1::LeafOp* p = _impl_.leaf_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::LeafOp&>(
      ::cosmos::ics23::v1::_LeafOp_default_instance_);
}
inline const ::cosmos::ics23::v1::LeafOp& ProofSpec::leaf_spec() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.leaf_spec)
  return _internal_leaf_spec();
}
inline void ProofSpec::unsafe_arena_set_allocated_leaf_spec(
    ::cosmos::ics23::v1::LeafOp* leaf_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leaf_spec_);
  }
  _impl_.leaf_spec_ = leaf_spec;
  if (leaf_spec) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.ProofSpec.leaf_spec)
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::release_leaf_spec() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_spec_;
  _impl_.leaf_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::unsafe_arena_release_leaf_spec() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ProofSpec.leaf_spec)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_spec_;
  _impl_.leaf_spec_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::_internal_mutable_leaf_spec() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.leaf_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::LeafOp>(GetArenaForAllocation());
    _impl_.leaf_spec_ = p;
  }
  return _impl_.leaf_spec_;
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::mutable_leaf_spec() {
  ::cosmos::ics23::v1::LeafOp* _msg = _internal_mutable_leaf_spec();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ProofSpec.leaf_spec)
  return _msg;
}
inline void ProofSpec::set_allocated_leaf_spec(::cosmos::ics23::v1::LeafOp* leaf_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.leaf_spec_;
  }
  if (leaf_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(leaf_spec);
    if (message_arena != submessage_arena) {
      leaf_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leaf_spec, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leaf_spec_ = leaf_spec;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ProofSpec.leaf_spec)
}

// .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
inline bool ProofSpec::has_inner_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inner_spec_ != nullptr);
  return value;
}
inline void ProofSpec::clear_inner_spec() {
  if (_impl_.inner_spec_ != nullptr) _impl_.inner_spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::ics23::v1::InnerSpec& ProofSpec::_internal_inner_spec() const {
  const ::cosmos::ics23::v1::InnerSpec* p = _impl_.inner_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::InnerSpec&>(
      ::cosmos::ics23::v1::_InnerSpec_default_instance_);
}
inline const ::cosmos::ics23::v1::InnerSpec& ProofSpec::inner_spec() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.inner_spec)
  return _internal_inner_spec();
}
inline void ProofSpec::unsafe_arena_set_allocated_inner_spec(
    ::cosmos::ics23::v1::InnerSpec* inner_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inner_spec_);
  }
  _impl_.inner_spec_ = inner_spec;
  if (inner_spec) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.ProofSpec.inner_spec)
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::release_inner_spec() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::InnerSpec* temp = _impl_.inner_spec_;
  _impl_.inner_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::unsafe_arena_release_inner_spec() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ProofSpec.inner_spec)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::InnerSpec* temp = _impl_.inner_spec_;
  _impl_.inner_spec_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::_internal_mutable_inner_spec() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.inner_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::InnerSpec>(GetArenaForAllocation());
    _impl_.inner_spec_ = p;
  }
  return _impl_.inner_spec_;
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::mutable_inner_spec() {
  ::cosmos::ics23::v1::InnerSpec* _msg = _internal_mutable_inner_spec();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ProofSpec.inner_spec)
  return _msg;
}
inline void ProofSpec::set_allocated_inner_spec(::cosmos::ics23::v1::InnerSpec* inner_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inner_spec_;
  }
  if (inner_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inner_spec);
    if (message_arena != submessage_arena) {
      inner_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inner_spec, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.inner_spec_ = inner_spec;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ProofSpec.inner_spec)
}

// int32 max_depth = 3 [json_name = "maxDepth"];
inline void ProofSpec::clear_max_depth() {
  _impl_.max_depth_ = 0;
}
inline ::int32_t ProofSpec::max_depth() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.max_depth)
  return _internal_max_depth();
}
inline void ProofSpec::set_max_depth(::int32_t value) {
  _internal_set_max_depth(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ProofSpec.max_depth)
}
inline ::int32_t ProofSpec::_internal_max_depth() const {
  return _impl_.max_depth_;
}
inline void ProofSpec::_internal_set_max_depth(::int32_t value) {
  ;
  _impl_.max_depth_ = value;
}

// int32 min_depth = 4 [json_name = "minDepth"];
inline void ProofSpec::clear_min_depth() {
  _impl_.min_depth_ = 0;
}
inline ::int32_t ProofSpec::min_depth() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.min_depth)
  return _internal_min_depth();
}
inline void ProofSpec::set_min_depth(::int32_t value) {
  _internal_set_min_depth(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ProofSpec.min_depth)
}
inline ::int32_t ProofSpec::_internal_min_depth() const {
  return _impl_.min_depth_;
}
inline void ProofSpec::_internal_set_min_depth(::int32_t value) {
  ;
  _impl_.min_depth_ = value;
}

// bool prehash_key_before_comparison = 5 [json_name = "prehashKeyBeforeComparison"];
inline void ProofSpec::clear_prehash_key_before_comparison() {
  _impl_.prehash_key_before_comparison_ = false;
}
inline bool ProofSpec::prehash_key_before_comparison() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.prehash_key_before_comparison)
  return _internal_prehash_key_before_comparison();
}
inline void ProofSpec::set_prehash_key_before_comparison(bool value) {
  _internal_set_prehash_key_before_comparison(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ProofSpec.prehash_key_before_comparison)
}
inline bool ProofSpec::_internal_prehash_key_before_comparison() const {
  return _impl_.prehash_key_before_comparison_;
}
inline void ProofSpec::_internal_set_prehash_key_before_comparison(bool value) {
  ;
  _impl_.prehash_key_before_comparison_ = value;
}

// -------------------------------------------------------------------

// InnerSpec

// repeated int32 child_order = 1 [json_name = "childOrder"];
inline int InnerSpec::_internal_child_order_size() const {
  return _impl_.child_order_.size();
}
inline int InnerSpec::child_order_size() const {
  return _internal_child_order_size();
}
inline void InnerSpec::clear_child_order() {
  _internal_mutable_child_order()->Clear();
}
inline ::int32_t InnerSpec::child_order(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.child_order)
  return _internal_child_order(index);
}
inline void InnerSpec::set_child_order(int index, ::int32_t value) {
  _internal_mutable_child_order()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.child_order)
}
inline void InnerSpec::add_child_order(::int32_t value) {
  _internal_add_child_order(value);
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.InnerSpec.child_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& InnerSpec::child_order() const {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.InnerSpec.child_order)
  return _internal_child_order();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* InnerSpec::mutable_child_order() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.InnerSpec.child_order)
  return _internal_mutable_child_order();
}

inline ::int32_t InnerSpec::_internal_child_order(int index) const {
  return _internal_child_order().Get(index);
}
inline void InnerSpec::_internal_add_child_order(::int32_t value) {
  _internal_mutable_child_order()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& InnerSpec::_internal_child_order() const {
  return _impl_.child_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* InnerSpec::_internal_mutable_child_order() {
  return &_impl_.child_order_;
}

// int32 child_size = 2 [json_name = "childSize"];
inline void InnerSpec::clear_child_size() {
  _impl_.child_size_ = 0;
}
inline ::int32_t InnerSpec::child_size() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.child_size)
  return _internal_child_size();
}
inline void InnerSpec::set_child_size(::int32_t value) {
  _internal_set_child_size(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.child_size)
}
inline ::int32_t InnerSpec::_internal_child_size() const {
  return _impl_.child_size_;
}
inline void InnerSpec::_internal_set_child_size(::int32_t value) {
  ;
  _impl_.child_size_ = value;
}

// int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
inline void InnerSpec::clear_min_prefix_length() {
  _impl_.min_prefix_length_ = 0;
}
inline ::int32_t InnerSpec::min_prefix_length() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.min_prefix_length)
  return _internal_min_prefix_length();
}
inline void InnerSpec::set_min_prefix_length(::int32_t value) {
  _internal_set_min_prefix_length(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.min_prefix_length)
}
inline ::int32_t InnerSpec::_internal_min_prefix_length() const {
  return _impl_.min_prefix_length_;
}
inline void InnerSpec::_internal_set_min_prefix_length(::int32_t value) {
  ;
  _impl_.min_prefix_length_ = value;
}

// int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
inline void InnerSpec::clear_max_prefix_length() {
  _impl_.max_prefix_length_ = 0;
}
inline ::int32_t InnerSpec::max_prefix_length() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.max_prefix_length)
  return _internal_max_prefix_length();
}
inline void InnerSpec::set_max_prefix_length(::int32_t value) {
  _internal_set_max_prefix_length(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.max_prefix_length)
}
inline ::int32_t InnerSpec::_internal_max_prefix_length() const {
  return _impl_.max_prefix_length_;
}
inline void InnerSpec::_internal_set_max_prefix_length(::int32_t value) {
  ;
  _impl_.max_prefix_length_ = value;
}

// bytes empty_child = 5 [json_name = "emptyChild"];
inline void InnerSpec::clear_empty_child() {
  _impl_.empty_child_.ClearToEmpty();
}
inline const std::string& InnerSpec::empty_child() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.empty_child)
  return _internal_empty_child();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InnerSpec::set_empty_child(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.empty_child_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.empty_child)
}
inline std::string* InnerSpec::mutable_empty_child() {
  std::string* _s = _internal_mutable_empty_child();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.InnerSpec.empty_child)
  return _s;
}
inline const std::string& InnerSpec::_internal_empty_child() const {
  return _impl_.empty_child_.Get();
}
inline void InnerSpec::_internal_set_empty_child(const std::string& value) {
  ;


  _impl_.empty_child_.Set(value, GetArenaForAllocation());
}
inline std::string* InnerSpec::_internal_mutable_empty_child() {
  ;
  return _impl_.empty_child_.Mutable( GetArenaForAllocation());
}
inline std::string* InnerSpec::release_empty_child() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.InnerSpec.empty_child)
  return _impl_.empty_child_.Release();
}
inline void InnerSpec::set_allocated_empty_child(std::string* value) {
  _impl_.empty_child_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.empty_child_.IsDefault()) {
          _impl_.empty_child_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.InnerSpec.empty_child)
}

// .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
inline void InnerSpec::clear_hash() {
  _impl_.hash_ = 0;
}
inline ::cosmos::ics23::v1::HashOp InnerSpec::hash() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.hash)
  return _internal_hash();
}
inline void InnerSpec::set_hash(::cosmos::ics23::v1::HashOp value) {
   _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.hash)
}
inline ::cosmos::ics23::v1::HashOp InnerSpec::_internal_hash() const {
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.hash_);
}
inline void InnerSpec::_internal_set_hash(::cosmos::ics23::v1::HashOp value) {
  ;
  _impl_.hash_ = value;
}

// -------------------------------------------------------------------

// BatchProof

// repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
inline int BatchProof::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int BatchProof::entries_size() const {
  return _internal_entries_size();
}
inline void BatchProof::clear_entries() {
  _internal_mutable_entries()->Clear();
}
inline ::cosmos::ics23::v1::BatchEntry* BatchProof::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.BatchProof.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::BatchEntry >*
BatchProof::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.BatchProof.entries)
  return _internal_mutable_entries();
}
inline const ::cosmos::ics23::v1::BatchEntry& BatchProof::_internal_entries(int index) const {
  return _internal_entries().Get(index);
}
inline const ::cosmos::ics23::v1::BatchEntry& BatchProof::entries(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.BatchProof.entries)
  return _internal_entries(index);
}
inline ::cosmos::ics23::v1::BatchEntry* BatchProof::_internal_add_entries() {
  return _internal_mutable_entries()->Add();
}
inline ::cosmos::ics23::v1::BatchEntry* BatchProof::add_entries() {
  ::cosmos::ics23::v1::BatchEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.BatchProof.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::BatchEntry >&
BatchProof::entries() const {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.BatchProof.entries)
  return _internal_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>&
BatchProof::_internal_entries() const {
  return _impl_.entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>*
BatchProof::_internal_mutable_entries() {
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// BatchEntry

// .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
inline bool BatchEntry::has_exist() const {
  return proof_case() == kExist;
}
inline bool BatchEntry::_internal_has_exist() const {
  return proof_case() == kExist;
}
inline void BatchEntry::set_has_exist() {
  _impl_._oneof_case_[0] = kExist;
}
inline void BatchEntry::clear_exist() {
  if (proof_case() == kExist) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.exist_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::release_exist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.BatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.proof_.exist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::ExistenceProof& BatchEntry::_internal_exist() const {
  return proof_case() == kExist
      ? *_impl_.proof_.exist_
      : reinterpret_cast<::cosmos::ics23::v1::ExistenceProof&>(::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& BatchEntry::exist() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.BatchEntry.exist)
  return _internal_exist();
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::unsafe_arena_release_exist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.BatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.proof_.exist_;
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchEntry::unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist) {
  clear_proof();
  if (exist) {
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.BatchEntry.exist)
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::_internal_mutable_exist() {
  if (proof_case() != kExist) {
    clear_proof();
    set_has_exist();
    _impl_.proof_.exist_ = CreateMaybeMessage< ::cosmos::ics23::v1::ExistenceProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.exist_;
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::mutable_exist() {
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_exist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.BatchEntry.exist)
  return _msg;
}

// .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
inline bool BatchEntry::has_nonexist() const {
  return proof_case() == kNonexist;
}
inline bool BatchEntry::_internal_has_nonexist() const {
  return proof_case() == kNonexist;
}
inline void BatchEntry::set_has_nonexist() {
  _impl_._oneof_case_[0] = kNonexist;
}
inline void BatchEntry::clear_nonexist() {
  if (proof_case() == kNonexist) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.nonexist_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::release_nonexist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.BatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    ::cosmos::ics23::v1::NonExistenceProof* temp = _impl_.proof_.nonexist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::NonExistenceProof& BatchEntry::_internal_nonexist() const {
  return proof_case() == kNonexist
      ? *_impl_.proof_.nonexist_
      : reinterpret_cast<::cosmos::ics23::v1::NonExistenceProof&>(::cosmos::ics23::v1::_NonExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::NonExistenceProof& BatchEntry::nonexist() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.BatchEntry.nonexist)
  return _internal_nonexist();
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::unsafe_arena_release_nonexist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.BatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    ::cosmos::ics23::v1::NonExistenceProof* temp = _impl_.proof_.nonexist_;
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchEntry::unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist) {
  clear_proof();
  if (nonexist) {
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.BatchEntry.nonexist)
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::_internal_mutable_nonexist() {
  if (proof_case() != kNonexist) {
    clear_proof();
    set_has_nonexist();
    _impl_.proof_.nonexist_ = CreateMaybeMessage< ::cosmos::ics23::v1::NonExistenceProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.nonexist_;
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::mutable_nonexist() {
  ::cosmos::ics23::v1::NonExistenceProof* _msg = _internal_mutable_nonexist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.BatchEntry.nonexist)
  return _msg;
}

inline bool BatchEntry::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void BatchEntry::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline BatchEntry::ProofCase BatchEntry::proof_case() const {
  return BatchEntry::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CompressedBatchProof

// repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
inline int CompressedBatchProof::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int CompressedBatchProof::entries_size() const {
  return _internal_entries_size();
}
inline void CompressedBatchProof::clear_entries() {
  _internal_mutable_entries()->Clear();
}
inline ::cosmos::ics23::v1::CompressedBatchEntry* CompressedBatchProof::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::CompressedBatchEntry >*
CompressedBatchProof::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _internal_mutable_entries();
}
inline const ::cosmos::ics23::v1::CompressedBatchEntry& CompressedBatchProof::_internal_entries(int index) const {
  return _internal_entries().Get(index);
}
inline const ::cosmos::ics23::v1::CompressedBatchEntry& CompressedBatchProof::entries(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _internal_entries(index);
}
inline ::cosmos::ics23::v1::CompressedBatchEntry* CompressedBatchProof::_internal_add_entries() {
  return _internal_mutable_entries()->Add();
}
inline ::cosmos::ics23::v1::CompressedBatchEntry* CompressedBatchProof::add_entries() {
  ::cosmos::ics23::v1::CompressedBatchEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::CompressedBatchEntry >&
CompressedBatchProof::entries() const {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _internal_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>&
CompressedBatchProof::_internal_entries() const {
  return _impl_.entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>*
CompressedBatchProof::_internal_mutable_entries() {
  return &_impl_.entries_;
}

// repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
inline int CompressedBatchProof::_internal_lookup_inners_size() const {
  return _impl_.lookup_inners_.size();
}
inline int CompressedBatchProof::lookup_inners_size() const {
  return _internal_lookup_inners_size();
}
inline void CompressedBatchProof::clear_lookup_inners() {
  _internal_mutable_lookup_inners()->Clear();
}
inline ::cosmos::ics23::v1::InnerOp* CompressedBatchProof::mutable_lookup_inners(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _internal_mutable_lookup_inners()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >*
CompressedBatchProof::mutable_lookup_inners() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _internal_mutable_lookup_inners();
}
inline const ::cosmos::ics23::v1::InnerOp& CompressedBatchProof::_internal_lookup_inners(int index) const {
  return _internal_lookup_inners().Get(index);
}
inline const ::cosmos::ics23::v1::InnerOp& CompressedBatchProof::lookup_inners(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _internal_lookup_inners(index);
}
inline ::cosmos::ics23::v1::InnerOp* CompressedBatchProof::_internal_add_lookup_inners() {
  return _internal_mutable_lookup_inners()->Add();
}
inline ::cosmos::ics23::v1::InnerOp* CompressedBatchProof::add_lookup_inners() {
  ::cosmos::ics23::v1::InnerOp* _add = _internal_add_lookup_inners();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp >&
CompressedBatchProof::lookup_inners() const {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _internal_lookup_inners();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>&
CompressedBatchProof::_internal_lookup_inners() const {
  return _impl_.lookup_inners_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>*
CompressedBatchProof::_internal_mutable_lookup_inners() {
  return &_impl_.lookup_inners_;
}

// -------------------------------------------------------------------

// CompressedBatchEntry

// .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
inline bool CompressedBatchEntry::has_exist() const {
  return proof_case() == kExist;
}
inline bool CompressedBatchEntry::_internal_has_exist() const {
  return proof_case() == kExist;
}
inline void CompressedBatchEntry::set_has_exist() {
  _impl_._oneof_case_[0] = kExist;
}
inline void CompressedBatchEntry::clear_exist() {
  if (proof_case() == kExist) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.exist_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::release_exist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedBatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.proof_.exist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedBatchEntry::_internal_exist() const {
  return proof_case() == kExist
      ? *_impl_.proof_.exist_
      : reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof&>(::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedBatchEntry::exist() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchEntry.exist)
  return _internal_exist();
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::unsafe_arena_release_exist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CompressedBatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.proof_.exist_;
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompressedBatchEntry::unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::CompressedExistenceProof* exist) {
  clear_proof();
  if (exist) {
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.exist)
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::_internal_mutable_exist() {
  if (proof_case() != kExist) {
    clear_proof();
    set_has_exist();
    _impl_.proof_.exist_ = CreateMaybeMessage< ::cosmos::ics23::v1::CompressedExistenceProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.exist_;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::mutable_exist() {
  ::cosmos::ics23::v1::CompressedExistenceProof* _msg = _internal_mutable_exist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchEntry.exist)
  return _msg;
}

// .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
inline bool CompressedBatchEntry::has_nonexist() const {
  return proof_case() == kNonexist;
}
inline bool CompressedBatchEntry::_internal_has_nonexist() const {
  return proof_case() == kNonexist;
}
inline void CompressedBatchEntry::set_has_nonexist() {
  _impl_._oneof_case_[0] = kNonexist;
}
inline void CompressedBatchEntry::clear_nonexist() {
  if (proof_case() == kNonexist) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.nonexist_;
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::release_nonexist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    ::cosmos::ics23::v1::CompressedNonExistenceProof* temp = _impl_.proof_.nonexist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::CompressedNonExistenceProof& CompressedBatchEntry::_internal_nonexist() const {
  return proof_case() == kNonexist
      ? *_impl_.proof_.nonexist_
      : reinterpret_cast<::cosmos::ics23::v1::CompressedNonExistenceProof&>(::cosmos::ics23::v1::_CompressedNonExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedNonExistenceProof& CompressedBatchEntry::nonexist() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  return _internal_nonexist();
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::unsafe_arena_release_nonexist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    ::cosmos::ics23::v1::CompressedNonExistenceProof* temp = _impl_.proof_.nonexist_;
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompressedBatchEntry::unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::CompressedNonExistenceProof* nonexist) {
  clear_proof();
  if (nonexist) {
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::_internal_mutable_nonexist() {
  if (proof_case() != kNonexist) {
    clear_proof();
    set_has_nonexist();
    _impl_.proof_.nonexist_ = CreateMaybeMessage< ::cosmos::ics23::v1::CompressedNonExistenceProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.nonexist_;
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::mutable_nonexist() {
  ::cosmos::ics23::v1::CompressedNonExistenceProof* _msg = _internal_mutable_nonexist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  return _msg;
}

inline bool CompressedBatchEntry::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void CompressedBatchEntry::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline CompressedBatchEntry::ProofCase CompressedBatchEntry::proof_case() const {
  return CompressedBatchEntry::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CompressedExistenceProof

// bytes key = 1 [json_name = "key"];
inline void CompressedExistenceProof::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CompressedExistenceProof::key() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedExistenceProof.key)
}
inline std::string* CompressedExistenceProof::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedExistenceProof.key)
  return _s;
}
inline const std::string& CompressedExistenceProof::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CompressedExistenceProof::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedExistenceProof::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* CompressedExistenceProof::release_key() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedExistenceProof.key)
  return _impl_.key_.Release();
}
inline void CompressedExistenceProof::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.key)
}

// bytes value = 2 [json_name = "value"];
inline void CompressedExistenceProof::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CompressedExistenceProof::value() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedExistenceProof::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedExistenceProof.value)
}
inline std::string* CompressedExistenceProof::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedExistenceProof.value)
  return _s;
}
inline const std::string& CompressedExistenceProof::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CompressedExistenceProof::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedExistenceProof::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* CompressedExistenceProof::release_value() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedExistenceProof.value)
  return _impl_.value_.Release();
}
inline void CompressedExistenceProof::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.value)
}

// .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
inline bool CompressedExistenceProof::has_leaf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.leaf_ != nullptr);
  return value;
}
inline void CompressedExistenceProof::clear_leaf() {
  if (_impl_.leaf_ != nullptr) _impl_.leaf_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::LeafOp& CompressedExistenceProof::_internal_leaf() const {
  const ::cosmos::ics23::v1::LeafOp* p = _impl_.leaf_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::LeafOp&>(
      ::cosmos::ics23::v1::_LeafOp_default_instance_);
}
inline const ::cosmos::ics23::v1::LeafOp& CompressedExistenceProof::leaf() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.leaf)
  return _internal_leaf();
}
inline void CompressedExistenceProof::unsafe_arena_set_allocated_leaf(
    ::cosmos::ics23::v1::LeafOp* leaf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leaf_);
  }
  _impl_.leaf_ = leaf;
  if (leaf) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.leaf)
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::release_leaf() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedExistenceProof.leaf)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::_internal_mutable_leaf() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.leaf_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::LeafOp>(GetArenaForAllocation());
    _impl_.leaf_ = p;
  }
  return _impl_.leaf_;
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::mutable_leaf() {
  ::cosmos::ics23::v1::LeafOp* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedExistenceProof.leaf)
  return _msg;
}
inline void CompressedExistenceProof::set_allocated_leaf(::cosmos::ics23::v1::LeafOp* leaf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.leaf_;
  }
  if (leaf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(leaf);
    if (message_arena != submessage_arena) {
      leaf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leaf, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.leaf_ = leaf;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.leaf)
}

// repeated int32 path = 4 [json_name = "path"];
inline int CompressedExistenceProof::_internal_path_size() const {
  return _impl_.path_.size();
}
inline int CompressedExistenceProof::path_size() const {
  return _internal_path_size();
}
inline void CompressedExistenceProof::clear_path() {
  _internal_mutable_path()->Clear();
}
inline ::int32_t CompressedExistenceProof::path(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.path)
  return _internal_path(index);
}
inline void CompressedExistenceProof::set_path(int index, ::int32_t value) {
  _internal_mutable_path()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedExistenceProof.path)
}
inline void CompressedExistenceProof::add_path(::int32_t value) {
  _internal_add_path(value);
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.CompressedExistenceProof.path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& CompressedExistenceProof::path() const {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.CompressedExistenceProof.path)
  return _internal_path();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* CompressedExistenceProof::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.CompressedExistenceProof.path)
  return _internal_mutable_path();
}

inline ::int32_t CompressedExistenceProof::_internal_path(int index) const {
  return _internal_path().Get(index);
}
inline void CompressedExistenceProof::_internal_add_path(::int32_t value) {
  _internal_mutable_path()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& CompressedExistenceProof::_internal_path() const {
  return _impl_.path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* CompressedExistenceProof::_internal_mutable_path() {
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// CompressedNonExistenceProof

// bytes key = 1 [json_name = "key"];
inline void CompressedNonExistenceProof::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CompressedNonExistenceProof::key() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedNonExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedNonExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedNonExistenceProof.key)
}
inline std::string* CompressedNonExistenceProof::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedNonExistenceProof.key)
  return _s;
}
inline const std::string& CompressedNonExistenceProof::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CompressedNonExistenceProof::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedNonExistenceProof::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* CompressedNonExistenceProof::release_key() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedNonExistenceProof.key)
  return _impl_.key_.Release();
}
inline void CompressedNonExistenceProof::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.key)
}

// .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
inline bool CompressedNonExistenceProof::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void CompressedNonExistenceProof::clear_left() {
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::_internal_left() const {
  const ::cosmos::ics23::v1::CompressedExistenceProof* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::CompressedExistenceProof&>(
      ::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::left() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedNonExistenceProof.left)
  return _internal_left();
}
inline void CompressedNonExistenceProof::unsafe_arena_set_allocated_left(
    ::cosmos::ics23::v1::CompressedExistenceProof* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.left)
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::release_left() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedNonExistenceProof.left)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::_internal_mutable_left() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::CompressedExistenceProof>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::mutable_left() {
  ::cosmos::ics23::v1::CompressedExistenceProof* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedNonExistenceProof.left)
  return _msg;
}
inline void CompressedNonExistenceProof::set_allocated_left(::cosmos::ics23::v1::CompressedExistenceProof* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.left)
}

// .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
inline bool CompressedNonExistenceProof::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void CompressedNonExistenceProof::clear_right() {
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::_internal_right() const {
  const ::cosmos::ics23::v1::CompressedExistenceProof* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::CompressedExistenceProof&>(
      ::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::right() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedNonExistenceProof.right)
  return _internal_right();
}
inline void CompressedNonExistenceProof::unsafe_arena_set_allocated_right(
    ::cosmos::ics23::v1::CompressedExistenceProof* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = right;
  if (right) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.right)
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::release_right() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedNonExistenceProof.right)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::_internal_mutable_right() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::ics23::v1::CompressedExistenceProof>(GetArenaForAllocation());
    _impl_.right_ = p;
  }
  return _impl_.right_;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::mutable_right() {
  ::cosmos::ics23::v1::CompressedExistenceProof* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedNonExistenceProof.right)
  return _msg;
}
inline void CompressedNonExistenceProof::set_allocated_right(::cosmos::ics23::v1::CompressedExistenceProof* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.right_ = right;
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.right)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::cosmos::ics23::v1::HashOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::ics23::v1::HashOp>() {
  return ::cosmos::ics23::v1::HashOp_descriptor();
}
template <>
struct is_proto_enum<::cosmos::ics23::v1::LengthOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::ics23::v1::LengthOp>() {
  return ::cosmos::ics23::v1::LengthOp_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmos_2fics23_2fv1_2fproofs_2eproto_2epb_2eh
