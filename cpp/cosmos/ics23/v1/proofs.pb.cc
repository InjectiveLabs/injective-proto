// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/ics23/v1/proofs.proto

#include "cosmos/ics23/v1/proofs.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace cosmos {
namespace ics23 {
namespace v1 {
template <typename>
PROTOBUF_CONSTEXPR ExistenceProof::ExistenceProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{}
  , /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.value_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.leaf_)*/nullptr} {}
struct ExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExistenceProofDefaultTypeInternal() {}
  union {
    ExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExistenceProofDefaultTypeInternal _ExistenceProof_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NonExistenceProof::NonExistenceProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.left_)*/nullptr
  , /*decltype(_impl_.right_)*/nullptr} {}
struct NonExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NonExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NonExistenceProofDefaultTypeInternal() {}
  union {
    NonExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NonExistenceProofDefaultTypeInternal _NonExistenceProof_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CommitmentProof::CommitmentProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CommitmentProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommitmentProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommitmentProofDefaultTypeInternal() {}
  union {
    CommitmentProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitmentProofDefaultTypeInternal _CommitmentProof_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LeafOp::LeafOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.prefix_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hash_)*/ 0

  , /*decltype(_impl_.prehash_key_)*/ 0

  , /*decltype(_impl_.prehash_value_)*/ 0

  , /*decltype(_impl_.length_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeafOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeafOpDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeafOpDefaultTypeInternal() {}
  union {
    LeafOp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeafOpDefaultTypeInternal _LeafOp_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InnerOp::InnerOp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.prefix_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.suffix_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hash_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InnerOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InnerOpDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InnerOpDefaultTypeInternal() {}
  union {
    InnerOp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InnerOpDefaultTypeInternal _InnerOp_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ProofSpec::ProofSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.leaf_spec_)*/nullptr
  , /*decltype(_impl_.inner_spec_)*/nullptr
  , /*decltype(_impl_.max_depth_)*/ 0

  , /*decltype(_impl_.min_depth_)*/ 0

  , /*decltype(_impl_.prehash_key_before_comparison_)*/ false
} {}
struct ProofSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProofSpecDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProofSpecDefaultTypeInternal() {}
  union {
    ProofSpec _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProofSpecDefaultTypeInternal _ProofSpec_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InnerSpec::InnerSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.child_order_)*/ {}
  ,/* _impl_._child_order_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.empty_child_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.child_size_)*/ 0

  , /*decltype(_impl_.min_prefix_length_)*/ 0

  , /*decltype(_impl_.max_prefix_length_)*/ 0

  , /*decltype(_impl_.hash_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InnerSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InnerSpecDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InnerSpecDefaultTypeInternal() {}
  union {
    InnerSpec _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InnerSpecDefaultTypeInternal _InnerSpec_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BatchProof::BatchProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchProofDefaultTypeInternal() {}
  union {
    BatchProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchProofDefaultTypeInternal _BatchProof_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BatchEntry::BatchEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BatchEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchEntryDefaultTypeInternal() {}
  union {
    BatchEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchEntryDefaultTypeInternal _BatchEntry_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CompressedBatchProof::CompressedBatchProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.lookup_inners_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CompressedBatchProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedBatchProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedBatchProofDefaultTypeInternal() {}
  union {
    CompressedBatchProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedBatchProofDefaultTypeInternal _CompressedBatchProof_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CompressedBatchEntry::CompressedBatchEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CompressedBatchEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedBatchEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedBatchEntryDefaultTypeInternal() {}
  union {
    CompressedBatchEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedBatchEntryDefaultTypeInternal _CompressedBatchEntry_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CompressedExistenceProof::CompressedExistenceProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/ {}
  ,/* _impl_._path_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.value_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.leaf_)*/nullptr} {}
struct CompressedExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedExistenceProofDefaultTypeInternal() {}
  union {
    CompressedExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedExistenceProofDefaultTypeInternal _CompressedExistenceProof_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CompressedNonExistenceProof::CompressedNonExistenceProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.left_)*/nullptr
  , /*decltype(_impl_.right_)*/nullptr} {}
struct CompressedNonExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedNonExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedNonExistenceProofDefaultTypeInternal() {}
  union {
    CompressedNonExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedNonExistenceProofDefaultTypeInternal _CompressedNonExistenceProof_default_instance_;
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos
static ::_pb::Metadata file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto[2];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto = nullptr;
const ::uint32_t TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.leaf_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.path_),
    ~0u,
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_.left_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_.right_),
    ~0u,
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _impl_.proof_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.hash_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.prehash_key_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.prehash_value_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.length_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.prefix_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _impl_.hash_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _impl_.prefix_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _impl_.suffix_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.leaf_spec_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.inner_spec_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.max_depth_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.min_depth_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.prehash_key_before_comparison_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.child_order_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.child_size_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.min_prefix_length_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.max_prefix_length_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.empty_child_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.hash_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchProof, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchProof, _impl_.entries_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _impl_.proof_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchProof, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchProof, _impl_.entries_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchProof, _impl_.lookup_inners_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _impl_.proof_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.leaf_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.path_),
    ~0u,
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_.left_),
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_.right_),
    ~0u,
    0,
    1,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 12, -1, sizeof(::cosmos::ics23::v1::ExistenceProof)},
        { 16, 27, -1, sizeof(::cosmos::ics23::v1::NonExistenceProof)},
        { 30, -1, -1, sizeof(::cosmos::ics23::v1::CommitmentProof)},
        { 43, -1, -1, sizeof(::cosmos::ics23::v1::LeafOp)},
        { 56, -1, -1, sizeof(::cosmos::ics23::v1::InnerOp)},
        { 67, 80, -1, sizeof(::cosmos::ics23::v1::ProofSpec)},
        { 85, -1, -1, sizeof(::cosmos::ics23::v1::InnerSpec)},
        { 99, -1, -1, sizeof(::cosmos::ics23::v1::BatchProof)},
        { 108, -1, -1, sizeof(::cosmos::ics23::v1::BatchEntry)},
        { 119, -1, -1, sizeof(::cosmos::ics23::v1::CompressedBatchProof)},
        { 129, -1, -1, sizeof(::cosmos::ics23::v1::CompressedBatchEntry)},
        { 140, 152, -1, sizeof(::cosmos::ics23::v1::CompressedExistenceProof)},
        { 156, 167, -1, sizeof(::cosmos::ics23::v1::CompressedNonExistenceProof)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::cosmos::ics23::v1::_ExistenceProof_default_instance_._instance,
    &::cosmos::ics23::v1::_NonExistenceProof_default_instance_._instance,
    &::cosmos::ics23::v1::_CommitmentProof_default_instance_._instance,
    &::cosmos::ics23::v1::_LeafOp_default_instance_._instance,
    &::cosmos::ics23::v1::_InnerOp_default_instance_._instance,
    &::cosmos::ics23::v1::_ProofSpec_default_instance_._instance,
    &::cosmos::ics23::v1::_InnerSpec_default_instance_._instance,
    &::cosmos::ics23::v1::_BatchProof_default_instance_._instance,
    &::cosmos::ics23::v1::_BatchEntry_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedBatchProof_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedBatchEntry_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedNonExistenceProof_default_instance_._instance,
};
const char descriptor_table_protodef_cosmos_2fics23_2fv1_2fproofs_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\034cosmos/ics23/v1/proofs.proto\022\017cosmos.i"
    "cs23.v1\"\223\001\n\016ExistenceProof\022\020\n\003key\030\001 \001(\014R"
    "\003key\022\024\n\005value\030\002 \001(\014R\005value\022+\n\004leaf\030\003 \001(\013"
    "2\027.cosmos.ics23.v1.LeafOpR\004leaf\022,\n\004path\030"
    "\004 \003(\0132\030.cosmos.ics23.v1.InnerOpR\004path\"\221\001"
    "\n\021NonExistenceProof\022\020\n\003key\030\001 \001(\014R\003key\0223\n"
    "\004left\030\002 \001(\0132\037.cosmos.ics23.v1.ExistenceP"
    "roofR\004left\0225\n\005right\030\003 \001(\0132\037.cosmos.ics23"
    ".v1.ExistenceProofR\005right\"\223\002\n\017Commitment"
    "Proof\0227\n\005exist\030\001 \001(\0132\037.cosmos.ics23.v1.E"
    "xistenceProofH\000R\005exist\022@\n\010nonexist\030\002 \001(\013"
    "2\".cosmos.ics23.v1.NonExistenceProofH\000R\010"
    "nonexist\0223\n\005batch\030\003 \001(\0132\033.cosmos.ics23.v"
    "1.BatchProofH\000R\005batch\022G\n\ncompressed\030\004 \001("
    "\0132%.cosmos.ics23.v1.CompressedBatchProof"
    "H\000R\ncompressedB\007\n\005proof\"\370\001\n\006LeafOp\022+\n\004ha"
    "sh\030\001 \001(\0162\027.cosmos.ics23.v1.HashOpR\004hash\022"
    "8\n\013prehash_key\030\002 \001(\0162\027.cosmos.ics23.v1.H"
    "ashOpR\nprehashKey\022<\n\rprehash_value\030\003 \001(\016"
    "2\027.cosmos.ics23.v1.HashOpR\014prehashValue\022"
    "1\n\006length\030\004 \001(\0162\031.cosmos.ics23.v1.Length"
    "OpR\006length\022\026\n\006prefix\030\005 \001(\014R\006prefix\"f\n\007In"
    "nerOp\022+\n\004hash\030\001 \001(\0162\027.cosmos.ics23.v1.Ha"
    "shOpR\004hash\022\026\n\006prefix\030\002 \001(\014R\006prefix\022\026\n\006su"
    "ffix\030\003 \001(\014R\006suffix\"\371\001\n\tProofSpec\0224\n\tleaf"
    "_spec\030\001 \001(\0132\027.cosmos.ics23.v1.LeafOpR\010le"
    "afSpec\0229\n\ninner_spec\030\002 \001(\0132\032.cosmos.ics2"
    "3.v1.InnerSpecR\tinnerSpec\022\033\n\tmax_depth\030\003"
    " \001(\005R\010maxDepth\022\033\n\tmin_depth\030\004 \001(\005R\010minDe"
    "pth\022A\n\035prehash_key_before_comparison\030\005 \001"
    "(\010R\032prehashKeyBeforeComparison\"\361\001\n\tInner"
    "Spec\022\037\n\013child_order\030\001 \003(\005R\nchildOrder\022\035\n"
    "\nchild_size\030\002 \001(\005R\tchildSize\022*\n\021min_pref"
    "ix_length\030\003 \001(\005R\017minPrefixLength\022*\n\021max_"
    "prefix_length\030\004 \001(\005R\017maxPrefixLength\022\037\n\013"
    "empty_child\030\005 \001(\014R\nemptyChild\022+\n\004hash\030\006 "
    "\001(\0162\027.cosmos.ics23.v1.HashOpR\004hash\"C\n\nBa"
    "tchProof\0225\n\007entries\030\001 \003(\0132\033.cosmos.ics23"
    ".v1.BatchEntryR\007entries\"\220\001\n\nBatchEntry\0227"
    "\n\005exist\030\001 \001(\0132\037.cosmos.ics23.v1.Existenc"
    "eProofH\000R\005exist\022@\n\010nonexist\030\002 \001(\0132\".cosm"
    "os.ics23.v1.NonExistenceProofH\000R\010nonexis"
    "tB\007\n\005proof\"\226\001\n\024CompressedBatchProof\022\?\n\007e"
    "ntries\030\001 \003(\0132%.cosmos.ics23.v1.Compresse"
    "dBatchEntryR\007entries\022=\n\rlookup_inners\030\002 "
    "\003(\0132\030.cosmos.ics23.v1.InnerOpR\014lookupInn"
    "ers\"\256\001\n\024CompressedBatchEntry\022A\n\005exist\030\001 "
    "\001(\0132).cosmos.ics23.v1.CompressedExistenc"
    "eProofH\000R\005exist\022J\n\010nonexist\030\002 \001(\0132,.cosm"
    "os.ics23.v1.CompressedNonExistenceProofH"
    "\000R\010nonexistB\007\n\005proof\"\203\001\n\030CompressedExist"
    "enceProof\022\020\n\003key\030\001 \001(\014R\003key\022\024\n\005value\030\002 \001"
    "(\014R\005value\022+\n\004leaf\030\003 \001(\0132\027.cosmos.ics23.v"
    "1.LeafOpR\004leaf\022\022\n\004path\030\004 \003(\005R\004path\"\257\001\n\033C"
    "ompressedNonExistenceProof\022\020\n\003key\030\001 \001(\014R"
    "\003key\022=\n\004left\030\002 \001(\0132).cosmos.ics23.v1.Com"
    "pressedExistenceProofR\004left\022\?\n\005right\030\003 \001"
    "(\0132).cosmos.ics23.v1.CompressedExistence"
    "ProofR\005right*e\n\006HashOp\022\013\n\007NO_HASH\020\000\022\n\n\006S"
    "HA256\020\001\022\n\n\006SHA512\020\002\022\n\n\006KECCAK\020\003\022\r\n\tRIPEM"
    "D160\020\004\022\013\n\007BITCOIN\020\005\022\016\n\nSHA512_256\020\006*\253\001\n\010"
    "LengthOp\022\r\n\tNO_PREFIX\020\000\022\r\n\tVAR_PROTO\020\001\022\013"
    "\n\007VAR_RLP\020\002\022\017\n\013FIXED32_BIG\020\003\022\022\n\016FIXED32_"
    "LITTLE\020\004\022\017\n\013FIXED64_BIG\020\005\022\022\n\016FIXED64_LIT"
    "TLE\020\006\022\024\n\020REQUIRE_32_BYTES\020\007\022\024\n\020REQUIRE_6"
    "4_BYTES\020\010B\242\001\n\023com.cosmos.ics23.v1B\013Proof"
    "sProtoP\001Z github.com/cosmos/ics23/go;ics"
    "23\242\002\003CIX\252\002\017Cosmos.Ics23.V1\312\002\017Cosmos\\Ics2"
    "3\\V1\342\002\033Cosmos\\Ics23\\V1\\GPBMetadata\352\002\021Cos"
    "mos::Ics23::V1b\006proto3"
};
static ::absl::once_flag descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto = {
    false,
    false,
    2782,
    descriptor_table_protodef_cosmos_2fics23_2fv1_2fproofs_2eproto,
    "cosmos/ics23/v1/proofs.proto",
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
    nullptr,
    0,
    13,
    schemas,
    file_default_instances,
    TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto::offsets,
    file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto,
    file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto,
    file_level_service_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter() {
  return &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_cosmos_2fics23_2fv1_2fproofs_2eproto(&descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto);
namespace cosmos {
namespace ics23 {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HashOp_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto);
  return file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto[0];
}
bool HashOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LengthOp_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto);
  return file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto[1];
}
bool LengthOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class ExistenceProof::_Internal {
 public:
  using HasBits = decltype(std::declval<ExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_._has_bits_);
  static const ::cosmos::ics23::v1::LeafOp& leaf(const ExistenceProof* msg);
  static void set_has_leaf(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::ics23::v1::LeafOp&
ExistenceProof::_Internal::leaf(const ExistenceProof* msg) {
  return *msg->_impl_.leaf_;
}
ExistenceProof::ExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.ExistenceProof)
}
ExistenceProof::ExistenceProof(const ExistenceProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExistenceProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){from._impl_.path_}
    , decltype(_impl_.key_) {}

    , decltype(_impl_.value_) {}

    , decltype(_impl_.leaf_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.leaf_ = new ::cosmos::ics23::v1::LeafOp(*from._impl_.leaf_);
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.ExistenceProof)
}

inline void ExistenceProof::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){arena}
    , decltype(_impl_.key_) {}

    , decltype(_impl_.value_) {}

    , decltype(_impl_.leaf_){nullptr}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExistenceProof::~ExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.ExistenceProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExistenceProof::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_path()->~RepeatedPtrField();
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.leaf_;
}

void ExistenceProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.ExistenceProof)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_path()->Clear();
  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.leaf_ != nullptr);
    _impl_.leaf_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExistenceProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1 [json_name = "key"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes value = 2 [json_name = "value"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_leaf(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_path(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ExistenceProof::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.ExistenceProof)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes value = 2 [json_name = "value"];
  if (!this->_internal_value().empty()) {
    const std::string& _s = this->_internal_value();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::leaf(this),
        _Internal::leaf(this).GetCachedSize(), target, stream);
  }

  // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_path_size()); i < n; i++) {
    const auto& repfield = this->_internal_path(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.ExistenceProof)
  return target;
}

::size_t ExistenceProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.ExistenceProof)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
  total_size += 1UL * this->_internal_path_size();
  for (const auto& msg : this->_internal_path()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes value = 2 [json_name = "value"];
  if (!this->_internal_value().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_value());
  }

  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.leaf_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExistenceProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExistenceProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExistenceProof::GetClassData() const { return &_class_data_; }


void ExistenceProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExistenceProof*>(&to_msg);
  auto& from = static_cast<const ExistenceProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.ExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_path()->MergeFrom(from._internal_path());
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_leaf()->::cosmos::ics23::v1::LeafOp::MergeFrom(
        from._internal_leaf());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExistenceProof::CopyFrom(const ExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.ExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExistenceProof::IsInitialized() const {
  return true;
}

void ExistenceProof::InternalSwap(ExistenceProof* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_path()->InternalSwap(other->_internal_mutable_path());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena,
                                       &other->_impl_.value_, rhs_arena);
  swap(_impl_.leaf_, other->_impl_.leaf_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExistenceProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[0]);
}
// ===================================================================

class NonExistenceProof::_Internal {
 public:
  using HasBits = decltype(std::declval<NonExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_._has_bits_);
  static const ::cosmos::ics23::v1::ExistenceProof& left(const NonExistenceProof* msg);
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::ics23::v1::ExistenceProof& right(const NonExistenceProof* msg);
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cosmos::ics23::v1::ExistenceProof&
NonExistenceProof::_Internal::left(const NonExistenceProof* msg) {
  return *msg->_impl_.left_;
}
const ::cosmos::ics23::v1::ExistenceProof&
NonExistenceProof::_Internal::right(const NonExistenceProof* msg) {
  return *msg->_impl_.right_;
}
NonExistenceProof::NonExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.NonExistenceProof)
}
NonExistenceProof::NonExistenceProof(const NonExistenceProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NonExistenceProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_) {}

    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.left_ = new ::cosmos::ics23::v1::ExistenceProof(*from._impl_.left_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.right_ = new ::cosmos::ics23::v1::ExistenceProof(*from._impl_.right_);
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.NonExistenceProof)
}

inline void NonExistenceProof::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_) {}

    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NonExistenceProof::~NonExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.NonExistenceProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NonExistenceProof::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.left_;
  if (this != internal_default_instance()) delete _impl_.right_;
}

void NonExistenceProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NonExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.NonExistenceProof)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.left_ != nullptr);
      _impl_.left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.right_ != nullptr);
      _impl_.right_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NonExistenceProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1 [json_name = "key"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_left(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_right(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* NonExistenceProof::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.NonExistenceProof)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::left(this),
        _Internal::left(this).GetCachedSize(), target, stream);
  }

  // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::right(this),
        _Internal::right(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.NonExistenceProof)
  return target;
}

::size_t NonExistenceProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.NonExistenceProof)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.left_);
    }

    // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.right_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NonExistenceProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NonExistenceProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NonExistenceProof::GetClassData() const { return &_class_data_; }


void NonExistenceProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NonExistenceProof*>(&to_msg);
  auto& from = static_cast<const NonExistenceProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.NonExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_left()->::cosmos::ics23::v1::ExistenceProof::MergeFrom(
          from._internal_left());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_right()->::cosmos::ics23::v1::ExistenceProof::MergeFrom(
          from._internal_right());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NonExistenceProof::CopyFrom(const NonExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.NonExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NonExistenceProof::IsInitialized() const {
  return true;
}

void NonExistenceProof::InternalSwap(NonExistenceProof* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.right_)
      + sizeof(NonExistenceProof::_impl_.right_)
      - PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.left_)>(
          reinterpret_cast<char*>(&_impl_.left_),
          reinterpret_cast<char*>(&other->_impl_.left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NonExistenceProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[1]);
}
// ===================================================================

class CommitmentProof::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _impl_._oneof_case_);
  static const ::cosmos::ics23::v1::ExistenceProof& exist(const CommitmentProof* msg);
  static const ::cosmos::ics23::v1::NonExistenceProof& nonexist(const CommitmentProof* msg);
  static const ::cosmos::ics23::v1::BatchProof& batch(const CommitmentProof* msg);
  static const ::cosmos::ics23::v1::CompressedBatchProof& compressed(const CommitmentProof* msg);
};

const ::cosmos::ics23::v1::ExistenceProof&
CommitmentProof::_Internal::exist(const CommitmentProof* msg) {
  return *msg->_impl_.proof_.exist_;
}
const ::cosmos::ics23::v1::NonExistenceProof&
CommitmentProof::_Internal::nonexist(const CommitmentProof* msg) {
  return *msg->_impl_.proof_.nonexist_;
}
const ::cosmos::ics23::v1::BatchProof&
CommitmentProof::_Internal::batch(const CommitmentProof* msg) {
  return *msg->_impl_.proof_.batch_;
}
const ::cosmos::ics23::v1::CompressedBatchProof&
CommitmentProof::_Internal::compressed(const CommitmentProof* msg) {
  return *msg->_impl_.proof_.compressed_;
}
void CommitmentProof::set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (exist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exist);
    if (message_arena != submessage_arena) {
      exist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exist, submessage_arena);
    }
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.exist)
}
void CommitmentProof::set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (nonexist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nonexist);
    if (message_arena != submessage_arena) {
      nonexist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nonexist, submessage_arena);
    }
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.nonexist)
}
void CommitmentProof::set_allocated_batch(::cosmos::ics23::v1::BatchProof* batch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (batch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(batch);
    if (message_arena != submessage_arena) {
      batch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch, submessage_arena);
    }
    set_has_batch();
    _impl_.proof_.batch_ = batch;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.batch)
}
void CommitmentProof::set_allocated_compressed(::cosmos::ics23::v1::CompressedBatchProof* compressed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (compressed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compressed);
    if (message_arena != submessage_arena) {
      compressed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compressed, submessage_arena);
    }
    set_has_compressed();
    _impl_.proof_.compressed_ = compressed;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.compressed)
}
CommitmentProof::CommitmentProof(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CommitmentProof)
}
CommitmentProof::CommitmentProof(const CommitmentProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommitmentProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_proof();
  switch (from.proof_case()) {
    case kExist: {
      _this->_internal_mutable_exist()->::cosmos::ics23::v1::ExistenceProof::MergeFrom(
          from._internal_exist());
      break;
    }
    case kNonexist: {
      _this->_internal_mutable_nonexist()->::cosmos::ics23::v1::NonExistenceProof::MergeFrom(
          from._internal_nonexist());
      break;
    }
    case kBatch: {
      _this->_internal_mutable_batch()->::cosmos::ics23::v1::BatchProof::MergeFrom(
          from._internal_batch());
      break;
    }
    case kCompressed: {
      _this->_internal_mutable_compressed()->::cosmos::ics23::v1::CompressedBatchProof::MergeFrom(
          from._internal_compressed());
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CommitmentProof)
}

inline void CommitmentProof::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_proof();
}

CommitmentProof::~CommitmentProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CommitmentProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommitmentProof::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_proof()) {
    clear_proof();
  }
}

void CommitmentProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommitmentProof::clear_proof() {
// @@protoc_insertion_point(one_of_clear_start:cosmos.ics23.v1.CommitmentProof)
  switch (proof_case()) {
    case kExist: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.exist_;
      }
      break;
    }
    case kNonexist: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.nonexist_;
      }
      break;
    }
    case kBatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.batch_;
      }
      break;
    }
    case kCompressed: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.compressed_;
      }
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}


void CommitmentProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CommitmentProof)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_proof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommitmentProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_exist(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nonexist(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_batch(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_compressed(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CommitmentProof::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CommitmentProof)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (proof_case()) {
    case kExist: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::exist(this),
          _Internal::exist(this).GetCachedSize(), target, stream);
      break;
    }
    case kNonexist: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::nonexist(this),
          _Internal::nonexist(this).GetCachedSize(), target, stream);
      break;
    }
    case kBatch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::batch(this),
          _Internal::batch(this).GetCachedSize(), target, stream);
      break;
    }
    case kCompressed: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::compressed(this),
          _Internal::compressed(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CommitmentProof)
  return target;
}

::size_t CommitmentProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CommitmentProof)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (proof_case()) {
    // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
    case kExist: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.exist_);
      break;
    }
    // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
    case kNonexist: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.nonexist_);
      break;
    }
    // .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
    case kBatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.batch_);
      break;
    }
    // .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
    case kCompressed: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.compressed_);
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommitmentProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommitmentProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommitmentProof::GetClassData() const { return &_class_data_; }


void CommitmentProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommitmentProof*>(&to_msg);
  auto& from = static_cast<const CommitmentProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CommitmentProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.proof_case()) {
    case kExist: {
      _this->_internal_mutable_exist()->::cosmos::ics23::v1::ExistenceProof::MergeFrom(
          from._internal_exist());
      break;
    }
    case kNonexist: {
      _this->_internal_mutable_nonexist()->::cosmos::ics23::v1::NonExistenceProof::MergeFrom(
          from._internal_nonexist());
      break;
    }
    case kBatch: {
      _this->_internal_mutable_batch()->::cosmos::ics23::v1::BatchProof::MergeFrom(
          from._internal_batch());
      break;
    }
    case kCompressed: {
      _this->_internal_mutable_compressed()->::cosmos::ics23::v1::CompressedBatchProof::MergeFrom(
          from._internal_compressed());
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommitmentProof::CopyFrom(const CommitmentProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CommitmentProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitmentProof::IsInitialized() const {
  return true;
}

void CommitmentProof::InternalSwap(CommitmentProof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.proof_, other->_impl_.proof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommitmentProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[2]);
}
// ===================================================================

class LeafOp::_Internal {
 public:
};

LeafOp::LeafOp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.LeafOp)
}
LeafOp::LeafOp(const LeafOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeafOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.prefix_) {}

    , decltype(_impl_.hash_) {}

    , decltype(_impl_.prehash_key_) {}

    , decltype(_impl_.prehash_value_) {}

    , decltype(_impl_.length_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_prefix().empty()) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.hash_, &from._impl_.hash_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.length_) -
    reinterpret_cast<char*>(&_impl_.hash_)) + sizeof(_impl_.length_));
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.LeafOp)
}

inline void LeafOp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.prefix_) {}

    , decltype(_impl_.hash_) { 0 }

    , decltype(_impl_.prehash_key_) { 0 }

    , decltype(_impl_.prehash_value_) { 0 }

    , decltype(_impl_.length_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LeafOp::~LeafOp() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.LeafOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeafOp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prefix_.Destroy();
}

void LeafOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeafOp::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.LeafOp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prefix_.ClearToEmpty();
  ::memset(&_impl_.hash_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.length_) -
      reinterpret_cast<char*>(&_impl_.hash_)) + sizeof(_impl_.length_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeafOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_hash(static_cast<::cosmos::ics23::v1::HashOp>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_prehash_key(static_cast<::cosmos::ics23::v1::HashOp>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_prehash_value(static_cast<::cosmos::ics23::v1::HashOp>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_length(static_cast<::cosmos::ics23::v1::LengthOp>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes prefix = 5 [json_name = "prefix"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LeafOp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.LeafOp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_hash(), target);
  }

  // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
  if (this->_internal_prehash_key() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_prehash_key(), target);
  }

  // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
  if (this->_internal_prehash_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_prehash_value(), target);
  }

  // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
  if (this->_internal_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_length(), target);
  }

  // bytes prefix = 5 [json_name = "prefix"];
  if (!this->_internal_prefix().empty()) {
    const std::string& _s = this->_internal_prefix();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.LeafOp)
  return target;
}

::size_t LeafOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.LeafOp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes prefix = 5 [json_name = "prefix"];
  if (!this->_internal_prefix().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_prefix());
  }

  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  if (this->_internal_hash() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_hash());
  }

  // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
  if (this->_internal_prehash_key() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_prehash_key());
  }

  // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
  if (this->_internal_prehash_value() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_prehash_value());
  }

  // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
  if (this->_internal_length() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeafOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeafOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeafOp::GetClassData() const { return &_class_data_; }


void LeafOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeafOp*>(&to_msg);
  auto& from = static_cast<const LeafOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.LeafOp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_prefix().empty()) {
    _this->_internal_set_prefix(from._internal_prefix());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  if (from._internal_prehash_key() != 0) {
    _this->_internal_set_prehash_key(from._internal_prehash_key());
  }
  if (from._internal_prehash_value() != 0) {
    _this->_internal_set_prehash_value(from._internal_prehash_value());
  }
  if (from._internal_length() != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeafOp::CopyFrom(const LeafOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.LeafOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeafOp::IsInitialized() const {
  return true;
}

void LeafOp::InternalSwap(LeafOp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, lhs_arena,
                                       &other->_impl_.prefix_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.length_)
      + sizeof(LeafOp::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.hash_)>(
          reinterpret_cast<char*>(&_impl_.hash_),
          reinterpret_cast<char*>(&other->_impl_.hash_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeafOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[3]);
}
// ===================================================================

class InnerOp::_Internal {
 public:
};

InnerOp::InnerOp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.InnerOp)
}
InnerOp::InnerOp(const InnerOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InnerOp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.prefix_) {}

    , decltype(_impl_.suffix_) {}

    , decltype(_impl_.hash_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_prefix().empty()) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), _this->GetArenaForAllocation());
  }
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_suffix().empty()) {
    _this->_impl_.suffix_.Set(from._internal_suffix(), _this->GetArenaForAllocation());
  }
  _this->_impl_.hash_ = from._impl_.hash_;
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.InnerOp)
}

inline void InnerOp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.prefix_) {}

    , decltype(_impl_.suffix_) {}

    , decltype(_impl_.hash_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InnerOp::~InnerOp() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.InnerOp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InnerOp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prefix_.Destroy();
  _impl_.suffix_.Destroy();
}

void InnerOp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InnerOp::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.InnerOp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prefix_.ClearToEmpty();
  _impl_.suffix_.ClearToEmpty();
  _impl_.hash_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InnerOp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_hash(static_cast<::cosmos::ics23::v1::HashOp>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes prefix = 2 [json_name = "prefix"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes suffix = 3 [json_name = "suffix"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_suffix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InnerOp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.InnerOp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_hash(), target);
  }

  // bytes prefix = 2 [json_name = "prefix"];
  if (!this->_internal_prefix().empty()) {
    const std::string& _s = this->_internal_prefix();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // bytes suffix = 3 [json_name = "suffix"];
  if (!this->_internal_suffix().empty()) {
    const std::string& _s = this->_internal_suffix();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.InnerOp)
  return target;
}

::size_t InnerOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.InnerOp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes prefix = 2 [json_name = "prefix"];
  if (!this->_internal_prefix().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_prefix());
  }

  // bytes suffix = 3 [json_name = "suffix"];
  if (!this->_internal_suffix().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_suffix());
  }

  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  if (this->_internal_hash() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InnerOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InnerOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InnerOp::GetClassData() const { return &_class_data_; }


void InnerOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InnerOp*>(&to_msg);
  auto& from = static_cast<const InnerOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.InnerOp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_prefix().empty()) {
    _this->_internal_set_prefix(from._internal_prefix());
  }
  if (!from._internal_suffix().empty()) {
    _this->_internal_set_suffix(from._internal_suffix());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InnerOp::CopyFrom(const InnerOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.InnerOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InnerOp::IsInitialized() const {
  return true;
}

void InnerOp::InternalSwap(InnerOp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, lhs_arena,
                                       &other->_impl_.prefix_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, lhs_arena,
                                       &other->_impl_.suffix_, rhs_arena);
  swap(_impl_.hash_, other->_impl_.hash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InnerOp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[4]);
}
// ===================================================================

class ProofSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ProofSpec>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_._has_bits_);
  static const ::cosmos::ics23::v1::LeafOp& leaf_spec(const ProofSpec* msg);
  static void set_has_leaf_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::ics23::v1::InnerSpec& inner_spec(const ProofSpec* msg);
  static void set_has_inner_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cosmos::ics23::v1::LeafOp&
ProofSpec::_Internal::leaf_spec(const ProofSpec* msg) {
  return *msg->_impl_.leaf_spec_;
}
const ::cosmos::ics23::v1::InnerSpec&
ProofSpec::_Internal::inner_spec(const ProofSpec* msg) {
  return *msg->_impl_.inner_spec_;
}
ProofSpec::ProofSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.ProofSpec)
}
ProofSpec::ProofSpec(const ProofSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProofSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leaf_spec_){nullptr}
    , decltype(_impl_.inner_spec_){nullptr}
    , decltype(_impl_.max_depth_) {}

    , decltype(_impl_.min_depth_) {}

    , decltype(_impl_.prehash_key_before_comparison_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.leaf_spec_ = new ::cosmos::ics23::v1::LeafOp(*from._impl_.leaf_spec_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.inner_spec_ = new ::cosmos::ics23::v1::InnerSpec(*from._impl_.inner_spec_);
  }
  ::memcpy(&_impl_.max_depth_, &from._impl_.max_depth_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.prehash_key_before_comparison_) -
    reinterpret_cast<char*>(&_impl_.max_depth_)) + sizeof(_impl_.prehash_key_before_comparison_));
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.ProofSpec)
}

inline void ProofSpec::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leaf_spec_){nullptr}
    , decltype(_impl_.inner_spec_){nullptr}
    , decltype(_impl_.max_depth_) { 0 }

    , decltype(_impl_.min_depth_) { 0 }

    , decltype(_impl_.prehash_key_before_comparison_) { false }

  };
}

ProofSpec::~ProofSpec() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.ProofSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProofSpec::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.leaf_spec_;
  if (this != internal_default_instance()) delete _impl_.inner_spec_;
}

void ProofSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProofSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.ProofSpec)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.leaf_spec_ != nullptr);
      _impl_.leaf_spec_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.inner_spec_ != nullptr);
      _impl_.inner_spec_->Clear();
    }
  }
  ::memset(&_impl_.max_depth_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.prehash_key_before_comparison_) -
      reinterpret_cast<char*>(&_impl_.max_depth_)) + sizeof(_impl_.prehash_key_before_comparison_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProofSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_leaf_spec(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_inner_spec(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 max_depth = 3 [json_name = "maxDepth"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.max_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 min_depth = 4 [json_name = "minDepth"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.min_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool prehash_key_before_comparison = 5 [json_name = "prehashKeyBeforeComparison"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.prehash_key_before_comparison_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ProofSpec::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.ProofSpec)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::leaf_spec(this),
        _Internal::leaf_spec(this).GetCachedSize(), target, stream);
  }

  // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::inner_spec(this),
        _Internal::inner_spec(this).GetCachedSize(), target, stream);
  }

  // int32 max_depth = 3 [json_name = "maxDepth"];
  if (this->_internal_max_depth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_max_depth(), target);
  }

  // int32 min_depth = 4 [json_name = "minDepth"];
  if (this->_internal_min_depth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_min_depth(), target);
  }

  // bool prehash_key_before_comparison = 5 [json_name = "prehashKeyBeforeComparison"];
  if (this->_internal_prehash_key_before_comparison() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_prehash_key_before_comparison(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.ProofSpec)
  return target;
}

::size_t ProofSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.ProofSpec)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.leaf_spec_);
    }

    // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.inner_spec_);
    }

  }
  // int32 max_depth = 3 [json_name = "maxDepth"];
  if (this->_internal_max_depth() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_max_depth());
  }

  // int32 min_depth = 4 [json_name = "minDepth"];
  if (this->_internal_min_depth() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_min_depth());
  }

  // bool prehash_key_before_comparison = 5 [json_name = "prehashKeyBeforeComparison"];
  if (this->_internal_prehash_key_before_comparison() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProofSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProofSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProofSpec::GetClassData() const { return &_class_data_; }


void ProofSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProofSpec*>(&to_msg);
  auto& from = static_cast<const ProofSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.ProofSpec)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_leaf_spec()->::cosmos::ics23::v1::LeafOp::MergeFrom(
          from._internal_leaf_spec());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_inner_spec()->::cosmos::ics23::v1::InnerSpec::MergeFrom(
          from._internal_inner_spec());
    }
  }
  if (from._internal_max_depth() != 0) {
    _this->_internal_set_max_depth(from._internal_max_depth());
  }
  if (from._internal_min_depth() != 0) {
    _this->_internal_set_min_depth(from._internal_min_depth());
  }
  if (from._internal_prehash_key_before_comparison() != 0) {
    _this->_internal_set_prehash_key_before_comparison(from._internal_prehash_key_before_comparison());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProofSpec::CopyFrom(const ProofSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.ProofSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProofSpec::IsInitialized() const {
  return true;
}

void ProofSpec::InternalSwap(ProofSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.prehash_key_before_comparison_)
      + sizeof(ProofSpec::_impl_.prehash_key_before_comparison_)
      - PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.leaf_spec_)>(
          reinterpret_cast<char*>(&_impl_.leaf_spec_),
          reinterpret_cast<char*>(&other->_impl_.leaf_spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProofSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[5]);
}
// ===================================================================

class InnerSpec::_Internal {
 public:
};

InnerSpec::InnerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.InnerSpec)
}
InnerSpec::InnerSpec(const InnerSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InnerSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.child_order_) { from._impl_.child_order_ }
    ,/* _impl_._child_order_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.empty_child_) {}

    , decltype(_impl_.child_size_) {}

    , decltype(_impl_.min_prefix_length_) {}

    , decltype(_impl_.max_prefix_length_) {}

    , decltype(_impl_.hash_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.empty_child_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.empty_child_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_empty_child().empty()) {
    _this->_impl_.empty_child_.Set(from._internal_empty_child(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.child_size_, &from._impl_.child_size_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.hash_) -
    reinterpret_cast<char*>(&_impl_.child_size_)) + sizeof(_impl_.hash_));
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.InnerSpec)
}

inline void InnerSpec::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.child_order_) { arena }
    ,/* _impl_._child_order_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.empty_child_) {}

    , decltype(_impl_.child_size_) { 0 }

    , decltype(_impl_.min_prefix_length_) { 0 }

    , decltype(_impl_.max_prefix_length_) { 0 }

    , decltype(_impl_.hash_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.empty_child_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.empty_child_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InnerSpec::~InnerSpec() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.InnerSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InnerSpec::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.child_order_.~RepeatedField();
  _impl_.empty_child_.Destroy();
}

void InnerSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InnerSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.InnerSpec)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_child_order()->Clear();
  _impl_.empty_child_.ClearToEmpty();
  ::memset(&_impl_.child_size_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.hash_) -
      reinterpret_cast<char*>(&_impl_.child_size_)) + sizeof(_impl_.hash_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InnerSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 child_order = 1 [json_name = "childOrder"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_child_order(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 8) {
          _internal_add_child_order(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 child_size = 2 [json_name = "childSize"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.child_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.min_prefix_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.max_prefix_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes empty_child = 5 [json_name = "emptyChild"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_empty_child();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_hash(static_cast<::cosmos::ics23::v1::HashOp>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InnerSpec::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.InnerSpec)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 child_order = 1 [json_name = "childOrder"];
  {
    int byte_size = _impl_._child_order_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(1, _internal_child_order(),
                                                 byte_size, target);
    }
  }

  // int32 child_size = 2 [json_name = "childSize"];
  if (this->_internal_child_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_child_size(), target);
  }

  // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
  if (this->_internal_min_prefix_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_min_prefix_length(), target);
  }

  // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
  if (this->_internal_max_prefix_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_max_prefix_length(), target);
  }

  // bytes empty_child = 5 [json_name = "emptyChild"];
  if (!this->_internal_empty_child().empty()) {
    const std::string& _s = this->_internal_empty_child();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.InnerSpec)
  return target;
}

::size_t InnerSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.InnerSpec)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 child_order = 1 [json_name = "childOrder"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_child_order())
    ;
    _impl_._child_order_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // bytes empty_child = 5 [json_name = "emptyChild"];
  if (!this->_internal_empty_child().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_empty_child());
  }

  // int32 child_size = 2 [json_name = "childSize"];
  if (this->_internal_child_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_child_size());
  }

  // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
  if (this->_internal_min_prefix_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_min_prefix_length());
  }

  // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
  if (this->_internal_max_prefix_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_max_prefix_length());
  }

  // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
  if (this->_internal_hash() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InnerSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InnerSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InnerSpec::GetClassData() const { return &_class_data_; }


void InnerSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InnerSpec*>(&to_msg);
  auto& from = static_cast<const InnerSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.InnerSpec)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.child_order_.MergeFrom(from._impl_.child_order_);
  if (!from._internal_empty_child().empty()) {
    _this->_internal_set_empty_child(from._internal_empty_child());
  }
  if (from._internal_child_size() != 0) {
    _this->_internal_set_child_size(from._internal_child_size());
  }
  if (from._internal_min_prefix_length() != 0) {
    _this->_internal_set_min_prefix_length(from._internal_min_prefix_length());
  }
  if (from._internal_max_prefix_length() != 0) {
    _this->_internal_set_max_prefix_length(from._internal_max_prefix_length());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InnerSpec::CopyFrom(const InnerSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.InnerSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InnerSpec::IsInitialized() const {
  return true;
}

void InnerSpec::InternalSwap(InnerSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.child_order_.InternalSwap(&other->_impl_.child_order_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.empty_child_, lhs_arena,
                                       &other->_impl_.empty_child_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.hash_)
      + sizeof(InnerSpec::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.child_size_)>(
          reinterpret_cast<char*>(&_impl_.child_size_),
          reinterpret_cast<char*>(&other->_impl_.child_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InnerSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[6]);
}
// ===================================================================

class BatchProof::_Internal {
 public:
};

BatchProof::BatchProof(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.BatchProof)
}
BatchProof::BatchProof(const BatchProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.BatchProof)
}

inline void BatchProof::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchProof::~BatchProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.BatchProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchProof::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_entries()->~RepeatedPtrField();
}

void BatchProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.BatchProof)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_entries()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchProof::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.BatchProof)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.BatchProof)
  return target;
}

::size_t BatchProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.BatchProof)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_internal_entries()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchProof::GetClassData() const { return &_class_data_; }


void BatchProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchProof*>(&to_msg);
  auto& from = static_cast<const BatchProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.BatchProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_entries()->MergeFrom(from._internal_entries());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchProof::CopyFrom(const BatchProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.BatchProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchProof::IsInitialized() const {
  return true;
}

void BatchProof::InternalSwap(BatchProof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_entries()->InternalSwap(other->_internal_mutable_entries());
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[7]);
}
// ===================================================================

class BatchEntry::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _impl_._oneof_case_);
  static const ::cosmos::ics23::v1::ExistenceProof& exist(const BatchEntry* msg);
  static const ::cosmos::ics23::v1::NonExistenceProof& nonexist(const BatchEntry* msg);
};

const ::cosmos::ics23::v1::ExistenceProof&
BatchEntry::_Internal::exist(const BatchEntry* msg) {
  return *msg->_impl_.proof_.exist_;
}
const ::cosmos::ics23::v1::NonExistenceProof&
BatchEntry::_Internal::nonexist(const BatchEntry* msg) {
  return *msg->_impl_.proof_.nonexist_;
}
void BatchEntry::set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (exist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exist);
    if (message_arena != submessage_arena) {
      exist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exist, submessage_arena);
    }
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.BatchEntry.exist)
}
void BatchEntry::set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (nonexist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nonexist);
    if (message_arena != submessage_arena) {
      nonexist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nonexist, submessage_arena);
    }
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.BatchEntry.nonexist)
}
BatchEntry::BatchEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.BatchEntry)
}
BatchEntry::BatchEntry(const BatchEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_proof();
  switch (from.proof_case()) {
    case kExist: {
      _this->_internal_mutable_exist()->::cosmos::ics23::v1::ExistenceProof::MergeFrom(
          from._internal_exist());
      break;
    }
    case kNonexist: {
      _this->_internal_mutable_nonexist()->::cosmos::ics23::v1::NonExistenceProof::MergeFrom(
          from._internal_nonexist());
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.BatchEntry)
}

inline void BatchEntry::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_proof();
}

BatchEntry::~BatchEntry() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.BatchEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchEntry::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_proof()) {
    clear_proof();
  }
}

void BatchEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchEntry::clear_proof() {
// @@protoc_insertion_point(one_of_clear_start:cosmos.ics23.v1.BatchEntry)
  switch (proof_case()) {
    case kExist: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.exist_;
      }
      break;
    }
    case kNonexist: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.nonexist_;
      }
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}


void BatchEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.BatchEntry)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_proof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_exist(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nonexist(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BatchEntry::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.BatchEntry)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (proof_case()) {
    case kExist: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::exist(this),
          _Internal::exist(this).GetCachedSize(), target, stream);
      break;
    }
    case kNonexist: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::nonexist(this),
          _Internal::nonexist(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.BatchEntry)
  return target;
}

::size_t BatchEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.BatchEntry)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (proof_case()) {
    // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
    case kExist: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.exist_);
      break;
    }
    // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
    case kNonexist: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.nonexist_);
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchEntry::GetClassData() const { return &_class_data_; }


void BatchEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchEntry*>(&to_msg);
  auto& from = static_cast<const BatchEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.BatchEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.proof_case()) {
    case kExist: {
      _this->_internal_mutable_exist()->::cosmos::ics23::v1::ExistenceProof::MergeFrom(
          from._internal_exist());
      break;
    }
    case kNonexist: {
      _this->_internal_mutable_nonexist()->::cosmos::ics23::v1::NonExistenceProof::MergeFrom(
          from._internal_nonexist());
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchEntry::CopyFrom(const BatchEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.BatchEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchEntry::IsInitialized() const {
  return true;
}

void BatchEntry::InternalSwap(BatchEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.proof_, other->_impl_.proof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[8]);
}
// ===================================================================

class CompressedBatchProof::_Internal {
 public:
};

CompressedBatchProof::CompressedBatchProof(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedBatchProof)
}
CompressedBatchProof::CompressedBatchProof(const CompressedBatchProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompressedBatchProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.lookup_inners_){from._impl_.lookup_inners_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedBatchProof)
}

inline void CompressedBatchProof::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , decltype(_impl_.lookup_inners_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CompressedBatchProof::~CompressedBatchProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedBatchProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompressedBatchProof::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_entries()->~RepeatedPtrField();
  _internal_mutable_lookup_inners()->~RepeatedPtrField();
}

void CompressedBatchProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompressedBatchProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedBatchProof)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_entries()->Clear();
  _internal_mutable_lookup_inners()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompressedBatchProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lookup_inners(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CompressedBatchProof::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedBatchProof)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lookup_inners_size()); i < n; i++) {
    const auto& repfield = this->_internal_lookup_inners(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedBatchProof)
  return target;
}

::size_t CompressedBatchProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedBatchProof)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_internal_entries()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
  total_size += 1UL * this->_internal_lookup_inners_size();
  for (const auto& msg : this->_internal_lookup_inners()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompressedBatchProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompressedBatchProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompressedBatchProof::GetClassData() const { return &_class_data_; }


void CompressedBatchProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompressedBatchProof*>(&to_msg);
  auto& from = static_cast<const CompressedBatchProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedBatchProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_entries()->MergeFrom(from._internal_entries());
  _this->_internal_mutable_lookup_inners()->MergeFrom(from._internal_lookup_inners());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedBatchProof::CopyFrom(const CompressedBatchProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedBatchProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompressedBatchProof::IsInitialized() const {
  return true;
}

void CompressedBatchProof::InternalSwap(CompressedBatchProof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_entries()->InternalSwap(other->_internal_mutable_entries());
  _internal_mutable_lookup_inners()->InternalSwap(other->_internal_mutable_lookup_inners());
}

::PROTOBUF_NAMESPACE_ID::Metadata CompressedBatchProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[9]);
}
// ===================================================================

class CompressedBatchEntry::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _impl_._oneof_case_);
  static const ::cosmos::ics23::v1::CompressedExistenceProof& exist(const CompressedBatchEntry* msg);
  static const ::cosmos::ics23::v1::CompressedNonExistenceProof& nonexist(const CompressedBatchEntry* msg);
};

const ::cosmos::ics23::v1::CompressedExistenceProof&
CompressedBatchEntry::_Internal::exist(const CompressedBatchEntry* msg) {
  return *msg->_impl_.proof_.exist_;
}
const ::cosmos::ics23::v1::CompressedNonExistenceProof&
CompressedBatchEntry::_Internal::nonexist(const CompressedBatchEntry* msg) {
  return *msg->_impl_.proof_.nonexist_;
}
void CompressedBatchEntry::set_allocated_exist(::cosmos::ics23::v1::CompressedExistenceProof* exist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (exist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exist);
    if (message_arena != submessage_arena) {
      exist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exist, submessage_arena);
    }
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.exist)
}
void CompressedBatchEntry::set_allocated_nonexist(::cosmos::ics23::v1::CompressedNonExistenceProof* nonexist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_proof();
  if (nonexist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nonexist);
    if (message_arena != submessage_arena) {
      nonexist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nonexist, submessage_arena);
    }
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
}
CompressedBatchEntry::CompressedBatchEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedBatchEntry)
}
CompressedBatchEntry::CompressedBatchEntry(const CompressedBatchEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompressedBatchEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_proof();
  switch (from.proof_case()) {
    case kExist: {
      _this->_internal_mutable_exist()->::cosmos::ics23::v1::CompressedExistenceProof::MergeFrom(
          from._internal_exist());
      break;
    }
    case kNonexist: {
      _this->_internal_mutable_nonexist()->::cosmos::ics23::v1::CompressedNonExistenceProof::MergeFrom(
          from._internal_nonexist());
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedBatchEntry)
}

inline void CompressedBatchEntry::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_proof();
}

CompressedBatchEntry::~CompressedBatchEntry() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedBatchEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompressedBatchEntry::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_proof()) {
    clear_proof();
  }
}

void CompressedBatchEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompressedBatchEntry::clear_proof() {
// @@protoc_insertion_point(one_of_clear_start:cosmos.ics23.v1.CompressedBatchEntry)
  switch (proof_case()) {
    case kExist: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.exist_;
      }
      break;
    }
    case kNonexist: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.proof_.nonexist_;
      }
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}


void CompressedBatchEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedBatchEntry)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_proof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompressedBatchEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_exist(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nonexist(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CompressedBatchEntry::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedBatchEntry)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (proof_case()) {
    case kExist: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::exist(this),
          _Internal::exist(this).GetCachedSize(), target, stream);
      break;
    }
    case kNonexist: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::nonexist(this),
          _Internal::nonexist(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedBatchEntry)
  return target;
}

::size_t CompressedBatchEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedBatchEntry)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (proof_case()) {
    // .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
    case kExist: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.exist_);
      break;
    }
    // .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
    case kNonexist: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.proof_.nonexist_);
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompressedBatchEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompressedBatchEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompressedBatchEntry::GetClassData() const { return &_class_data_; }


void CompressedBatchEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompressedBatchEntry*>(&to_msg);
  auto& from = static_cast<const CompressedBatchEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedBatchEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.proof_case()) {
    case kExist: {
      _this->_internal_mutable_exist()->::cosmos::ics23::v1::CompressedExistenceProof::MergeFrom(
          from._internal_exist());
      break;
    }
    case kNonexist: {
      _this->_internal_mutable_nonexist()->::cosmos::ics23::v1::CompressedNonExistenceProof::MergeFrom(
          from._internal_nonexist());
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedBatchEntry::CopyFrom(const CompressedBatchEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedBatchEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompressedBatchEntry::IsInitialized() const {
  return true;
}

void CompressedBatchEntry::InternalSwap(CompressedBatchEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.proof_, other->_impl_.proof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompressedBatchEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[10]);
}
// ===================================================================

class CompressedExistenceProof::_Internal {
 public:
  using HasBits = decltype(std::declval<CompressedExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_._has_bits_);
  static const ::cosmos::ics23::v1::LeafOp& leaf(const CompressedExistenceProof* msg);
  static void set_has_leaf(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::ics23::v1::LeafOp&
CompressedExistenceProof::_Internal::leaf(const CompressedExistenceProof* msg) {
  return *msg->_impl_.leaf_;
}
CompressedExistenceProof::CompressedExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedExistenceProof)
}
CompressedExistenceProof::CompressedExistenceProof(const CompressedExistenceProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompressedExistenceProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_) { from._impl_.path_ }
    ,/* _impl_._path_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.key_) {}

    , decltype(_impl_.value_) {}

    , decltype(_impl_.leaf_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.leaf_ = new ::cosmos::ics23::v1::LeafOp(*from._impl_.leaf_);
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedExistenceProof)
}

inline void CompressedExistenceProof::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_) { arena }
    ,/* _impl_._path_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.key_) {}

    , decltype(_impl_.value_) {}

    , decltype(_impl_.leaf_){nullptr}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CompressedExistenceProof::~CompressedExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedExistenceProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompressedExistenceProof::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.~RepeatedField();
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.leaf_;
}

void CompressedExistenceProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompressedExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedExistenceProof)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_path()->Clear();
  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.leaf_ != nullptr);
    _impl_.leaf_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompressedExistenceProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1 [json_name = "key"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes value = 2 [json_name = "value"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_leaf(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int32 path = 4 [json_name = "path"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_path(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 32) {
          _internal_add_path(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CompressedExistenceProof::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedExistenceProof)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes value = 2 [json_name = "value"];
  if (!this->_internal_value().empty()) {
    const std::string& _s = this->_internal_value();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::leaf(this),
        _Internal::leaf(this).GetCachedSize(), target, stream);
  }

  // repeated int32 path = 4 [json_name = "path"];
  {
    int byte_size = _impl_._path_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(4, _internal_path(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedExistenceProof)
  return target;
}

::size_t CompressedExistenceProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedExistenceProof)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 path = 4 [json_name = "path"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_path())
    ;
    _impl_._path_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  // bytes value = 2 [json_name = "value"];
  if (!this->_internal_value().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_value());
  }

  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.leaf_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompressedExistenceProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompressedExistenceProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompressedExistenceProof::GetClassData() const { return &_class_data_; }


void CompressedExistenceProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompressedExistenceProof*>(&to_msg);
  auto& from = static_cast<const CompressedExistenceProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.path_.MergeFrom(from._impl_.path_);
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_leaf()->::cosmos::ics23::v1::LeafOp::MergeFrom(
        from._internal_leaf());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedExistenceProof::CopyFrom(const CompressedExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompressedExistenceProof::IsInitialized() const {
  return true;
}

void CompressedExistenceProof::InternalSwap(CompressedExistenceProof* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena,
                                       &other->_impl_.value_, rhs_arena);
  swap(_impl_.leaf_, other->_impl_.leaf_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompressedExistenceProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[11]);
}
// ===================================================================

class CompressedNonExistenceProof::_Internal {
 public:
  using HasBits = decltype(std::declval<CompressedNonExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_._has_bits_);
  static const ::cosmos::ics23::v1::CompressedExistenceProof& left(const CompressedNonExistenceProof* msg);
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::ics23::v1::CompressedExistenceProof& right(const CompressedNonExistenceProof* msg);
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cosmos::ics23::v1::CompressedExistenceProof&
CompressedNonExistenceProof::_Internal::left(const CompressedNonExistenceProof* msg) {
  return *msg->_impl_.left_;
}
const ::cosmos::ics23::v1::CompressedExistenceProof&
CompressedNonExistenceProof::_Internal::right(const CompressedNonExistenceProof* msg) {
  return *msg->_impl_.right_;
}
CompressedNonExistenceProof::CompressedNonExistenceProof(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedNonExistenceProof)
}
CompressedNonExistenceProof::CompressedNonExistenceProof(const CompressedNonExistenceProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompressedNonExistenceProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_) {}

    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.left_ = new ::cosmos::ics23::v1::CompressedExistenceProof(*from._impl_.left_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.right_ = new ::cosmos::ics23::v1::CompressedExistenceProof(*from._impl_.right_);
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedNonExistenceProof)
}

inline void CompressedNonExistenceProof::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_) {}

    , decltype(_impl_.left_){nullptr}
    , decltype(_impl_.right_){nullptr}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CompressedNonExistenceProof::~CompressedNonExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedNonExistenceProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompressedNonExistenceProof::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.left_;
  if (this != internal_default_instance()) delete _impl_.right_;
}

void CompressedNonExistenceProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompressedNonExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.left_ != nullptr);
      _impl_.left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.right_ != nullptr);
      _impl_.right_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompressedNonExistenceProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1 [json_name = "key"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_left(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_right(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CompressedNonExistenceProof::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::left(this),
        _Internal::left(this).GetCachedSize(), target, stream);
  }

  // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::right(this),
        _Internal::right(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedNonExistenceProof)
  return target;
}

::size_t CompressedNonExistenceProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_key());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.left_);
    }

    // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.right_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompressedNonExistenceProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompressedNonExistenceProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompressedNonExistenceProof::GetClassData() const { return &_class_data_; }


void CompressedNonExistenceProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompressedNonExistenceProof*>(&to_msg);
  auto& from = static_cast<const CompressedNonExistenceProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_left()->::cosmos::ics23::v1::CompressedExistenceProof::MergeFrom(
          from._internal_left());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_right()->::cosmos::ics23::v1::CompressedExistenceProof::MergeFrom(
          from._internal_right());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedNonExistenceProof::CopyFrom(const CompressedNonExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompressedNonExistenceProof::IsInitialized() const {
  return true;
}

void CompressedNonExistenceProof::InternalSwap(CompressedNonExistenceProof* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.right_)
      + sizeof(CompressedNonExistenceProof::_impl_.right_)
      - PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.left_)>(
          reinterpret_cast<char*>(&_impl_.left_),
          reinterpret_cast<char*>(&other->_impl_.left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CompressedNonExistenceProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_getter, &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
      file_level_metadata_cosmos_2fics23_2fv1_2fproofs_2eproto[12]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::ExistenceProof*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::ExistenceProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::ExistenceProof >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::NonExistenceProof*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::NonExistenceProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::NonExistenceProof >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::CommitmentProof*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::CommitmentProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::CommitmentProof >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::LeafOp*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::LeafOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::LeafOp >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::InnerOp*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::InnerOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::InnerOp >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::ProofSpec*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::ProofSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::ProofSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::InnerSpec*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::InnerSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::InnerSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::BatchProof*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::BatchProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::BatchProof >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::BatchEntry*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::BatchEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::BatchEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::CompressedBatchProof*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::CompressedBatchProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::CompressedBatchProof >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::CompressedBatchEntry*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::CompressedBatchEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::CompressedBatchEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::CompressedExistenceProof*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::CompressedExistenceProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::CompressedExistenceProof >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::ics23::v1::CompressedNonExistenceProof*
Arena::CreateMaybeMessage< ::cosmos::ics23::v1::CompressedNonExistenceProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::ics23::v1::CompressedNonExistenceProof >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
