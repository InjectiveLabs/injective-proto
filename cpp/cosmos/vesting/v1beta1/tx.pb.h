// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/vesting/v1beta1/tx.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmos_2fvesting_2fv1beta1_2ftx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmos_2fvesting_2fv1beta1_2ftx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "cosmos/vesting/v1beta1/vesting.pb.h"
#include "cosmos/msg/v1/msg.pb.h"
#include "amino/amino.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmos_2fvesting_2fv1beta1_2ftx_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmos_2fvesting_2fv1beta1_2ftx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmos_2fvesting_2fv1beta1_2ftx_2eproto;
namespace cosmos {
namespace vesting {
namespace v1beta1 {
class MsgCreatePeriodicVestingAccount;
struct MsgCreatePeriodicVestingAccountDefaultTypeInternal;
extern MsgCreatePeriodicVestingAccountDefaultTypeInternal _MsgCreatePeriodicVestingAccount_default_instance_;
class MsgCreatePeriodicVestingAccountResponse;
struct MsgCreatePeriodicVestingAccountResponseDefaultTypeInternal;
extern MsgCreatePeriodicVestingAccountResponseDefaultTypeInternal _MsgCreatePeriodicVestingAccountResponse_default_instance_;
class MsgCreatePermanentLockedAccount;
struct MsgCreatePermanentLockedAccountDefaultTypeInternal;
extern MsgCreatePermanentLockedAccountDefaultTypeInternal _MsgCreatePermanentLockedAccount_default_instance_;
class MsgCreatePermanentLockedAccountResponse;
struct MsgCreatePermanentLockedAccountResponseDefaultTypeInternal;
extern MsgCreatePermanentLockedAccountResponseDefaultTypeInternal _MsgCreatePermanentLockedAccountResponse_default_instance_;
class MsgCreateVestingAccount;
struct MsgCreateVestingAccountDefaultTypeInternal;
extern MsgCreateVestingAccountDefaultTypeInternal _MsgCreateVestingAccount_default_instance_;
class MsgCreateVestingAccountResponse;
struct MsgCreateVestingAccountResponseDefaultTypeInternal;
extern MsgCreateVestingAccountResponseDefaultTypeInternal _MsgCreateVestingAccountResponse_default_instance_;
}  // namespace v1beta1
}  // namespace vesting
}  // namespace cosmos
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmos::vesting::v1beta1::MsgCreatePeriodicVestingAccount* Arena::CreateMaybeMessage<::cosmos::vesting::v1beta1::MsgCreatePeriodicVestingAccount>(Arena*);
template <>
::cosmos::vesting::v1beta1::MsgCreatePeriodicVestingAccountResponse* Arena::CreateMaybeMessage<::cosmos::vesting::v1beta1::MsgCreatePeriodicVestingAccountResponse>(Arena*);
template <>
::cosmos::vesting::v1beta1::MsgCreatePermanentLockedAccount* Arena::CreateMaybeMessage<::cosmos::vesting::v1beta1::MsgCreatePermanentLockedAccount>(Arena*);
template <>
::cosmos::vesting::v1beta1::MsgCreatePermanentLockedAccountResponse* Arena::CreateMaybeMessage<::cosmos::vesting::v1beta1::MsgCreatePermanentLockedAccountResponse>(Arena*);
template <>
::cosmos::vesting::v1beta1::MsgCreateVestingAccount* Arena::CreateMaybeMessage<::cosmos::vesting::v1beta1::MsgCreateVestingAccount>(Arena*);
template <>
::cosmos::vesting::v1beta1::MsgCreateVestingAccountResponse* Arena::CreateMaybeMessage<::cosmos::vesting::v1beta1::MsgCreateVestingAccountResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmos {
namespace vesting {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class MsgCreateVestingAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.vesting.v1beta1.MsgCreateVestingAccount) */ {
 public:
  inline MsgCreateVestingAccount() : MsgCreateVestingAccount(nullptr) {}
  ~MsgCreateVestingAccount() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateVestingAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateVestingAccount(const MsgCreateVestingAccount& from);
  MsgCreateVestingAccount(MsgCreateVestingAccount&& from) noexcept
    : MsgCreateVestingAccount() {
    *this = ::std::move(from);
  }

  inline MsgCreateVestingAccount& operator=(const MsgCreateVestingAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateVestingAccount& operator=(MsgCreateVestingAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateVestingAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateVestingAccount* internal_default_instance() {
    return reinterpret_cast<const MsgCreateVestingAccount*>(
               &_MsgCreateVestingAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgCreateVestingAccount& a, MsgCreateVestingAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateVestingAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateVestingAccount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateVestingAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateVestingAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateVestingAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateVestingAccount& from) {
    MsgCreateVestingAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateVestingAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.vesting.v1beta1.MsgCreateVestingAccount";
  }
  protected:
  explicit MsgCreateVestingAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 3,
    kFromAddressFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kEndTimeFieldNumber = 4,
    kDelayedFieldNumber = 5,
  };
  // repeated .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int amount_size() const;
  private:
  int _internal_amount_size() const;

  public:
  void clear_amount() ;
  ::cosmos::base::v1beta1::Coin* mutable_amount(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_amount();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_amount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_amount();
  public:
  const ::cosmos::base::v1beta1::Coin& amount(int index) const;
  ::cosmos::base::v1beta1::Coin* add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      amount() const;
  // string from_address = 1 [json_name = "fromAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_from_address() ;
  const std::string& from_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_address(Arg_&& arg, Args_... args);
  std::string* mutable_from_address();
  PROTOBUF_NODISCARD std::string* release_from_address();
  void set_allocated_from_address(std::string* ptr);

  private:
  const std::string& _internal_from_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_address(
      const std::string& value);
  std::string* _internal_mutable_from_address();

  public:
  // string to_address = 2 [json_name = "toAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_to_address() ;
  const std::string& to_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to_address(Arg_&& arg, Args_... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* ptr);

  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(
      const std::string& value);
  std::string* _internal_mutable_to_address();

  public:
  // int64 end_time = 4 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // bool delayed = 5 [json_name = "delayed"];
  void clear_delayed() ;
  bool delayed() const;
  void set_delayed(bool value);

  private:
  bool _internal_delayed() const;
  void _internal_set_delayed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.vesting.v1beta1.MsgCreateVestingAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
    ::int64_t end_time_;
    bool delayed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fvesting_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateVestingAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse) */ {
 public:
  inline MsgCreateVestingAccountResponse() : MsgCreateVestingAccountResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateVestingAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateVestingAccountResponse(const MsgCreateVestingAccountResponse& from);
  MsgCreateVestingAccountResponse(MsgCreateVestingAccountResponse&& from) noexcept
    : MsgCreateVestingAccountResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateVestingAccountResponse& operator=(const MsgCreateVestingAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateVestingAccountResponse& operator=(MsgCreateVestingAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateVestingAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateVestingAccountResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateVestingAccountResponse*>(
               &_MsgCreateVestingAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgCreateVestingAccountResponse& a, MsgCreateVestingAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateVestingAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateVestingAccountResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateVestingAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateVestingAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgCreateVestingAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgCreateVestingAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse";
  }
  protected:
  explicit MsgCreateVestingAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_cosmos_2fvesting_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreatePermanentLockedAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount) */ {
 public:
  inline MsgCreatePermanentLockedAccount() : MsgCreatePermanentLockedAccount(nullptr) {}
  ~MsgCreatePermanentLockedAccount() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreatePermanentLockedAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreatePermanentLockedAccount(const MsgCreatePermanentLockedAccount& from);
  MsgCreatePermanentLockedAccount(MsgCreatePermanentLockedAccount&& from) noexcept
    : MsgCreatePermanentLockedAccount() {
    *this = ::std::move(from);
  }

  inline MsgCreatePermanentLockedAccount& operator=(const MsgCreatePermanentLockedAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreatePermanentLockedAccount& operator=(MsgCreatePermanentLockedAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreatePermanentLockedAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreatePermanentLockedAccount* internal_default_instance() {
    return reinterpret_cast<const MsgCreatePermanentLockedAccount*>(
               &_MsgCreatePermanentLockedAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgCreatePermanentLockedAccount& a, MsgCreatePermanentLockedAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreatePermanentLockedAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreatePermanentLockedAccount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreatePermanentLockedAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreatePermanentLockedAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreatePermanentLockedAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreatePermanentLockedAccount& from) {
    MsgCreatePermanentLockedAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreatePermanentLockedAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount";
  }
  protected:
  explicit MsgCreatePermanentLockedAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 3,
    kFromAddressFieldNumber = 1,
    kToAddressFieldNumber = 2,
  };
  // repeated .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int amount_size() const;
  private:
  int _internal_amount_size() const;

  public:
  void clear_amount() ;
  ::cosmos::base::v1beta1::Coin* mutable_amount(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_amount();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_amount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_amount();
  public:
  const ::cosmos::base::v1beta1::Coin& amount(int index) const;
  ::cosmos::base::v1beta1::Coin* add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      amount() const;
  // string from_address = 1 [json_name = "fromAddress", (.gogoproto.moretags) = "yaml:\"from_address\""];
  void clear_from_address() ;
  const std::string& from_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_address(Arg_&& arg, Args_... args);
  std::string* mutable_from_address();
  PROTOBUF_NODISCARD std::string* release_from_address();
  void set_allocated_from_address(std::string* ptr);

  private:
  const std::string& _internal_from_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_address(
      const std::string& value);
  std::string* _internal_mutable_from_address();

  public:
  // string to_address = 2 [json_name = "toAddress", (.gogoproto.moretags) = "yaml:\"to_address\""];
  void clear_to_address() ;
  const std::string& to_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to_address(Arg_&& arg, Args_... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* ptr);

  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(
      const std::string& value);
  std::string* _internal_mutable_to_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fvesting_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreatePermanentLockedAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse) */ {
 public:
  inline MsgCreatePermanentLockedAccountResponse() : MsgCreatePermanentLockedAccountResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreatePermanentLockedAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreatePermanentLockedAccountResponse(const MsgCreatePermanentLockedAccountResponse& from);
  MsgCreatePermanentLockedAccountResponse(MsgCreatePermanentLockedAccountResponse&& from) noexcept
    : MsgCreatePermanentLockedAccountResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreatePermanentLockedAccountResponse& operator=(const MsgCreatePermanentLockedAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreatePermanentLockedAccountResponse& operator=(MsgCreatePermanentLockedAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreatePermanentLockedAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreatePermanentLockedAccountResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreatePermanentLockedAccountResponse*>(
               &_MsgCreatePermanentLockedAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgCreatePermanentLockedAccountResponse& a, MsgCreatePermanentLockedAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreatePermanentLockedAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreatePermanentLockedAccountResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreatePermanentLockedAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreatePermanentLockedAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgCreatePermanentLockedAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgCreatePermanentLockedAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse";
  }
  protected:
  explicit MsgCreatePermanentLockedAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_cosmos_2fvesting_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreatePeriodicVestingAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount) */ {
 public:
  inline MsgCreatePeriodicVestingAccount() : MsgCreatePeriodicVestingAccount(nullptr) {}
  ~MsgCreatePeriodicVestingAccount() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreatePeriodicVestingAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreatePeriodicVestingAccount(const MsgCreatePeriodicVestingAccount& from);
  MsgCreatePeriodicVestingAccount(MsgCreatePeriodicVestingAccount&& from) noexcept
    : MsgCreatePeriodicVestingAccount() {
    *this = ::std::move(from);
  }

  inline MsgCreatePeriodicVestingAccount& operator=(const MsgCreatePeriodicVestingAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreatePeriodicVestingAccount& operator=(MsgCreatePeriodicVestingAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreatePeriodicVestingAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreatePeriodicVestingAccount* internal_default_instance() {
    return reinterpret_cast<const MsgCreatePeriodicVestingAccount*>(
               &_MsgCreatePeriodicVestingAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgCreatePeriodicVestingAccount& a, MsgCreatePeriodicVestingAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreatePeriodicVestingAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreatePeriodicVestingAccount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreatePeriodicVestingAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreatePeriodicVestingAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreatePeriodicVestingAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreatePeriodicVestingAccount& from) {
    MsgCreatePeriodicVestingAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreatePeriodicVestingAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount";
  }
  protected:
  explicit MsgCreatePeriodicVestingAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVestingPeriodsFieldNumber = 4,
    kFromAddressFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kStartTimeFieldNumber = 3,
  };
  // repeated .cosmos.vesting.v1beta1.Period vesting_periods = 4 [json_name = "vestingPeriods", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int vesting_periods_size() const;
  private:
  int _internal_vesting_periods_size() const;

  public:
  void clear_vesting_periods() ;
  ::cosmos::vesting::v1beta1::Period* mutable_vesting_periods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::vesting::v1beta1::Period >*
      mutable_vesting_periods();
  private:
  const ::cosmos::vesting::v1beta1::Period& _internal_vesting_periods(int index) const;
  ::cosmos::vesting::v1beta1::Period* _internal_add_vesting_periods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::vesting::v1beta1::Period>& _internal_vesting_periods() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::vesting::v1beta1::Period>* _internal_mutable_vesting_periods();
  public:
  const ::cosmos::vesting::v1beta1::Period& vesting_periods(int index) const;
  ::cosmos::vesting::v1beta1::Period* add_vesting_periods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::vesting::v1beta1::Period >&
      vesting_periods() const;
  // string from_address = 1 [json_name = "fromAddress"];
  void clear_from_address() ;
  const std::string& from_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_address(Arg_&& arg, Args_... args);
  std::string* mutable_from_address();
  PROTOBUF_NODISCARD std::string* release_from_address();
  void set_allocated_from_address(std::string* ptr);

  private:
  const std::string& _internal_from_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_address(
      const std::string& value);
  std::string* _internal_mutable_from_address();

  public:
  // string to_address = 2 [json_name = "toAddress"];
  void clear_to_address() ;
  const std::string& to_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to_address(Arg_&& arg, Args_... args);
  std::string* mutable_to_address();
  PROTOBUF_NODISCARD std::string* release_to_address();
  void set_allocated_to_address(std::string* ptr);

  private:
  const std::string& _internal_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_address(
      const std::string& value);
  std::string* _internal_mutable_to_address();

  public:
  // int64 start_time = 3 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::vesting::v1beta1::Period > vesting_periods_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_address_;
    ::int64_t start_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fvesting_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreatePeriodicVestingAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse) */ {
 public:
  inline MsgCreatePeriodicVestingAccountResponse() : MsgCreatePeriodicVestingAccountResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreatePeriodicVestingAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreatePeriodicVestingAccountResponse(const MsgCreatePeriodicVestingAccountResponse& from);
  MsgCreatePeriodicVestingAccountResponse(MsgCreatePeriodicVestingAccountResponse&& from) noexcept
    : MsgCreatePeriodicVestingAccountResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreatePeriodicVestingAccountResponse& operator=(const MsgCreatePeriodicVestingAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreatePeriodicVestingAccountResponse& operator=(MsgCreatePeriodicVestingAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreatePeriodicVestingAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreatePeriodicVestingAccountResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreatePeriodicVestingAccountResponse*>(
               &_MsgCreatePeriodicVestingAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgCreatePeriodicVestingAccountResponse& a, MsgCreatePeriodicVestingAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreatePeriodicVestingAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreatePeriodicVestingAccountResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreatePeriodicVestingAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreatePeriodicVestingAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgCreatePeriodicVestingAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgCreatePeriodicVestingAccountResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse";
  }
  protected:
  explicit MsgCreatePeriodicVestingAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_cosmos_2fvesting_2fv1beta1_2ftx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MsgCreateVestingAccount

// string from_address = 1 [json_name = "fromAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void MsgCreateVestingAccount::clear_from_address() {
  _impl_.from_address_.ClearToEmpty();
}
inline const std::string& MsgCreateVestingAccount::from_address() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreateVestingAccount.from_address)
  return _internal_from_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateVestingAccount::set_from_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.from_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreateVestingAccount.from_address)
}
inline std::string* MsgCreateVestingAccount::mutable_from_address() {
  std::string* _s = _internal_mutable_from_address();
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreateVestingAccount.from_address)
  return _s;
}
inline const std::string& MsgCreateVestingAccount::_internal_from_address() const {
  return _impl_.from_address_.Get();
}
inline void MsgCreateVestingAccount::_internal_set_from_address(const std::string& value) {
  ;


  _impl_.from_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateVestingAccount::_internal_mutable_from_address() {
  ;
  return _impl_.from_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateVestingAccount::release_from_address() {
  // @@protoc_insertion_point(field_release:cosmos.vesting.v1beta1.MsgCreateVestingAccount.from_address)
  return _impl_.from_address_.Release();
}
inline void MsgCreateVestingAccount::set_allocated_from_address(std::string* value) {
  _impl_.from_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_address_.IsDefault()) {
          _impl_.from_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.vesting.v1beta1.MsgCreateVestingAccount.from_address)
}

// string to_address = 2 [json_name = "toAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void MsgCreateVestingAccount::clear_to_address() {
  _impl_.to_address_.ClearToEmpty();
}
inline const std::string& MsgCreateVestingAccount::to_address() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreateVestingAccount.to_address)
  return _internal_to_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateVestingAccount::set_to_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.to_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreateVestingAccount.to_address)
}
inline std::string* MsgCreateVestingAccount::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreateVestingAccount.to_address)
  return _s;
}
inline const std::string& MsgCreateVestingAccount::_internal_to_address() const {
  return _impl_.to_address_.Get();
}
inline void MsgCreateVestingAccount::_internal_set_to_address(const std::string& value) {
  ;


  _impl_.to_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateVestingAccount::_internal_mutable_to_address() {
  ;
  return _impl_.to_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateVestingAccount::release_to_address() {
  // @@protoc_insertion_point(field_release:cosmos.vesting.v1beta1.MsgCreateVestingAccount.to_address)
  return _impl_.to_address_.Release();
}
inline void MsgCreateVestingAccount::set_allocated_to_address(std::string* value) {
  _impl_.to_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_address_.IsDefault()) {
          _impl_.to_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.vesting.v1beta1.MsgCreateVestingAccount.to_address)
}

// repeated .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int MsgCreateVestingAccount::_internal_amount_size() const {
  return _impl_.amount_.size();
}
inline int MsgCreateVestingAccount::amount_size() const {
  return _internal_amount_size();
}
inline ::cosmos::base::v1beta1::Coin* MsgCreateVestingAccount::mutable_amount(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreateVestingAccount.amount)
  return _internal_mutable_amount()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
MsgCreateVestingAccount::mutable_amount() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.vesting.v1beta1.MsgCreateVestingAccount.amount)
  return _internal_mutable_amount();
}
inline const ::cosmos::base::v1beta1::Coin& MsgCreateVestingAccount::_internal_amount(int index) const {
  return _internal_amount().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& MsgCreateVestingAccount::amount(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreateVestingAccount.amount)
  return _internal_amount(index);
}
inline ::cosmos::base::v1beta1::Coin* MsgCreateVestingAccount::_internal_add_amount() {
  return _internal_mutable_amount()->Add();
}
inline ::cosmos::base::v1beta1::Coin* MsgCreateVestingAccount::add_amount() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_amount();
  // @@protoc_insertion_point(field_add:cosmos.vesting.v1beta1.MsgCreateVestingAccount.amount)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
MsgCreateVestingAccount::amount() const {
  // @@protoc_insertion_point(field_list:cosmos.vesting.v1beta1.MsgCreateVestingAccount.amount)
  return _internal_amount();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
MsgCreateVestingAccount::_internal_amount() const {
  return _impl_.amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
MsgCreateVestingAccount::_internal_mutable_amount() {
  return &_impl_.amount_;
}

// int64 end_time = 4 [json_name = "endTime"];
inline void MsgCreateVestingAccount::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t MsgCreateVestingAccount::end_time() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreateVestingAccount.end_time)
  return _internal_end_time();
}
inline void MsgCreateVestingAccount::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreateVestingAccount.end_time)
}
inline ::int64_t MsgCreateVestingAccount::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void MsgCreateVestingAccount::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// bool delayed = 5 [json_name = "delayed"];
inline void MsgCreateVestingAccount::clear_delayed() {
  _impl_.delayed_ = false;
}
inline bool MsgCreateVestingAccount::delayed() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreateVestingAccount.delayed)
  return _internal_delayed();
}
inline void MsgCreateVestingAccount::set_delayed(bool value) {
  _internal_set_delayed(value);
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreateVestingAccount.delayed)
}
inline bool MsgCreateVestingAccount::_internal_delayed() const {
  return _impl_.delayed_;
}
inline void MsgCreateVestingAccount::_internal_set_delayed(bool value) {
  ;
  _impl_.delayed_ = value;
}

// -------------------------------------------------------------------

// MsgCreateVestingAccountResponse

// -------------------------------------------------------------------

// MsgCreatePermanentLockedAccount

// string from_address = 1 [json_name = "fromAddress", (.gogoproto.moretags) = "yaml:\"from_address\""];
inline void MsgCreatePermanentLockedAccount::clear_from_address() {
  _impl_.from_address_.ClearToEmpty();
}
inline const std::string& MsgCreatePermanentLockedAccount::from_address() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.from_address)
  return _internal_from_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreatePermanentLockedAccount::set_from_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.from_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.from_address)
}
inline std::string* MsgCreatePermanentLockedAccount::mutable_from_address() {
  std::string* _s = _internal_mutable_from_address();
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.from_address)
  return _s;
}
inline const std::string& MsgCreatePermanentLockedAccount::_internal_from_address() const {
  return _impl_.from_address_.Get();
}
inline void MsgCreatePermanentLockedAccount::_internal_set_from_address(const std::string& value) {
  ;


  _impl_.from_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreatePermanentLockedAccount::_internal_mutable_from_address() {
  ;
  return _impl_.from_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreatePermanentLockedAccount::release_from_address() {
  // @@protoc_insertion_point(field_release:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.from_address)
  return _impl_.from_address_.Release();
}
inline void MsgCreatePermanentLockedAccount::set_allocated_from_address(std::string* value) {
  _impl_.from_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_address_.IsDefault()) {
          _impl_.from_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.from_address)
}

// string to_address = 2 [json_name = "toAddress", (.gogoproto.moretags) = "yaml:\"to_address\""];
inline void MsgCreatePermanentLockedAccount::clear_to_address() {
  _impl_.to_address_.ClearToEmpty();
}
inline const std::string& MsgCreatePermanentLockedAccount::to_address() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.to_address)
  return _internal_to_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreatePermanentLockedAccount::set_to_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.to_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.to_address)
}
inline std::string* MsgCreatePermanentLockedAccount::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.to_address)
  return _s;
}
inline const std::string& MsgCreatePermanentLockedAccount::_internal_to_address() const {
  return _impl_.to_address_.Get();
}
inline void MsgCreatePermanentLockedAccount::_internal_set_to_address(const std::string& value) {
  ;


  _impl_.to_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreatePermanentLockedAccount::_internal_mutable_to_address() {
  ;
  return _impl_.to_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreatePermanentLockedAccount::release_to_address() {
  // @@protoc_insertion_point(field_release:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.to_address)
  return _impl_.to_address_.Release();
}
inline void MsgCreatePermanentLockedAccount::set_allocated_to_address(std::string* value) {
  _impl_.to_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_address_.IsDefault()) {
          _impl_.to_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.to_address)
}

// repeated .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int MsgCreatePermanentLockedAccount::_internal_amount_size() const {
  return _impl_.amount_.size();
}
inline int MsgCreatePermanentLockedAccount::amount_size() const {
  return _internal_amount_size();
}
inline ::cosmos::base::v1beta1::Coin* MsgCreatePermanentLockedAccount::mutable_amount(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.amount)
  return _internal_mutable_amount()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
MsgCreatePermanentLockedAccount::mutable_amount() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.amount)
  return _internal_mutable_amount();
}
inline const ::cosmos::base::v1beta1::Coin& MsgCreatePermanentLockedAccount::_internal_amount(int index) const {
  return _internal_amount().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& MsgCreatePermanentLockedAccount::amount(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.amount)
  return _internal_amount(index);
}
inline ::cosmos::base::v1beta1::Coin* MsgCreatePermanentLockedAccount::_internal_add_amount() {
  return _internal_mutable_amount()->Add();
}
inline ::cosmos::base::v1beta1::Coin* MsgCreatePermanentLockedAccount::add_amount() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_amount();
  // @@protoc_insertion_point(field_add:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.amount)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
MsgCreatePermanentLockedAccount::amount() const {
  // @@protoc_insertion_point(field_list:cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount.amount)
  return _internal_amount();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
MsgCreatePermanentLockedAccount::_internal_amount() const {
  return _impl_.amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
MsgCreatePermanentLockedAccount::_internal_mutable_amount() {
  return &_impl_.amount_;
}

// -------------------------------------------------------------------

// MsgCreatePermanentLockedAccountResponse

// -------------------------------------------------------------------

// MsgCreatePeriodicVestingAccount

// string from_address = 1 [json_name = "fromAddress"];
inline void MsgCreatePeriodicVestingAccount::clear_from_address() {
  _impl_.from_address_.ClearToEmpty();
}
inline const std::string& MsgCreatePeriodicVestingAccount::from_address() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.from_address)
  return _internal_from_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreatePeriodicVestingAccount::set_from_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.from_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.from_address)
}
inline std::string* MsgCreatePeriodicVestingAccount::mutable_from_address() {
  std::string* _s = _internal_mutable_from_address();
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.from_address)
  return _s;
}
inline const std::string& MsgCreatePeriodicVestingAccount::_internal_from_address() const {
  return _impl_.from_address_.Get();
}
inline void MsgCreatePeriodicVestingAccount::_internal_set_from_address(const std::string& value) {
  ;


  _impl_.from_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreatePeriodicVestingAccount::_internal_mutable_from_address() {
  ;
  return _impl_.from_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreatePeriodicVestingAccount::release_from_address() {
  // @@protoc_insertion_point(field_release:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.from_address)
  return _impl_.from_address_.Release();
}
inline void MsgCreatePeriodicVestingAccount::set_allocated_from_address(std::string* value) {
  _impl_.from_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_address_.IsDefault()) {
          _impl_.from_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.from_address)
}

// string to_address = 2 [json_name = "toAddress"];
inline void MsgCreatePeriodicVestingAccount::clear_to_address() {
  _impl_.to_address_.ClearToEmpty();
}
inline const std::string& MsgCreatePeriodicVestingAccount::to_address() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.to_address)
  return _internal_to_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreatePeriodicVestingAccount::set_to_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.to_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.to_address)
}
inline std::string* MsgCreatePeriodicVestingAccount::mutable_to_address() {
  std::string* _s = _internal_mutable_to_address();
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.to_address)
  return _s;
}
inline const std::string& MsgCreatePeriodicVestingAccount::_internal_to_address() const {
  return _impl_.to_address_.Get();
}
inline void MsgCreatePeriodicVestingAccount::_internal_set_to_address(const std::string& value) {
  ;


  _impl_.to_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreatePeriodicVestingAccount::_internal_mutable_to_address() {
  ;
  return _impl_.to_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreatePeriodicVestingAccount::release_to_address() {
  // @@protoc_insertion_point(field_release:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.to_address)
  return _impl_.to_address_.Release();
}
inline void MsgCreatePeriodicVestingAccount::set_allocated_to_address(std::string* value) {
  _impl_.to_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_address_.IsDefault()) {
          _impl_.to_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.to_address)
}

// int64 start_time = 3 [json_name = "startTime"];
inline void MsgCreatePeriodicVestingAccount::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t MsgCreatePeriodicVestingAccount::start_time() const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.start_time)
  return _internal_start_time();
}
inline void MsgCreatePeriodicVestingAccount::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.start_time)
}
inline ::int64_t MsgCreatePeriodicVestingAccount::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void MsgCreatePeriodicVestingAccount::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// repeated .cosmos.vesting.v1beta1.Period vesting_periods = 4 [json_name = "vestingPeriods", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int MsgCreatePeriodicVestingAccount::_internal_vesting_periods_size() const {
  return _impl_.vesting_periods_.size();
}
inline int MsgCreatePeriodicVestingAccount::vesting_periods_size() const {
  return _internal_vesting_periods_size();
}
inline ::cosmos::vesting::v1beta1::Period* MsgCreatePeriodicVestingAccount::mutable_vesting_periods(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.vesting_periods)
  return _internal_mutable_vesting_periods()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::vesting::v1beta1::Period >*
MsgCreatePeriodicVestingAccount::mutable_vesting_periods() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.vesting_periods)
  return _internal_mutable_vesting_periods();
}
inline const ::cosmos::vesting::v1beta1::Period& MsgCreatePeriodicVestingAccount::_internal_vesting_periods(int index) const {
  return _internal_vesting_periods().Get(index);
}
inline const ::cosmos::vesting::v1beta1::Period& MsgCreatePeriodicVestingAccount::vesting_periods(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.vesting_periods)
  return _internal_vesting_periods(index);
}
inline ::cosmos::vesting::v1beta1::Period* MsgCreatePeriodicVestingAccount::_internal_add_vesting_periods() {
  return _internal_mutable_vesting_periods()->Add();
}
inline ::cosmos::vesting::v1beta1::Period* MsgCreatePeriodicVestingAccount::add_vesting_periods() {
  ::cosmos::vesting::v1beta1::Period* _add = _internal_add_vesting_periods();
  // @@protoc_insertion_point(field_add:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.vesting_periods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::vesting::v1beta1::Period >&
MsgCreatePeriodicVestingAccount::vesting_periods() const {
  // @@protoc_insertion_point(field_list:cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount.vesting_periods)
  return _internal_vesting_periods();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::vesting::v1beta1::Period>&
MsgCreatePeriodicVestingAccount::_internal_vesting_periods() const {
  return _impl_.vesting_periods_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::vesting::v1beta1::Period>*
MsgCreatePeriodicVestingAccount::_internal_mutable_vesting_periods() {
  return &_impl_.vesting_periods_;
}

// -------------------------------------------------------------------

// MsgCreatePeriodicVestingAccountResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace vesting
}  // namespace cosmos


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmos_2fvesting_2fv1beta1_2ftx_2eproto_2epb_2eh
