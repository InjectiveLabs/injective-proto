// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/distribution/v1beta1/distribution.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "amino/amino.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
namespace cosmos {
namespace distribution {
namespace v1beta1 {
class CommunityPoolSpendProposal;
struct CommunityPoolSpendProposalDefaultTypeInternal;
extern CommunityPoolSpendProposalDefaultTypeInternal _CommunityPoolSpendProposal_default_instance_;
class CommunityPoolSpendProposalWithDeposit;
struct CommunityPoolSpendProposalWithDepositDefaultTypeInternal;
extern CommunityPoolSpendProposalWithDepositDefaultTypeInternal _CommunityPoolSpendProposalWithDeposit_default_instance_;
class DelegationDelegatorReward;
struct DelegationDelegatorRewardDefaultTypeInternal;
extern DelegationDelegatorRewardDefaultTypeInternal _DelegationDelegatorReward_default_instance_;
class DelegatorStartingInfo;
struct DelegatorStartingInfoDefaultTypeInternal;
extern DelegatorStartingInfoDefaultTypeInternal _DelegatorStartingInfo_default_instance_;
class FeePool;
struct FeePoolDefaultTypeInternal;
extern FeePoolDefaultTypeInternal _FeePool_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
class ValidatorAccumulatedCommission;
struct ValidatorAccumulatedCommissionDefaultTypeInternal;
extern ValidatorAccumulatedCommissionDefaultTypeInternal _ValidatorAccumulatedCommission_default_instance_;
class ValidatorCurrentRewards;
struct ValidatorCurrentRewardsDefaultTypeInternal;
extern ValidatorCurrentRewardsDefaultTypeInternal _ValidatorCurrentRewards_default_instance_;
class ValidatorHistoricalRewards;
struct ValidatorHistoricalRewardsDefaultTypeInternal;
extern ValidatorHistoricalRewardsDefaultTypeInternal _ValidatorHistoricalRewards_default_instance_;
class ValidatorOutstandingRewards;
struct ValidatorOutstandingRewardsDefaultTypeInternal;
extern ValidatorOutstandingRewardsDefaultTypeInternal _ValidatorOutstandingRewards_default_instance_;
class ValidatorSlashEvent;
struct ValidatorSlashEventDefaultTypeInternal;
extern ValidatorSlashEventDefaultTypeInternal _ValidatorSlashEvent_default_instance_;
class ValidatorSlashEvents;
struct ValidatorSlashEventsDefaultTypeInternal;
extern ValidatorSlashEventsDefaultTypeInternal _ValidatorSlashEvents_default_instance_;
}  // namespace v1beta1
}  // namespace distribution
}  // namespace cosmos
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::CommunityPoolSpendProposal>(Arena*);
template <>
::cosmos::distribution::v1beta1::CommunityPoolSpendProposalWithDeposit* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::CommunityPoolSpendProposalWithDeposit>(Arena*);
template <>
::cosmos::distribution::v1beta1::DelegationDelegatorReward* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::DelegationDelegatorReward>(Arena*);
template <>
::cosmos::distribution::v1beta1::DelegatorStartingInfo* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::DelegatorStartingInfo>(Arena*);
template <>
::cosmos::distribution::v1beta1::FeePool* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::FeePool>(Arena*);
template <>
::cosmos::distribution::v1beta1::Params* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::Params>(Arena*);
template <>
::cosmos::distribution::v1beta1::ValidatorAccumulatedCommission* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::ValidatorAccumulatedCommission>(Arena*);
template <>
::cosmos::distribution::v1beta1::ValidatorCurrentRewards* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::ValidatorCurrentRewards>(Arena*);
template <>
::cosmos::distribution::v1beta1::ValidatorHistoricalRewards* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::ValidatorHistoricalRewards>(Arena*);
template <>
::cosmos::distribution::v1beta1::ValidatorOutstandingRewards* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::ValidatorOutstandingRewards>(Arena*);
template <>
::cosmos::distribution::v1beta1::ValidatorSlashEvent* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::ValidatorSlashEvent>(Arena*);
template <>
::cosmos::distribution::v1beta1::ValidatorSlashEvents* Arena::CreateMaybeMessage<::cosmos::distribution::v1beta1::ValidatorSlashEvents>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmos {
namespace distribution {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Params(const Params& from);
  Params(Params&& from) noexcept
    : Params() {
    *this = ::std::move(from);
  }

  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
               &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Params& a, Params& b) {
    a.Swap(&b);
  }
  inline void Swap(Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Params& from) {
    Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.Params";
  }
  protected:
  explicit Params(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommunityTaxFieldNumber = 1,
    kBaseProposerRewardFieldNumber = 2,
    kBonusProposerRewardFieldNumber = 3,
    kWithdrawAddrEnabledFieldNumber = 4,
  };
  // string community_tax = 1 [json_name = "communityTax", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_community_tax() ;
  const std::string& community_tax() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_community_tax(Arg_&& arg, Args_... args);
  std::string* mutable_community_tax();
  PROTOBUF_NODISCARD std::string* release_community_tax();
  void set_allocated_community_tax(std::string* ptr);

  private:
  const std::string& _internal_community_tax() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_community_tax(
      const std::string& value);
  std::string* _internal_mutable_community_tax();

  public:
  // string base_proposer_reward = 2 [json_name = "baseProposerReward", deprecated = true, (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  [[deprecated]]  void clear_base_proposer_reward() ;
  [[deprecated]] const std::string& base_proposer_reward() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_base_proposer_reward(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_base_proposer_reward();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_base_proposer_reward();
  [[deprecated]] void set_allocated_base_proposer_reward(std::string* ptr);

  private:
  const std::string& _internal_base_proposer_reward() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_proposer_reward(
      const std::string& value);
  std::string* _internal_mutable_base_proposer_reward();

  public:
  // string bonus_proposer_reward = 3 [json_name = "bonusProposerReward", deprecated = true, (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  [[deprecated]]  void clear_bonus_proposer_reward() ;
  [[deprecated]] const std::string& bonus_proposer_reward() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_bonus_proposer_reward(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_bonus_proposer_reward();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_bonus_proposer_reward();
  [[deprecated]] void set_allocated_bonus_proposer_reward(std::string* ptr);

  private:
  const std::string& _internal_bonus_proposer_reward() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bonus_proposer_reward(
      const std::string& value);
  std::string* _internal_mutable_bonus_proposer_reward();

  public:
  // bool withdraw_addr_enabled = 4 [json_name = "withdrawAddrEnabled"];
  void clear_withdraw_addr_enabled() ;
  bool withdraw_addr_enabled() const;
  void set_withdraw_addr_enabled(bool value);

  private:
  bool _internal_withdraw_addr_enabled() const;
  void _internal_set_withdraw_addr_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr community_tax_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_proposer_reward_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bonus_proposer_reward_;
    bool withdraw_addr_enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class ValidatorHistoricalRewards final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.ValidatorHistoricalRewards) */ {
 public:
  inline ValidatorHistoricalRewards() : ValidatorHistoricalRewards(nullptr) {}
  ~ValidatorHistoricalRewards() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorHistoricalRewards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorHistoricalRewards(const ValidatorHistoricalRewards& from);
  ValidatorHistoricalRewards(ValidatorHistoricalRewards&& from) noexcept
    : ValidatorHistoricalRewards() {
    *this = ::std::move(from);
  }

  inline ValidatorHistoricalRewards& operator=(const ValidatorHistoricalRewards& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorHistoricalRewards& operator=(ValidatorHistoricalRewards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorHistoricalRewards& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorHistoricalRewards* internal_default_instance() {
    return reinterpret_cast<const ValidatorHistoricalRewards*>(
               &_ValidatorHistoricalRewards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ValidatorHistoricalRewards& a, ValidatorHistoricalRewards& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorHistoricalRewards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorHistoricalRewards* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorHistoricalRewards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorHistoricalRewards>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorHistoricalRewards& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorHistoricalRewards& from) {
    ValidatorHistoricalRewards::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorHistoricalRewards* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.ValidatorHistoricalRewards";
  }
  protected:
  explicit ValidatorHistoricalRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCumulativeRewardRatioFieldNumber = 1,
    kReferenceCountFieldNumber = 2,
  };
  // repeated .cosmos.base.v1beta1.DecCoin cumulative_reward_ratio = 1 [json_name = "cumulativeRewardRatio", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
  int cumulative_reward_ratio_size() const;
  private:
  int _internal_cumulative_reward_ratio_size() const;

  public:
  void clear_cumulative_reward_ratio() ;
  ::cosmos::base::v1beta1::DecCoin* mutable_cumulative_reward_ratio(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
      mutable_cumulative_reward_ratio();
  private:
  const ::cosmos::base::v1beta1::DecCoin& _internal_cumulative_reward_ratio(int index) const;
  ::cosmos::base::v1beta1::DecCoin* _internal_add_cumulative_reward_ratio();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>& _internal_cumulative_reward_ratio() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>* _internal_mutable_cumulative_reward_ratio();
  public:
  const ::cosmos::base::v1beta1::DecCoin& cumulative_reward_ratio(int index) const;
  ::cosmos::base::v1beta1::DecCoin* add_cumulative_reward_ratio();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
      cumulative_reward_ratio() const;
  // uint32 reference_count = 2 [json_name = "referenceCount"];
  void clear_reference_count() ;
  ::uint32_t reference_count() const;
  void set_reference_count(::uint32_t value);

  private:
  ::uint32_t _internal_reference_count() const;
  void _internal_set_reference_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.ValidatorHistoricalRewards)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin > cumulative_reward_ratio_;
    ::uint32_t reference_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class ValidatorCurrentRewards final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.ValidatorCurrentRewards) */ {
 public:
  inline ValidatorCurrentRewards() : ValidatorCurrentRewards(nullptr) {}
  ~ValidatorCurrentRewards() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorCurrentRewards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorCurrentRewards(const ValidatorCurrentRewards& from);
  ValidatorCurrentRewards(ValidatorCurrentRewards&& from) noexcept
    : ValidatorCurrentRewards() {
    *this = ::std::move(from);
  }

  inline ValidatorCurrentRewards& operator=(const ValidatorCurrentRewards& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorCurrentRewards& operator=(ValidatorCurrentRewards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorCurrentRewards& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorCurrentRewards* internal_default_instance() {
    return reinterpret_cast<const ValidatorCurrentRewards*>(
               &_ValidatorCurrentRewards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ValidatorCurrentRewards& a, ValidatorCurrentRewards& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorCurrentRewards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorCurrentRewards* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorCurrentRewards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorCurrentRewards>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorCurrentRewards& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorCurrentRewards& from) {
    ValidatorCurrentRewards::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorCurrentRewards* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.ValidatorCurrentRewards";
  }
  protected:
  explicit ValidatorCurrentRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardsFieldNumber = 1,
    kPeriodFieldNumber = 2,
  };
  // repeated .cosmos.base.v1beta1.DecCoin rewards = 1 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;

  public:
  void clear_rewards() ;
  ::cosmos::base::v1beta1::DecCoin* mutable_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
      mutable_rewards();
  private:
  const ::cosmos::base::v1beta1::DecCoin& _internal_rewards(int index) const;
  ::cosmos::base::v1beta1::DecCoin* _internal_add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>& _internal_rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>* _internal_mutable_rewards();
  public:
  const ::cosmos::base::v1beta1::DecCoin& rewards(int index) const;
  ::cosmos::base::v1beta1::DecCoin* add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
      rewards() const;
  // uint64 period = 2 [json_name = "period"];
  void clear_period() ;
  ::uint64_t period() const;
  void set_period(::uint64_t value);

  private:
  ::uint64_t _internal_period() const;
  void _internal_set_period(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.ValidatorCurrentRewards)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin > rewards_;
    ::uint64_t period_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class ValidatorAccumulatedCommission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission) */ {
 public:
  inline ValidatorAccumulatedCommission() : ValidatorAccumulatedCommission(nullptr) {}
  ~ValidatorAccumulatedCommission() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorAccumulatedCommission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorAccumulatedCommission(const ValidatorAccumulatedCommission& from);
  ValidatorAccumulatedCommission(ValidatorAccumulatedCommission&& from) noexcept
    : ValidatorAccumulatedCommission() {
    *this = ::std::move(from);
  }

  inline ValidatorAccumulatedCommission& operator=(const ValidatorAccumulatedCommission& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorAccumulatedCommission& operator=(ValidatorAccumulatedCommission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorAccumulatedCommission& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorAccumulatedCommission* internal_default_instance() {
    return reinterpret_cast<const ValidatorAccumulatedCommission*>(
               &_ValidatorAccumulatedCommission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ValidatorAccumulatedCommission& a, ValidatorAccumulatedCommission& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorAccumulatedCommission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorAccumulatedCommission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorAccumulatedCommission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorAccumulatedCommission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorAccumulatedCommission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorAccumulatedCommission& from) {
    ValidatorAccumulatedCommission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorAccumulatedCommission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission";
  }
  protected:
  explicit ValidatorAccumulatedCommission(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommissionFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.DecCoin commission = 1 [json_name = "commission", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
  int commission_size() const;
  private:
  int _internal_commission_size() const;

  public:
  void clear_commission() ;
  ::cosmos::base::v1beta1::DecCoin* mutable_commission(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
      mutable_commission();
  private:
  const ::cosmos::base::v1beta1::DecCoin& _internal_commission(int index) const;
  ::cosmos::base::v1beta1::DecCoin* _internal_add_commission();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>& _internal_commission() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>* _internal_mutable_commission();
  public:
  const ::cosmos::base::v1beta1::DecCoin& commission(int index) const;
  ::cosmos::base::v1beta1::DecCoin* add_commission();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
      commission() const;
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin > commission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class ValidatorOutstandingRewards final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.ValidatorOutstandingRewards) */ {
 public:
  inline ValidatorOutstandingRewards() : ValidatorOutstandingRewards(nullptr) {}
  ~ValidatorOutstandingRewards() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorOutstandingRewards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorOutstandingRewards(const ValidatorOutstandingRewards& from);
  ValidatorOutstandingRewards(ValidatorOutstandingRewards&& from) noexcept
    : ValidatorOutstandingRewards() {
    *this = ::std::move(from);
  }

  inline ValidatorOutstandingRewards& operator=(const ValidatorOutstandingRewards& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorOutstandingRewards& operator=(ValidatorOutstandingRewards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorOutstandingRewards& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorOutstandingRewards* internal_default_instance() {
    return reinterpret_cast<const ValidatorOutstandingRewards*>(
               &_ValidatorOutstandingRewards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ValidatorOutstandingRewards& a, ValidatorOutstandingRewards& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorOutstandingRewards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorOutstandingRewards* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorOutstandingRewards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorOutstandingRewards>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorOutstandingRewards& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorOutstandingRewards& from) {
    ValidatorOutstandingRewards::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorOutstandingRewards* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.ValidatorOutstandingRewards";
  }
  protected:
  explicit ValidatorOutstandingRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardsFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.DecCoin rewards = 1 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;

  public:
  void clear_rewards() ;
  ::cosmos::base::v1beta1::DecCoin* mutable_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
      mutable_rewards();
  private:
  const ::cosmos::base::v1beta1::DecCoin& _internal_rewards(int index) const;
  ::cosmos::base::v1beta1::DecCoin* _internal_add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>& _internal_rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>* _internal_mutable_rewards();
  public:
  const ::cosmos::base::v1beta1::DecCoin& rewards(int index) const;
  ::cosmos::base::v1beta1::DecCoin* add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
      rewards() const;
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.ValidatorOutstandingRewards)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin > rewards_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class ValidatorSlashEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.ValidatorSlashEvent) */ {
 public:
  inline ValidatorSlashEvent() : ValidatorSlashEvent(nullptr) {}
  ~ValidatorSlashEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorSlashEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorSlashEvent(const ValidatorSlashEvent& from);
  ValidatorSlashEvent(ValidatorSlashEvent&& from) noexcept
    : ValidatorSlashEvent() {
    *this = ::std::move(from);
  }

  inline ValidatorSlashEvent& operator=(const ValidatorSlashEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorSlashEvent& operator=(ValidatorSlashEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorSlashEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorSlashEvent* internal_default_instance() {
    return reinterpret_cast<const ValidatorSlashEvent*>(
               &_ValidatorSlashEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValidatorSlashEvent& a, ValidatorSlashEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorSlashEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorSlashEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorSlashEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorSlashEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorSlashEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorSlashEvent& from) {
    ValidatorSlashEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorSlashEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.ValidatorSlashEvent";
  }
  protected:
  explicit ValidatorSlashEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFractionFieldNumber = 2,
    kValidatorPeriodFieldNumber = 1,
  };
  // string fraction = 2 [json_name = "fraction", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_fraction() ;
  const std::string& fraction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fraction(Arg_&& arg, Args_... args);
  std::string* mutable_fraction();
  PROTOBUF_NODISCARD std::string* release_fraction();
  void set_allocated_fraction(std::string* ptr);

  private:
  const std::string& _internal_fraction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fraction(
      const std::string& value);
  std::string* _internal_mutable_fraction();

  public:
  // uint64 validator_period = 1 [json_name = "validatorPeriod"];
  void clear_validator_period() ;
  ::uint64_t validator_period() const;
  void set_validator_period(::uint64_t value);

  private:
  ::uint64_t _internal_validator_period() const;
  void _internal_set_validator_period(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.ValidatorSlashEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fraction_;
    ::uint64_t validator_period_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class ValidatorSlashEvents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.ValidatorSlashEvents) */ {
 public:
  inline ValidatorSlashEvents() : ValidatorSlashEvents(nullptr) {}
  ~ValidatorSlashEvents() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorSlashEvents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorSlashEvents(const ValidatorSlashEvents& from);
  ValidatorSlashEvents(ValidatorSlashEvents&& from) noexcept
    : ValidatorSlashEvents() {
    *this = ::std::move(from);
  }

  inline ValidatorSlashEvents& operator=(const ValidatorSlashEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorSlashEvents& operator=(ValidatorSlashEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorSlashEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorSlashEvents* internal_default_instance() {
    return reinterpret_cast<const ValidatorSlashEvents*>(
               &_ValidatorSlashEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ValidatorSlashEvents& a, ValidatorSlashEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorSlashEvents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorSlashEvents* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorSlashEvents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorSlashEvents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorSlashEvents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorSlashEvents& from) {
    ValidatorSlashEvents::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorSlashEvents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.ValidatorSlashEvents";
  }
  protected:
  explicit ValidatorSlashEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorSlashEventsFieldNumber = 1,
  };
  // repeated .cosmos.distribution.v1beta1.ValidatorSlashEvent validator_slash_events = 1 [json_name = "validatorSlashEvents", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int validator_slash_events_size() const;
  private:
  int _internal_validator_slash_events_size() const;

  public:
  void clear_validator_slash_events() ;
  ::cosmos::distribution::v1beta1::ValidatorSlashEvent* mutable_validator_slash_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::ValidatorSlashEvent >*
      mutable_validator_slash_events();
  private:
  const ::cosmos::distribution::v1beta1::ValidatorSlashEvent& _internal_validator_slash_events(int index) const;
  ::cosmos::distribution::v1beta1::ValidatorSlashEvent* _internal_add_validator_slash_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::ValidatorSlashEvent>& _internal_validator_slash_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::ValidatorSlashEvent>* _internal_mutable_validator_slash_events();
  public:
  const ::cosmos::distribution::v1beta1::ValidatorSlashEvent& validator_slash_events(int index) const;
  ::cosmos::distribution::v1beta1::ValidatorSlashEvent* add_validator_slash_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::ValidatorSlashEvent >&
      validator_slash_events() const;
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.ValidatorSlashEvents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::ValidatorSlashEvent > validator_slash_events_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class FeePool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.FeePool) */ {
 public:
  inline FeePool() : FeePool(nullptr) {}
  ~FeePool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeePool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeePool(const FeePool& from);
  FeePool(FeePool&& from) noexcept
    : FeePool() {
    *this = ::std::move(from);
  }

  inline FeePool& operator=(const FeePool& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeePool& operator=(FeePool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeePool& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeePool* internal_default_instance() {
    return reinterpret_cast<const FeePool*>(
               &_FeePool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FeePool& a, FeePool& b) {
    a.Swap(&b);
  }
  inline void Swap(FeePool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeePool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeePool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeePool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeePool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeePool& from) {
    FeePool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeePool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.FeePool";
  }
  protected:
  explicit FeePool(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommunityPoolFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.DecCoin community_pool = 1 [json_name = "communityPool", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
  int community_pool_size() const;
  private:
  int _internal_community_pool_size() const;

  public:
  void clear_community_pool() ;
  ::cosmos::base::v1beta1::DecCoin* mutable_community_pool(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
      mutable_community_pool();
  private:
  const ::cosmos::base::v1beta1::DecCoin& _internal_community_pool(int index) const;
  ::cosmos::base::v1beta1::DecCoin* _internal_add_community_pool();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>& _internal_community_pool() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>* _internal_mutable_community_pool();
  public:
  const ::cosmos::base::v1beta1::DecCoin& community_pool(int index) const;
  ::cosmos::base::v1beta1::DecCoin* add_community_pool();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
      community_pool() const;
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.FeePool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin > community_pool_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class CommunityPoolSpendProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.CommunityPoolSpendProposal) */ {
 public:
  inline CommunityPoolSpendProposal() : CommunityPoolSpendProposal(nullptr) {}
  ~CommunityPoolSpendProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommunityPoolSpendProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommunityPoolSpendProposal(const CommunityPoolSpendProposal& from);
  CommunityPoolSpendProposal(CommunityPoolSpendProposal&& from) noexcept
    : CommunityPoolSpendProposal() {
    *this = ::std::move(from);
  }

  inline CommunityPoolSpendProposal& operator=(const CommunityPoolSpendProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommunityPoolSpendProposal& operator=(CommunityPoolSpendProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommunityPoolSpendProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommunityPoolSpendProposal* internal_default_instance() {
    return reinterpret_cast<const CommunityPoolSpendProposal*>(
               &_CommunityPoolSpendProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CommunityPoolSpendProposal& a, CommunityPoolSpendProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(CommunityPoolSpendProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommunityPoolSpendProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommunityPoolSpendProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommunityPoolSpendProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommunityPoolSpendProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommunityPoolSpendProposal& from) {
    CommunityPoolSpendProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommunityPoolSpendProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.CommunityPoolSpendProposal";
  }
  protected:
  explicit CommunityPoolSpendProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 4,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRecipientFieldNumber = 3,
  };
  // repeated .cosmos.base.v1beta1.Coin amount = 4 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int amount_size() const;
  private:
  int _internal_amount_size() const;

  public:
  void clear_amount() ;
  ::cosmos::base::v1beta1::Coin* mutable_amount(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_amount();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_amount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_amount();
  public:
  const ::cosmos::base::v1beta1::Coin& amount(int index) const;
  ::cosmos::base::v1beta1::Coin* add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      amount() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string recipient = 3 [json_name = "recipient"];
  void clear_recipient() ;
  const std::string& recipient() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_recipient();
  PROTOBUF_NODISCARD std::string* release_recipient();
  void set_allocated_recipient(std::string* ptr);

  private:
  const std::string& _internal_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient(
      const std::string& value);
  std::string* _internal_mutable_recipient();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.CommunityPoolSpendProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class DelegatorStartingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.DelegatorStartingInfo) */ {
 public:
  inline DelegatorStartingInfo() : DelegatorStartingInfo(nullptr) {}
  ~DelegatorStartingInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DelegatorStartingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegatorStartingInfo(const DelegatorStartingInfo& from);
  DelegatorStartingInfo(DelegatorStartingInfo&& from) noexcept
    : DelegatorStartingInfo() {
    *this = ::std::move(from);
  }

  inline DelegatorStartingInfo& operator=(const DelegatorStartingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatorStartingInfo& operator=(DelegatorStartingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegatorStartingInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegatorStartingInfo* internal_default_instance() {
    return reinterpret_cast<const DelegatorStartingInfo*>(
               &_DelegatorStartingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DelegatorStartingInfo& a, DelegatorStartingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatorStartingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatorStartingInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegatorStartingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegatorStartingInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegatorStartingInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegatorStartingInfo& from) {
    DelegatorStartingInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatorStartingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.DelegatorStartingInfo";
  }
  protected:
  explicit DelegatorStartingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakeFieldNumber = 2,
    kPreviousPeriodFieldNumber = 1,
    kHeightFieldNumber = 3,
  };
  // string stake = 2 [json_name = "stake", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_stake() ;
  const std::string& stake() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stake(Arg_&& arg, Args_... args);
  std::string* mutable_stake();
  PROTOBUF_NODISCARD std::string* release_stake();
  void set_allocated_stake(std::string* ptr);

  private:
  const std::string& _internal_stake() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stake(
      const std::string& value);
  std::string* _internal_mutable_stake();

  public:
  // uint64 previous_period = 1 [json_name = "previousPeriod"];
  void clear_previous_period() ;
  ::uint64_t previous_period() const;
  void set_previous_period(::uint64_t value);

  private:
  ::uint64_t _internal_previous_period() const;
  void _internal_set_previous_period(::uint64_t value);

  public:
  // uint64 height = 3 [json_name = "height", (.gogoproto.jsontag) = "creation_height", (.amino.field_name) = "creation_height", (.amino.dont_omitempty) = true];
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.DelegatorStartingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stake_;
    ::uint64_t previous_period_;
    ::uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class DelegationDelegatorReward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.DelegationDelegatorReward) */ {
 public:
  inline DelegationDelegatorReward() : DelegationDelegatorReward(nullptr) {}
  ~DelegationDelegatorReward() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DelegationDelegatorReward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegationDelegatorReward(const DelegationDelegatorReward& from);
  DelegationDelegatorReward(DelegationDelegatorReward&& from) noexcept
    : DelegationDelegatorReward() {
    *this = ::std::move(from);
  }

  inline DelegationDelegatorReward& operator=(const DelegationDelegatorReward& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegationDelegatorReward& operator=(DelegationDelegatorReward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegationDelegatorReward& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegationDelegatorReward* internal_default_instance() {
    return reinterpret_cast<const DelegationDelegatorReward*>(
               &_DelegationDelegatorReward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DelegationDelegatorReward& a, DelegationDelegatorReward& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegationDelegatorReward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegationDelegatorReward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegationDelegatorReward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegationDelegatorReward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegationDelegatorReward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegationDelegatorReward& from) {
    DelegationDelegatorReward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegationDelegatorReward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.DelegationDelegatorReward";
  }
  protected:
  explicit DelegationDelegatorReward(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardFieldNumber = 2,
    kValidatorAddressFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.DecCoin reward = 2 [json_name = "reward", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
  int reward_size() const;
  private:
  int _internal_reward_size() const;

  public:
  void clear_reward() ;
  ::cosmos::base::v1beta1::DecCoin* mutable_reward(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
      mutable_reward();
  private:
  const ::cosmos::base::v1beta1::DecCoin& _internal_reward(int index) const;
  ::cosmos::base::v1beta1::DecCoin* _internal_add_reward();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>& _internal_reward() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>* _internal_mutable_reward();
  public:
  const ::cosmos::base::v1beta1::DecCoin& reward(int index) const;
  ::cosmos::base::v1beta1::DecCoin* add_reward();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
      reward() const;
  // string validator_address = 1 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.DelegationDelegatorReward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin > reward_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};// -------------------------------------------------------------------

class CommunityPoolSpendProposalWithDeposit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit) */ {
 public:
  inline CommunityPoolSpendProposalWithDeposit() : CommunityPoolSpendProposalWithDeposit(nullptr) {}
  ~CommunityPoolSpendProposalWithDeposit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommunityPoolSpendProposalWithDeposit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommunityPoolSpendProposalWithDeposit(const CommunityPoolSpendProposalWithDeposit& from);
  CommunityPoolSpendProposalWithDeposit(CommunityPoolSpendProposalWithDeposit&& from) noexcept
    : CommunityPoolSpendProposalWithDeposit() {
    *this = ::std::move(from);
  }

  inline CommunityPoolSpendProposalWithDeposit& operator=(const CommunityPoolSpendProposalWithDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommunityPoolSpendProposalWithDeposit& operator=(CommunityPoolSpendProposalWithDeposit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommunityPoolSpendProposalWithDeposit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommunityPoolSpendProposalWithDeposit* internal_default_instance() {
    return reinterpret_cast<const CommunityPoolSpendProposalWithDeposit*>(
               &_CommunityPoolSpendProposalWithDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommunityPoolSpendProposalWithDeposit& a, CommunityPoolSpendProposalWithDeposit& b) {
    a.Swap(&b);
  }
  inline void Swap(CommunityPoolSpendProposalWithDeposit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommunityPoolSpendProposalWithDeposit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommunityPoolSpendProposalWithDeposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommunityPoolSpendProposalWithDeposit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommunityPoolSpendProposalWithDeposit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommunityPoolSpendProposalWithDeposit& from) {
    CommunityPoolSpendProposalWithDeposit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommunityPoolSpendProposalWithDeposit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit";
  }
  protected:
  explicit CommunityPoolSpendProposalWithDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRecipientFieldNumber = 3,
    kAmountFieldNumber = 4,
    kDepositFieldNumber = 5,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string recipient = 3 [json_name = "recipient"];
  void clear_recipient() ;
  const std::string& recipient() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_recipient();
  PROTOBUF_NODISCARD std::string* release_recipient();
  void set_allocated_recipient(std::string* ptr);

  private:
  const std::string& _internal_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient(
      const std::string& value);
  std::string* _internal_mutable_recipient();

  public:
  // string amount = 4 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // string deposit = 5 [json_name = "deposit"];
  void clear_deposit() ;
  const std::string& deposit() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_deposit(Arg_&& arg, Args_... args);
  std::string* mutable_deposit();
  PROTOBUF_NODISCARD std::string* release_deposit();
  void set_allocated_deposit(std::string* ptr);

  private:
  const std::string& _internal_deposit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deposit(
      const std::string& value);
  std::string* _internal_mutable_deposit();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deposit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Params

// string community_tax = 1 [json_name = "communityTax", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void Params::clear_community_tax() {
  _impl_.community_tax_.ClearToEmpty();
}
inline const std::string& Params::community_tax() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.Params.community_tax)
  return _internal_community_tax();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_community_tax(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.community_tax_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.Params.community_tax)
}
inline std::string* Params::mutable_community_tax() {
  std::string* _s = _internal_mutable_community_tax();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.Params.community_tax)
  return _s;
}
inline const std::string& Params::_internal_community_tax() const {
  return _impl_.community_tax_.Get();
}
inline void Params::_internal_set_community_tax(const std::string& value) {
  ;


  _impl_.community_tax_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_community_tax() {
  ;
  return _impl_.community_tax_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_community_tax() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.Params.community_tax)
  return _impl_.community_tax_.Release();
}
inline void Params::set_allocated_community_tax(std::string* value) {
  _impl_.community_tax_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.community_tax_.IsDefault()) {
          _impl_.community_tax_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.Params.community_tax)
}

// string base_proposer_reward = 2 [json_name = "baseProposerReward", deprecated = true, (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void Params::clear_base_proposer_reward() {
  _impl_.base_proposer_reward_.ClearToEmpty();
}
inline const std::string& Params::base_proposer_reward() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.Params.base_proposer_reward)
  return _internal_base_proposer_reward();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_base_proposer_reward(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_proposer_reward_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.Params.base_proposer_reward)
}
inline std::string* Params::mutable_base_proposer_reward() {
  std::string* _s = _internal_mutable_base_proposer_reward();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.Params.base_proposer_reward)
  return _s;
}
inline const std::string& Params::_internal_base_proposer_reward() const {
  return _impl_.base_proposer_reward_.Get();
}
inline void Params::_internal_set_base_proposer_reward(const std::string& value) {
  ;


  _impl_.base_proposer_reward_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_base_proposer_reward() {
  ;
  return _impl_.base_proposer_reward_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_base_proposer_reward() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.Params.base_proposer_reward)
  return _impl_.base_proposer_reward_.Release();
}
inline void Params::set_allocated_base_proposer_reward(std::string* value) {
  _impl_.base_proposer_reward_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_proposer_reward_.IsDefault()) {
          _impl_.base_proposer_reward_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.Params.base_proposer_reward)
}

// string bonus_proposer_reward = 3 [json_name = "bonusProposerReward", deprecated = true, (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void Params::clear_bonus_proposer_reward() {
  _impl_.bonus_proposer_reward_.ClearToEmpty();
}
inline const std::string& Params::bonus_proposer_reward() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.Params.bonus_proposer_reward)
  return _internal_bonus_proposer_reward();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_bonus_proposer_reward(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bonus_proposer_reward_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.Params.bonus_proposer_reward)
}
inline std::string* Params::mutable_bonus_proposer_reward() {
  std::string* _s = _internal_mutable_bonus_proposer_reward();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.Params.bonus_proposer_reward)
  return _s;
}
inline const std::string& Params::_internal_bonus_proposer_reward() const {
  return _impl_.bonus_proposer_reward_.Get();
}
inline void Params::_internal_set_bonus_proposer_reward(const std::string& value) {
  ;


  _impl_.bonus_proposer_reward_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_bonus_proposer_reward() {
  ;
  return _impl_.bonus_proposer_reward_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_bonus_proposer_reward() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.Params.bonus_proposer_reward)
  return _impl_.bonus_proposer_reward_.Release();
}
inline void Params::set_allocated_bonus_proposer_reward(std::string* value) {
  _impl_.bonus_proposer_reward_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bonus_proposer_reward_.IsDefault()) {
          _impl_.bonus_proposer_reward_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.Params.bonus_proposer_reward)
}

// bool withdraw_addr_enabled = 4 [json_name = "withdrawAddrEnabled"];
inline void Params::clear_withdraw_addr_enabled() {
  _impl_.withdraw_addr_enabled_ = false;
}
inline bool Params::withdraw_addr_enabled() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.Params.withdraw_addr_enabled)
  return _internal_withdraw_addr_enabled();
}
inline void Params::set_withdraw_addr_enabled(bool value) {
  _internal_set_withdraw_addr_enabled(value);
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.Params.withdraw_addr_enabled)
}
inline bool Params::_internal_withdraw_addr_enabled() const {
  return _impl_.withdraw_addr_enabled_;
}
inline void Params::_internal_set_withdraw_addr_enabled(bool value) {
  ;
  _impl_.withdraw_addr_enabled_ = value;
}

// -------------------------------------------------------------------

// ValidatorHistoricalRewards

// repeated .cosmos.base.v1beta1.DecCoin cumulative_reward_ratio = 1 [json_name = "cumulativeRewardRatio", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
inline int ValidatorHistoricalRewards::_internal_cumulative_reward_ratio_size() const {
  return _impl_.cumulative_reward_ratio_.size();
}
inline int ValidatorHistoricalRewards::cumulative_reward_ratio_size() const {
  return _internal_cumulative_reward_ratio_size();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorHistoricalRewards::mutable_cumulative_reward_ratio(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.cumulative_reward_ratio)
  return _internal_mutable_cumulative_reward_ratio()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
ValidatorHistoricalRewards::mutable_cumulative_reward_ratio() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.cumulative_reward_ratio)
  return _internal_mutable_cumulative_reward_ratio();
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorHistoricalRewards::_internal_cumulative_reward_ratio(int index) const {
  return _internal_cumulative_reward_ratio().Get(index);
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorHistoricalRewards::cumulative_reward_ratio(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.cumulative_reward_ratio)
  return _internal_cumulative_reward_ratio(index);
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorHistoricalRewards::_internal_add_cumulative_reward_ratio() {
  return _internal_mutable_cumulative_reward_ratio()->Add();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorHistoricalRewards::add_cumulative_reward_ratio() {
  ::cosmos::base::v1beta1::DecCoin* _add = _internal_add_cumulative_reward_ratio();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.cumulative_reward_ratio)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
ValidatorHistoricalRewards::cumulative_reward_ratio() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.cumulative_reward_ratio)
  return _internal_cumulative_reward_ratio();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>&
ValidatorHistoricalRewards::_internal_cumulative_reward_ratio() const {
  return _impl_.cumulative_reward_ratio_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>*
ValidatorHistoricalRewards::_internal_mutable_cumulative_reward_ratio() {
  return &_impl_.cumulative_reward_ratio_;
}

// uint32 reference_count = 2 [json_name = "referenceCount"];
inline void ValidatorHistoricalRewards::clear_reference_count() {
  _impl_.reference_count_ = 0u;
}
inline ::uint32_t ValidatorHistoricalRewards::reference_count() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.reference_count)
  return _internal_reference_count();
}
inline void ValidatorHistoricalRewards::set_reference_count(::uint32_t value) {
  _internal_set_reference_count(value);
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.ValidatorHistoricalRewards.reference_count)
}
inline ::uint32_t ValidatorHistoricalRewards::_internal_reference_count() const {
  return _impl_.reference_count_;
}
inline void ValidatorHistoricalRewards::_internal_set_reference_count(::uint32_t value) {
  ;
  _impl_.reference_count_ = value;
}

// -------------------------------------------------------------------

// ValidatorCurrentRewards

// repeated .cosmos.base.v1beta1.DecCoin rewards = 1 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
inline int ValidatorCurrentRewards::_internal_rewards_size() const {
  return _impl_.rewards_.size();
}
inline int ValidatorCurrentRewards::rewards_size() const {
  return _internal_rewards_size();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorCurrentRewards::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.ValidatorCurrentRewards.rewards)
  return _internal_mutable_rewards()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
ValidatorCurrentRewards::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.ValidatorCurrentRewards.rewards)
  return _internal_mutable_rewards();
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorCurrentRewards::_internal_rewards(int index) const {
  return _internal_rewards().Get(index);
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorCurrentRewards::rewards(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorCurrentRewards.rewards)
  return _internal_rewards(index);
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorCurrentRewards::_internal_add_rewards() {
  return _internal_mutable_rewards()->Add();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorCurrentRewards::add_rewards() {
  ::cosmos::base::v1beta1::DecCoin* _add = _internal_add_rewards();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.ValidatorCurrentRewards.rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
ValidatorCurrentRewards::rewards() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.ValidatorCurrentRewards.rewards)
  return _internal_rewards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>&
ValidatorCurrentRewards::_internal_rewards() const {
  return _impl_.rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>*
ValidatorCurrentRewards::_internal_mutable_rewards() {
  return &_impl_.rewards_;
}

// uint64 period = 2 [json_name = "period"];
inline void ValidatorCurrentRewards::clear_period() {
  _impl_.period_ = ::uint64_t{0u};
}
inline ::uint64_t ValidatorCurrentRewards::period() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorCurrentRewards.period)
  return _internal_period();
}
inline void ValidatorCurrentRewards::set_period(::uint64_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.ValidatorCurrentRewards.period)
}
inline ::uint64_t ValidatorCurrentRewards::_internal_period() const {
  return _impl_.period_;
}
inline void ValidatorCurrentRewards::_internal_set_period(::uint64_t value) {
  ;
  _impl_.period_ = value;
}

// -------------------------------------------------------------------

// ValidatorAccumulatedCommission

// repeated .cosmos.base.v1beta1.DecCoin commission = 1 [json_name = "commission", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
inline int ValidatorAccumulatedCommission::_internal_commission_size() const {
  return _impl_.commission_.size();
}
inline int ValidatorAccumulatedCommission::commission_size() const {
  return _internal_commission_size();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorAccumulatedCommission::mutable_commission(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission.commission)
  return _internal_mutable_commission()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
ValidatorAccumulatedCommission::mutable_commission() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission.commission)
  return _internal_mutable_commission();
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorAccumulatedCommission::_internal_commission(int index) const {
  return _internal_commission().Get(index);
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorAccumulatedCommission::commission(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission.commission)
  return _internal_commission(index);
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorAccumulatedCommission::_internal_add_commission() {
  return _internal_mutable_commission()->Add();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorAccumulatedCommission::add_commission() {
  ::cosmos::base::v1beta1::DecCoin* _add = _internal_add_commission();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission.commission)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
ValidatorAccumulatedCommission::commission() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.ValidatorAccumulatedCommission.commission)
  return _internal_commission();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>&
ValidatorAccumulatedCommission::_internal_commission() const {
  return _impl_.commission_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>*
ValidatorAccumulatedCommission::_internal_mutable_commission() {
  return &_impl_.commission_;
}

// -------------------------------------------------------------------

// ValidatorOutstandingRewards

// repeated .cosmos.base.v1beta1.DecCoin rewards = 1 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
inline int ValidatorOutstandingRewards::_internal_rewards_size() const {
  return _impl_.rewards_.size();
}
inline int ValidatorOutstandingRewards::rewards_size() const {
  return _internal_rewards_size();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorOutstandingRewards::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.ValidatorOutstandingRewards.rewards)
  return _internal_mutable_rewards()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
ValidatorOutstandingRewards::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.ValidatorOutstandingRewards.rewards)
  return _internal_mutable_rewards();
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorOutstandingRewards::_internal_rewards(int index) const {
  return _internal_rewards().Get(index);
}
inline const ::cosmos::base::v1beta1::DecCoin& ValidatorOutstandingRewards::rewards(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorOutstandingRewards.rewards)
  return _internal_rewards(index);
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorOutstandingRewards::_internal_add_rewards() {
  return _internal_mutable_rewards()->Add();
}
inline ::cosmos::base::v1beta1::DecCoin* ValidatorOutstandingRewards::add_rewards() {
  ::cosmos::base::v1beta1::DecCoin* _add = _internal_add_rewards();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.ValidatorOutstandingRewards.rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
ValidatorOutstandingRewards::rewards() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.ValidatorOutstandingRewards.rewards)
  return _internal_rewards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>&
ValidatorOutstandingRewards::_internal_rewards() const {
  return _impl_.rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>*
ValidatorOutstandingRewards::_internal_mutable_rewards() {
  return &_impl_.rewards_;
}

// -------------------------------------------------------------------

// ValidatorSlashEvent

// uint64 validator_period = 1 [json_name = "validatorPeriod"];
inline void ValidatorSlashEvent::clear_validator_period() {
  _impl_.validator_period_ = ::uint64_t{0u};
}
inline ::uint64_t ValidatorSlashEvent::validator_period() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorSlashEvent.validator_period)
  return _internal_validator_period();
}
inline void ValidatorSlashEvent::set_validator_period(::uint64_t value) {
  _internal_set_validator_period(value);
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.ValidatorSlashEvent.validator_period)
}
inline ::uint64_t ValidatorSlashEvent::_internal_validator_period() const {
  return _impl_.validator_period_;
}
inline void ValidatorSlashEvent::_internal_set_validator_period(::uint64_t value) {
  ;
  _impl_.validator_period_ = value;
}

// string fraction = 2 [json_name = "fraction", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void ValidatorSlashEvent::clear_fraction() {
  _impl_.fraction_.ClearToEmpty();
}
inline const std::string& ValidatorSlashEvent::fraction() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorSlashEvent.fraction)
  return _internal_fraction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorSlashEvent::set_fraction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fraction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.ValidatorSlashEvent.fraction)
}
inline std::string* ValidatorSlashEvent::mutable_fraction() {
  std::string* _s = _internal_mutable_fraction();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.ValidatorSlashEvent.fraction)
  return _s;
}
inline const std::string& ValidatorSlashEvent::_internal_fraction() const {
  return _impl_.fraction_.Get();
}
inline void ValidatorSlashEvent::_internal_set_fraction(const std::string& value) {
  ;


  _impl_.fraction_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorSlashEvent::_internal_mutable_fraction() {
  ;
  return _impl_.fraction_.Mutable( GetArenaForAllocation());
}
inline std::string* ValidatorSlashEvent::release_fraction() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.ValidatorSlashEvent.fraction)
  return _impl_.fraction_.Release();
}
inline void ValidatorSlashEvent::set_allocated_fraction(std::string* value) {
  _impl_.fraction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fraction_.IsDefault()) {
          _impl_.fraction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.ValidatorSlashEvent.fraction)
}

// -------------------------------------------------------------------

// ValidatorSlashEvents

// repeated .cosmos.distribution.v1beta1.ValidatorSlashEvent validator_slash_events = 1 [json_name = "validatorSlashEvents", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int ValidatorSlashEvents::_internal_validator_slash_events_size() const {
  return _impl_.validator_slash_events_.size();
}
inline int ValidatorSlashEvents::validator_slash_events_size() const {
  return _internal_validator_slash_events_size();
}
inline void ValidatorSlashEvents::clear_validator_slash_events() {
  _internal_mutable_validator_slash_events()->Clear();
}
inline ::cosmos::distribution::v1beta1::ValidatorSlashEvent* ValidatorSlashEvents::mutable_validator_slash_events(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.ValidatorSlashEvents.validator_slash_events)
  return _internal_mutable_validator_slash_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::ValidatorSlashEvent >*
ValidatorSlashEvents::mutable_validator_slash_events() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.ValidatorSlashEvents.validator_slash_events)
  return _internal_mutable_validator_slash_events();
}
inline const ::cosmos::distribution::v1beta1::ValidatorSlashEvent& ValidatorSlashEvents::_internal_validator_slash_events(int index) const {
  return _internal_validator_slash_events().Get(index);
}
inline const ::cosmos::distribution::v1beta1::ValidatorSlashEvent& ValidatorSlashEvents::validator_slash_events(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.ValidatorSlashEvents.validator_slash_events)
  return _internal_validator_slash_events(index);
}
inline ::cosmos::distribution::v1beta1::ValidatorSlashEvent* ValidatorSlashEvents::_internal_add_validator_slash_events() {
  return _internal_mutable_validator_slash_events()->Add();
}
inline ::cosmos::distribution::v1beta1::ValidatorSlashEvent* ValidatorSlashEvents::add_validator_slash_events() {
  ::cosmos::distribution::v1beta1::ValidatorSlashEvent* _add = _internal_add_validator_slash_events();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.ValidatorSlashEvents.validator_slash_events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::ValidatorSlashEvent >&
ValidatorSlashEvents::validator_slash_events() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.ValidatorSlashEvents.validator_slash_events)
  return _internal_validator_slash_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::ValidatorSlashEvent>&
ValidatorSlashEvents::_internal_validator_slash_events() const {
  return _impl_.validator_slash_events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::ValidatorSlashEvent>*
ValidatorSlashEvents::_internal_mutable_validator_slash_events() {
  return &_impl_.validator_slash_events_;
}

// -------------------------------------------------------------------

// FeePool

// repeated .cosmos.base.v1beta1.DecCoin community_pool = 1 [json_name = "communityPool", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
inline int FeePool::_internal_community_pool_size() const {
  return _impl_.community_pool_.size();
}
inline int FeePool::community_pool_size() const {
  return _internal_community_pool_size();
}
inline ::cosmos::base::v1beta1::DecCoin* FeePool::mutable_community_pool(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.FeePool.community_pool)
  return _internal_mutable_community_pool()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
FeePool::mutable_community_pool() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.FeePool.community_pool)
  return _internal_mutable_community_pool();
}
inline const ::cosmos::base::v1beta1::DecCoin& FeePool::_internal_community_pool(int index) const {
  return _internal_community_pool().Get(index);
}
inline const ::cosmos::base::v1beta1::DecCoin& FeePool::community_pool(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.FeePool.community_pool)
  return _internal_community_pool(index);
}
inline ::cosmos::base::v1beta1::DecCoin* FeePool::_internal_add_community_pool() {
  return _internal_mutable_community_pool()->Add();
}
inline ::cosmos::base::v1beta1::DecCoin* FeePool::add_community_pool() {
  ::cosmos::base::v1beta1::DecCoin* _add = _internal_add_community_pool();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.FeePool.community_pool)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
FeePool::community_pool() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.FeePool.community_pool)
  return _internal_community_pool();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>&
FeePool::_internal_community_pool() const {
  return _impl_.community_pool_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>*
FeePool::_internal_mutable_community_pool() {
  return &_impl_.community_pool_;
}

// -------------------------------------------------------------------

// CommunityPoolSpendProposal

// string title = 1 [json_name = "title"];
inline void CommunityPoolSpendProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.title)
}
inline std::string* CommunityPoolSpendProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.title)
  return _s;
}
inline const std::string& CommunityPoolSpendProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CommunityPoolSpendProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.title)
  return _impl_.title_.Release();
}
inline void CommunityPoolSpendProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.title)
}

// string description = 2 [json_name = "description"];
inline void CommunityPoolSpendProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.description)
}
inline std::string* CommunityPoolSpendProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.description)
  return _s;
}
inline const std::string& CommunityPoolSpendProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CommunityPoolSpendProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.description)
  return _impl_.description_.Release();
}
inline void CommunityPoolSpendProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.description)
}

// string recipient = 3 [json_name = "recipient"];
inline void CommunityPoolSpendProposal::clear_recipient() {
  _impl_.recipient_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposal::recipient() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.recipient)
  return _internal_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposal::set_recipient(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.recipient)
}
inline std::string* CommunityPoolSpendProposal::mutable_recipient() {
  std::string* _s = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.recipient)
  return _s;
}
inline const std::string& CommunityPoolSpendProposal::_internal_recipient() const {
  return _impl_.recipient_.Get();
}
inline void CommunityPoolSpendProposal::_internal_set_recipient(const std::string& value) {
  ;


  _impl_.recipient_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposal::_internal_mutable_recipient() {
  ;
  return _impl_.recipient_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposal::release_recipient() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.recipient)
  return _impl_.recipient_.Release();
}
inline void CommunityPoolSpendProposal::set_allocated_recipient(std::string* value) {
  _impl_.recipient_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipient_.IsDefault()) {
          _impl_.recipient_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.recipient)
}

// repeated .cosmos.base.v1beta1.Coin amount = 4 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int CommunityPoolSpendProposal::_internal_amount_size() const {
  return _impl_.amount_.size();
}
inline int CommunityPoolSpendProposal::amount_size() const {
  return _internal_amount_size();
}
inline ::cosmos::base::v1beta1::Coin* CommunityPoolSpendProposal::mutable_amount(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.amount)
  return _internal_mutable_amount()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
CommunityPoolSpendProposal::mutable_amount() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.amount)
  return _internal_mutable_amount();
}
inline const ::cosmos::base::v1beta1::Coin& CommunityPoolSpendProposal::_internal_amount(int index) const {
  return _internal_amount().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& CommunityPoolSpendProposal::amount(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.amount)
  return _internal_amount(index);
}
inline ::cosmos::base::v1beta1::Coin* CommunityPoolSpendProposal::_internal_add_amount() {
  return _internal_mutable_amount()->Add();
}
inline ::cosmos::base::v1beta1::Coin* CommunityPoolSpendProposal::add_amount() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_amount();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.amount)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
CommunityPoolSpendProposal::amount() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.CommunityPoolSpendProposal.amount)
  return _internal_amount();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
CommunityPoolSpendProposal::_internal_amount() const {
  return _impl_.amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
CommunityPoolSpendProposal::_internal_mutable_amount() {
  return &_impl_.amount_;
}

// -------------------------------------------------------------------

// DelegatorStartingInfo

// uint64 previous_period = 1 [json_name = "previousPeriod"];
inline void DelegatorStartingInfo::clear_previous_period() {
  _impl_.previous_period_ = ::uint64_t{0u};
}
inline ::uint64_t DelegatorStartingInfo::previous_period() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.DelegatorStartingInfo.previous_period)
  return _internal_previous_period();
}
inline void DelegatorStartingInfo::set_previous_period(::uint64_t value) {
  _internal_set_previous_period(value);
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.DelegatorStartingInfo.previous_period)
}
inline ::uint64_t DelegatorStartingInfo::_internal_previous_period() const {
  return _impl_.previous_period_;
}
inline void DelegatorStartingInfo::_internal_set_previous_period(::uint64_t value) {
  ;
  _impl_.previous_period_ = value;
}

// string stake = 2 [json_name = "stake", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void DelegatorStartingInfo::clear_stake() {
  _impl_.stake_.ClearToEmpty();
}
inline const std::string& DelegatorStartingInfo::stake() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.DelegatorStartingInfo.stake)
  return _internal_stake();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DelegatorStartingInfo::set_stake(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.stake_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.DelegatorStartingInfo.stake)
}
inline std::string* DelegatorStartingInfo::mutable_stake() {
  std::string* _s = _internal_mutable_stake();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.DelegatorStartingInfo.stake)
  return _s;
}
inline const std::string& DelegatorStartingInfo::_internal_stake() const {
  return _impl_.stake_.Get();
}
inline void DelegatorStartingInfo::_internal_set_stake(const std::string& value) {
  ;


  _impl_.stake_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegatorStartingInfo::_internal_mutable_stake() {
  ;
  return _impl_.stake_.Mutable( GetArenaForAllocation());
}
inline std::string* DelegatorStartingInfo::release_stake() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.DelegatorStartingInfo.stake)
  return _impl_.stake_.Release();
}
inline void DelegatorStartingInfo::set_allocated_stake(std::string* value) {
  _impl_.stake_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stake_.IsDefault()) {
          _impl_.stake_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.DelegatorStartingInfo.stake)
}

// uint64 height = 3 [json_name = "height", (.gogoproto.jsontag) = "creation_height", (.amino.field_name) = "creation_height", (.amino.dont_omitempty) = true];
inline void DelegatorStartingInfo::clear_height() {
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t DelegatorStartingInfo::height() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.DelegatorStartingInfo.height)
  return _internal_height();
}
inline void DelegatorStartingInfo::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.DelegatorStartingInfo.height)
}
inline ::uint64_t DelegatorStartingInfo::_internal_height() const {
  return _impl_.height_;
}
inline void DelegatorStartingInfo::_internal_set_height(::uint64_t value) {
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// DelegationDelegatorReward

// string validator_address = 1 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DelegationDelegatorReward::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& DelegationDelegatorReward::validator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.DelegationDelegatorReward.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DelegationDelegatorReward::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.DelegationDelegatorReward.validator_address)
}
inline std::string* DelegationDelegatorReward::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.DelegationDelegatorReward.validator_address)
  return _s;
}
inline const std::string& DelegationDelegatorReward::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void DelegationDelegatorReward::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DelegationDelegatorReward::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* DelegationDelegatorReward::release_validator_address() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.DelegationDelegatorReward.validator_address)
  return _impl_.validator_address_.Release();
}
inline void DelegationDelegatorReward::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.DelegationDelegatorReward.validator_address)
}

// repeated .cosmos.base.v1beta1.DecCoin reward = 2 [json_name = "reward", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins", (.amino.dont_omitempty) = true];
inline int DelegationDelegatorReward::_internal_reward_size() const {
  return _impl_.reward_.size();
}
inline int DelegationDelegatorReward::reward_size() const {
  return _internal_reward_size();
}
inline ::cosmos::base::v1beta1::DecCoin* DelegationDelegatorReward::mutable_reward(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.DelegationDelegatorReward.reward)
  return _internal_mutable_reward()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >*
DelegationDelegatorReward::mutable_reward() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.distribution.v1beta1.DelegationDelegatorReward.reward)
  return _internal_mutable_reward();
}
inline const ::cosmos::base::v1beta1::DecCoin& DelegationDelegatorReward::_internal_reward(int index) const {
  return _internal_reward().Get(index);
}
inline const ::cosmos::base::v1beta1::DecCoin& DelegationDelegatorReward::reward(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.DelegationDelegatorReward.reward)
  return _internal_reward(index);
}
inline ::cosmos::base::v1beta1::DecCoin* DelegationDelegatorReward::_internal_add_reward() {
  return _internal_mutable_reward()->Add();
}
inline ::cosmos::base::v1beta1::DecCoin* DelegationDelegatorReward::add_reward() {
  ::cosmos::base::v1beta1::DecCoin* _add = _internal_add_reward();
  // @@protoc_insertion_point(field_add:cosmos.distribution.v1beta1.DelegationDelegatorReward.reward)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::DecCoin >&
DelegationDelegatorReward::reward() const {
  // @@protoc_insertion_point(field_list:cosmos.distribution.v1beta1.DelegationDelegatorReward.reward)
  return _internal_reward();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>&
DelegationDelegatorReward::_internal_reward() const {
  return _impl_.reward_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::DecCoin>*
DelegationDelegatorReward::_internal_mutable_reward() {
  return &_impl_.reward_;
}

// -------------------------------------------------------------------

// CommunityPoolSpendProposalWithDeposit

// string title = 1 [json_name = "title"];
inline void CommunityPoolSpendProposalWithDeposit::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::title() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposalWithDeposit::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.title)
}
inline std::string* CommunityPoolSpendProposalWithDeposit::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.title)
  return _s;
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CommunityPoolSpendProposalWithDeposit::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::release_title() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.title)
  return _impl_.title_.Release();
}
inline void CommunityPoolSpendProposalWithDeposit::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.title)
}

// string description = 2 [json_name = "description"];
inline void CommunityPoolSpendProposalWithDeposit::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::description() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposalWithDeposit::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.description)
}
inline std::string* CommunityPoolSpendProposalWithDeposit::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.description)
  return _s;
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CommunityPoolSpendProposalWithDeposit::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::release_description() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.description)
  return _impl_.description_.Release();
}
inline void CommunityPoolSpendProposalWithDeposit::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.description)
}

// string recipient = 3 [json_name = "recipient"];
inline void CommunityPoolSpendProposalWithDeposit::clear_recipient() {
  _impl_.recipient_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::recipient() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.recipient)
  return _internal_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposalWithDeposit::set_recipient(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.recipient)
}
inline std::string* CommunityPoolSpendProposalWithDeposit::mutable_recipient() {
  std::string* _s = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.recipient)
  return _s;
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::_internal_recipient() const {
  return _impl_.recipient_.Get();
}
inline void CommunityPoolSpendProposalWithDeposit::_internal_set_recipient(const std::string& value) {
  ;


  _impl_.recipient_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::_internal_mutable_recipient() {
  ;
  return _impl_.recipient_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::release_recipient() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.recipient)
  return _impl_.recipient_.Release();
}
inline void CommunityPoolSpendProposalWithDeposit::set_allocated_recipient(std::string* value) {
  _impl_.recipient_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipient_.IsDefault()) {
          _impl_.recipient_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.recipient)
}

// string amount = 4 [json_name = "amount"];
inline void CommunityPoolSpendProposalWithDeposit::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::amount() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposalWithDeposit::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.amount)
}
inline std::string* CommunityPoolSpendProposalWithDeposit::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.amount)
  return _s;
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void CommunityPoolSpendProposalWithDeposit::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::release_amount() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.amount)
  return _impl_.amount_.Release();
}
inline void CommunityPoolSpendProposalWithDeposit::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.amount)
}

// string deposit = 5 [json_name = "deposit"];
inline void CommunityPoolSpendProposalWithDeposit::clear_deposit() {
  _impl_.deposit_.ClearToEmpty();
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::deposit() const {
  // @@protoc_insertion_point(field_get:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.deposit)
  return _internal_deposit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommunityPoolSpendProposalWithDeposit::set_deposit(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.deposit_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.deposit)
}
inline std::string* CommunityPoolSpendProposalWithDeposit::mutable_deposit() {
  std::string* _s = _internal_mutable_deposit();
  // @@protoc_insertion_point(field_mutable:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.deposit)
  return _s;
}
inline const std::string& CommunityPoolSpendProposalWithDeposit::_internal_deposit() const {
  return _impl_.deposit_.Get();
}
inline void CommunityPoolSpendProposalWithDeposit::_internal_set_deposit(const std::string& value) {
  ;


  _impl_.deposit_.Set(value, GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::_internal_mutable_deposit() {
  ;
  return _impl_.deposit_.Mutable( GetArenaForAllocation());
}
inline std::string* CommunityPoolSpendProposalWithDeposit::release_deposit() {
  // @@protoc_insertion_point(field_release:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.deposit)
  return _impl_.deposit_.Release();
}
inline void CommunityPoolSpendProposalWithDeposit::set_allocated_deposit(std::string* value) {
  _impl_.deposit_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.deposit_.IsDefault()) {
          _impl_.deposit_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit.deposit)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace distribution
}  // namespace cosmos


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmos_2fdistribution_2fv1beta1_2fdistribution_2eproto_2epb_2eh
