// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: cosmos/group/v1/query.proto
// Original file comments:
// Since: cosmos-sdk 0.46
#ifndef GRPC_cosmos_2fgroup_2fv1_2fquery_2eproto__INCLUDED
#define GRPC_cosmos_2fgroup_2fv1_2fquery_2eproto__INCLUDED

#include "cosmos/group/v1/query.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace cosmos {
namespace group {
namespace v1 {

// Query is the cosmos.group.v1 Query service.
class Query final {
 public:
  static constexpr char const* service_full_name() {
    return "cosmos.group.v1.Query";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // GroupInfo queries group info based on group id.
    virtual ::grpc::Status GroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::cosmos::group::v1::QueryGroupInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupInfoResponse>> AsyncGroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupInfoResponse>>(AsyncGroupInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupInfoResponse>> PrepareAsyncGroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupInfoResponse>>(PrepareAsyncGroupInfoRaw(context, request, cq));
    }
    // GroupPolicyInfo queries group policy info based on account address of group policy.
    virtual ::grpc::Status GroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>> AsyncGroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>>(AsyncGroupPolicyInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>> PrepareAsyncGroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>>(PrepareAsyncGroupPolicyInfoRaw(context, request, cq));
    }
    // GroupMembers queries members of a group by group id.
    virtual ::grpc::Status GroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::cosmos::group::v1::QueryGroupMembersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupMembersResponse>> AsyncGroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupMembersResponse>>(AsyncGroupMembersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupMembersResponse>> PrepareAsyncGroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupMembersResponse>>(PrepareAsyncGroupMembersRaw(context, request, cq));
    }
    // GroupsByAdmin queries groups by admin address.
    virtual ::grpc::Status GroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByAdminResponse>> AsyncGroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByAdminResponse>>(AsyncGroupsByAdminRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByAdminResponse>> PrepareAsyncGroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByAdminResponse>>(PrepareAsyncGroupsByAdminRaw(context, request, cq));
    }
    // GroupPoliciesByGroup queries group policies by group id.
    virtual ::grpc::Status GroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>> AsyncGroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>>(AsyncGroupPoliciesByGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>> PrepareAsyncGroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>>(PrepareAsyncGroupPoliciesByGroupRaw(context, request, cq));
    }
    // GroupPoliciesByAdmin queries group policies by admin address.
    virtual ::grpc::Status GroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>> AsyncGroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>>(AsyncGroupPoliciesByAdminRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>> PrepareAsyncGroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>>(PrepareAsyncGroupPoliciesByAdminRaw(context, request, cq));
    }
    // Proposal queries a proposal based on proposal id.
    virtual ::grpc::Status Proposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::cosmos::group::v1::QueryProposalResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalResponse>> AsyncProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalResponse>>(AsyncProposalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalResponse>> PrepareAsyncProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalResponse>>(PrepareAsyncProposalRaw(context, request, cq));
    }
    // ProposalsByGroupPolicy queries proposals based on account address of group policy.
    virtual ::grpc::Status ProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>> AsyncProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>>(AsyncProposalsByGroupPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>> PrepareAsyncProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>>(PrepareAsyncProposalsByGroupPolicyRaw(context, request, cq));
    }
    // VoteByProposalVoter queries a vote by proposal id and voter.
    virtual ::grpc::Status VoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>> AsyncVoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>>(AsyncVoteByProposalVoterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>> PrepareAsyncVoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>>(PrepareAsyncVoteByProposalVoterRaw(context, request, cq));
    }
    // VotesByProposal queries a vote by proposal id.
    virtual ::grpc::Status VotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::cosmos::group::v1::QueryVotesByProposalResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByProposalResponse>> AsyncVotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByProposalResponse>>(AsyncVotesByProposalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByProposalResponse>> PrepareAsyncVotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByProposalResponse>>(PrepareAsyncVotesByProposalRaw(context, request, cq));
    }
    // VotesByVoter queries a vote by voter.
    virtual ::grpc::Status VotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::cosmos::group::v1::QueryVotesByVoterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByVoterResponse>> AsyncVotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByVoterResponse>>(AsyncVotesByVoterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByVoterResponse>> PrepareAsyncVotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByVoterResponse>>(PrepareAsyncVotesByVoterRaw(context, request, cq));
    }
    // GroupsByMember queries groups by member address.
    virtual ::grpc::Status GroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByMemberResponse>> AsyncGroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByMemberResponse>>(AsyncGroupsByMemberRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByMemberResponse>> PrepareAsyncGroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByMemberResponse>>(PrepareAsyncGroupsByMemberRaw(context, request, cq));
    }
    // TallyResult returns the tally result of a proposal. If the proposal is
    // still in voting period, then this query computes the current tally state,
    // which might not be final. On the other hand, if the proposal is final,
    // then it simply returns the `final_tally_result` state stored in the
    // proposal itself.
    virtual ::grpc::Status TallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::cosmos::group::v1::QueryTallyResultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryTallyResultResponse>> AsyncTallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryTallyResultResponse>>(AsyncTallyResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryTallyResultResponse>> PrepareAsyncTallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryTallyResultResponse>>(PrepareAsyncTallyResultRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // GroupInfo queries group info based on group id.
      virtual void GroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest* request, ::cosmos::group::v1::QueryGroupInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest* request, ::cosmos::group::v1::QueryGroupInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GroupPolicyInfo queries group policy info based on account address of group policy.
      virtual void GroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GroupMembers queries members of a group by group id.
      virtual void GroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest* request, ::cosmos::group::v1::QueryGroupMembersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest* request, ::cosmos::group::v1::QueryGroupMembersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GroupsByAdmin queries groups by admin address.
      virtual void GroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest* request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest* request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GroupPoliciesByGroup queries group policies by group id.
      virtual void GroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GroupPoliciesByAdmin queries group policies by admin address.
      virtual void GroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Proposal queries a proposal based on proposal id.
      virtual void Proposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest* request, ::cosmos::group::v1::QueryProposalResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Proposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest* request, ::cosmos::group::v1::QueryProposalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ProposalsByGroupPolicy queries proposals based on account address of group policy.
      virtual void ProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // VoteByProposalVoter queries a vote by proposal id and voter.
      virtual void VoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // VotesByProposal queries a vote by proposal id.
      virtual void VotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest* request, ::cosmos::group::v1::QueryVotesByProposalResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest* request, ::cosmos::group::v1::QueryVotesByProposalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // VotesByVoter queries a vote by voter.
      virtual void VotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest* request, ::cosmos::group::v1::QueryVotesByVoterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest* request, ::cosmos::group::v1::QueryVotesByVoterResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GroupsByMember queries groups by member address.
      virtual void GroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest* request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest* request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // TallyResult returns the tally result of a proposal. If the proposal is
      // still in voting period, then this query computes the current tally state,
      // which might not be final. On the other hand, if the proposal is final,
      // then it simply returns the `final_tally_result` state stored in the
      // proposal itself.
      virtual void TallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest* request, ::cosmos::group::v1::QueryTallyResultResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest* request, ::cosmos::group::v1::QueryTallyResultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupInfoResponse>* AsyncGroupInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupInfoResponse>* PrepareAsyncGroupInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>* AsyncGroupPolicyInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>* PrepareAsyncGroupPolicyInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupMembersResponse>* AsyncGroupMembersRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupMembersResponse>* PrepareAsyncGroupMembersRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByAdminResponse>* AsyncGroupsByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByAdminResponse>* PrepareAsyncGroupsByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* AsyncGroupPoliciesByGroupRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* PrepareAsyncGroupPoliciesByGroupRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* AsyncGroupPoliciesByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* PrepareAsyncGroupPoliciesByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalResponse>* AsyncProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalResponse>* PrepareAsyncProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* AsyncProposalsByGroupPolicyRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* PrepareAsyncProposalsByGroupPolicyRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>* AsyncVoteByProposalVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>* PrepareAsyncVoteByProposalVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByProposalResponse>* AsyncVotesByProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByProposalResponse>* PrepareAsyncVotesByProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByVoterResponse>* AsyncVotesByVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryVotesByVoterResponse>* PrepareAsyncVotesByVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByMemberResponse>* AsyncGroupsByMemberRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryGroupsByMemberResponse>* PrepareAsyncGroupsByMemberRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryTallyResultResponse>* AsyncTallyResultRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::cosmos::group::v1::QueryTallyResultResponse>* PrepareAsyncTallyResultRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::cosmos::group::v1::QueryGroupInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupInfoResponse>> AsyncGroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupInfoResponse>>(AsyncGroupInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupInfoResponse>> PrepareAsyncGroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupInfoResponse>>(PrepareAsyncGroupInfoRaw(context, request, cq));
    }
    ::grpc::Status GroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>> AsyncGroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>>(AsyncGroupPolicyInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>> PrepareAsyncGroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>>(PrepareAsyncGroupPolicyInfoRaw(context, request, cq));
    }
    ::grpc::Status GroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::cosmos::group::v1::QueryGroupMembersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupMembersResponse>> AsyncGroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupMembersResponse>>(AsyncGroupMembersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupMembersResponse>> PrepareAsyncGroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupMembersResponse>>(PrepareAsyncGroupMembersRaw(context, request, cq));
    }
    ::grpc::Status GroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByAdminResponse>> AsyncGroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByAdminResponse>>(AsyncGroupsByAdminRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByAdminResponse>> PrepareAsyncGroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByAdminResponse>>(PrepareAsyncGroupsByAdminRaw(context, request, cq));
    }
    ::grpc::Status GroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>> AsyncGroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>>(AsyncGroupPoliciesByGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>> PrepareAsyncGroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>>(PrepareAsyncGroupPoliciesByGroupRaw(context, request, cq));
    }
    ::grpc::Status GroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>> AsyncGroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>>(AsyncGroupPoliciesByAdminRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>> PrepareAsyncGroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>>(PrepareAsyncGroupPoliciesByAdminRaw(context, request, cq));
    }
    ::grpc::Status Proposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::cosmos::group::v1::QueryProposalResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalResponse>> AsyncProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalResponse>>(AsyncProposalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalResponse>> PrepareAsyncProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalResponse>>(PrepareAsyncProposalRaw(context, request, cq));
    }
    ::grpc::Status ProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>> AsyncProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>>(AsyncProposalsByGroupPolicyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>> PrepareAsyncProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>>(PrepareAsyncProposalsByGroupPolicyRaw(context, request, cq));
    }
    ::grpc::Status VoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>> AsyncVoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>>(AsyncVoteByProposalVoterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>> PrepareAsyncVoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>>(PrepareAsyncVoteByProposalVoterRaw(context, request, cq));
    }
    ::grpc::Status VotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::cosmos::group::v1::QueryVotesByProposalResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByProposalResponse>> AsyncVotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByProposalResponse>>(AsyncVotesByProposalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByProposalResponse>> PrepareAsyncVotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByProposalResponse>>(PrepareAsyncVotesByProposalRaw(context, request, cq));
    }
    ::grpc::Status VotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::cosmos::group::v1::QueryVotesByVoterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByVoterResponse>> AsyncVotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByVoterResponse>>(AsyncVotesByVoterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByVoterResponse>> PrepareAsyncVotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByVoterResponse>>(PrepareAsyncVotesByVoterRaw(context, request, cq));
    }
    ::grpc::Status GroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByMemberResponse>> AsyncGroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByMemberResponse>>(AsyncGroupsByMemberRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByMemberResponse>> PrepareAsyncGroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByMemberResponse>>(PrepareAsyncGroupsByMemberRaw(context, request, cq));
    }
    ::grpc::Status TallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::cosmos::group::v1::QueryTallyResultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryTallyResultResponse>> AsyncTallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryTallyResultResponse>>(AsyncTallyResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryTallyResultResponse>> PrepareAsyncTallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryTallyResultResponse>>(PrepareAsyncTallyResultRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest* request, ::cosmos::group::v1::QueryGroupInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GroupInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest* request, ::cosmos::group::v1::QueryGroupInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GroupPolicyInfo(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest* request, ::cosmos::group::v1::QueryGroupMembersResponse* response, std::function<void(::grpc::Status)>) override;
      void GroupMembers(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest* request, ::cosmos::group::v1::QueryGroupMembersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest* request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response, std::function<void(::grpc::Status)>) override;
      void GroupsByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest* request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void GroupPoliciesByGroup(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response, std::function<void(::grpc::Status)>) override;
      void GroupPoliciesByAdmin(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Proposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest* request, ::cosmos::group::v1::QueryProposalResponse* response, std::function<void(::grpc::Status)>) override;
      void Proposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest* request, ::cosmos::group::v1::QueryProposalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response, std::function<void(::grpc::Status)>) override;
      void ProposalsByGroupPolicy(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void VoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response, std::function<void(::grpc::Status)>) override;
      void VoteByProposalVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void VotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest* request, ::cosmos::group::v1::QueryVotesByProposalResponse* response, std::function<void(::grpc::Status)>) override;
      void VotesByProposal(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest* request, ::cosmos::group::v1::QueryVotesByProposalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void VotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest* request, ::cosmos::group::v1::QueryVotesByVoterResponse* response, std::function<void(::grpc::Status)>) override;
      void VotesByVoter(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest* request, ::cosmos::group::v1::QueryVotesByVoterResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest* request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response, std::function<void(::grpc::Status)>) override;
      void GroupsByMember(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest* request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest* request, ::cosmos::group::v1::QueryTallyResultResponse* response, std::function<void(::grpc::Status)>) override;
      void TallyResult(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest* request, ::cosmos::group::v1::QueryTallyResultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupInfoResponse>* AsyncGroupInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupInfoResponse>* PrepareAsyncGroupInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>* AsyncGroupPolicyInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>* PrepareAsyncGroupPolicyInfoRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupMembersResponse>* AsyncGroupMembersRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupMembersResponse>* PrepareAsyncGroupMembersRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByAdminResponse>* AsyncGroupsByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByAdminResponse>* PrepareAsyncGroupsByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* AsyncGroupPoliciesByGroupRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* PrepareAsyncGroupPoliciesByGroupRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* AsyncGroupPoliciesByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* PrepareAsyncGroupPoliciesByAdminRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalResponse>* AsyncProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalResponse>* PrepareAsyncProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* AsyncProposalsByGroupPolicyRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* PrepareAsyncProposalsByGroupPolicyRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>* AsyncVoteByProposalVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>* PrepareAsyncVoteByProposalVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByProposalResponse>* AsyncVotesByProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByProposalResponse>* PrepareAsyncVotesByProposalRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByVoterResponse>* AsyncVotesByVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryVotesByVoterResponse>* PrepareAsyncVotesByVoterRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByMemberResponse>* AsyncGroupsByMemberRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryGroupsByMemberResponse>* PrepareAsyncGroupsByMemberRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryTallyResultResponse>* AsyncTallyResultRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::cosmos::group::v1::QueryTallyResultResponse>* PrepareAsyncTallyResultRaw(::grpc::ClientContext* context, const ::cosmos::group::v1::QueryTallyResultRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GroupInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GroupPolicyInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GroupMembers_;
    const ::grpc::internal::RpcMethod rpcmethod_GroupsByAdmin_;
    const ::grpc::internal::RpcMethod rpcmethod_GroupPoliciesByGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_GroupPoliciesByAdmin_;
    const ::grpc::internal::RpcMethod rpcmethod_Proposal_;
    const ::grpc::internal::RpcMethod rpcmethod_ProposalsByGroupPolicy_;
    const ::grpc::internal::RpcMethod rpcmethod_VoteByProposalVoter_;
    const ::grpc::internal::RpcMethod rpcmethod_VotesByProposal_;
    const ::grpc::internal::RpcMethod rpcmethod_VotesByVoter_;
    const ::grpc::internal::RpcMethod rpcmethod_GroupsByMember_;
    const ::grpc::internal::RpcMethod rpcmethod_TallyResult_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // GroupInfo queries group info based on group id.
    virtual ::grpc::Status GroupInfo(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest* request, ::cosmos::group::v1::QueryGroupInfoResponse* response);
    // GroupPolicyInfo queries group policy info based on account address of group policy.
    virtual ::grpc::Status GroupPolicyInfo(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response);
    // GroupMembers queries members of a group by group id.
    virtual ::grpc::Status GroupMembers(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest* request, ::cosmos::group::v1::QueryGroupMembersResponse* response);
    // GroupsByAdmin queries groups by admin address.
    virtual ::grpc::Status GroupsByAdmin(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest* request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response);
    // GroupPoliciesByGroup queries group policies by group id.
    virtual ::grpc::Status GroupPoliciesByGroup(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response);
    // GroupPoliciesByAdmin queries group policies by admin address.
    virtual ::grpc::Status GroupPoliciesByAdmin(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response);
    // Proposal queries a proposal based on proposal id.
    virtual ::grpc::Status Proposal(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryProposalRequest* request, ::cosmos::group::v1::QueryProposalResponse* response);
    // ProposalsByGroupPolicy queries proposals based on account address of group policy.
    virtual ::grpc::Status ProposalsByGroupPolicy(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response);
    // VoteByProposalVoter queries a vote by proposal id and voter.
    virtual ::grpc::Status VoteByProposalVoter(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response);
    // VotesByProposal queries a vote by proposal id.
    virtual ::grpc::Status VotesByProposal(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest* request, ::cosmos::group::v1::QueryVotesByProposalResponse* response);
    // VotesByVoter queries a vote by voter.
    virtual ::grpc::Status VotesByVoter(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest* request, ::cosmos::group::v1::QueryVotesByVoterResponse* response);
    // GroupsByMember queries groups by member address.
    virtual ::grpc::Status GroupsByMember(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest* request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response);
    // TallyResult returns the tally result of a proposal. If the proposal is
    // still in voting period, then this query computes the current tally state,
    // which might not be final. On the other hand, if the proposal is final,
    // then it simply returns the `final_tally_result` state stored in the
    // proposal itself.
    virtual ::grpc::Status TallyResult(::grpc::ServerContext* context, const ::cosmos::group::v1::QueryTallyResultRequest* request, ::cosmos::group::v1::QueryTallyResultResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GroupInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GroupInfo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GroupInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupInfo(::grpc::ServerContext* context, ::cosmos::group::v1::QueryGroupInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryGroupInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GroupPolicyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GroupPolicyInfo() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GroupPolicyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPolicyInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupPolicyInfo(::grpc::ServerContext* context, ::cosmos::group::v1::QueryGroupPolicyInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryGroupPolicyInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GroupMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GroupMembers() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GroupMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupMembers(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupMembersRequest* /*request*/, ::cosmos::group::v1::QueryGroupMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupMembers(::grpc::ServerContext* context, ::cosmos::group::v1::QueryGroupMembersRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryGroupMembersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GroupsByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GroupsByAdmin() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GroupsByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupsByAdmin(::grpc::ServerContext* context, ::cosmos::group::v1::QueryGroupsByAdminRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryGroupsByAdminResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GroupPoliciesByGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GroupPoliciesByGroup() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GroupPoliciesByGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByGroup(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupPoliciesByGroup(::grpc::ServerContext* context, ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GroupPoliciesByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GroupPoliciesByAdmin() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GroupPoliciesByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupPoliciesByAdmin(::grpc::ServerContext* context, ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Proposal() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalRequest* /*request*/, ::cosmos::group::v1::QueryProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProposal(::grpc::ServerContext* context, ::cosmos::group::v1::QueryProposalRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryProposalResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProposalsByGroupPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProposalsByGroupPolicy() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ProposalsByGroupPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProposalsByGroupPolicy(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* /*request*/, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProposalsByGroupPolicy(::grpc::ServerContext* context, ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VoteByProposalVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VoteByProposalVoter() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_VoteByProposalVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoteByProposalVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* /*request*/, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVoteByProposalVoter(::grpc::ServerContext* context, ::cosmos::group::v1::QueryVoteByProposalVoterRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryVoteByProposalVoterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VotesByProposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VotesByProposal() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_VotesByProposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByProposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByProposalRequest* /*request*/, ::cosmos::group::v1::QueryVotesByProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVotesByProposal(::grpc::ServerContext* context, ::cosmos::group::v1::QueryVotesByProposalRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryVotesByProposalResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VotesByVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VotesByVoter() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_VotesByVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByVoterRequest* /*request*/, ::cosmos::group::v1::QueryVotesByVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVotesByVoter(::grpc::ServerContext* context, ::cosmos::group::v1::QueryVotesByVoterRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryVotesByVoterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GroupsByMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GroupsByMember() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GroupsByMember() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByMember(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByMemberRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByMemberResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupsByMember(::grpc::ServerContext* context, ::cosmos::group::v1::QueryGroupsByMemberRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryGroupsByMemberResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TallyResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TallyResult() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_TallyResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TallyResult(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryTallyResultRequest* /*request*/, ::cosmos::group::v1::QueryTallyResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTallyResult(::grpc::ServerContext* context, ::cosmos::group::v1::QueryTallyResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::cosmos::group::v1::QueryTallyResultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GroupInfo<WithAsyncMethod_GroupPolicyInfo<WithAsyncMethod_GroupMembers<WithAsyncMethod_GroupsByAdmin<WithAsyncMethod_GroupPoliciesByGroup<WithAsyncMethod_GroupPoliciesByAdmin<WithAsyncMethod_Proposal<WithAsyncMethod_ProposalsByGroupPolicy<WithAsyncMethod_VoteByProposalVoter<WithAsyncMethod_VotesByProposal<WithAsyncMethod_VotesByVoter<WithAsyncMethod_GroupsByMember<WithAsyncMethod_TallyResult<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GroupInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GroupInfo() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupInfoRequest, ::cosmos::group::v1::QueryGroupInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryGroupInfoRequest* request, ::cosmos::group::v1::QueryGroupInfoResponse* response) { return this->GroupInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GroupInfo(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryGroupInfoRequest, ::cosmos::group::v1::QueryGroupInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupInfoRequest, ::cosmos::group::v1::QueryGroupInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GroupInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GroupPolicyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GroupPolicyInfo() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupPolicyInfoRequest, ::cosmos::group::v1::QueryGroupPolicyInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* request, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* response) { return this->GroupPolicyInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GroupPolicyInfo(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryGroupPolicyInfoRequest, ::cosmos::group::v1::QueryGroupPolicyInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupPolicyInfoRequest, ::cosmos::group::v1::QueryGroupPolicyInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GroupPolicyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPolicyInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupPolicyInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GroupMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GroupMembers() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupMembersRequest, ::cosmos::group::v1::QueryGroupMembersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryGroupMembersRequest* request, ::cosmos::group::v1::QueryGroupMembersResponse* response) { return this->GroupMembers(context, request, response); }));}
    void SetMessageAllocatorFor_GroupMembers(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryGroupMembersRequest, ::cosmos::group::v1::QueryGroupMembersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupMembersRequest, ::cosmos::group::v1::QueryGroupMembersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GroupMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupMembers(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupMembersRequest* /*request*/, ::cosmos::group::v1::QueryGroupMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupMembers(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupMembersRequest* /*request*/, ::cosmos::group::v1::QueryGroupMembersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GroupsByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GroupsByAdmin() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupsByAdminRequest, ::cosmos::group::v1::QueryGroupsByAdminResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryGroupsByAdminRequest* request, ::cosmos::group::v1::QueryGroupsByAdminResponse* response) { return this->GroupsByAdmin(context, request, response); }));}
    void SetMessageAllocatorFor_GroupsByAdmin(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryGroupsByAdminRequest, ::cosmos::group::v1::QueryGroupsByAdminResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupsByAdminRequest, ::cosmos::group::v1::QueryGroupsByAdminResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GroupsByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupsByAdmin(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByAdminResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GroupPoliciesByGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GroupPoliciesByGroup() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* response) { return this->GroupPoliciesByGroup(context, request, response); }));}
    void SetMessageAllocatorFor_GroupPoliciesByGroup(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GroupPoliciesByGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByGroup(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupPoliciesByGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GroupPoliciesByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GroupPoliciesByAdmin() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* request, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* response) { return this->GroupPoliciesByAdmin(context, request, response); }));}
    void SetMessageAllocatorFor_GroupPoliciesByAdmin(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GroupPoliciesByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupPoliciesByAdmin(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Proposal() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryProposalRequest, ::cosmos::group::v1::QueryProposalResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryProposalRequest* request, ::cosmos::group::v1::QueryProposalResponse* response) { return this->Proposal(context, request, response); }));}
    void SetMessageAllocatorFor_Proposal(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryProposalRequest, ::cosmos::group::v1::QueryProposalResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryProposalRequest, ::cosmos::group::v1::QueryProposalResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalRequest* /*request*/, ::cosmos::group::v1::QueryProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Proposal(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalRequest* /*request*/, ::cosmos::group::v1::QueryProposalResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProposalsByGroupPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ProposalsByGroupPolicy() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* request, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* response) { return this->ProposalsByGroupPolicy(context, request, response); }));}
    void SetMessageAllocatorFor_ProposalsByGroupPolicy(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProposalsByGroupPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProposalsByGroupPolicy(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* /*request*/, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProposalsByGroupPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* /*request*/, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_VoteByProposalVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_VoteByProposalVoter() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryVoteByProposalVoterRequest, ::cosmos::group::v1::QueryVoteByProposalVoterResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* request, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* response) { return this->VoteByProposalVoter(context, request, response); }));}
    void SetMessageAllocatorFor_VoteByProposalVoter(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryVoteByProposalVoterRequest, ::cosmos::group::v1::QueryVoteByProposalVoterResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryVoteByProposalVoterRequest, ::cosmos::group::v1::QueryVoteByProposalVoterResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_VoteByProposalVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoteByProposalVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* /*request*/, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VoteByProposalVoter(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* /*request*/, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_VotesByProposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_VotesByProposal() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryVotesByProposalRequest, ::cosmos::group::v1::QueryVotesByProposalResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryVotesByProposalRequest* request, ::cosmos::group::v1::QueryVotesByProposalResponse* response) { return this->VotesByProposal(context, request, response); }));}
    void SetMessageAllocatorFor_VotesByProposal(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryVotesByProposalRequest, ::cosmos::group::v1::QueryVotesByProposalResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryVotesByProposalRequest, ::cosmos::group::v1::QueryVotesByProposalResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_VotesByProposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByProposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByProposalRequest* /*request*/, ::cosmos::group::v1::QueryVotesByProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VotesByProposal(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByProposalRequest* /*request*/, ::cosmos::group::v1::QueryVotesByProposalResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_VotesByVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_VotesByVoter() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryVotesByVoterRequest, ::cosmos::group::v1::QueryVotesByVoterResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryVotesByVoterRequest* request, ::cosmos::group::v1::QueryVotesByVoterResponse* response) { return this->VotesByVoter(context, request, response); }));}
    void SetMessageAllocatorFor_VotesByVoter(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryVotesByVoterRequest, ::cosmos::group::v1::QueryVotesByVoterResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryVotesByVoterRequest, ::cosmos::group::v1::QueryVotesByVoterResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_VotesByVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByVoterRequest* /*request*/, ::cosmos::group::v1::QueryVotesByVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VotesByVoter(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByVoterRequest* /*request*/, ::cosmos::group::v1::QueryVotesByVoterResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GroupsByMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GroupsByMember() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupsByMemberRequest, ::cosmos::group::v1::QueryGroupsByMemberResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryGroupsByMemberRequest* request, ::cosmos::group::v1::QueryGroupsByMemberResponse* response) { return this->GroupsByMember(context, request, response); }));}
    void SetMessageAllocatorFor_GroupsByMember(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryGroupsByMemberRequest, ::cosmos::group::v1::QueryGroupsByMemberResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryGroupsByMemberRequest, ::cosmos::group::v1::QueryGroupsByMemberResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GroupsByMember() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByMember(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByMemberRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByMemberResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupsByMember(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByMemberRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByMemberResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TallyResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TallyResult() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryTallyResultRequest, ::cosmos::group::v1::QueryTallyResultResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::cosmos::group::v1::QueryTallyResultRequest* request, ::cosmos::group::v1::QueryTallyResultResponse* response) { return this->TallyResult(context, request, response); }));}
    void SetMessageAllocatorFor_TallyResult(
        ::grpc::MessageAllocator< ::cosmos::group::v1::QueryTallyResultRequest, ::cosmos::group::v1::QueryTallyResultResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::cosmos::group::v1::QueryTallyResultRequest, ::cosmos::group::v1::QueryTallyResultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TallyResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TallyResult(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryTallyResultRequest* /*request*/, ::cosmos::group::v1::QueryTallyResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TallyResult(
      ::grpc::CallbackServerContext* /*context*/, const ::cosmos::group::v1::QueryTallyResultRequest* /*request*/, ::cosmos::group::v1::QueryTallyResultResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GroupInfo<WithCallbackMethod_GroupPolicyInfo<WithCallbackMethod_GroupMembers<WithCallbackMethod_GroupsByAdmin<WithCallbackMethod_GroupPoliciesByGroup<WithCallbackMethod_GroupPoliciesByAdmin<WithCallbackMethod_Proposal<WithCallbackMethod_ProposalsByGroupPolicy<WithCallbackMethod_VoteByProposalVoter<WithCallbackMethod_VotesByProposal<WithCallbackMethod_VotesByVoter<WithCallbackMethod_GroupsByMember<WithCallbackMethod_TallyResult<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GroupInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GroupInfo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GroupInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GroupPolicyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GroupPolicyInfo() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GroupPolicyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPolicyInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GroupMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GroupMembers() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GroupMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupMembers(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupMembersRequest* /*request*/, ::cosmos::group::v1::QueryGroupMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GroupsByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GroupsByAdmin() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GroupsByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GroupPoliciesByGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GroupPoliciesByGroup() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GroupPoliciesByGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByGroup(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GroupPoliciesByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GroupPoliciesByAdmin() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GroupPoliciesByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Proposal() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalRequest* /*request*/, ::cosmos::group::v1::QueryProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProposalsByGroupPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProposalsByGroupPolicy() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ProposalsByGroupPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProposalsByGroupPolicy(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* /*request*/, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VoteByProposalVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VoteByProposalVoter() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_VoteByProposalVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoteByProposalVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* /*request*/, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VotesByProposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VotesByProposal() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_VotesByProposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByProposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByProposalRequest* /*request*/, ::cosmos::group::v1::QueryVotesByProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VotesByVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VotesByVoter() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_VotesByVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByVoterRequest* /*request*/, ::cosmos::group::v1::QueryVotesByVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GroupsByMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GroupsByMember() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GroupsByMember() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByMember(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByMemberRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByMemberResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TallyResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TallyResult() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_TallyResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TallyResult(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryTallyResultRequest* /*request*/, ::cosmos::group::v1::QueryTallyResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GroupInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GroupInfo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GroupInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GroupPolicyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GroupPolicyInfo() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GroupPolicyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPolicyInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupPolicyInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GroupMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GroupMembers() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GroupMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupMembers(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupMembersRequest* /*request*/, ::cosmos::group::v1::QueryGroupMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupMembers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GroupsByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GroupsByAdmin() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GroupsByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupsByAdmin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GroupPoliciesByGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GroupPoliciesByGroup() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GroupPoliciesByGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByGroup(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupPoliciesByGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GroupPoliciesByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GroupPoliciesByAdmin() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GroupPoliciesByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupPoliciesByAdmin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Proposal() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalRequest* /*request*/, ::cosmos::group::v1::QueryProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProposal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProposalsByGroupPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProposalsByGroupPolicy() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ProposalsByGroupPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProposalsByGroupPolicy(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* /*request*/, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProposalsByGroupPolicy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VoteByProposalVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VoteByProposalVoter() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_VoteByProposalVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoteByProposalVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* /*request*/, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVoteByProposalVoter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VotesByProposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VotesByProposal() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_VotesByProposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByProposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByProposalRequest* /*request*/, ::cosmos::group::v1::QueryVotesByProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVotesByProposal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VotesByVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VotesByVoter() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_VotesByVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByVoterRequest* /*request*/, ::cosmos::group::v1::QueryVotesByVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVotesByVoter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GroupsByMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GroupsByMember() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GroupsByMember() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByMember(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByMemberRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByMemberResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGroupsByMember(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TallyResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TallyResult() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_TallyResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TallyResult(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryTallyResultRequest* /*request*/, ::cosmos::group::v1::QueryTallyResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTallyResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GroupInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GroupInfo() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GroupInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GroupInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GroupPolicyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GroupPolicyInfo() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GroupPolicyInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GroupPolicyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPolicyInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupPolicyInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GroupMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GroupMembers() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GroupMembers(context, request, response); }));
    }
    ~WithRawCallbackMethod_GroupMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupMembers(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupMembersRequest* /*request*/, ::cosmos::group::v1::QueryGroupMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupMembers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GroupsByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GroupsByAdmin() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GroupsByAdmin(context, request, response); }));
    }
    ~WithRawCallbackMethod_GroupsByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupsByAdmin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GroupPoliciesByGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GroupPoliciesByGroup() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GroupPoliciesByGroup(context, request, response); }));
    }
    ~WithRawCallbackMethod_GroupPoliciesByGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByGroup(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupPoliciesByGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GroupPoliciesByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GroupPoliciesByAdmin() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GroupPoliciesByAdmin(context, request, response); }));
    }
    ~WithRawCallbackMethod_GroupPoliciesByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupPoliciesByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupPoliciesByAdmin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Proposal() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Proposal(context, request, response); }));
    }
    ~WithRawCallbackMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalRequest* /*request*/, ::cosmos::group::v1::QueryProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Proposal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProposalsByGroupPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ProposalsByGroupPolicy() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProposalsByGroupPolicy(context, request, response); }));
    }
    ~WithRawCallbackMethod_ProposalsByGroupPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProposalsByGroupPolicy(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* /*request*/, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProposalsByGroupPolicy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_VoteByProposalVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_VoteByProposalVoter() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VoteByProposalVoter(context, request, response); }));
    }
    ~WithRawCallbackMethod_VoteByProposalVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoteByProposalVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* /*request*/, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VoteByProposalVoter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_VotesByProposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_VotesByProposal() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VotesByProposal(context, request, response); }));
    }
    ~WithRawCallbackMethod_VotesByProposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByProposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByProposalRequest* /*request*/, ::cosmos::group::v1::QueryVotesByProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VotesByProposal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_VotesByVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_VotesByVoter() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VotesByVoter(context, request, response); }));
    }
    ~WithRawCallbackMethod_VotesByVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VotesByVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByVoterRequest* /*request*/, ::cosmos::group::v1::QueryVotesByVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VotesByVoter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GroupsByMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GroupsByMember() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GroupsByMember(context, request, response); }));
    }
    ~WithRawCallbackMethod_GroupsByMember() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GroupsByMember(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByMemberRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByMemberResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GroupsByMember(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TallyResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TallyResult() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TallyResult(context, request, response); }));
    }
    ~WithRawCallbackMethod_TallyResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TallyResult(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryTallyResultRequest* /*request*/, ::cosmos::group::v1::QueryTallyResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TallyResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GroupInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GroupInfo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryGroupInfoRequest, ::cosmos::group::v1::QueryGroupInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryGroupInfoRequest, ::cosmos::group::v1::QueryGroupInfoResponse>* streamer) {
                       return this->StreamedGroupInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GroupInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GroupInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGroupInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryGroupInfoRequest,::cosmos::group::v1::QueryGroupInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GroupPolicyInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GroupPolicyInfo() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryGroupPolicyInfoRequest, ::cosmos::group::v1::QueryGroupPolicyInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryGroupPolicyInfoRequest, ::cosmos::group::v1::QueryGroupPolicyInfoResponse>* streamer) {
                       return this->StreamedGroupPolicyInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GroupPolicyInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GroupPolicyInfo(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPolicyInfoRequest* /*request*/, ::cosmos::group::v1::QueryGroupPolicyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGroupPolicyInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryGroupPolicyInfoRequest,::cosmos::group::v1::QueryGroupPolicyInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GroupMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GroupMembers() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryGroupMembersRequest, ::cosmos::group::v1::QueryGroupMembersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryGroupMembersRequest, ::cosmos::group::v1::QueryGroupMembersResponse>* streamer) {
                       return this->StreamedGroupMembers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GroupMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GroupMembers(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupMembersRequest* /*request*/, ::cosmos::group::v1::QueryGroupMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGroupMembers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryGroupMembersRequest,::cosmos::group::v1::QueryGroupMembersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GroupsByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GroupsByAdmin() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryGroupsByAdminRequest, ::cosmos::group::v1::QueryGroupsByAdminResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryGroupsByAdminRequest, ::cosmos::group::v1::QueryGroupsByAdminResponse>* streamer) {
                       return this->StreamedGroupsByAdmin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GroupsByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GroupsByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGroupsByAdmin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryGroupsByAdminRequest,::cosmos::group::v1::QueryGroupsByAdminResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GroupPoliciesByGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GroupPoliciesByGroup() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* streamer) {
                       return this->StreamedGroupPoliciesByGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GroupPoliciesByGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GroupPoliciesByGroup(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByGroupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGroupPoliciesByGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryGroupPoliciesByGroupRequest,::cosmos::group::v1::QueryGroupPoliciesByGroupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GroupPoliciesByAdmin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GroupPoliciesByAdmin() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* streamer) {
                       return this->StreamedGroupPoliciesByAdmin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GroupPoliciesByAdmin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GroupPoliciesByAdmin(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest* /*request*/, ::cosmos::group::v1::QueryGroupPoliciesByAdminResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGroupPoliciesByAdmin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryGroupPoliciesByAdminRequest,::cosmos::group::v1::QueryGroupPoliciesByAdminResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Proposal() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryProposalRequest, ::cosmos::group::v1::QueryProposalResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryProposalRequest, ::cosmos::group::v1::QueryProposalResponse>* streamer) {
                       return this->StreamedProposal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalRequest* /*request*/, ::cosmos::group::v1::QueryProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProposal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryProposalRequest,::cosmos::group::v1::QueryProposalResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProposalsByGroupPolicy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProposalsByGroupPolicy() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* streamer) {
                       return this->StreamedProposalsByGroupPolicy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProposalsByGroupPolicy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProposalsByGroupPolicy(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest* /*request*/, ::cosmos::group::v1::QueryProposalsByGroupPolicyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProposalsByGroupPolicy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryProposalsByGroupPolicyRequest,::cosmos::group::v1::QueryProposalsByGroupPolicyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VoteByProposalVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VoteByProposalVoter() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryVoteByProposalVoterRequest, ::cosmos::group::v1::QueryVoteByProposalVoterResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryVoteByProposalVoterRequest, ::cosmos::group::v1::QueryVoteByProposalVoterResponse>* streamer) {
                       return this->StreamedVoteByProposalVoter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VoteByProposalVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VoteByProposalVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVoteByProposalVoterRequest* /*request*/, ::cosmos::group::v1::QueryVoteByProposalVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVoteByProposalVoter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryVoteByProposalVoterRequest,::cosmos::group::v1::QueryVoteByProposalVoterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VotesByProposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VotesByProposal() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryVotesByProposalRequest, ::cosmos::group::v1::QueryVotesByProposalResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryVotesByProposalRequest, ::cosmos::group::v1::QueryVotesByProposalResponse>* streamer) {
                       return this->StreamedVotesByProposal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VotesByProposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VotesByProposal(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByProposalRequest* /*request*/, ::cosmos::group::v1::QueryVotesByProposalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVotesByProposal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryVotesByProposalRequest,::cosmos::group::v1::QueryVotesByProposalResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VotesByVoter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VotesByVoter() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryVotesByVoterRequest, ::cosmos::group::v1::QueryVotesByVoterResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryVotesByVoterRequest, ::cosmos::group::v1::QueryVotesByVoterResponse>* streamer) {
                       return this->StreamedVotesByVoter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VotesByVoter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VotesByVoter(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryVotesByVoterRequest* /*request*/, ::cosmos::group::v1::QueryVotesByVoterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVotesByVoter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryVotesByVoterRequest,::cosmos::group::v1::QueryVotesByVoterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GroupsByMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GroupsByMember() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryGroupsByMemberRequest, ::cosmos::group::v1::QueryGroupsByMemberResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryGroupsByMemberRequest, ::cosmos::group::v1::QueryGroupsByMemberResponse>* streamer) {
                       return this->StreamedGroupsByMember(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GroupsByMember() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GroupsByMember(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryGroupsByMemberRequest* /*request*/, ::cosmos::group::v1::QueryGroupsByMemberResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGroupsByMember(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryGroupsByMemberRequest,::cosmos::group::v1::QueryGroupsByMemberResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TallyResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TallyResult() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::cosmos::group::v1::QueryTallyResultRequest, ::cosmos::group::v1::QueryTallyResultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::cosmos::group::v1::QueryTallyResultRequest, ::cosmos::group::v1::QueryTallyResultResponse>* streamer) {
                       return this->StreamedTallyResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TallyResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TallyResult(::grpc::ServerContext* /*context*/, const ::cosmos::group::v1::QueryTallyResultRequest* /*request*/, ::cosmos::group::v1::QueryTallyResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTallyResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::cosmos::group::v1::QueryTallyResultRequest,::cosmos::group::v1::QueryTallyResultResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GroupInfo<WithStreamedUnaryMethod_GroupPolicyInfo<WithStreamedUnaryMethod_GroupMembers<WithStreamedUnaryMethod_GroupsByAdmin<WithStreamedUnaryMethod_GroupPoliciesByGroup<WithStreamedUnaryMethod_GroupPoliciesByAdmin<WithStreamedUnaryMethod_Proposal<WithStreamedUnaryMethod_ProposalsByGroupPolicy<WithStreamedUnaryMethod_VoteByProposalVoter<WithStreamedUnaryMethod_VotesByProposal<WithStreamedUnaryMethod_VotesByVoter<WithStreamedUnaryMethod_GroupsByMember<WithStreamedUnaryMethod_TallyResult<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GroupInfo<WithStreamedUnaryMethod_GroupPolicyInfo<WithStreamedUnaryMethod_GroupMembers<WithStreamedUnaryMethod_GroupsByAdmin<WithStreamedUnaryMethod_GroupPoliciesByGroup<WithStreamedUnaryMethod_GroupPoliciesByAdmin<WithStreamedUnaryMethod_Proposal<WithStreamedUnaryMethod_ProposalsByGroupPolicy<WithStreamedUnaryMethod_VoteByProposalVoter<WithStreamedUnaryMethod_VotesByProposal<WithStreamedUnaryMethod_VotesByVoter<WithStreamedUnaryMethod_GroupsByMember<WithStreamedUnaryMethod_TallyResult<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace group
}  // namespace cosmos


#endif  // GRPC_cosmos_2fgroup_2fv1_2fquery_2eproto__INCLUDED
