// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/staking/v1beta1/staking.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "amino/amino.pb.h"
#include "tendermint/types/types.pb.h"
#include "tendermint/abci/types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
namespace cosmos {
namespace staking {
namespace v1beta1 {
class Commission;
struct CommissionDefaultTypeInternal;
extern CommissionDefaultTypeInternal _Commission_default_instance_;
class CommissionRates;
struct CommissionRatesDefaultTypeInternal;
extern CommissionRatesDefaultTypeInternal _CommissionRates_default_instance_;
class DVPair;
struct DVPairDefaultTypeInternal;
extern DVPairDefaultTypeInternal _DVPair_default_instance_;
class DVPairs;
struct DVPairsDefaultTypeInternal;
extern DVPairsDefaultTypeInternal _DVPairs_default_instance_;
class DVVTriplet;
struct DVVTripletDefaultTypeInternal;
extern DVVTripletDefaultTypeInternal _DVVTriplet_default_instance_;
class DVVTriplets;
struct DVVTripletsDefaultTypeInternal;
extern DVVTripletsDefaultTypeInternal _DVVTriplets_default_instance_;
class Delegation;
struct DelegationDefaultTypeInternal;
extern DelegationDefaultTypeInternal _Delegation_default_instance_;
class DelegationResponse;
struct DelegationResponseDefaultTypeInternal;
extern DelegationResponseDefaultTypeInternal _DelegationResponse_default_instance_;
class Description;
struct DescriptionDefaultTypeInternal;
extern DescriptionDefaultTypeInternal _Description_default_instance_;
class HistoricalInfo;
struct HistoricalInfoDefaultTypeInternal;
extern HistoricalInfoDefaultTypeInternal _HistoricalInfo_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
class Pool;
struct PoolDefaultTypeInternal;
extern PoolDefaultTypeInternal _Pool_default_instance_;
class Redelegation;
struct RedelegationDefaultTypeInternal;
extern RedelegationDefaultTypeInternal _Redelegation_default_instance_;
class RedelegationEntry;
struct RedelegationEntryDefaultTypeInternal;
extern RedelegationEntryDefaultTypeInternal _RedelegationEntry_default_instance_;
class RedelegationEntryResponse;
struct RedelegationEntryResponseDefaultTypeInternal;
extern RedelegationEntryResponseDefaultTypeInternal _RedelegationEntryResponse_default_instance_;
class RedelegationResponse;
struct RedelegationResponseDefaultTypeInternal;
extern RedelegationResponseDefaultTypeInternal _RedelegationResponse_default_instance_;
class UnbondingDelegation;
struct UnbondingDelegationDefaultTypeInternal;
extern UnbondingDelegationDefaultTypeInternal _UnbondingDelegation_default_instance_;
class UnbondingDelegationEntry;
struct UnbondingDelegationEntryDefaultTypeInternal;
extern UnbondingDelegationEntryDefaultTypeInternal _UnbondingDelegationEntry_default_instance_;
class ValAddresses;
struct ValAddressesDefaultTypeInternal;
extern ValAddressesDefaultTypeInternal _ValAddresses_default_instance_;
class Validator;
struct ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorUpdates;
struct ValidatorUpdatesDefaultTypeInternal;
extern ValidatorUpdatesDefaultTypeInternal _ValidatorUpdates_default_instance_;
}  // namespace v1beta1
}  // namespace staking
}  // namespace cosmos
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmos::staking::v1beta1::Commission* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::Commission>(Arena*);
template <>
::cosmos::staking::v1beta1::CommissionRates* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::CommissionRates>(Arena*);
template <>
::cosmos::staking::v1beta1::DVPair* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::DVPair>(Arena*);
template <>
::cosmos::staking::v1beta1::DVPairs* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::DVPairs>(Arena*);
template <>
::cosmos::staking::v1beta1::DVVTriplet* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::DVVTriplet>(Arena*);
template <>
::cosmos::staking::v1beta1::DVVTriplets* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::DVVTriplets>(Arena*);
template <>
::cosmos::staking::v1beta1::Delegation* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::Delegation>(Arena*);
template <>
::cosmos::staking::v1beta1::DelegationResponse* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::DelegationResponse>(Arena*);
template <>
::cosmos::staking::v1beta1::Description* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::Description>(Arena*);
template <>
::cosmos::staking::v1beta1::HistoricalInfo* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::HistoricalInfo>(Arena*);
template <>
::cosmos::staking::v1beta1::Params* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::Params>(Arena*);
template <>
::cosmos::staking::v1beta1::Pool* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::Pool>(Arena*);
template <>
::cosmos::staking::v1beta1::Redelegation* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::Redelegation>(Arena*);
template <>
::cosmos::staking::v1beta1::RedelegationEntry* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::RedelegationEntry>(Arena*);
template <>
::cosmos::staking::v1beta1::RedelegationEntryResponse* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::RedelegationEntryResponse>(Arena*);
template <>
::cosmos::staking::v1beta1::RedelegationResponse* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::RedelegationResponse>(Arena*);
template <>
::cosmos::staking::v1beta1::UnbondingDelegation* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::UnbondingDelegation>(Arena*);
template <>
::cosmos::staking::v1beta1::UnbondingDelegationEntry* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::UnbondingDelegationEntry>(Arena*);
template <>
::cosmos::staking::v1beta1::ValAddresses* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::ValAddresses>(Arena*);
template <>
::cosmos::staking::v1beta1::Validator* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::Validator>(Arena*);
template <>
::cosmos::staking::v1beta1::ValidatorUpdates* Arena::CreateMaybeMessage<::cosmos::staking::v1beta1::ValidatorUpdates>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmos {
namespace staking {
namespace v1beta1 {
enum BondStatus : int {
  BOND_STATUS_UNSPECIFIED = 0,
  BOND_STATUS_UNBONDED = 1,
  BOND_STATUS_UNBONDING = 2,
  BOND_STATUS_BONDED = 3,
  BondStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BondStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BondStatus_IsValid(int value);
constexpr BondStatus BondStatus_MIN = static_cast<BondStatus>(0);
constexpr BondStatus BondStatus_MAX = static_cast<BondStatus>(3);
constexpr int BondStatus_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
BondStatus_descriptor();
template <typename T>
const std::string& BondStatus_Name(T value) {
  static_assert(std::is_same<T, BondStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BondStatus_Name().");
  return BondStatus_Name(static_cast<BondStatus>(value));
}
template <>
inline const std::string& BondStatus_Name(BondStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<BondStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool BondStatus_Parse(absl::string_view name, BondStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BondStatus>(
      BondStatus_descriptor(), name, value);
}
enum Infraction : int {
  INFRACTION_UNSPECIFIED = 0,
  INFRACTION_DOUBLE_SIGN = 1,
  INFRACTION_DOWNTIME = 2,
  Infraction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Infraction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Infraction_IsValid(int value);
constexpr Infraction Infraction_MIN = static_cast<Infraction>(0);
constexpr Infraction Infraction_MAX = static_cast<Infraction>(2);
constexpr int Infraction_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Infraction_descriptor();
template <typename T>
const std::string& Infraction_Name(T value) {
  static_assert(std::is_same<T, Infraction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Infraction_Name().");
  return Infraction_Name(static_cast<Infraction>(value));
}
template <>
inline const std::string& Infraction_Name(Infraction value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Infraction_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Infraction_Parse(absl::string_view name, Infraction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Infraction>(
      Infraction_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class HistoricalInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.HistoricalInfo) */ {
 public:
  inline HistoricalInfo() : HistoricalInfo(nullptr) {}
  ~HistoricalInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HistoricalInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistoricalInfo(const HistoricalInfo& from);
  HistoricalInfo(HistoricalInfo&& from) noexcept
    : HistoricalInfo() {
    *this = ::std::move(from);
  }

  inline HistoricalInfo& operator=(const HistoricalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoricalInfo& operator=(HistoricalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoricalInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistoricalInfo* internal_default_instance() {
    return reinterpret_cast<const HistoricalInfo*>(
               &_HistoricalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HistoricalInfo& a, HistoricalInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoricalInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoricalInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoricalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistoricalInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistoricalInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistoricalInfo& from) {
    HistoricalInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoricalInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.HistoricalInfo";
  }
  protected:
  explicit HistoricalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsetFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.Validator valset = 2 [json_name = "valset", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int valset_size() const;
  private:
  int _internal_valset_size() const;

  public:
  void clear_valset() ;
  ::cosmos::staking::v1beta1::Validator* mutable_valset(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::Validator >*
      mutable_valset();
  private:
  const ::cosmos::staking::v1beta1::Validator& _internal_valset(int index) const;
  ::cosmos::staking::v1beta1::Validator* _internal_add_valset();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>& _internal_valset() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>* _internal_mutable_valset();
  public:
  const ::cosmos::staking::v1beta1::Validator& valset(int index) const;
  ::cosmos::staking::v1beta1::Validator* add_valset();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::Validator >&
      valset() const;
  // .tendermint.types.Header header = 1 [json_name = "header", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_header() const;
  void clear_header() ;
  const ::tendermint::types::Header& header() const;
  PROTOBUF_NODISCARD ::tendermint::types::Header* release_header();
  ::tendermint::types::Header* mutable_header();
  void set_allocated_header(::tendermint::types::Header* header);
  private:
  const ::tendermint::types::Header& _internal_header() const;
  ::tendermint::types::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tendermint::types::Header* header);
  ::tendermint::types::Header* unsafe_arena_release_header();
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.HistoricalInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::Validator > valset_;
    ::tendermint::types::Header* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class CommissionRates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.CommissionRates) */ {
 public:
  inline CommissionRates() : CommissionRates(nullptr) {}
  ~CommissionRates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommissionRates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommissionRates(const CommissionRates& from);
  CommissionRates(CommissionRates&& from) noexcept
    : CommissionRates() {
    *this = ::std::move(from);
  }

  inline CommissionRates& operator=(const CommissionRates& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommissionRates& operator=(CommissionRates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommissionRates& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommissionRates* internal_default_instance() {
    return reinterpret_cast<const CommissionRates*>(
               &_CommissionRates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CommissionRates& a, CommissionRates& b) {
    a.Swap(&b);
  }
  inline void Swap(CommissionRates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommissionRates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommissionRates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommissionRates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommissionRates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommissionRates& from) {
    CommissionRates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommissionRates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.CommissionRates";
  }
  protected:
  explicit CommissionRates(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRateFieldNumber = 1,
    kMaxRateFieldNumber = 2,
    kMaxChangeRateFieldNumber = 3,
  };
  // string rate = 1 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_rate() ;
  const std::string& rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rate(Arg_&& arg, Args_... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* ptr);

  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(
      const std::string& value);
  std::string* _internal_mutable_rate();

  public:
  // string max_rate = 2 [json_name = "maxRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_max_rate() ;
  const std::string& max_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_rate(Arg_&& arg, Args_... args);
  std::string* mutable_max_rate();
  PROTOBUF_NODISCARD std::string* release_max_rate();
  void set_allocated_max_rate(std::string* ptr);

  private:
  const std::string& _internal_max_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_rate(
      const std::string& value);
  std::string* _internal_mutable_max_rate();

  public:
  // string max_change_rate = 3 [json_name = "maxChangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_max_change_rate() ;
  const std::string& max_change_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_change_rate(Arg_&& arg, Args_... args);
  std::string* mutable_max_change_rate();
  PROTOBUF_NODISCARD std::string* release_max_change_rate();
  void set_allocated_max_change_rate(std::string* ptr);

  private:
  const std::string& _internal_max_change_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_change_rate(
      const std::string& value);
  std::string* _internal_mutable_max_change_rate();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.CommissionRates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_change_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class Commission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Commission) */ {
 public:
  inline Commission() : Commission(nullptr) {}
  ~Commission() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Commission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Commission(const Commission& from);
  Commission(Commission&& from) noexcept
    : Commission() {
    *this = ::std::move(from);
  }

  inline Commission& operator=(const Commission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Commission& operator=(Commission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Commission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Commission* internal_default_instance() {
    return reinterpret_cast<const Commission*>(
               &_Commission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Commission& a, Commission& b) {
    a.Swap(&b);
  }
  inline void Swap(Commission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Commission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Commission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Commission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Commission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Commission& from) {
    Commission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Commission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.Commission";
  }
  protected:
  explicit Commission(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommissionRatesFieldNumber = 1,
    kUpdateTimeFieldNumber = 2,
  };
  // .cosmos.staking.v1beta1.CommissionRates commission_rates = 1 [json_name = "commissionRates", (.gogoproto.nullable) = false, (.gogoproto.embed) = true, (.amino.dont_omitempty) = true];
  bool has_commission_rates() const;
  void clear_commission_rates() ;
  const ::cosmos::staking::v1beta1::CommissionRates& commission_rates() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::CommissionRates* release_commission_rates();
  ::cosmos::staking::v1beta1::CommissionRates* mutable_commission_rates();
  void set_allocated_commission_rates(::cosmos::staking::v1beta1::CommissionRates* commission_rates);
  private:
  const ::cosmos::staking::v1beta1::CommissionRates& _internal_commission_rates() const;
  ::cosmos::staking::v1beta1::CommissionRates* _internal_mutable_commission_rates();
  public:
  void unsafe_arena_set_allocated_commission_rates(
      ::cosmos::staking::v1beta1::CommissionRates* commission_rates);
  ::cosmos::staking::v1beta1::CommissionRates* unsafe_arena_release_commission_rates();
  // .google.protobuf.Timestamp update_time = 2 [json_name = "updateTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_update_time() const;
  void clear_update_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Commission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cosmos::staking::v1beta1::CommissionRates* commission_rates_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class Description final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Description) */ {
 public:
  inline Description() : Description(nullptr) {}
  ~Description() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Description(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Description(const Description& from);
  Description(Description&& from) noexcept
    : Description() {
    *this = ::std::move(from);
  }

  inline Description& operator=(const Description& from) {
    CopyFrom(from);
    return *this;
  }
  inline Description& operator=(Description&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Description& default_instance() {
    return *internal_default_instance();
  }
  static inline const Description* internal_default_instance() {
    return reinterpret_cast<const Description*>(
               &_Description_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Description& a, Description& b) {
    a.Swap(&b);
  }
  inline void Swap(Description* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Description* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Description* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Description>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Description& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Description& from) {
    Description::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Description* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.Description";
  }
  protected:
  explicit Description(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonikerFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kWebsiteFieldNumber = 3,
    kSecurityContactFieldNumber = 4,
    kDetailsFieldNumber = 5,
  };
  // string moniker = 1 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* ptr);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // string identity = 2 [json_name = "identity"];
  void clear_identity() ;
  const std::string& identity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identity(Arg_&& arg, Args_... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* ptr);

  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(
      const std::string& value);
  std::string* _internal_mutable_identity();

  public:
  // string website = 3 [json_name = "website"];
  void clear_website() ;
  const std::string& website() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_website(Arg_&& arg, Args_... args);
  std::string* mutable_website();
  PROTOBUF_NODISCARD std::string* release_website();
  void set_allocated_website(std::string* ptr);

  private:
  const std::string& _internal_website() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website(
      const std::string& value);
  std::string* _internal_mutable_website();

  public:
  // string security_contact = 4 [json_name = "securityContact"];
  void clear_security_contact() ;
  const std::string& security_contact() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_security_contact(Arg_&& arg, Args_... args);
  std::string* mutable_security_contact();
  PROTOBUF_NODISCARD std::string* release_security_contact();
  void set_allocated_security_contact(std::string* ptr);

  private:
  const std::string& _internal_security_contact() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_contact(
      const std::string& value);
  std::string* _internal_mutable_security_contact();

  public:
  // string details = 5 [json_name = "details"];
  void clear_details() ;
  const std::string& details() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_details(Arg_&& arg, Args_... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* ptr);

  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(
      const std::string& value);
  std::string* _internal_mutable_details();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Description)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr moniker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr security_contact_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class Validator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Validator) */ {
 public:
  inline Validator() : Validator(nullptr) {}
  ~Validator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Validator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Validator(const Validator& from);
  Validator(Validator&& from) noexcept
    : Validator() {
    *this = ::std::move(from);
  }

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Validator& operator=(Validator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Validator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Validator& a, Validator& b) {
    a.Swap(&b);
  }
  inline void Swap(Validator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Validator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Validator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Validator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Validator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Validator& from) {
    Validator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Validator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.Validator";
  }
  protected:
  explicit Validator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnbondingIdsFieldNumber = 13,
    kOperatorAddressFieldNumber = 1,
    kTokensFieldNumber = 5,
    kDelegatorSharesFieldNumber = 6,
    kMinSelfDelegationFieldNumber = 11,
    kConsensusPubkeyFieldNumber = 2,
    kDescriptionFieldNumber = 7,
    kUnbondingTimeFieldNumber = 9,
    kCommissionFieldNumber = 10,
    kJailedFieldNumber = 3,
    kStatusFieldNumber = 4,
    kUnbondingHeightFieldNumber = 8,
    kUnbondingOnHoldRefCountFieldNumber = 12,
  };
  // repeated uint64 unbonding_ids = 13 [json_name = "unbondingIds"];
  int unbonding_ids_size() const;
  private:
  int _internal_unbonding_ids_size() const;

  public:
  void clear_unbonding_ids() ;
  ::uint64_t unbonding_ids(int index) const;
  void set_unbonding_ids(int index, ::uint64_t value);
  void add_unbonding_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& unbonding_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_unbonding_ids();

  private:
  ::uint64_t _internal_unbonding_ids(int index) const;
  void _internal_add_unbonding_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_unbonding_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_unbonding_ids();

  public:
  // string operator_address = 1 [json_name = "operatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_operator_address() ;
  const std::string& operator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_address(Arg_&& arg, Args_... args);
  std::string* mutable_operator_address();
  PROTOBUF_NODISCARD std::string* release_operator_address();
  void set_allocated_operator_address(std::string* ptr);

  private:
  const std::string& _internal_operator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_address(
      const std::string& value);
  std::string* _internal_mutable_operator_address();

  public:
  // string tokens = 5 [json_name = "tokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_tokens() ;
  const std::string& tokens() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tokens(Arg_&& arg, Args_... args);
  std::string* mutable_tokens();
  PROTOBUF_NODISCARD std::string* release_tokens();
  void set_allocated_tokens(std::string* ptr);

  private:
  const std::string& _internal_tokens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokens(
      const std::string& value);
  std::string* _internal_mutable_tokens();

  public:
  // string delegator_shares = 6 [json_name = "delegatorShares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_delegator_shares() ;
  const std::string& delegator_shares() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_shares(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_shares();
  PROTOBUF_NODISCARD std::string* release_delegator_shares();
  void set_allocated_delegator_shares(std::string* ptr);

  private:
  const std::string& _internal_delegator_shares() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_shares(
      const std::string& value);
  std::string* _internal_mutable_delegator_shares();

  public:
  // string min_self_delegation = 11 [json_name = "minSelfDelegation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_min_self_delegation() ;
  const std::string& min_self_delegation() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_self_delegation(Arg_&& arg, Args_... args);
  std::string* mutable_min_self_delegation();
  PROTOBUF_NODISCARD std::string* release_min_self_delegation();
  void set_allocated_min_self_delegation(std::string* ptr);

  private:
  const std::string& _internal_min_self_delegation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_self_delegation(
      const std::string& value);
  std::string* _internal_mutable_min_self_delegation();

  public:
  // .google.protobuf.Any consensus_pubkey = 2 [json_name = "consensusPubkey", (.cosmos_proto.accepts_interface) = "cosmos.crypto.PubKey"];
  bool has_consensus_pubkey() const;
  void clear_consensus_pubkey() ;
  const ::PROTOBUF_NAMESPACE_ID::Any& consensus_pubkey() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_consensus_pubkey();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_consensus_pubkey();
  void set_allocated_consensus_pubkey(::PROTOBUF_NAMESPACE_ID::Any* consensus_pubkey);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_consensus_pubkey() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_consensus_pubkey();
  public:
  void unsafe_arena_set_allocated_consensus_pubkey(
      ::PROTOBUF_NAMESPACE_ID::Any* consensus_pubkey);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_consensus_pubkey();
  // .cosmos.staking.v1beta1.Description description = 7 [json_name = "description", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_description() const;
  void clear_description() ;
  const ::cosmos::staking::v1beta1::Description& description() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Description* release_description();
  ::cosmos::staking::v1beta1::Description* mutable_description();
  void set_allocated_description(::cosmos::staking::v1beta1::Description* description);
  private:
  const ::cosmos::staking::v1beta1::Description& _internal_description() const;
  ::cosmos::staking::v1beta1::Description* _internal_mutable_description();
  public:
  void unsafe_arena_set_allocated_description(
      ::cosmos::staking::v1beta1::Description* description);
  ::cosmos::staking::v1beta1::Description* unsafe_arena_release_description();
  // .google.protobuf.Timestamp unbonding_time = 9 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_unbonding_time() const;
  void clear_unbonding_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& unbonding_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_unbonding_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_unbonding_time();
  void set_allocated_unbonding_time(::PROTOBUF_NAMESPACE_ID::Timestamp* unbonding_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_unbonding_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_unbonding_time();
  public:
  void unsafe_arena_set_allocated_unbonding_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* unbonding_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_unbonding_time();
  // .cosmos.staking.v1beta1.Commission commission = 10 [json_name = "commission", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_commission() const;
  void clear_commission() ;
  const ::cosmos::staking::v1beta1::Commission& commission() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Commission* release_commission();
  ::cosmos::staking::v1beta1::Commission* mutable_commission();
  void set_allocated_commission(::cosmos::staking::v1beta1::Commission* commission);
  private:
  const ::cosmos::staking::v1beta1::Commission& _internal_commission() const;
  ::cosmos::staking::v1beta1::Commission* _internal_mutable_commission();
  public:
  void unsafe_arena_set_allocated_commission(
      ::cosmos::staking::v1beta1::Commission* commission);
  ::cosmos::staking::v1beta1::Commission* unsafe_arena_release_commission();
  // bool jailed = 3 [json_name = "jailed"];
  void clear_jailed() ;
  bool jailed() const;
  void set_jailed(bool value);

  private:
  bool _internal_jailed() const;
  void _internal_set_jailed(bool value);

  public:
  // .cosmos.staking.v1beta1.BondStatus status = 4 [json_name = "status"];
  void clear_status() ;
  ::cosmos::staking::v1beta1::BondStatus status() const;
  void set_status(::cosmos::staking::v1beta1::BondStatus value);

  private:
  ::cosmos::staking::v1beta1::BondStatus _internal_status() const;
  void _internal_set_status(::cosmos::staking::v1beta1::BondStatus value);

  public:
  // int64 unbonding_height = 8 [json_name = "unbondingHeight"];
  void clear_unbonding_height() ;
  ::int64_t unbonding_height() const;
  void set_unbonding_height(::int64_t value);

  private:
  ::int64_t _internal_unbonding_height() const;
  void _internal_set_unbonding_height(::int64_t value);

  public:
  // int64 unbonding_on_hold_ref_count = 12 [json_name = "unbondingOnHoldRefCount"];
  void clear_unbonding_on_hold_ref_count() ;
  ::int64_t unbonding_on_hold_ref_count() const;
  void set_unbonding_on_hold_ref_count(::int64_t value);

  private:
  ::int64_t _internal_unbonding_on_hold_ref_count() const;
  void _internal_set_unbonding_on_hold_ref_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Validator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> unbonding_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _unbonding_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokens_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegator_shares_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_self_delegation_;
    ::PROTOBUF_NAMESPACE_ID::Any* consensus_pubkey_;
    ::cosmos::staking::v1beta1::Description* description_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* unbonding_time_;
    ::cosmos::staking::v1beta1::Commission* commission_;
    bool jailed_;
    int status_;
    ::int64_t unbonding_height_;
    ::int64_t unbonding_on_hold_ref_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class ValAddresses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.ValAddresses) */ {
 public:
  inline ValAddresses() : ValAddresses(nullptr) {}
  ~ValAddresses() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValAddresses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValAddresses(const ValAddresses& from);
  ValAddresses(ValAddresses&& from) noexcept
    : ValAddresses() {
    *this = ::std::move(from);
  }

  inline ValAddresses& operator=(const ValAddresses& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValAddresses& operator=(ValAddresses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValAddresses& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValAddresses* internal_default_instance() {
    return reinterpret_cast<const ValAddresses*>(
               &_ValAddresses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValAddresses& a, ValAddresses& b) {
    a.Swap(&b);
  }
  inline void Swap(ValAddresses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValAddresses* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValAddresses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValAddresses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValAddresses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValAddresses& from) {
    ValAddresses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValAddresses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.ValAddresses";
  }
  protected:
  explicit ValAddresses(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 1,
  };
  // repeated string addresses = 1 [json_name = "addresses", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;

  public:
  void clear_addresses() ;
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, std::size_t size);
  void set_addresses(int index, absl::string_view value);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, std::size_t size);
  void add_addresses(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();

  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_addresses();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.ValAddresses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class DVPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVPair) */ {
 public:
  inline DVPair() : DVPair(nullptr) {}
  ~DVPair() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DVPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DVPair(const DVPair& from);
  DVPair(DVPair&& from) noexcept
    : DVPair() {
    *this = ::std::move(from);
  }

  inline DVPair& operator=(const DVPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVPair& operator=(DVPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVPair* internal_default_instance() {
    return reinterpret_cast<const DVPair*>(
               &_DVPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DVPair& a, DVPair& b) {
    a.Swap(&b);
  }
  inline void Swap(DVPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVPair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DVPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DVPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DVPair& from) {
    DVPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DVPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.DVPair";
  }
  protected:
  explicit DVPair(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatorAddressFieldNumber = 1,
    kValidatorAddressFieldNumber = 2,
  };
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* ptr);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class DVPairs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVPairs) */ {
 public:
  inline DVPairs() : DVPairs(nullptr) {}
  ~DVPairs() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DVPairs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DVPairs(const DVPairs& from);
  DVPairs(DVPairs&& from) noexcept
    : DVPairs() {
    *this = ::std::move(from);
  }

  inline DVPairs& operator=(const DVPairs& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVPairs& operator=(DVPairs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVPairs& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVPairs* internal_default_instance() {
    return reinterpret_cast<const DVPairs*>(
               &_DVPairs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DVPairs& a, DVPairs& b) {
    a.Swap(&b);
  }
  inline void Swap(DVPairs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVPairs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVPairs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DVPairs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DVPairs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DVPairs& from) {
    DVPairs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DVPairs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.DVPairs";
  }
  protected:
  explicit DVPairs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPairsFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.DVPair pairs = 1 [json_name = "pairs", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int pairs_size() const;
  private:
  int _internal_pairs_size() const;

  public:
  void clear_pairs() ;
  ::cosmos::staking::v1beta1::DVPair* mutable_pairs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVPair >*
      mutable_pairs();
  private:
  const ::cosmos::staking::v1beta1::DVPair& _internal_pairs(int index) const;
  ::cosmos::staking::v1beta1::DVPair* _internal_add_pairs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>& _internal_pairs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>* _internal_mutable_pairs();
  public:
  const ::cosmos::staking::v1beta1::DVPair& pairs(int index) const;
  ::cosmos::staking::v1beta1::DVPair* add_pairs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVPair >&
      pairs() const;
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVPairs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVPair > pairs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class DVVTriplet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVVTriplet) */ {
 public:
  inline DVVTriplet() : DVVTriplet(nullptr) {}
  ~DVVTriplet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DVVTriplet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DVVTriplet(const DVVTriplet& from);
  DVVTriplet(DVVTriplet&& from) noexcept
    : DVVTriplet() {
    *this = ::std::move(from);
  }

  inline DVVTriplet& operator=(const DVVTriplet& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVVTriplet& operator=(DVVTriplet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVVTriplet& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVVTriplet* internal_default_instance() {
    return reinterpret_cast<const DVVTriplet*>(
               &_DVVTriplet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DVVTriplet& a, DVVTriplet& b) {
    a.Swap(&b);
  }
  inline void Swap(DVVTriplet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVVTriplet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVVTriplet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DVVTriplet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DVVTriplet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DVVTriplet& from) {
    DVVTriplet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DVVTriplet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.DVVTriplet";
  }
  protected:
  explicit DVVTriplet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatorAddressFieldNumber = 1,
    kValidatorSrcAddressFieldNumber = 2,
    kValidatorDstAddressFieldNumber = 3,
  };
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* ptr);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_src_address() ;
  const std::string& validator_src_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_src_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_src_address();
  PROTOBUF_NODISCARD std::string* release_validator_src_address();
  void set_allocated_validator_src_address(std::string* ptr);

  private:
  const std::string& _internal_validator_src_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_src_address(
      const std::string& value);
  std::string* _internal_mutable_validator_src_address();

  public:
  // string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_dst_address() ;
  const std::string& validator_dst_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_dst_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_dst_address();
  PROTOBUF_NODISCARD std::string* release_validator_dst_address();
  void set_allocated_validator_dst_address(std::string* ptr);

  private:
  const std::string& _internal_validator_dst_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_dst_address(
      const std::string& value);
  std::string* _internal_mutable_validator_dst_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVVTriplet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_src_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_dst_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class DVVTriplets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVVTriplets) */ {
 public:
  inline DVVTriplets() : DVVTriplets(nullptr) {}
  ~DVVTriplets() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DVVTriplets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DVVTriplets(const DVVTriplets& from);
  DVVTriplets(DVVTriplets&& from) noexcept
    : DVVTriplets() {
    *this = ::std::move(from);
  }

  inline DVVTriplets& operator=(const DVVTriplets& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVVTriplets& operator=(DVVTriplets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVVTriplets& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVVTriplets* internal_default_instance() {
    return reinterpret_cast<const DVVTriplets*>(
               &_DVVTriplets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DVVTriplets& a, DVVTriplets& b) {
    a.Swap(&b);
  }
  inline void Swap(DVVTriplets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVVTriplets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVVTriplets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DVVTriplets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DVVTriplets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DVVTriplets& from) {
    DVVTriplets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DVVTriplets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.DVVTriplets";
  }
  protected:
  explicit DVVTriplets(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTripletsFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.DVVTriplet triplets = 1 [json_name = "triplets", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int triplets_size() const;
  private:
  int _internal_triplets_size() const;

  public:
  void clear_triplets() ;
  ::cosmos::staking::v1beta1::DVVTriplet* mutable_triplets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVVTriplet >*
      mutable_triplets();
  private:
  const ::cosmos::staking::v1beta1::DVVTriplet& _internal_triplets(int index) const;
  ::cosmos::staking::v1beta1::DVVTriplet* _internal_add_triplets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>& _internal_triplets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>* _internal_mutable_triplets();
  public:
  const ::cosmos::staking::v1beta1::DVVTriplet& triplets(int index) const;
  ::cosmos::staking::v1beta1::DVVTriplet* add_triplets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVVTriplet >&
      triplets() const;
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVVTriplets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVVTriplet > triplets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class Delegation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Delegation) */ {
 public:
  inline Delegation() : Delegation(nullptr) {}
  ~Delegation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Delegation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Delegation(const Delegation& from);
  Delegation(Delegation&& from) noexcept
    : Delegation() {
    *this = ::std::move(from);
  }

  inline Delegation& operator=(const Delegation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delegation& operator=(Delegation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Delegation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Delegation* internal_default_instance() {
    return reinterpret_cast<const Delegation*>(
               &_Delegation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Delegation& a, Delegation& b) {
    a.Swap(&b);
  }
  inline void Swap(Delegation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Delegation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Delegation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Delegation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Delegation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Delegation& from) {
    Delegation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delegation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.Delegation";
  }
  protected:
  explicit Delegation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatorAddressFieldNumber = 1,
    kValidatorAddressFieldNumber = 2,
    kSharesFieldNumber = 3,
  };
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* ptr);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // string shares = 3 [json_name = "shares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_shares() ;
  const std::string& shares() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shares(Arg_&& arg, Args_... args);
  std::string* mutable_shares();
  PROTOBUF_NODISCARD std::string* release_shares();
  void set_allocated_shares(std::string* ptr);

  private:
  const std::string& _internal_shares() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shares(
      const std::string& value);
  std::string* _internal_mutable_shares();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Delegation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shares_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class UnbondingDelegation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.UnbondingDelegation) */ {
 public:
  inline UnbondingDelegation() : UnbondingDelegation(nullptr) {}
  ~UnbondingDelegation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnbondingDelegation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnbondingDelegation(const UnbondingDelegation& from);
  UnbondingDelegation(UnbondingDelegation&& from) noexcept
    : UnbondingDelegation() {
    *this = ::std::move(from);
  }

  inline UnbondingDelegation& operator=(const UnbondingDelegation& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnbondingDelegation& operator=(UnbondingDelegation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnbondingDelegation& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnbondingDelegation* internal_default_instance() {
    return reinterpret_cast<const UnbondingDelegation*>(
               &_UnbondingDelegation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UnbondingDelegation& a, UnbondingDelegation& b) {
    a.Swap(&b);
  }
  inline void Swap(UnbondingDelegation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnbondingDelegation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnbondingDelegation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnbondingDelegation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnbondingDelegation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnbondingDelegation& from) {
    UnbondingDelegation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnbondingDelegation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.UnbondingDelegation";
  }
  protected:
  explicit UnbondingDelegation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kDelegatorAddressFieldNumber = 1,
    kValidatorAddressFieldNumber = 2,
  };
  // repeated .cosmos.staking.v1beta1.UnbondingDelegationEntry entries = 3 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::staking::v1beta1::UnbondingDelegationEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::UnbondingDelegationEntry >*
      mutable_entries();
  private:
  const ::cosmos::staking::v1beta1::UnbondingDelegationEntry& _internal_entries(int index) const;
  ::cosmos::staking::v1beta1::UnbondingDelegationEntry* _internal_add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>& _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::staking::v1beta1::UnbondingDelegationEntry& entries(int index) const;
  ::cosmos::staking::v1beta1::UnbondingDelegationEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::UnbondingDelegationEntry >&
      entries() const;
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* ptr);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.UnbondingDelegation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::UnbondingDelegationEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class UnbondingDelegationEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.UnbondingDelegationEntry) */ {
 public:
  inline UnbondingDelegationEntry() : UnbondingDelegationEntry(nullptr) {}
  ~UnbondingDelegationEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnbondingDelegationEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnbondingDelegationEntry(const UnbondingDelegationEntry& from);
  UnbondingDelegationEntry(UnbondingDelegationEntry&& from) noexcept
    : UnbondingDelegationEntry() {
    *this = ::std::move(from);
  }

  inline UnbondingDelegationEntry& operator=(const UnbondingDelegationEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnbondingDelegationEntry& operator=(UnbondingDelegationEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnbondingDelegationEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnbondingDelegationEntry* internal_default_instance() {
    return reinterpret_cast<const UnbondingDelegationEntry*>(
               &_UnbondingDelegationEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UnbondingDelegationEntry& a, UnbondingDelegationEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(UnbondingDelegationEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnbondingDelegationEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnbondingDelegationEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnbondingDelegationEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnbondingDelegationEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnbondingDelegationEntry& from) {
    UnbondingDelegationEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnbondingDelegationEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.UnbondingDelegationEntry";
  }
  protected:
  explicit UnbondingDelegationEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialBalanceFieldNumber = 3,
    kBalanceFieldNumber = 4,
    kCompletionTimeFieldNumber = 2,
    kCreationHeightFieldNumber = 1,
    kUnbondingIdFieldNumber = 5,
    kUnbondingOnHoldRefCountFieldNumber = 6,
  };
  // string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_initial_balance() ;
  const std::string& initial_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_balance(Arg_&& arg, Args_... args);
  std::string* mutable_initial_balance();
  PROTOBUF_NODISCARD std::string* release_initial_balance();
  void set_allocated_initial_balance(std::string* ptr);

  private:
  const std::string& _internal_initial_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_balance(
      const std::string& value);
  std::string* _internal_mutable_initial_balance();

  public:
  // string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_balance() ;
  const std::string& balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* ptr);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_completion_time() const;
  void clear_completion_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& completion_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_completion_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_completion_time();
  void set_allocated_completion_time(::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_completion_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_completion_time();
  public:
  void unsafe_arena_set_allocated_completion_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_completion_time();
  // int64 creation_height = 1 [json_name = "creationHeight"];
  void clear_creation_height() ;
  ::int64_t creation_height() const;
  void set_creation_height(::int64_t value);

  private:
  ::int64_t _internal_creation_height() const;
  void _internal_set_creation_height(::int64_t value);

  public:
  // uint64 unbonding_id = 5 [json_name = "unbondingId"];
  void clear_unbonding_id() ;
  ::uint64_t unbonding_id() const;
  void set_unbonding_id(::uint64_t value);

  private:
  ::uint64_t _internal_unbonding_id() const;
  void _internal_set_unbonding_id(::uint64_t value);

  public:
  // int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
  void clear_unbonding_on_hold_ref_count() ;
  ::int64_t unbonding_on_hold_ref_count() const;
  void set_unbonding_on_hold_ref_count(::int64_t value);

  private:
  ::int64_t _internal_unbonding_on_hold_ref_count() const;
  void _internal_set_unbonding_on_hold_ref_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.UnbondingDelegationEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time_;
    ::int64_t creation_height_;
    ::uint64_t unbonding_id_;
    ::int64_t unbonding_on_hold_ref_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class RedelegationEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.RedelegationEntry) */ {
 public:
  inline RedelegationEntry() : RedelegationEntry(nullptr) {}
  ~RedelegationEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RedelegationEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedelegationEntry(const RedelegationEntry& from);
  RedelegationEntry(RedelegationEntry&& from) noexcept
    : RedelegationEntry() {
    *this = ::std::move(from);
  }

  inline RedelegationEntry& operator=(const RedelegationEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedelegationEntry& operator=(RedelegationEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedelegationEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedelegationEntry* internal_default_instance() {
    return reinterpret_cast<const RedelegationEntry*>(
               &_RedelegationEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RedelegationEntry& a, RedelegationEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RedelegationEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedelegationEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedelegationEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedelegationEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedelegationEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedelegationEntry& from) {
    RedelegationEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedelegationEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.RedelegationEntry";
  }
  protected:
  explicit RedelegationEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialBalanceFieldNumber = 3,
    kSharesDstFieldNumber = 4,
    kCompletionTimeFieldNumber = 2,
    kCreationHeightFieldNumber = 1,
    kUnbondingIdFieldNumber = 5,
    kUnbondingOnHoldRefCountFieldNumber = 6,
  };
  // string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_initial_balance() ;
  const std::string& initial_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_balance(Arg_&& arg, Args_... args);
  std::string* mutable_initial_balance();
  PROTOBUF_NODISCARD std::string* release_initial_balance();
  void set_allocated_initial_balance(std::string* ptr);

  private:
  const std::string& _internal_initial_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_balance(
      const std::string& value);
  std::string* _internal_mutable_initial_balance();

  public:
  // string shares_dst = 4 [json_name = "sharesDst", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_shares_dst() ;
  const std::string& shares_dst() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shares_dst(Arg_&& arg, Args_... args);
  std::string* mutable_shares_dst();
  PROTOBUF_NODISCARD std::string* release_shares_dst();
  void set_allocated_shares_dst(std::string* ptr);

  private:
  const std::string& _internal_shares_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shares_dst(
      const std::string& value);
  std::string* _internal_mutable_shares_dst();

  public:
  // .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_completion_time() const;
  void clear_completion_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& completion_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_completion_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_completion_time();
  void set_allocated_completion_time(::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_completion_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_completion_time();
  public:
  void unsafe_arena_set_allocated_completion_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_completion_time();
  // int64 creation_height = 1 [json_name = "creationHeight"];
  void clear_creation_height() ;
  ::int64_t creation_height() const;
  void set_creation_height(::int64_t value);

  private:
  ::int64_t _internal_creation_height() const;
  void _internal_set_creation_height(::int64_t value);

  public:
  // uint64 unbonding_id = 5 [json_name = "unbondingId"];
  void clear_unbonding_id() ;
  ::uint64_t unbonding_id() const;
  void set_unbonding_id(::uint64_t value);

  private:
  ::uint64_t _internal_unbonding_id() const;
  void _internal_set_unbonding_id(::uint64_t value);

  public:
  // int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
  void clear_unbonding_on_hold_ref_count() ;
  ::int64_t unbonding_on_hold_ref_count() const;
  void set_unbonding_on_hold_ref_count(::int64_t value);

  private:
  ::int64_t _internal_unbonding_on_hold_ref_count() const;
  void _internal_set_unbonding_on_hold_ref_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.RedelegationEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shares_dst_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time_;
    ::int64_t creation_height_;
    ::uint64_t unbonding_id_;
    ::int64_t unbonding_on_hold_ref_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class Redelegation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Redelegation) */ {
 public:
  inline Redelegation() : Redelegation(nullptr) {}
  ~Redelegation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Redelegation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Redelegation(const Redelegation& from);
  Redelegation(Redelegation&& from) noexcept
    : Redelegation() {
    *this = ::std::move(from);
  }

  inline Redelegation& operator=(const Redelegation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Redelegation& operator=(Redelegation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Redelegation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Redelegation* internal_default_instance() {
    return reinterpret_cast<const Redelegation*>(
               &_Redelegation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Redelegation& a, Redelegation& b) {
    a.Swap(&b);
  }
  inline void Swap(Redelegation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Redelegation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Redelegation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Redelegation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Redelegation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Redelegation& from) {
    Redelegation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Redelegation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.Redelegation";
  }
  protected:
  explicit Redelegation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 4,
    kDelegatorAddressFieldNumber = 1,
    kValidatorSrcAddressFieldNumber = 2,
    kValidatorDstAddressFieldNumber = 3,
  };
  // repeated .cosmos.staking.v1beta1.RedelegationEntry entries = 4 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::staking::v1beta1::RedelegationEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntry >*
      mutable_entries();
  private:
  const ::cosmos::staking::v1beta1::RedelegationEntry& _internal_entries(int index) const;
  ::cosmos::staking::v1beta1::RedelegationEntry* _internal_add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>& _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::staking::v1beta1::RedelegationEntry& entries(int index) const;
  ::cosmos::staking::v1beta1::RedelegationEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntry >&
      entries() const;
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* ptr);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_src_address() ;
  const std::string& validator_src_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_src_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_src_address();
  PROTOBUF_NODISCARD std::string* release_validator_src_address();
  void set_allocated_validator_src_address(std::string* ptr);

  private:
  const std::string& _internal_validator_src_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_src_address(
      const std::string& value);
  std::string* _internal_mutable_validator_src_address();

  public:
  // string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_validator_dst_address() ;
  const std::string& validator_dst_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_dst_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_dst_address();
  PROTOBUF_NODISCARD std::string* release_validator_dst_address();
  void set_allocated_validator_dst_address(std::string* ptr);

  private:
  const std::string& _internal_validator_dst_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_dst_address(
      const std::string& value);
  std::string* _internal_mutable_validator_dst_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Redelegation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_src_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_dst_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Params(const Params& from);
  Params(Params&& from) noexcept
    : Params() {
    *this = ::std::move(from);
  }

  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
               &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Params& a, Params& b) {
    a.Swap(&b);
  }
  inline void Swap(Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Params& from) {
    Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.Params";
  }
  protected:
  explicit Params(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBondDenomFieldNumber = 5,
    kMinCommissionRateFieldNumber = 6,
    kUnbondingTimeFieldNumber = 1,
    kMaxValidatorsFieldNumber = 2,
    kMaxEntriesFieldNumber = 3,
    kHistoricalEntriesFieldNumber = 4,
  };
  // string bond_denom = 5 [json_name = "bondDenom"];
  void clear_bond_denom() ;
  const std::string& bond_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bond_denom(Arg_&& arg, Args_... args);
  std::string* mutable_bond_denom();
  PROTOBUF_NODISCARD std::string* release_bond_denom();
  void set_allocated_bond_denom(std::string* ptr);

  private:
  const std::string& _internal_bond_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bond_denom(
      const std::string& value);
  std::string* _internal_mutable_bond_denom();

  public:
  // string min_commission_rate = 6 [json_name = "minCommissionRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.moretags) = "yaml:\"min_commission_rate\""];
  void clear_min_commission_rate() ;
  const std::string& min_commission_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_commission_rate(Arg_&& arg, Args_... args);
  std::string* mutable_min_commission_rate();
  PROTOBUF_NODISCARD std::string* release_min_commission_rate();
  void set_allocated_min_commission_rate(std::string* ptr);

  private:
  const std::string& _internal_min_commission_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_commission_rate(
      const std::string& value);
  std::string* _internal_mutable_min_commission_rate();

  public:
  // .google.protobuf.Duration unbonding_time = 1 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdduration) = true, (.amino.dont_omitempty) = true];
  bool has_unbonding_time() const;
  void clear_unbonding_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Duration& unbonding_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_unbonding_time();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_unbonding_time();
  void set_allocated_unbonding_time(::PROTOBUF_NAMESPACE_ID::Duration* unbonding_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_unbonding_time() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_unbonding_time();
  public:
  void unsafe_arena_set_allocated_unbonding_time(
      ::PROTOBUF_NAMESPACE_ID::Duration* unbonding_time);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_unbonding_time();
  // uint32 max_validators = 2 [json_name = "maxValidators"];
  void clear_max_validators() ;
  ::uint32_t max_validators() const;
  void set_max_validators(::uint32_t value);

  private:
  ::uint32_t _internal_max_validators() const;
  void _internal_set_max_validators(::uint32_t value);

  public:
  // uint32 max_entries = 3 [json_name = "maxEntries"];
  void clear_max_entries() ;
  ::uint32_t max_entries() const;
  void set_max_entries(::uint32_t value);

  private:
  ::uint32_t _internal_max_entries() const;
  void _internal_set_max_entries(::uint32_t value);

  public:
  // uint32 historical_entries = 4 [json_name = "historicalEntries"];
  void clear_historical_entries() ;
  ::uint32_t historical_entries() const;
  void set_historical_entries(::uint32_t value);

  private:
  ::uint32_t _internal_historical_entries() const;
  void _internal_set_historical_entries(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bond_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_commission_rate_;
    ::PROTOBUF_NAMESPACE_ID::Duration* unbonding_time_;
    ::uint32_t max_validators_;
    ::uint32_t max_entries_;
    ::uint32_t historical_entries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class DelegationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DelegationResponse) */ {
 public:
  inline DelegationResponse() : DelegationResponse(nullptr) {}
  ~DelegationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DelegationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegationResponse(const DelegationResponse& from);
  DelegationResponse(DelegationResponse&& from) noexcept
    : DelegationResponse() {
    *this = ::std::move(from);
  }

  inline DelegationResponse& operator=(const DelegationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegationResponse& operator=(DelegationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegationResponse* internal_default_instance() {
    return reinterpret_cast<const DelegationResponse*>(
               &_DelegationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DelegationResponse& a, DelegationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelegationResponse& from) {
    DelegationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.DelegationResponse";
  }
  protected:
  explicit DelegationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegationFieldNumber = 1,
    kBalanceFieldNumber = 2,
  };
  // .cosmos.staking.v1beta1.Delegation delegation = 1 [json_name = "delegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_delegation() const;
  void clear_delegation() ;
  const ::cosmos::staking::v1beta1::Delegation& delegation() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Delegation* release_delegation();
  ::cosmos::staking::v1beta1::Delegation* mutable_delegation();
  void set_allocated_delegation(::cosmos::staking::v1beta1::Delegation* delegation);
  private:
  const ::cosmos::staking::v1beta1::Delegation& _internal_delegation() const;
  ::cosmos::staking::v1beta1::Delegation* _internal_mutable_delegation();
  public:
  void unsafe_arena_set_allocated_delegation(
      ::cosmos::staking::v1beta1::Delegation* delegation);
  ::cosmos::staking::v1beta1::Delegation* unsafe_arena_release_delegation();
  // .cosmos.base.v1beta1.Coin balance = 2 [json_name = "balance", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_balance() const;
  void clear_balance() ;
  const ::cosmos::base::v1beta1::Coin& balance() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_balance();
  ::cosmos::base::v1beta1::Coin* mutable_balance();
  void set_allocated_balance(::cosmos::base::v1beta1::Coin* balance);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_balance() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_balance();
  public:
  void unsafe_arena_set_allocated_balance(
      ::cosmos::base::v1beta1::Coin* balance);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_balance();
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DelegationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cosmos::staking::v1beta1::Delegation* delegation_;
    ::cosmos::base::v1beta1::Coin* balance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class RedelegationEntryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.RedelegationEntryResponse) */ {
 public:
  inline RedelegationEntryResponse() : RedelegationEntryResponse(nullptr) {}
  ~RedelegationEntryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RedelegationEntryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedelegationEntryResponse(const RedelegationEntryResponse& from);
  RedelegationEntryResponse(RedelegationEntryResponse&& from) noexcept
    : RedelegationEntryResponse() {
    *this = ::std::move(from);
  }

  inline RedelegationEntryResponse& operator=(const RedelegationEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedelegationEntryResponse& operator=(RedelegationEntryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedelegationEntryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedelegationEntryResponse* internal_default_instance() {
    return reinterpret_cast<const RedelegationEntryResponse*>(
               &_RedelegationEntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RedelegationEntryResponse& a, RedelegationEntryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RedelegationEntryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedelegationEntryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedelegationEntryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedelegationEntryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedelegationEntryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedelegationEntryResponse& from) {
    RedelegationEntryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedelegationEntryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.RedelegationEntryResponse";
  }
  protected:
  explicit RedelegationEntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceFieldNumber = 4,
    kRedelegationEntryFieldNumber = 1,
  };
  // string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_balance() ;
  const std::string& balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* ptr);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // .cosmos.staking.v1beta1.RedelegationEntry redelegation_entry = 1 [json_name = "redelegationEntry", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_redelegation_entry() const;
  void clear_redelegation_entry() ;
  const ::cosmos::staking::v1beta1::RedelegationEntry& redelegation_entry() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::RedelegationEntry* release_redelegation_entry();
  ::cosmos::staking::v1beta1::RedelegationEntry* mutable_redelegation_entry();
  void set_allocated_redelegation_entry(::cosmos::staking::v1beta1::RedelegationEntry* redelegation_entry);
  private:
  const ::cosmos::staking::v1beta1::RedelegationEntry& _internal_redelegation_entry() const;
  ::cosmos::staking::v1beta1::RedelegationEntry* _internal_mutable_redelegation_entry();
  public:
  void unsafe_arena_set_allocated_redelegation_entry(
      ::cosmos::staking::v1beta1::RedelegationEntry* redelegation_entry);
  ::cosmos::staking::v1beta1::RedelegationEntry* unsafe_arena_release_redelegation_entry();
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.RedelegationEntryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::cosmos::staking::v1beta1::RedelegationEntry* redelegation_entry_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class RedelegationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.RedelegationResponse) */ {
 public:
  inline RedelegationResponse() : RedelegationResponse(nullptr) {}
  ~RedelegationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RedelegationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedelegationResponse(const RedelegationResponse& from);
  RedelegationResponse(RedelegationResponse&& from) noexcept
    : RedelegationResponse() {
    *this = ::std::move(from);
  }

  inline RedelegationResponse& operator=(const RedelegationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedelegationResponse& operator=(RedelegationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedelegationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedelegationResponse* internal_default_instance() {
    return reinterpret_cast<const RedelegationResponse*>(
               &_RedelegationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RedelegationResponse& a, RedelegationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RedelegationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedelegationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedelegationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedelegationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedelegationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedelegationResponse& from) {
    RedelegationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedelegationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.RedelegationResponse";
  }
  protected:
  explicit RedelegationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
    kRedelegationFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.RedelegationEntryResponse entries = 2 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::staking::v1beta1::RedelegationEntryResponse* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntryResponse >*
      mutable_entries();
  private:
  const ::cosmos::staking::v1beta1::RedelegationEntryResponse& _internal_entries(int index) const;
  ::cosmos::staking::v1beta1::RedelegationEntryResponse* _internal_add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>& _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>* _internal_mutable_entries();
  public:
  const ::cosmos::staking::v1beta1::RedelegationEntryResponse& entries(int index) const;
  ::cosmos::staking::v1beta1::RedelegationEntryResponse* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntryResponse >&
      entries() const;
  // .cosmos.staking.v1beta1.Redelegation redelegation = 1 [json_name = "redelegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_redelegation() const;
  void clear_redelegation() ;
  const ::cosmos::staking::v1beta1::Redelegation& redelegation() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Redelegation* release_redelegation();
  ::cosmos::staking::v1beta1::Redelegation* mutable_redelegation();
  void set_allocated_redelegation(::cosmos::staking::v1beta1::Redelegation* redelegation);
  private:
  const ::cosmos::staking::v1beta1::Redelegation& _internal_redelegation() const;
  ::cosmos::staking::v1beta1::Redelegation* _internal_mutable_redelegation();
  public:
  void unsafe_arena_set_allocated_redelegation(
      ::cosmos::staking::v1beta1::Redelegation* redelegation);
  ::cosmos::staking::v1beta1::Redelegation* unsafe_arena_release_redelegation();
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.RedelegationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntryResponse > entries_;
    ::cosmos::staking::v1beta1::Redelegation* redelegation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class Pool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Pool) */ {
 public:
  inline Pool() : Pool(nullptr) {}
  ~Pool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Pool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pool(const Pool& from);
  Pool(Pool&& from) noexcept
    : Pool() {
    *this = ::std::move(from);
  }

  inline Pool& operator=(const Pool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pool& operator=(Pool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pool* internal_default_instance() {
    return reinterpret_cast<const Pool*>(
               &_Pool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Pool& a, Pool& b) {
    a.Swap(&b);
  }
  inline void Swap(Pool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pool& from) {
    Pool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.Pool";
  }
  protected:
  explicit Pool(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotBondedTokensFieldNumber = 1,
    kBondedTokensFieldNumber = 2,
  };
  // string not_bonded_tokens = 1 [json_name = "notBondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "not_bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
  void clear_not_bonded_tokens() ;
  const std::string& not_bonded_tokens() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_not_bonded_tokens(Arg_&& arg, Args_... args);
  std::string* mutable_not_bonded_tokens();
  PROTOBUF_NODISCARD std::string* release_not_bonded_tokens();
  void set_allocated_not_bonded_tokens(std::string* ptr);

  private:
  const std::string& _internal_not_bonded_tokens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_bonded_tokens(
      const std::string& value);
  std::string* _internal_mutable_not_bonded_tokens();

  public:
  // string bonded_tokens = 2 [json_name = "bondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
  void clear_bonded_tokens() ;
  const std::string& bonded_tokens() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bonded_tokens(Arg_&& arg, Args_... args);
  std::string* mutable_bonded_tokens();
  PROTOBUF_NODISCARD std::string* release_bonded_tokens();
  void set_allocated_bonded_tokens(std::string* ptr);

  private:
  const std::string& _internal_bonded_tokens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bonded_tokens(
      const std::string& value);
  std::string* _internal_mutable_bonded_tokens();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Pool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_bonded_tokens_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bonded_tokens_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};// -------------------------------------------------------------------

class ValidatorUpdates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.ValidatorUpdates) */ {
 public:
  inline ValidatorUpdates() : ValidatorUpdates(nullptr) {}
  ~ValidatorUpdates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorUpdates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorUpdates(const ValidatorUpdates& from);
  ValidatorUpdates(ValidatorUpdates&& from) noexcept
    : ValidatorUpdates() {
    *this = ::std::move(from);
  }

  inline ValidatorUpdates& operator=(const ValidatorUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorUpdates& operator=(ValidatorUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorUpdates* internal_default_instance() {
    return reinterpret_cast<const ValidatorUpdates*>(
               &_ValidatorUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ValidatorUpdates& a, ValidatorUpdates& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorUpdates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorUpdates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorUpdates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorUpdates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorUpdates& from) {
    ValidatorUpdates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorUpdates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmos.staking.v1beta1.ValidatorUpdates";
  }
  protected:
  explicit ValidatorUpdates(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatesFieldNumber = 1,
  };
  // repeated .tendermint.abci.ValidatorUpdate updates = 1 [json_name = "updates", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int updates_size() const;
  private:
  int _internal_updates_size() const;

  public:
  void clear_updates() ;
  ::tendermint::abci::ValidatorUpdate* mutable_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
      mutable_updates();
  private:
  const ::tendermint::abci::ValidatorUpdate& _internal_updates(int index) const;
  ::tendermint::abci::ValidatorUpdate* _internal_add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>& _internal_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>* _internal_mutable_updates();
  public:
  const ::tendermint::abci::ValidatorUpdate& updates(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
      updates() const;
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.ValidatorUpdates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > updates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HistoricalInfo

// .tendermint.types.Header header = 1 [json_name = "header", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool HistoricalInfo::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::tendermint::types::Header& HistoricalInfo::_internal_header() const {
  const ::tendermint::types::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Header&>(
      ::tendermint::types::_Header_default_instance_);
}
inline const ::tendermint::types::Header& HistoricalInfo::header() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.HistoricalInfo.header)
  return _internal_header();
}
inline void HistoricalInfo::unsafe_arena_set_allocated_header(
    ::tendermint::types::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.HistoricalInfo.header)
}
inline ::tendermint::types::Header* HistoricalInfo::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Header* HistoricalInfo::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.HistoricalInfo.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::tendermint::types::Header* HistoricalInfo::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::tendermint::types::Header* HistoricalInfo::mutable_header() {
  ::tendermint::types::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.HistoricalInfo.header)
  return _msg;
}
inline void HistoricalInfo::set_allocated_header(::tendermint::types::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.HistoricalInfo.header)
}

// repeated .cosmos.staking.v1beta1.Validator valset = 2 [json_name = "valset", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int HistoricalInfo::_internal_valset_size() const {
  return _impl_.valset_.size();
}
inline int HistoricalInfo::valset_size() const {
  return _internal_valset_size();
}
inline void HistoricalInfo::clear_valset() {
  _internal_mutable_valset()->Clear();
}
inline ::cosmos::staking::v1beta1::Validator* HistoricalInfo::mutable_valset(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _internal_mutable_valset()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::Validator >*
HistoricalInfo::mutable_valset() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _internal_mutable_valset();
}
inline const ::cosmos::staking::v1beta1::Validator& HistoricalInfo::_internal_valset(int index) const {
  return _internal_valset().Get(index);
}
inline const ::cosmos::staking::v1beta1::Validator& HistoricalInfo::valset(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _internal_valset(index);
}
inline ::cosmos::staking::v1beta1::Validator* HistoricalInfo::_internal_add_valset() {
  return _internal_mutable_valset()->Add();
}
inline ::cosmos::staking::v1beta1::Validator* HistoricalInfo::add_valset() {
  ::cosmos::staking::v1beta1::Validator* _add = _internal_add_valset();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::Validator >&
HistoricalInfo::valset() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _internal_valset();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>&
HistoricalInfo::_internal_valset() const {
  return _impl_.valset_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>*
HistoricalInfo::_internal_mutable_valset() {
  return &_impl_.valset_;
}

// -------------------------------------------------------------------

// CommissionRates

// string rate = 1 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void CommissionRates::clear_rate() {
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& CommissionRates::rate() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.CommissionRates.rate)
  return _internal_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommissionRates::set_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.CommissionRates.rate)
}
inline std::string* CommissionRates::mutable_rate() {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.CommissionRates.rate)
  return _s;
}
inline const std::string& CommissionRates::_internal_rate() const {
  return _impl_.rate_.Get();
}
inline void CommissionRates::_internal_set_rate(const std::string& value) {
  ;


  _impl_.rate_.Set(value, GetArenaForAllocation());
}
inline std::string* CommissionRates::_internal_mutable_rate() {
  ;
  return _impl_.rate_.Mutable( GetArenaForAllocation());
}
inline std::string* CommissionRates::release_rate() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.CommissionRates.rate)
  return _impl_.rate_.Release();
}
inline void CommissionRates::set_allocated_rate(std::string* value) {
  _impl_.rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rate_.IsDefault()) {
          _impl_.rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.CommissionRates.rate)
}

// string max_rate = 2 [json_name = "maxRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void CommissionRates::clear_max_rate() {
  _impl_.max_rate_.ClearToEmpty();
}
inline const std::string& CommissionRates::max_rate() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.CommissionRates.max_rate)
  return _internal_max_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommissionRates::set_max_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.max_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.CommissionRates.max_rate)
}
inline std::string* CommissionRates::mutable_max_rate() {
  std::string* _s = _internal_mutable_max_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.CommissionRates.max_rate)
  return _s;
}
inline const std::string& CommissionRates::_internal_max_rate() const {
  return _impl_.max_rate_.Get();
}
inline void CommissionRates::_internal_set_max_rate(const std::string& value) {
  ;


  _impl_.max_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* CommissionRates::_internal_mutable_max_rate() {
  ;
  return _impl_.max_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* CommissionRates::release_max_rate() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.CommissionRates.max_rate)
  return _impl_.max_rate_.Release();
}
inline void CommissionRates::set_allocated_max_rate(std::string* value) {
  _impl_.max_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.max_rate_.IsDefault()) {
          _impl_.max_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.CommissionRates.max_rate)
}

// string max_change_rate = 3 [json_name = "maxChangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void CommissionRates::clear_max_change_rate() {
  _impl_.max_change_rate_.ClearToEmpty();
}
inline const std::string& CommissionRates::max_change_rate() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
  return _internal_max_change_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommissionRates::set_max_change_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.max_change_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
}
inline std::string* CommissionRates::mutable_max_change_rate() {
  std::string* _s = _internal_mutable_max_change_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
  return _s;
}
inline const std::string& CommissionRates::_internal_max_change_rate() const {
  return _impl_.max_change_rate_.Get();
}
inline void CommissionRates::_internal_set_max_change_rate(const std::string& value) {
  ;


  _impl_.max_change_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* CommissionRates::_internal_mutable_max_change_rate() {
  ;
  return _impl_.max_change_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* CommissionRates::release_max_change_rate() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
  return _impl_.max_change_rate_.Release();
}
inline void CommissionRates::set_allocated_max_change_rate(std::string* value) {
  _impl_.max_change_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.max_change_rate_.IsDefault()) {
          _impl_.max_change_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
}

// -------------------------------------------------------------------

// Commission

// .cosmos.staking.v1beta1.CommissionRates commission_rates = 1 [json_name = "commissionRates", (.gogoproto.nullable) = false, (.gogoproto.embed) = true, (.amino.dont_omitempty) = true];
inline bool Commission::has_commission_rates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commission_rates_ != nullptr);
  return value;
}
inline void Commission::clear_commission_rates() {
  if (_impl_.commission_rates_ != nullptr) _impl_.commission_rates_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::CommissionRates& Commission::_internal_commission_rates() const {
  const ::cosmos::staking::v1beta1::CommissionRates* p = _impl_.commission_rates_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::CommissionRates&>(
      ::cosmos::staking::v1beta1::_CommissionRates_default_instance_);
}
inline const ::cosmos::staking::v1beta1::CommissionRates& Commission::commission_rates() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Commission.commission_rates)
  return _internal_commission_rates();
}
inline void Commission::unsafe_arena_set_allocated_commission_rates(
    ::cosmos::staking::v1beta1::CommissionRates* commission_rates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commission_rates_);
  }
  _impl_.commission_rates_ = commission_rates;
  if (commission_rates) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Commission.commission_rates)
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::release_commission_rates() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::CommissionRates* temp = _impl_.commission_rates_;
  _impl_.commission_rates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::unsafe_arena_release_commission_rates() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Commission.commission_rates)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::CommissionRates* temp = _impl_.commission_rates_;
  _impl_.commission_rates_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::_internal_mutable_commission_rates() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.commission_rates_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::staking::v1beta1::CommissionRates>(GetArenaForAllocation());
    _impl_.commission_rates_ = p;
  }
  return _impl_.commission_rates_;
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::mutable_commission_rates() {
  ::cosmos::staking::v1beta1::CommissionRates* _msg = _internal_mutable_commission_rates();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Commission.commission_rates)
  return _msg;
}
inline void Commission::set_allocated_commission_rates(::cosmos::staking::v1beta1::CommissionRates* commission_rates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.commission_rates_;
  }
  if (commission_rates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commission_rates);
    if (message_arena != submessage_arena) {
      commission_rates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commission_rates, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.commission_rates_ = commission_rates;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Commission.commission_rates)
}

// .google.protobuf.Timestamp update_time = 2 [json_name = "updateTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool Commission::has_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Commission::_internal_update_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Commission::update_time() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Commission.update_time)
  return _internal_update_time();
}
inline void Commission::unsafe_arena_set_allocated_update_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  _impl_.update_time_ = update_time;
  if (update_time) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Commission.update_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Commission::release_update_time() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Commission::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Commission.update_time)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Commission::_internal_mutable_update_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.update_time_ = p;
  }
  return _impl_.update_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Commission::mutable_update_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_update_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Commission.update_time)
  return _msg;
}
inline void Commission::set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time));
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Commission.update_time)
}

// -------------------------------------------------------------------

// Description

// string moniker = 1 [json_name = "moniker"];
inline void Description::clear_moniker() {
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& Description::moniker() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.moniker)
}
inline std::string* Description::mutable_moniker() {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.moniker)
  return _s;
}
inline const std::string& Description::_internal_moniker() const {
  return _impl_.moniker_.Get();
}
inline void Description::_internal_set_moniker(const std::string& value) {
  ;


  _impl_.moniker_.Set(value, GetArenaForAllocation());
}
inline std::string* Description::_internal_mutable_moniker() {
  ;
  return _impl_.moniker_.Mutable( GetArenaForAllocation());
}
inline std::string* Description::release_moniker() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.moniker)
  return _impl_.moniker_.Release();
}
inline void Description::set_allocated_moniker(std::string* value) {
  _impl_.moniker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.moniker_.IsDefault()) {
          _impl_.moniker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.moniker)
}

// string identity = 2 [json_name = "identity"];
inline void Description::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& Description::identity() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.identity)
  return _internal_identity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_identity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.identity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.identity)
}
inline std::string* Description::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.identity)
  return _s;
}
inline const std::string& Description::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void Description::_internal_set_identity(const std::string& value) {
  ;


  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* Description::_internal_mutable_identity() {
  ;
  return _impl_.identity_.Mutable( GetArenaForAllocation());
}
inline std::string* Description::release_identity() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.identity)
  return _impl_.identity_.Release();
}
inline void Description::set_allocated_identity(std::string* value) {
  _impl_.identity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.identity_.IsDefault()) {
          _impl_.identity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.identity)
}

// string website = 3 [json_name = "website"];
inline void Description::clear_website() {
  _impl_.website_.ClearToEmpty();
}
inline const std::string& Description::website() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.website)
  return _internal_website();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_website(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.website_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.website)
}
inline std::string* Description::mutable_website() {
  std::string* _s = _internal_mutable_website();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.website)
  return _s;
}
inline const std::string& Description::_internal_website() const {
  return _impl_.website_.Get();
}
inline void Description::_internal_set_website(const std::string& value) {
  ;


  _impl_.website_.Set(value, GetArenaForAllocation());
}
inline std::string* Description::_internal_mutable_website() {
  ;
  return _impl_.website_.Mutable( GetArenaForAllocation());
}
inline std::string* Description::release_website() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.website)
  return _impl_.website_.Release();
}
inline void Description::set_allocated_website(std::string* value) {
  _impl_.website_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.website_.IsDefault()) {
          _impl_.website_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.website)
}

// string security_contact = 4 [json_name = "securityContact"];
inline void Description::clear_security_contact() {
  _impl_.security_contact_.ClearToEmpty();
}
inline const std::string& Description::security_contact() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.security_contact)
  return _internal_security_contact();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_security_contact(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.security_contact_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.security_contact)
}
inline std::string* Description::mutable_security_contact() {
  std::string* _s = _internal_mutable_security_contact();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.security_contact)
  return _s;
}
inline const std::string& Description::_internal_security_contact() const {
  return _impl_.security_contact_.Get();
}
inline void Description::_internal_set_security_contact(const std::string& value) {
  ;


  _impl_.security_contact_.Set(value, GetArenaForAllocation());
}
inline std::string* Description::_internal_mutable_security_contact() {
  ;
  return _impl_.security_contact_.Mutable( GetArenaForAllocation());
}
inline std::string* Description::release_security_contact() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.security_contact)
  return _impl_.security_contact_.Release();
}
inline void Description::set_allocated_security_contact(std::string* value) {
  _impl_.security_contact_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.security_contact_.IsDefault()) {
          _impl_.security_contact_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.security_contact)
}

// string details = 5 [json_name = "details"];
inline void Description::clear_details() {
  _impl_.details_.ClearToEmpty();
}
inline const std::string& Description::details() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.details)
  return _internal_details();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_details(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.details_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.details)
}
inline std::string* Description::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.details)
  return _s;
}
inline const std::string& Description::_internal_details() const {
  return _impl_.details_.Get();
}
inline void Description::_internal_set_details(const std::string& value) {
  ;


  _impl_.details_.Set(value, GetArenaForAllocation());
}
inline std::string* Description::_internal_mutable_details() {
  ;
  return _impl_.details_.Mutable( GetArenaForAllocation());
}
inline std::string* Description::release_details() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.details)
  return _impl_.details_.Release();
}
inline void Description::set_allocated_details(std::string* value) {
  _impl_.details_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.details_.IsDefault()) {
          _impl_.details_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.details)
}

// -------------------------------------------------------------------

// Validator

// string operator_address = 1 [json_name = "operatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Validator::clear_operator_address() {
  _impl_.operator_address_.ClearToEmpty();
}
inline const std::string& Validator::operator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.operator_address)
  return _internal_operator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_operator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.operator_address)
}
inline std::string* Validator::mutable_operator_address() {
  std::string* _s = _internal_mutable_operator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.operator_address)
  return _s;
}
inline const std::string& Validator::_internal_operator_address() const {
  return _impl_.operator_address_.Get();
}
inline void Validator::_internal_set_operator_address(const std::string& value) {
  ;


  _impl_.operator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_operator_address() {
  ;
  return _impl_.operator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_operator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.operator_address)
  return _impl_.operator_address_.Release();
}
inline void Validator::set_allocated_operator_address(std::string* value) {
  _impl_.operator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_address_.IsDefault()) {
          _impl_.operator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.operator_address)
}

// .google.protobuf.Any consensus_pubkey = 2 [json_name = "consensusPubkey", (.cosmos_proto.accepts_interface) = "cosmos.crypto.PubKey"];
inline bool Validator::has_consensus_pubkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consensus_pubkey_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Validator::_internal_consensus_pubkey() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.consensus_pubkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Validator::consensus_pubkey() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.consensus_pubkey)
  return _internal_consensus_pubkey();
}
inline void Validator::unsafe_arena_set_allocated_consensus_pubkey(
    ::PROTOBUF_NAMESPACE_ID::Any* consensus_pubkey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_pubkey_);
  }
  _impl_.consensus_pubkey_ = consensus_pubkey;
  if (consensus_pubkey) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.consensus_pubkey)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Validator::release_consensus_pubkey() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.consensus_pubkey_;
  _impl_.consensus_pubkey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Validator::unsafe_arena_release_consensus_pubkey() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.consensus_pubkey)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.consensus_pubkey_;
  _impl_.consensus_pubkey_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Validator::_internal_mutable_consensus_pubkey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.consensus_pubkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.consensus_pubkey_ = p;
  }
  return _impl_.consensus_pubkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Validator::mutable_consensus_pubkey() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_consensus_pubkey();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.consensus_pubkey)
  return _msg;
}
inline void Validator::set_allocated_consensus_pubkey(::PROTOBUF_NAMESPACE_ID::Any* consensus_pubkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consensus_pubkey_);
  }
  if (consensus_pubkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_pubkey));
    if (message_arena != submessage_arena) {
      consensus_pubkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_pubkey, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.consensus_pubkey_ = consensus_pubkey;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.consensus_pubkey)
}

// bool jailed = 3 [json_name = "jailed"];
inline void Validator::clear_jailed() {
  _impl_.jailed_ = false;
}
inline bool Validator::jailed() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.jailed)
  return _internal_jailed();
}
inline void Validator::set_jailed(bool value) {
  _internal_set_jailed(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.jailed)
}
inline bool Validator::_internal_jailed() const {
  return _impl_.jailed_;
}
inline void Validator::_internal_set_jailed(bool value) {
  ;
  _impl_.jailed_ = value;
}

// .cosmos.staking.v1beta1.BondStatus status = 4 [json_name = "status"];
inline void Validator::clear_status() {
  _impl_.status_ = 0;
}
inline ::cosmos::staking::v1beta1::BondStatus Validator::status() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.status)
  return _internal_status();
}
inline void Validator::set_status(::cosmos::staking::v1beta1::BondStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.status)
}
inline ::cosmos::staking::v1beta1::BondStatus Validator::_internal_status() const {
  return static_cast<::cosmos::staking::v1beta1::BondStatus>(_impl_.status_);
}
inline void Validator::_internal_set_status(::cosmos::staking::v1beta1::BondStatus value) {
  ;
  _impl_.status_ = value;
}

// string tokens = 5 [json_name = "tokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void Validator::clear_tokens() {
  _impl_.tokens_.ClearToEmpty();
}
inline const std::string& Validator::tokens() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.tokens)
  return _internal_tokens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_tokens(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tokens_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.tokens)
}
inline std::string* Validator::mutable_tokens() {
  std::string* _s = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.tokens)
  return _s;
}
inline const std::string& Validator::_internal_tokens() const {
  return _impl_.tokens_.Get();
}
inline void Validator::_internal_set_tokens(const std::string& value) {
  ;


  _impl_.tokens_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_tokens() {
  ;
  return _impl_.tokens_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_tokens() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.tokens)
  return _impl_.tokens_.Release();
}
inline void Validator::set_allocated_tokens(std::string* value) {
  _impl_.tokens_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tokens_.IsDefault()) {
          _impl_.tokens_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.tokens)
}

// string delegator_shares = 6 [json_name = "delegatorShares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void Validator::clear_delegator_shares() {
  _impl_.delegator_shares_.ClearToEmpty();
}
inline const std::string& Validator::delegator_shares() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.delegator_shares)
  return _internal_delegator_shares();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_delegator_shares(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.delegator_shares_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.delegator_shares)
}
inline std::string* Validator::mutable_delegator_shares() {
  std::string* _s = _internal_mutable_delegator_shares();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.delegator_shares)
  return _s;
}
inline const std::string& Validator::_internal_delegator_shares() const {
  return _impl_.delegator_shares_.Get();
}
inline void Validator::_internal_set_delegator_shares(const std::string& value) {
  ;


  _impl_.delegator_shares_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_delegator_shares() {
  ;
  return _impl_.delegator_shares_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_delegator_shares() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.delegator_shares)
  return _impl_.delegator_shares_.Release();
}
inline void Validator::set_allocated_delegator_shares(std::string* value) {
  _impl_.delegator_shares_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.delegator_shares_.IsDefault()) {
          _impl_.delegator_shares_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.delegator_shares)
}

// .cosmos.staking.v1beta1.Description description = 7 [json_name = "description", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool Validator::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.description_ != nullptr);
  return value;
}
inline void Validator::clear_description() {
  if (_impl_.description_ != nullptr) _impl_.description_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::staking::v1beta1::Description& Validator::_internal_description() const {
  const ::cosmos::staking::v1beta1::Description* p = _impl_.description_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Description&>(
      ::cosmos::staking::v1beta1::_Description_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Description& Validator::description() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.description)
  return _internal_description();
}
inline void Validator::unsafe_arena_set_allocated_description(
    ::cosmos::staking::v1beta1::Description* description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_);
  }
  _impl_.description_ = description;
  if (description) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.description)
}
inline ::cosmos::staking::v1beta1::Description* Validator::release_description() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::staking::v1beta1::Description* temp = _impl_.description_;
  _impl_.description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::staking::v1beta1::Description* Validator::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.description)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::staking::v1beta1::Description* temp = _impl_.description_;
  _impl_.description_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Description* Validator::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.description_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::staking::v1beta1::Description>(GetArenaForAllocation());
    _impl_.description_ = p;
  }
  return _impl_.description_;
}
inline ::cosmos::staking::v1beta1::Description* Validator::mutable_description() {
  ::cosmos::staking::v1beta1::Description* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.description)
  return _msg;
}
inline void Validator::set_allocated_description(::cosmos::staking::v1beta1::Description* description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.description_;
  }
  if (description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(description);
    if (message_arena != submessage_arena) {
      description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_ = description;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.description)
}

// int64 unbonding_height = 8 [json_name = "unbondingHeight"];
inline void Validator::clear_unbonding_height() {
  _impl_.unbonding_height_ = ::int64_t{0};
}
inline ::int64_t Validator::unbonding_height() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_height)
  return _internal_unbonding_height();
}
inline void Validator::set_unbonding_height(::int64_t value) {
  _internal_set_unbonding_height(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.unbonding_height)
}
inline ::int64_t Validator::_internal_unbonding_height() const {
  return _impl_.unbonding_height_;
}
inline void Validator::_internal_set_unbonding_height(::int64_t value) {
  ;
  _impl_.unbonding_height_ = value;
}

// .google.protobuf.Timestamp unbonding_time = 9 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool Validator::has_unbonding_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unbonding_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Validator::_internal_unbonding_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.unbonding_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Validator::unbonding_time() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_time)
  return _internal_unbonding_time();
}
inline void Validator::unsafe_arena_set_allocated_unbonding_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* unbonding_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unbonding_time_);
  }
  _impl_.unbonding_time_ = unbonding_time;
  if (unbonding_time) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.unbonding_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::release_unbonding_time() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::unsafe_arena_release_unbonding_time() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.unbonding_time)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::_internal_mutable_unbonding_time() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.unbonding_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.unbonding_time_ = p;
  }
  return _impl_.unbonding_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Validator::mutable_unbonding_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_unbonding_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.unbonding_time)
  return _msg;
}
inline void Validator::set_allocated_unbonding_time(::PROTOBUF_NAMESPACE_ID::Timestamp* unbonding_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unbonding_time_);
  }
  if (unbonding_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unbonding_time));
    if (message_arena != submessage_arena) {
      unbonding_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unbonding_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.unbonding_time_ = unbonding_time;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.unbonding_time)
}

// .cosmos.staking.v1beta1.Commission commission = 10 [json_name = "commission", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool Validator::has_commission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commission_ != nullptr);
  return value;
}
inline void Validator::clear_commission() {
  if (_impl_.commission_ != nullptr) _impl_.commission_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::cosmos::staking::v1beta1::Commission& Validator::_internal_commission() const {
  const ::cosmos::staking::v1beta1::Commission* p = _impl_.commission_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Commission&>(
      ::cosmos::staking::v1beta1::_Commission_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Commission& Validator::commission() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.commission)
  return _internal_commission();
}
inline void Validator::unsafe_arena_set_allocated_commission(
    ::cosmos::staking::v1beta1::Commission* commission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commission_);
  }
  _impl_.commission_ = commission;
  if (commission) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.commission)
}
inline ::cosmos::staking::v1beta1::Commission* Validator::release_commission() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cosmos::staking::v1beta1::Commission* temp = _impl_.commission_;
  _impl_.commission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::staking::v1beta1::Commission* Validator::unsafe_arena_release_commission() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.commission)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cosmos::staking::v1beta1::Commission* temp = _impl_.commission_;
  _impl_.commission_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Commission* Validator::_internal_mutable_commission() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.commission_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::staking::v1beta1::Commission>(GetArenaForAllocation());
    _impl_.commission_ = p;
  }
  return _impl_.commission_;
}
inline ::cosmos::staking::v1beta1::Commission* Validator::mutable_commission() {
  ::cosmos::staking::v1beta1::Commission* _msg = _internal_mutable_commission();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.commission)
  return _msg;
}
inline void Validator::set_allocated_commission(::cosmos::staking::v1beta1::Commission* commission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.commission_;
  }
  if (commission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commission);
    if (message_arena != submessage_arena) {
      commission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commission, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.commission_ = commission;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.commission)
}

// string min_self_delegation = 11 [json_name = "minSelfDelegation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void Validator::clear_min_self_delegation() {
  _impl_.min_self_delegation_.ClearToEmpty();
}
inline const std::string& Validator::min_self_delegation() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.min_self_delegation)
  return _internal_min_self_delegation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_min_self_delegation(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_self_delegation_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.min_self_delegation)
}
inline std::string* Validator::mutable_min_self_delegation() {
  std::string* _s = _internal_mutable_min_self_delegation();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.min_self_delegation)
  return _s;
}
inline const std::string& Validator::_internal_min_self_delegation() const {
  return _impl_.min_self_delegation_.Get();
}
inline void Validator::_internal_set_min_self_delegation(const std::string& value) {
  ;


  _impl_.min_self_delegation_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_min_self_delegation() {
  ;
  return _impl_.min_self_delegation_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_min_self_delegation() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.min_self_delegation)
  return _impl_.min_self_delegation_.Release();
}
inline void Validator::set_allocated_min_self_delegation(std::string* value) {
  _impl_.min_self_delegation_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_self_delegation_.IsDefault()) {
          _impl_.min_self_delegation_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.min_self_delegation)
}

// int64 unbonding_on_hold_ref_count = 12 [json_name = "unbondingOnHoldRefCount"];
inline void Validator::clear_unbonding_on_hold_ref_count() {
  _impl_.unbonding_on_hold_ref_count_ = ::int64_t{0};
}
inline ::int64_t Validator::unbonding_on_hold_ref_count() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_on_hold_ref_count)
  return _internal_unbonding_on_hold_ref_count();
}
inline void Validator::set_unbonding_on_hold_ref_count(::int64_t value) {
  _internal_set_unbonding_on_hold_ref_count(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.unbonding_on_hold_ref_count)
}
inline ::int64_t Validator::_internal_unbonding_on_hold_ref_count() const {
  return _impl_.unbonding_on_hold_ref_count_;
}
inline void Validator::_internal_set_unbonding_on_hold_ref_count(::int64_t value) {
  ;
  _impl_.unbonding_on_hold_ref_count_ = value;
}

// repeated uint64 unbonding_ids = 13 [json_name = "unbondingIds"];
inline int Validator::_internal_unbonding_ids_size() const {
  return _impl_.unbonding_ids_.size();
}
inline int Validator::unbonding_ids_size() const {
  return _internal_unbonding_ids_size();
}
inline void Validator::clear_unbonding_ids() {
  _internal_mutable_unbonding_ids()->Clear();
}
inline ::uint64_t Validator::unbonding_ids(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_ids)
  return _internal_unbonding_ids(index);
}
inline void Validator::set_unbonding_ids(int index, ::uint64_t value) {
  _internal_mutable_unbonding_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.unbonding_ids)
}
inline void Validator::add_unbonding_ids(::uint64_t value) {
  _internal_add_unbonding_ids(value);
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.Validator.unbonding_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& Validator::unbonding_ids() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.Validator.unbonding_ids)
  return _internal_unbonding_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* Validator::mutable_unbonding_ids() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.Validator.unbonding_ids)
  return _internal_mutable_unbonding_ids();
}

inline ::uint64_t Validator::_internal_unbonding_ids(int index) const {
  return _internal_unbonding_ids().Get(index);
}
inline void Validator::_internal_add_unbonding_ids(::uint64_t value) {
  _internal_mutable_unbonding_ids()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& Validator::_internal_unbonding_ids() const {
  return _impl_.unbonding_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* Validator::_internal_mutable_unbonding_ids() {
  return &_impl_.unbonding_ids_;
}

// -------------------------------------------------------------------

// ValAddresses

// repeated string addresses = 1 [json_name = "addresses", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline int ValAddresses::_internal_addresses_size() const {
  return _impl_.addresses_.size();
}
inline int ValAddresses::addresses_size() const {
  return _internal_addresses_size();
}
inline void ValAddresses::clear_addresses() {
  _internal_mutable_addresses()->Clear();
}
inline std::string* ValAddresses::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _s;
}
inline const std::string& ValAddresses::addresses(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _internal_addresses(index);
}
inline std::string* ValAddresses::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _internal_mutable_addresses()->Mutable(index);
}
inline void ValAddresses::set_addresses(int index, const std::string& value) {
  _internal_mutable_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::set_addresses(int index, std::string&& value) {
  _internal_mutable_addresses()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::set_addresses(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::set_addresses(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_addresses()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::set_addresses(int index, absl::string_view value) {
  _internal_mutable_addresses()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::add_addresses(const std::string& value) {
  _internal_mutable_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::add_addresses(std::string&& value) {
  _internal_mutable_addresses()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::add_addresses(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::add_addresses(const char* value, std::size_t size) {
  _internal_mutable_addresses()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline void ValAddresses::add_addresses(absl::string_view value) {
  _internal_mutable_addresses()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ValAddresses::addresses() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _internal_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ValAddresses::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _internal_mutable_addresses();
}
inline const std::string& ValAddresses::_internal_addresses(int index) const {
  return _internal_addresses().Get(index);
}
inline std::string* ValAddresses::_internal_add_addresses() {
  return _internal_mutable_addresses()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ValAddresses::_internal_addresses() const {
  return _impl_.addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ValAddresses::_internal_mutable_addresses() {
  return &_impl_.addresses_;
}

// -------------------------------------------------------------------

// DVPair

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DVPair::clear_delegator_address() {
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& DVPair::delegator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVPair.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVPair::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVPair.delegator_address)
}
inline std::string* DVPair::mutable_delegator_address() {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVPair.delegator_address)
  return _s;
}
inline const std::string& DVPair::_internal_delegator_address() const {
  return _impl_.delegator_address_.Get();
}
inline void DVPair::_internal_set_delegator_address(const std::string& value) {
  ;


  _impl_.delegator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DVPair::_internal_mutable_delegator_address() {
  ;
  return _impl_.delegator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* DVPair::release_delegator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVPair.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void DVPair::set_allocated_delegator_address(std::string* value) {
  _impl_.delegator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.delegator_address_.IsDefault()) {
          _impl_.delegator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVPair.delegator_address)
}

// string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DVPair::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& DVPair::validator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVPair.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVPair::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVPair.validator_address)
}
inline std::string* DVPair::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVPair.validator_address)
  return _s;
}
inline const std::string& DVPair::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void DVPair::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DVPair::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* DVPair::release_validator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVPair.validator_address)
  return _impl_.validator_address_.Release();
}
inline void DVPair::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVPair.validator_address)
}

// -------------------------------------------------------------------

// DVPairs

// repeated .cosmos.staking.v1beta1.DVPair pairs = 1 [json_name = "pairs", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int DVPairs::_internal_pairs_size() const {
  return _impl_.pairs_.size();
}
inline int DVPairs::pairs_size() const {
  return _internal_pairs_size();
}
inline void DVPairs::clear_pairs() {
  _internal_mutable_pairs()->Clear();
}
inline ::cosmos::staking::v1beta1::DVPair* DVPairs::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVPairs.pairs)
  return _internal_mutable_pairs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVPair >*
DVPairs::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.DVPairs.pairs)
  return _internal_mutable_pairs();
}
inline const ::cosmos::staking::v1beta1::DVPair& DVPairs::_internal_pairs(int index) const {
  return _internal_pairs().Get(index);
}
inline const ::cosmos::staking::v1beta1::DVPair& DVPairs::pairs(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVPairs.pairs)
  return _internal_pairs(index);
}
inline ::cosmos::staking::v1beta1::DVPair* DVPairs::_internal_add_pairs() {
  return _internal_mutable_pairs()->Add();
}
inline ::cosmos::staking::v1beta1::DVPair* DVPairs::add_pairs() {
  ::cosmos::staking::v1beta1::DVPair* _add = _internal_add_pairs();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.DVPairs.pairs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVPair >&
DVPairs::pairs() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.DVPairs.pairs)
  return _internal_pairs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>&
DVPairs::_internal_pairs() const {
  return _impl_.pairs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>*
DVPairs::_internal_mutable_pairs() {
  return &_impl_.pairs_;
}

// -------------------------------------------------------------------

// DVVTriplet

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DVVTriplet::clear_delegator_address() {
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& DVVTriplet::delegator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVVTriplet::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
}
inline std::string* DVVTriplet::mutable_delegator_address() {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
  return _s;
}
inline const std::string& DVVTriplet::_internal_delegator_address() const {
  return _impl_.delegator_address_.Get();
}
inline void DVVTriplet::_internal_set_delegator_address(const std::string& value) {
  ;


  _impl_.delegator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DVVTriplet::_internal_mutable_delegator_address() {
  ;
  return _impl_.delegator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* DVVTriplet::release_delegator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void DVVTriplet::set_allocated_delegator_address(std::string* value) {
  _impl_.delegator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.delegator_address_.IsDefault()) {
          _impl_.delegator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
}

// string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DVVTriplet::clear_validator_src_address() {
  _impl_.validator_src_address_.ClearToEmpty();
}
inline const std::string& DVVTriplet::validator_src_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
  return _internal_validator_src_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVVTriplet::set_validator_src_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_src_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
}
inline std::string* DVVTriplet::mutable_validator_src_address() {
  std::string* _s = _internal_mutable_validator_src_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
  return _s;
}
inline const std::string& DVVTriplet::_internal_validator_src_address() const {
  return _impl_.validator_src_address_.Get();
}
inline void DVVTriplet::_internal_set_validator_src_address(const std::string& value) {
  ;


  _impl_.validator_src_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DVVTriplet::_internal_mutable_validator_src_address() {
  ;
  return _impl_.validator_src_address_.Mutable( GetArenaForAllocation());
}
inline std::string* DVVTriplet::release_validator_src_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
  return _impl_.validator_src_address_.Release();
}
inline void DVVTriplet::set_allocated_validator_src_address(std::string* value) {
  _impl_.validator_src_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_src_address_.IsDefault()) {
          _impl_.validator_src_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
}

// string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DVVTriplet::clear_validator_dst_address() {
  _impl_.validator_dst_address_.ClearToEmpty();
}
inline const std::string& DVVTriplet::validator_dst_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
  return _internal_validator_dst_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVVTriplet::set_validator_dst_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_dst_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
}
inline std::string* DVVTriplet::mutable_validator_dst_address() {
  std::string* _s = _internal_mutable_validator_dst_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
  return _s;
}
inline const std::string& DVVTriplet::_internal_validator_dst_address() const {
  return _impl_.validator_dst_address_.Get();
}
inline void DVVTriplet::_internal_set_validator_dst_address(const std::string& value) {
  ;


  _impl_.validator_dst_address_.Set(value, GetArenaForAllocation());
}
inline std::string* DVVTriplet::_internal_mutable_validator_dst_address() {
  ;
  return _impl_.validator_dst_address_.Mutable( GetArenaForAllocation());
}
inline std::string* DVVTriplet::release_validator_dst_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
  return _impl_.validator_dst_address_.Release();
}
inline void DVVTriplet::set_allocated_validator_dst_address(std::string* value) {
  _impl_.validator_dst_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_dst_address_.IsDefault()) {
          _impl_.validator_dst_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
}

// -------------------------------------------------------------------

// DVVTriplets

// repeated .cosmos.staking.v1beta1.DVVTriplet triplets = 1 [json_name = "triplets", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int DVVTriplets::_internal_triplets_size() const {
  return _impl_.triplets_.size();
}
inline int DVVTriplets::triplets_size() const {
  return _internal_triplets_size();
}
inline void DVVTriplets::clear_triplets() {
  _internal_mutable_triplets()->Clear();
}
inline ::cosmos::staking::v1beta1::DVVTriplet* DVVTriplets::mutable_triplets(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _internal_mutable_triplets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVVTriplet >*
DVVTriplets::mutable_triplets() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _internal_mutable_triplets();
}
inline const ::cosmos::staking::v1beta1::DVVTriplet& DVVTriplets::_internal_triplets(int index) const {
  return _internal_triplets().Get(index);
}
inline const ::cosmos::staking::v1beta1::DVVTriplet& DVVTriplets::triplets(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _internal_triplets(index);
}
inline ::cosmos::staking::v1beta1::DVVTriplet* DVVTriplets::_internal_add_triplets() {
  return _internal_mutable_triplets()->Add();
}
inline ::cosmos::staking::v1beta1::DVVTriplet* DVVTriplets::add_triplets() {
  ::cosmos::staking::v1beta1::DVVTriplet* _add = _internal_add_triplets();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::DVVTriplet >&
DVVTriplets::triplets() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _internal_triplets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>&
DVVTriplets::_internal_triplets() const {
  return _impl_.triplets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>*
DVVTriplets::_internal_mutable_triplets() {
  return &_impl_.triplets_;
}

// -------------------------------------------------------------------

// Delegation

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Delegation::clear_delegator_address() {
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& Delegation::delegator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Delegation.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Delegation::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Delegation.delegator_address)
}
inline std::string* Delegation::mutable_delegator_address() {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Delegation.delegator_address)
  return _s;
}
inline const std::string& Delegation::_internal_delegator_address() const {
  return _impl_.delegator_address_.Get();
}
inline void Delegation::_internal_set_delegator_address(const std::string& value) {
  ;


  _impl_.delegator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Delegation::_internal_mutable_delegator_address() {
  ;
  return _impl_.delegator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Delegation::release_delegator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Delegation.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void Delegation::set_allocated_delegator_address(std::string* value) {
  _impl_.delegator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.delegator_address_.IsDefault()) {
          _impl_.delegator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Delegation.delegator_address)
}

// string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Delegation::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& Delegation::validator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Delegation.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Delegation::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Delegation.validator_address)
}
inline std::string* Delegation::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Delegation.validator_address)
  return _s;
}
inline const std::string& Delegation::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void Delegation::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Delegation::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Delegation::release_validator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Delegation.validator_address)
  return _impl_.validator_address_.Release();
}
inline void Delegation::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Delegation.validator_address)
}

// string shares = 3 [json_name = "shares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void Delegation::clear_shares() {
  _impl_.shares_.ClearToEmpty();
}
inline const std::string& Delegation::shares() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Delegation.shares)
  return _internal_shares();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Delegation::set_shares(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.shares_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Delegation.shares)
}
inline std::string* Delegation::mutable_shares() {
  std::string* _s = _internal_mutable_shares();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Delegation.shares)
  return _s;
}
inline const std::string& Delegation::_internal_shares() const {
  return _impl_.shares_.Get();
}
inline void Delegation::_internal_set_shares(const std::string& value) {
  ;


  _impl_.shares_.Set(value, GetArenaForAllocation());
}
inline std::string* Delegation::_internal_mutable_shares() {
  ;
  return _impl_.shares_.Mutable( GetArenaForAllocation());
}
inline std::string* Delegation::release_shares() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Delegation.shares)
  return _impl_.shares_.Release();
}
inline void Delegation::set_allocated_shares(std::string* value) {
  _impl_.shares_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shares_.IsDefault()) {
          _impl_.shares_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Delegation.shares)
}

// -------------------------------------------------------------------

// UnbondingDelegation

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void UnbondingDelegation::clear_delegator_address() {
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& UnbondingDelegation::delegator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegation::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
}
inline std::string* UnbondingDelegation::mutable_delegator_address() {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
  return _s;
}
inline const std::string& UnbondingDelegation::_internal_delegator_address() const {
  return _impl_.delegator_address_.Get();
}
inline void UnbondingDelegation::_internal_set_delegator_address(const std::string& value) {
  ;


  _impl_.delegator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnbondingDelegation::_internal_mutable_delegator_address() {
  ;
  return _impl_.delegator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* UnbondingDelegation::release_delegator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void UnbondingDelegation::set_allocated_delegator_address(std::string* value) {
  _impl_.delegator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.delegator_address_.IsDefault()) {
          _impl_.delegator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
}

// string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void UnbondingDelegation::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& UnbondingDelegation::validator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegation::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
}
inline std::string* UnbondingDelegation::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
  return _s;
}
inline const std::string& UnbondingDelegation::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void UnbondingDelegation::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UnbondingDelegation::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* UnbondingDelegation::release_validator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
  return _impl_.validator_address_.Release();
}
inline void UnbondingDelegation::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
}

// repeated .cosmos.staking.v1beta1.UnbondingDelegationEntry entries = 3 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int UnbondingDelegation::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int UnbondingDelegation::entries_size() const {
  return _internal_entries_size();
}
inline void UnbondingDelegation::clear_entries() {
  _internal_mutable_entries()->Clear();
}
inline ::cosmos::staking::v1beta1::UnbondingDelegationEntry* UnbondingDelegation::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::UnbondingDelegationEntry >*
UnbondingDelegation::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _internal_mutable_entries();
}
inline const ::cosmos::staking::v1beta1::UnbondingDelegationEntry& UnbondingDelegation::_internal_entries(int index) const {
  return _internal_entries().Get(index);
}
inline const ::cosmos::staking::v1beta1::UnbondingDelegationEntry& UnbondingDelegation::entries(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _internal_entries(index);
}
inline ::cosmos::staking::v1beta1::UnbondingDelegationEntry* UnbondingDelegation::_internal_add_entries() {
  return _internal_mutable_entries()->Add();
}
inline ::cosmos::staking::v1beta1::UnbondingDelegationEntry* UnbondingDelegation::add_entries() {
  ::cosmos::staking::v1beta1::UnbondingDelegationEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::UnbondingDelegationEntry >&
UnbondingDelegation::entries() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _internal_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>&
UnbondingDelegation::_internal_entries() const {
  return _impl_.entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>*
UnbondingDelegation::_internal_mutable_entries() {
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// UnbondingDelegationEntry

// int64 creation_height = 1 [json_name = "creationHeight"];
inline void UnbondingDelegationEntry::clear_creation_height() {
  _impl_.creation_height_ = ::int64_t{0};
}
inline ::int64_t UnbondingDelegationEntry::creation_height() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.creation_height)
  return _internal_creation_height();
}
inline void UnbondingDelegationEntry::set_creation_height(::int64_t value) {
  _internal_set_creation_height(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.creation_height)
}
inline ::int64_t UnbondingDelegationEntry::_internal_creation_height() const {
  return _impl_.creation_height_;
}
inline void UnbondingDelegationEntry::_internal_set_creation_height(::int64_t value) {
  ;
  _impl_.creation_height_ = value;
}

// .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool UnbondingDelegationEntry::has_completion_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.completion_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UnbondingDelegationEntry::_internal_completion_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.completion_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UnbondingDelegationEntry::completion_time() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
  return _internal_completion_time();
}
inline void UnbondingDelegationEntry::unsafe_arena_set_allocated_completion_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completion_time_);
  }
  _impl_.completion_time_ = completion_time;
  if (completion_time) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UnbondingDelegationEntry::release_completion_time() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UnbondingDelegationEntry::unsafe_arena_release_completion_time() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UnbondingDelegationEntry::_internal_mutable_completion_time() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.completion_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.completion_time_ = p;
  }
  return _impl_.completion_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UnbondingDelegationEntry::mutable_completion_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_completion_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
  return _msg;
}
inline void UnbondingDelegationEntry::set_allocated_completion_time(::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completion_time_);
  }
  if (completion_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(completion_time));
    if (message_arena != submessage_arena) {
      completion_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, completion_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.completion_time_ = completion_time;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
}

// string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void UnbondingDelegationEntry::clear_initial_balance() {
  _impl_.initial_balance_.ClearToEmpty();
}
inline const std::string& UnbondingDelegationEntry::initial_balance() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
  return _internal_initial_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegationEntry::set_initial_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
}
inline std::string* UnbondingDelegationEntry::mutable_initial_balance() {
  std::string* _s = _internal_mutable_initial_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
  return _s;
}
inline const std::string& UnbondingDelegationEntry::_internal_initial_balance() const {
  return _impl_.initial_balance_.Get();
}
inline void UnbondingDelegationEntry::_internal_set_initial_balance(const std::string& value) {
  ;


  _impl_.initial_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* UnbondingDelegationEntry::_internal_mutable_initial_balance() {
  ;
  return _impl_.initial_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* UnbondingDelegationEntry::release_initial_balance() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
  return _impl_.initial_balance_.Release();
}
inline void UnbondingDelegationEntry::set_allocated_initial_balance(std::string* value) {
  _impl_.initial_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_balance_.IsDefault()) {
          _impl_.initial_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
}

// string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void UnbondingDelegationEntry::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& UnbondingDelegationEntry::balance() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegationEntry::set_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
}
inline std::string* UnbondingDelegationEntry::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
  return _s;
}
inline const std::string& UnbondingDelegationEntry::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void UnbondingDelegationEntry::_internal_set_balance(const std::string& value) {
  ;


  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* UnbondingDelegationEntry::_internal_mutable_balance() {
  ;
  return _impl_.balance_.Mutable( GetArenaForAllocation());
}
inline std::string* UnbondingDelegationEntry::release_balance() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
  return _impl_.balance_.Release();
}
inline void UnbondingDelegationEntry::set_allocated_balance(std::string* value) {
  _impl_.balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_.IsDefault()) {
          _impl_.balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
}

// uint64 unbonding_id = 5 [json_name = "unbondingId"];
inline void UnbondingDelegationEntry::clear_unbonding_id() {
  _impl_.unbonding_id_ = ::uint64_t{0u};
}
inline ::uint64_t UnbondingDelegationEntry::unbonding_id() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_id)
  return _internal_unbonding_id();
}
inline void UnbondingDelegationEntry::set_unbonding_id(::uint64_t value) {
  _internal_set_unbonding_id(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_id)
}
inline ::uint64_t UnbondingDelegationEntry::_internal_unbonding_id() const {
  return _impl_.unbonding_id_;
}
inline void UnbondingDelegationEntry::_internal_set_unbonding_id(::uint64_t value) {
  ;
  _impl_.unbonding_id_ = value;
}

// int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
inline void UnbondingDelegationEntry::clear_unbonding_on_hold_ref_count() {
  _impl_.unbonding_on_hold_ref_count_ = ::int64_t{0};
}
inline ::int64_t UnbondingDelegationEntry::unbonding_on_hold_ref_count() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_on_hold_ref_count)
  return _internal_unbonding_on_hold_ref_count();
}
inline void UnbondingDelegationEntry::set_unbonding_on_hold_ref_count(::int64_t value) {
  _internal_set_unbonding_on_hold_ref_count(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_on_hold_ref_count)
}
inline ::int64_t UnbondingDelegationEntry::_internal_unbonding_on_hold_ref_count() const {
  return _impl_.unbonding_on_hold_ref_count_;
}
inline void UnbondingDelegationEntry::_internal_set_unbonding_on_hold_ref_count(::int64_t value) {
  ;
  _impl_.unbonding_on_hold_ref_count_ = value;
}

// -------------------------------------------------------------------

// RedelegationEntry

// int64 creation_height = 1 [json_name = "creationHeight"];
inline void RedelegationEntry::clear_creation_height() {
  _impl_.creation_height_ = ::int64_t{0};
}
inline ::int64_t RedelegationEntry::creation_height() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.creation_height)
  return _internal_creation_height();
}
inline void RedelegationEntry::set_creation_height(::int64_t value) {
  _internal_set_creation_height(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.creation_height)
}
inline ::int64_t RedelegationEntry::_internal_creation_height() const {
  return _impl_.creation_height_;
}
inline void RedelegationEntry::_internal_set_creation_height(::int64_t value) {
  ;
  _impl_.creation_height_ = value;
}

// .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool RedelegationEntry::has_completion_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.completion_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RedelegationEntry::_internal_completion_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.completion_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RedelegationEntry::completion_time() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
  return _internal_completion_time();
}
inline void RedelegationEntry::unsafe_arena_set_allocated_completion_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completion_time_);
  }
  _impl_.completion_time_ = completion_time;
  if (completion_time) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedelegationEntry::release_completion_time() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedelegationEntry::unsafe_arena_release_completion_time() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedelegationEntry::_internal_mutable_completion_time() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.completion_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.completion_time_ = p;
  }
  return _impl_.completion_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RedelegationEntry::mutable_completion_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_completion_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
  return _msg;
}
inline void RedelegationEntry::set_allocated_completion_time(::PROTOBUF_NAMESPACE_ID::Timestamp* completion_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completion_time_);
  }
  if (completion_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(completion_time));
    if (message_arena != submessage_arena) {
      completion_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, completion_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.completion_time_ = completion_time;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
}

// string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void RedelegationEntry::clear_initial_balance() {
  _impl_.initial_balance_.ClearToEmpty();
}
inline const std::string& RedelegationEntry::initial_balance() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
  return _internal_initial_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedelegationEntry::set_initial_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
}
inline std::string* RedelegationEntry::mutable_initial_balance() {
  std::string* _s = _internal_mutable_initial_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
  return _s;
}
inline const std::string& RedelegationEntry::_internal_initial_balance() const {
  return _impl_.initial_balance_.Get();
}
inline void RedelegationEntry::_internal_set_initial_balance(const std::string& value) {
  ;


  _impl_.initial_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* RedelegationEntry::_internal_mutable_initial_balance() {
  ;
  return _impl_.initial_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* RedelegationEntry::release_initial_balance() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
  return _impl_.initial_balance_.Release();
}
inline void RedelegationEntry::set_allocated_initial_balance(std::string* value) {
  _impl_.initial_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_balance_.IsDefault()) {
          _impl_.initial_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
}

// string shares_dst = 4 [json_name = "sharesDst", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void RedelegationEntry::clear_shares_dst() {
  _impl_.shares_dst_.ClearToEmpty();
}
inline const std::string& RedelegationEntry::shares_dst() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
  return _internal_shares_dst();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedelegationEntry::set_shares_dst(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.shares_dst_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
}
inline std::string* RedelegationEntry::mutable_shares_dst() {
  std::string* _s = _internal_mutable_shares_dst();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
  return _s;
}
inline const std::string& RedelegationEntry::_internal_shares_dst() const {
  return _impl_.shares_dst_.Get();
}
inline void RedelegationEntry::_internal_set_shares_dst(const std::string& value) {
  ;


  _impl_.shares_dst_.Set(value, GetArenaForAllocation());
}
inline std::string* RedelegationEntry::_internal_mutable_shares_dst() {
  ;
  return _impl_.shares_dst_.Mutable( GetArenaForAllocation());
}
inline std::string* RedelegationEntry::release_shares_dst() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
  return _impl_.shares_dst_.Release();
}
inline void RedelegationEntry::set_allocated_shares_dst(std::string* value) {
  _impl_.shares_dst_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shares_dst_.IsDefault()) {
          _impl_.shares_dst_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
}

// uint64 unbonding_id = 5 [json_name = "unbondingId"];
inline void RedelegationEntry::clear_unbonding_id() {
  _impl_.unbonding_id_ = ::uint64_t{0u};
}
inline ::uint64_t RedelegationEntry::unbonding_id() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.unbonding_id)
  return _internal_unbonding_id();
}
inline void RedelegationEntry::set_unbonding_id(::uint64_t value) {
  _internal_set_unbonding_id(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.unbonding_id)
}
inline ::uint64_t RedelegationEntry::_internal_unbonding_id() const {
  return _impl_.unbonding_id_;
}
inline void RedelegationEntry::_internal_set_unbonding_id(::uint64_t value) {
  ;
  _impl_.unbonding_id_ = value;
}

// int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
inline void RedelegationEntry::clear_unbonding_on_hold_ref_count() {
  _impl_.unbonding_on_hold_ref_count_ = ::int64_t{0};
}
inline ::int64_t RedelegationEntry::unbonding_on_hold_ref_count() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.unbonding_on_hold_ref_count)
  return _internal_unbonding_on_hold_ref_count();
}
inline void RedelegationEntry::set_unbonding_on_hold_ref_count(::int64_t value) {
  _internal_set_unbonding_on_hold_ref_count(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.unbonding_on_hold_ref_count)
}
inline ::int64_t RedelegationEntry::_internal_unbonding_on_hold_ref_count() const {
  return _impl_.unbonding_on_hold_ref_count_;
}
inline void RedelegationEntry::_internal_set_unbonding_on_hold_ref_count(::int64_t value) {
  ;
  _impl_.unbonding_on_hold_ref_count_ = value;
}

// -------------------------------------------------------------------

// Redelegation

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Redelegation::clear_delegator_address() {
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& Redelegation::delegator_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Redelegation::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Redelegation.delegator_address)
}
inline std::string* Redelegation::mutable_delegator_address() {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.delegator_address)
  return _s;
}
inline const std::string& Redelegation::_internal_delegator_address() const {
  return _impl_.delegator_address_.Get();
}
inline void Redelegation::_internal_set_delegator_address(const std::string& value) {
  ;


  _impl_.delegator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Redelegation::_internal_mutable_delegator_address() {
  ;
  return _impl_.delegator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Redelegation::release_delegator_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Redelegation.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void Redelegation::set_allocated_delegator_address(std::string* value) {
  _impl_.delegator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.delegator_address_.IsDefault()) {
          _impl_.delegator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Redelegation.delegator_address)
}

// string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Redelegation::clear_validator_src_address() {
  _impl_.validator_src_address_.ClearToEmpty();
}
inline const std::string& Redelegation::validator_src_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.validator_src_address)
  return _internal_validator_src_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Redelegation::set_validator_src_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_src_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Redelegation.validator_src_address)
}
inline std::string* Redelegation::mutable_validator_src_address() {
  std::string* _s = _internal_mutable_validator_src_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.validator_src_address)
  return _s;
}
inline const std::string& Redelegation::_internal_validator_src_address() const {
  return _impl_.validator_src_address_.Get();
}
inline void Redelegation::_internal_set_validator_src_address(const std::string& value) {
  ;


  _impl_.validator_src_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Redelegation::_internal_mutable_validator_src_address() {
  ;
  return _impl_.validator_src_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Redelegation::release_validator_src_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Redelegation.validator_src_address)
  return _impl_.validator_src_address_.Release();
}
inline void Redelegation::set_allocated_validator_src_address(std::string* value) {
  _impl_.validator_src_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_src_address_.IsDefault()) {
          _impl_.validator_src_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Redelegation.validator_src_address)
}

// string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Redelegation::clear_validator_dst_address() {
  _impl_.validator_dst_address_.ClearToEmpty();
}
inline const std::string& Redelegation::validator_dst_address() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
  return _internal_validator_dst_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Redelegation::set_validator_dst_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_dst_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
}
inline std::string* Redelegation::mutable_validator_dst_address() {
  std::string* _s = _internal_mutable_validator_dst_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
  return _s;
}
inline const std::string& Redelegation::_internal_validator_dst_address() const {
  return _impl_.validator_dst_address_.Get();
}
inline void Redelegation::_internal_set_validator_dst_address(const std::string& value) {
  ;


  _impl_.validator_dst_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Redelegation::_internal_mutable_validator_dst_address() {
  ;
  return _impl_.validator_dst_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Redelegation::release_validator_dst_address() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
  return _impl_.validator_dst_address_.Release();
}
inline void Redelegation::set_allocated_validator_dst_address(std::string* value) {
  _impl_.validator_dst_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_dst_address_.IsDefault()) {
          _impl_.validator_dst_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
}

// repeated .cosmos.staking.v1beta1.RedelegationEntry entries = 4 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int Redelegation::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int Redelegation::entries_size() const {
  return _internal_entries_size();
}
inline void Redelegation::clear_entries() {
  _internal_mutable_entries()->Clear();
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* Redelegation::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntry >*
Redelegation::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.Redelegation.entries)
  return _internal_mutable_entries();
}
inline const ::cosmos::staking::v1beta1::RedelegationEntry& Redelegation::_internal_entries(int index) const {
  return _internal_entries().Get(index);
}
inline const ::cosmos::staking::v1beta1::RedelegationEntry& Redelegation::entries(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.entries)
  return _internal_entries(index);
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* Redelegation::_internal_add_entries() {
  return _internal_mutable_entries()->Add();
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* Redelegation::add_entries() {
  ::cosmos::staking::v1beta1::RedelegationEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.Redelegation.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntry >&
Redelegation::entries() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.Redelegation.entries)
  return _internal_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>&
Redelegation::_internal_entries() const {
  return _impl_.entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>*
Redelegation::_internal_mutable_entries() {
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// Params

// .google.protobuf.Duration unbonding_time = 1 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdduration) = true, (.amino.dont_omitempty) = true];
inline bool Params::has_unbonding_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unbonding_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Params::_internal_unbonding_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.unbonding_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Params::unbonding_time() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.unbonding_time)
  return _internal_unbonding_time();
}
inline void Params::unsafe_arena_set_allocated_unbonding_time(
    ::PROTOBUF_NAMESPACE_ID::Duration* unbonding_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unbonding_time_);
  }
  _impl_.unbonding_time_ = unbonding_time;
  if (unbonding_time) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Params.unbonding_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::release_unbonding_time() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::unsafe_arena_release_unbonding_time() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Params.unbonding_time)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::_internal_mutable_unbonding_time() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.unbonding_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.unbonding_time_ = p;
  }
  return _impl_.unbonding_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Params::mutable_unbonding_time() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_unbonding_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Params.unbonding_time)
  return _msg;
}
inline void Params::set_allocated_unbonding_time(::PROTOBUF_NAMESPACE_ID::Duration* unbonding_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unbonding_time_);
  }
  if (unbonding_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unbonding_time));
    if (message_arena != submessage_arena) {
      unbonding_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unbonding_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.unbonding_time_ = unbonding_time;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Params.unbonding_time)
}

// uint32 max_validators = 2 [json_name = "maxValidators"];
inline void Params::clear_max_validators() {
  _impl_.max_validators_ = 0u;
}
inline ::uint32_t Params::max_validators() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.max_validators)
  return _internal_max_validators();
}
inline void Params::set_max_validators(::uint32_t value) {
  _internal_set_max_validators(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.max_validators)
}
inline ::uint32_t Params::_internal_max_validators() const {
  return _impl_.max_validators_;
}
inline void Params::_internal_set_max_validators(::uint32_t value) {
  ;
  _impl_.max_validators_ = value;
}

// uint32 max_entries = 3 [json_name = "maxEntries"];
inline void Params::clear_max_entries() {
  _impl_.max_entries_ = 0u;
}
inline ::uint32_t Params::max_entries() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.max_entries)
  return _internal_max_entries();
}
inline void Params::set_max_entries(::uint32_t value) {
  _internal_set_max_entries(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.max_entries)
}
inline ::uint32_t Params::_internal_max_entries() const {
  return _impl_.max_entries_;
}
inline void Params::_internal_set_max_entries(::uint32_t value) {
  ;
  _impl_.max_entries_ = value;
}

// uint32 historical_entries = 4 [json_name = "historicalEntries"];
inline void Params::clear_historical_entries() {
  _impl_.historical_entries_ = 0u;
}
inline ::uint32_t Params::historical_entries() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.historical_entries)
  return _internal_historical_entries();
}
inline void Params::set_historical_entries(::uint32_t value) {
  _internal_set_historical_entries(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.historical_entries)
}
inline ::uint32_t Params::_internal_historical_entries() const {
  return _impl_.historical_entries_;
}
inline void Params::_internal_set_historical_entries(::uint32_t value) {
  ;
  _impl_.historical_entries_ = value;
}

// string bond_denom = 5 [json_name = "bondDenom"];
inline void Params::clear_bond_denom() {
  _impl_.bond_denom_.ClearToEmpty();
}
inline const std::string& Params::bond_denom() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.bond_denom)
  return _internal_bond_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_bond_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bond_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.bond_denom)
}
inline std::string* Params::mutable_bond_denom() {
  std::string* _s = _internal_mutable_bond_denom();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Params.bond_denom)
  return _s;
}
inline const std::string& Params::_internal_bond_denom() const {
  return _impl_.bond_denom_.Get();
}
inline void Params::_internal_set_bond_denom(const std::string& value) {
  ;


  _impl_.bond_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_bond_denom() {
  ;
  return _impl_.bond_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_bond_denom() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Params.bond_denom)
  return _impl_.bond_denom_.Release();
}
inline void Params::set_allocated_bond_denom(std::string* value) {
  _impl_.bond_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bond_denom_.IsDefault()) {
          _impl_.bond_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Params.bond_denom)
}

// string min_commission_rate = 6 [json_name = "minCommissionRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec", (.gogoproto.moretags) = "yaml:\"min_commission_rate\""];
inline void Params::clear_min_commission_rate() {
  _impl_.min_commission_rate_.ClearToEmpty();
}
inline const std::string& Params::min_commission_rate() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.min_commission_rate)
  return _internal_min_commission_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_min_commission_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_commission_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.min_commission_rate)
}
inline std::string* Params::mutable_min_commission_rate() {
  std::string* _s = _internal_mutable_min_commission_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Params.min_commission_rate)
  return _s;
}
inline const std::string& Params::_internal_min_commission_rate() const {
  return _impl_.min_commission_rate_.Get();
}
inline void Params::_internal_set_min_commission_rate(const std::string& value) {
  ;


  _impl_.min_commission_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_min_commission_rate() {
  ;
  return _impl_.min_commission_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_min_commission_rate() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Params.min_commission_rate)
  return _impl_.min_commission_rate_.Release();
}
inline void Params::set_allocated_min_commission_rate(std::string* value) {
  _impl_.min_commission_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_commission_rate_.IsDefault()) {
          _impl_.min_commission_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Params.min_commission_rate)
}

// -------------------------------------------------------------------

// DelegationResponse

// .cosmos.staking.v1beta1.Delegation delegation = 1 [json_name = "delegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool DelegationResponse::has_delegation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.delegation_ != nullptr);
  return value;
}
inline void DelegationResponse::clear_delegation() {
  if (_impl_.delegation_ != nullptr) _impl_.delegation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::Delegation& DelegationResponse::_internal_delegation() const {
  const ::cosmos::staking::v1beta1::Delegation* p = _impl_.delegation_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Delegation&>(
      ::cosmos::staking::v1beta1::_Delegation_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Delegation& DelegationResponse::delegation() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DelegationResponse.delegation)
  return _internal_delegation();
}
inline void DelegationResponse::unsafe_arena_set_allocated_delegation(
    ::cosmos::staking::v1beta1::Delegation* delegation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delegation_);
  }
  _impl_.delegation_ = delegation;
  if (delegation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.DelegationResponse.delegation)
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::release_delegation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Delegation* temp = _impl_.delegation_;
  _impl_.delegation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::unsafe_arena_release_delegation() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DelegationResponse.delegation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Delegation* temp = _impl_.delegation_;
  _impl_.delegation_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::_internal_mutable_delegation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.delegation_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::staking::v1beta1::Delegation>(GetArenaForAllocation());
    _impl_.delegation_ = p;
  }
  return _impl_.delegation_;
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::mutable_delegation() {
  ::cosmos::staking::v1beta1::Delegation* _msg = _internal_mutable_delegation();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DelegationResponse.delegation)
  return _msg;
}
inline void DelegationResponse::set_allocated_delegation(::cosmos::staking::v1beta1::Delegation* delegation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.delegation_;
  }
  if (delegation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delegation);
    if (message_arena != submessage_arena) {
      delegation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delegation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.delegation_ = delegation;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DelegationResponse.delegation)
}

// .cosmos.base.v1beta1.Coin balance = 2 [json_name = "balance", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool DelegationResponse::has_balance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.balance_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& DelegationResponse::_internal_balance() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.balance_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& DelegationResponse::balance() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DelegationResponse.balance)
  return _internal_balance();
}
inline void DelegationResponse::unsafe_arena_set_allocated_balance(
    ::cosmos::base::v1beta1::Coin* balance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.balance_);
  }
  _impl_.balance_ = balance;
  if (balance) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.DelegationResponse.balance)
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::release_balance() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.balance_;
  _impl_.balance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::unsafe_arena_release_balance() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DelegationResponse.balance)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.balance_;
  _impl_.balance_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::_internal_mutable_balance() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.balance_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.balance_ = p;
  }
  return _impl_.balance_;
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::mutable_balance() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DelegationResponse.balance)
  return _msg;
}
inline void DelegationResponse::set_allocated_balance(::cosmos::base::v1beta1::Coin* balance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.balance_);
  }
  if (balance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(balance));
    if (message_arena != submessage_arena) {
      balance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, balance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.balance_ = balance;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DelegationResponse.balance)
}

// -------------------------------------------------------------------

// RedelegationEntryResponse

// .cosmos.staking.v1beta1.RedelegationEntry redelegation_entry = 1 [json_name = "redelegationEntry", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool RedelegationEntryResponse::has_redelegation_entry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redelegation_entry_ != nullptr);
  return value;
}
inline void RedelegationEntryResponse::clear_redelegation_entry() {
  if (_impl_.redelegation_entry_ != nullptr) _impl_.redelegation_entry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::RedelegationEntry& RedelegationEntryResponse::_internal_redelegation_entry() const {
  const ::cosmos::staking::v1beta1::RedelegationEntry* p = _impl_.redelegation_entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::RedelegationEntry&>(
      ::cosmos::staking::v1beta1::_RedelegationEntry_default_instance_);
}
inline const ::cosmos::staking::v1beta1::RedelegationEntry& RedelegationEntryResponse::redelegation_entry() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
  return _internal_redelegation_entry();
}
inline void RedelegationEntryResponse::unsafe_arena_set_allocated_redelegation_entry(
    ::cosmos::staking::v1beta1::RedelegationEntry* redelegation_entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redelegation_entry_);
  }
  _impl_.redelegation_entry_ = redelegation_entry;
  if (redelegation_entry) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::release_redelegation_entry() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::RedelegationEntry* temp = _impl_.redelegation_entry_;
  _impl_.redelegation_entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::unsafe_arena_release_redelegation_entry() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::RedelegationEntry* temp = _impl_.redelegation_entry_;
  _impl_.redelegation_entry_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::_internal_mutable_redelegation_entry() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.redelegation_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::staking::v1beta1::RedelegationEntry>(GetArenaForAllocation());
    _impl_.redelegation_entry_ = p;
  }
  return _impl_.redelegation_entry_;
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::mutable_redelegation_entry() {
  ::cosmos::staking::v1beta1::RedelegationEntry* _msg = _internal_mutable_redelegation_entry();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
  return _msg;
}
inline void RedelegationEntryResponse::set_allocated_redelegation_entry(::cosmos::staking::v1beta1::RedelegationEntry* redelegation_entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.redelegation_entry_;
  }
  if (redelegation_entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(redelegation_entry);
    if (message_arena != submessage_arena) {
      redelegation_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redelegation_entry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.redelegation_entry_ = redelegation_entry;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
}

// string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void RedelegationEntryResponse::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& RedelegationEntryResponse::balance() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedelegationEntryResponse::set_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
}
inline std::string* RedelegationEntryResponse::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
  return _s;
}
inline const std::string& RedelegationEntryResponse::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void RedelegationEntryResponse::_internal_set_balance(const std::string& value) {
  ;


  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* RedelegationEntryResponse::_internal_mutable_balance() {
  ;
  return _impl_.balance_.Mutable( GetArenaForAllocation());
}
inline std::string* RedelegationEntryResponse::release_balance() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
  return _impl_.balance_.Release();
}
inline void RedelegationEntryResponse::set_allocated_balance(std::string* value) {
  _impl_.balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_.IsDefault()) {
          _impl_.balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
}

// -------------------------------------------------------------------

// RedelegationResponse

// .cosmos.staking.v1beta1.Redelegation redelegation = 1 [json_name = "redelegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool RedelegationResponse::has_redelegation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redelegation_ != nullptr);
  return value;
}
inline void RedelegationResponse::clear_redelegation() {
  if (_impl_.redelegation_ != nullptr) _impl_.redelegation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::Redelegation& RedelegationResponse::_internal_redelegation() const {
  const ::cosmos::staking::v1beta1::Redelegation* p = _impl_.redelegation_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Redelegation&>(
      ::cosmos::staking::v1beta1::_Redelegation_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Redelegation& RedelegationResponse::redelegation() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
  return _internal_redelegation();
}
inline void RedelegationResponse::unsafe_arena_set_allocated_redelegation(
    ::cosmos::staking::v1beta1::Redelegation* redelegation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redelegation_);
  }
  _impl_.redelegation_ = redelegation;
  if (redelegation) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::release_redelegation() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Redelegation* temp = _impl_.redelegation_;
  _impl_.redelegation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::unsafe_arena_release_redelegation() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Redelegation* temp = _impl_.redelegation_;
  _impl_.redelegation_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::_internal_mutable_redelegation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.redelegation_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::staking::v1beta1::Redelegation>(GetArenaForAllocation());
    _impl_.redelegation_ = p;
  }
  return _impl_.redelegation_;
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::mutable_redelegation() {
  ::cosmos::staking::v1beta1::Redelegation* _msg = _internal_mutable_redelegation();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
  return _msg;
}
inline void RedelegationResponse::set_allocated_redelegation(::cosmos::staking::v1beta1::Redelegation* redelegation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.redelegation_;
  }
  if (redelegation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(redelegation);
    if (message_arena != submessage_arena) {
      redelegation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redelegation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.redelegation_ = redelegation;
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
}

// repeated .cosmos.staking.v1beta1.RedelegationEntryResponse entries = 2 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int RedelegationResponse::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int RedelegationResponse::entries_size() const {
  return _internal_entries_size();
}
inline void RedelegationResponse::clear_entries() {
  _internal_mutable_entries()->Clear();
}
inline ::cosmos::staking::v1beta1::RedelegationEntryResponse* RedelegationResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntryResponse >*
RedelegationResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _internal_mutable_entries();
}
inline const ::cosmos::staking::v1beta1::RedelegationEntryResponse& RedelegationResponse::_internal_entries(int index) const {
  return _internal_entries().Get(index);
}
inline const ::cosmos::staking::v1beta1::RedelegationEntryResponse& RedelegationResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _internal_entries(index);
}
inline ::cosmos::staking::v1beta1::RedelegationEntryResponse* RedelegationResponse::_internal_add_entries() {
  return _internal_mutable_entries()->Add();
}
inline ::cosmos::staking::v1beta1::RedelegationEntryResponse* RedelegationResponse::add_entries() {
  ::cosmos::staking::v1beta1::RedelegationEntryResponse* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntryResponse >&
RedelegationResponse::entries() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _internal_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>&
RedelegationResponse::_internal_entries() const {
  return _impl_.entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>*
RedelegationResponse::_internal_mutable_entries() {
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// Pool

// string not_bonded_tokens = 1 [json_name = "notBondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "not_bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
inline void Pool::clear_not_bonded_tokens() {
  _impl_.not_bonded_tokens_.ClearToEmpty();
}
inline const std::string& Pool::not_bonded_tokens() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
  return _internal_not_bonded_tokens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pool::set_not_bonded_tokens(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.not_bonded_tokens_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
}
inline std::string* Pool::mutable_not_bonded_tokens() {
  std::string* _s = _internal_mutable_not_bonded_tokens();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
  return _s;
}
inline const std::string& Pool::_internal_not_bonded_tokens() const {
  return _impl_.not_bonded_tokens_.Get();
}
inline void Pool::_internal_set_not_bonded_tokens(const std::string& value) {
  ;


  _impl_.not_bonded_tokens_.Set(value, GetArenaForAllocation());
}
inline std::string* Pool::_internal_mutable_not_bonded_tokens() {
  ;
  return _impl_.not_bonded_tokens_.Mutable( GetArenaForAllocation());
}
inline std::string* Pool::release_not_bonded_tokens() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
  return _impl_.not_bonded_tokens_.Release();
}
inline void Pool::set_allocated_not_bonded_tokens(std::string* value) {
  _impl_.not_bonded_tokens_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.not_bonded_tokens_.IsDefault()) {
          _impl_.not_bonded_tokens_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
}

// string bonded_tokens = 2 [json_name = "bondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (.gogoproto.jsontag) = "bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
inline void Pool::clear_bonded_tokens() {
  _impl_.bonded_tokens_.ClearToEmpty();
}
inline const std::string& Pool::bonded_tokens() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Pool.bonded_tokens)
  return _internal_bonded_tokens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pool::set_bonded_tokens(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bonded_tokens_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Pool.bonded_tokens)
}
inline std::string* Pool::mutable_bonded_tokens() {
  std::string* _s = _internal_mutable_bonded_tokens();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Pool.bonded_tokens)
  return _s;
}
inline const std::string& Pool::_internal_bonded_tokens() const {
  return _impl_.bonded_tokens_.Get();
}
inline void Pool::_internal_set_bonded_tokens(const std::string& value) {
  ;


  _impl_.bonded_tokens_.Set(value, GetArenaForAllocation());
}
inline std::string* Pool::_internal_mutable_bonded_tokens() {
  ;
  return _impl_.bonded_tokens_.Mutable( GetArenaForAllocation());
}
inline std::string* Pool::release_bonded_tokens() {
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Pool.bonded_tokens)
  return _impl_.bonded_tokens_.Release();
}
inline void Pool::set_allocated_bonded_tokens(std::string* value) {
  _impl_.bonded_tokens_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bonded_tokens_.IsDefault()) {
          _impl_.bonded_tokens_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Pool.bonded_tokens)
}

// -------------------------------------------------------------------

// ValidatorUpdates

// repeated .tendermint.abci.ValidatorUpdate updates = 1 [json_name = "updates", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int ValidatorUpdates::_internal_updates_size() const {
  return _impl_.updates_.size();
}
inline int ValidatorUpdates::updates_size() const {
  return _internal_updates_size();
}
inline ::tendermint::abci::ValidatorUpdate* ValidatorUpdates::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _internal_mutable_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
ValidatorUpdates::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _internal_mutable_updates();
}
inline const ::tendermint::abci::ValidatorUpdate& ValidatorUpdates::_internal_updates(int index) const {
  return _internal_updates().Get(index);
}
inline const ::tendermint::abci::ValidatorUpdate& ValidatorUpdates::updates(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _internal_updates(index);
}
inline ::tendermint::abci::ValidatorUpdate* ValidatorUpdates::_internal_add_updates() {
  return _internal_mutable_updates()->Add();
}
inline ::tendermint::abci::ValidatorUpdate* ValidatorUpdates::add_updates() {
  ::tendermint::abci::ValidatorUpdate* _add = _internal_add_updates();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
ValidatorUpdates::updates() const {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _internal_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>&
ValidatorUpdates::_internal_updates() const {
  return _impl_.updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>*
ValidatorUpdates::_internal_mutable_updates() {
  return &_impl_.updates_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace staking
}  // namespace cosmos


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::cosmos::staking::v1beta1::BondStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::staking::v1beta1::BondStatus>() {
  return ::cosmos::staking::v1beta1::BondStatus_descriptor();
}
template <>
struct is_proto_enum<::cosmos::staking::v1beta1::Infraction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::staking::v1beta1::Infraction>() {
  return ::cosmos::staking::v1beta1::Infraction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto_2epb_2eh
