// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/tx/v1beta1/tx.proto

#include "cosmos/tx/v1beta1/tx.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace cosmos {
namespace tx {
namespace v1beta1 {
template <typename>
PROTOBUF_CONSTEXPR Tx::Tx(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signatures_)*/{}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.auth_info_)*/nullptr} {}
struct TxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TxDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TxDefaultTypeInternal() {}
  union {
    Tx _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TxDefaultTypeInternal _Tx_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TxRaw::TxRaw(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signatures_)*/{}
  , /*decltype(_impl_.body_bytes_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.auth_info_bytes_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TxRawDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TxRawDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TxRawDefaultTypeInternal() {}
  union {
    TxRaw _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TxRawDefaultTypeInternal _TxRaw_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SignDoc::SignDoc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.body_bytes_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.auth_info_bytes_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.chain_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.account_number_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignDocDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignDocDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignDocDefaultTypeInternal() {}
  union {
    SignDoc _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignDocDefaultTypeInternal _SignDoc_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SignDocDirectAux::SignDocDirectAux(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.body_bytes_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.chain_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.tip_)*/nullptr
  , /*decltype(_impl_.account_number_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.sequence_)*/ ::uint64_t{0u}
} {}
struct SignDocDirectAuxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignDocDirectAuxDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignDocDirectAuxDefaultTypeInternal() {}
  union {
    SignDocDirectAux _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignDocDirectAuxDefaultTypeInternal _SignDocDirectAux_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TxBody::TxBody(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messages_)*/{}
  , /*decltype(_impl_.extension_options_)*/{}
  , /*decltype(_impl_.non_critical_extension_options_)*/{}
  , /*decltype(_impl_.memo_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timeout_height_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TxBodyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TxBodyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TxBodyDefaultTypeInternal() {}
  union {
    TxBody _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TxBodyDefaultTypeInternal _TxBody_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuthInfo::AuthInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signer_infos_)*/{}
  , /*decltype(_impl_.fee_)*/nullptr
  , /*decltype(_impl_.tip_)*/nullptr} {}
struct AuthInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthInfoDefaultTypeInternal() {}
  union {
    AuthInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthInfoDefaultTypeInternal _AuthInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SignerInfo::SignerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.public_key_)*/nullptr
  , /*decltype(_impl_.mode_info_)*/nullptr
  , /*decltype(_impl_.sequence_)*/ ::uint64_t{0u}
} {}
struct SignerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignerInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignerInfoDefaultTypeInternal() {}
  union {
    SignerInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignerInfoDefaultTypeInternal _SignerInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ModeInfo_Single::ModeInfo_Single(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mode_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModeInfo_SingleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModeInfo_SingleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModeInfo_SingleDefaultTypeInternal() {}
  union {
    ModeInfo_Single _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModeInfo_SingleDefaultTypeInternal _ModeInfo_Single_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ModeInfo_Multi::ModeInfo_Multi(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_infos_)*/{}
  , /*decltype(_impl_.bitarray_)*/nullptr} {}
struct ModeInfo_MultiDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModeInfo_MultiDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModeInfo_MultiDefaultTypeInternal() {}
  union {
    ModeInfo_Multi _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModeInfo_MultiDefaultTypeInternal _ModeInfo_Multi_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ModeInfo::ModeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sum_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ModeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModeInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModeInfoDefaultTypeInternal() {}
  union {
    ModeInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModeInfoDefaultTypeInternal _ModeInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Fee::Fee(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.amount_)*/{}
  , /*decltype(_impl_.payer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.granter_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.gas_limit_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeDefaultTypeInternal() {}
  union {
    Fee _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeDefaultTypeInternal _Fee_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Tip::Tip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.amount_)*/{}
  , /*decltype(_impl_.tipper_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TipDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TipDefaultTypeInternal() {}
  union {
    Tip _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TipDefaultTypeInternal _Tip_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AuxSignerData::AuxSignerData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.sig_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.sign_doc_)*/nullptr
  , /*decltype(_impl_.mode_)*/ 0
} {}
struct AuxSignerDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuxSignerDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuxSignerDataDefaultTypeInternal() {}
  union {
    AuxSignerData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuxSignerDataDefaultTypeInternal _AuxSignerData_default_instance_;
}  // namespace v1beta1
}  // namespace tx
}  // namespace cosmos
static ::_pb::Metadata file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[13];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_cosmos_2ftx_2fv1beta1_2ftx_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_cosmos_2ftx_2fv1beta1_2ftx_2eproto = nullptr;
const ::uint32_t TableStruct_cosmos_2ftx_2fv1beta1_2ftx_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tx, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tx, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tx, _impl_.body_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tx, _impl_.auth_info_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tx, _impl_.signatures_),
    0,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxRaw, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxRaw, _impl_.body_bytes_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxRaw, _impl_.auth_info_bytes_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxRaw, _impl_.signatures_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDoc, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDoc, _impl_.body_bytes_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDoc, _impl_.auth_info_bytes_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDoc, _impl_.chain_id_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDoc, _impl_.account_number_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _impl_.body_bytes_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _impl_.public_key_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _impl_.chain_id_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _impl_.account_number_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _impl_.sequence_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignDocDirectAux, _impl_.tip_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxBody, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxBody, _impl_.messages_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxBody, _impl_.memo_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxBody, _impl_.timeout_height_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxBody, _impl_.extension_options_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::TxBody, _impl_.non_critical_extension_options_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuthInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuthInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuthInfo, _impl_.signer_infos_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuthInfo, _impl_.fee_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuthInfo, _impl_.tip_),
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignerInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignerInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignerInfo, _impl_.public_key_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignerInfo, _impl_.mode_info_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::SignerInfo, _impl_.sequence_),
    0,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo_Single, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo_Single, _impl_.mode_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo_Multi, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo_Multi, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo_Multi, _impl_.bitarray_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo_Multi, _impl_.mode_infos_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo, _impl_.sum_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Fee, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Fee, _impl_.amount_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Fee, _impl_.gas_limit_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Fee, _impl_.payer_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Fee, _impl_.granter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tip, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tip, _impl_.amount_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::Tip, _impl_.tipper_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuxSignerData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuxSignerData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuxSignerData, _impl_.address_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuxSignerData, _impl_.sign_doc_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuxSignerData, _impl_.mode_),
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::AuxSignerData, _impl_.sig_),
    ~0u,
    0,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 11, -1, sizeof(::cosmos::tx::v1beta1::Tx)},
        { 14, -1, -1, sizeof(::cosmos::tx::v1beta1::TxRaw)},
        { 25, -1, -1, sizeof(::cosmos::tx::v1beta1::SignDoc)},
        { 37, 51, -1, sizeof(::cosmos::tx::v1beta1::SignDocDirectAux)},
        { 57, -1, -1, sizeof(::cosmos::tx::v1beta1::TxBody)},
        { 70, 81, -1, sizeof(::cosmos::tx::v1beta1::AuthInfo)},
        { 84, 95, -1, sizeof(::cosmos::tx::v1beta1::SignerInfo)},
        { 98, -1, -1, sizeof(::cosmos::tx::v1beta1::ModeInfo_Single)},
        { 107, 117, -1, sizeof(::cosmos::tx::v1beta1::ModeInfo_Multi)},
        { 119, -1, -1, sizeof(::cosmos::tx::v1beta1::ModeInfo)},
        { 130, -1, -1, sizeof(::cosmos::tx::v1beta1::Fee)},
        { 142, -1, -1, sizeof(::cosmos::tx::v1beta1::Tip)},
        { 152, 164, -1, sizeof(::cosmos::tx::v1beta1::AuxSignerData)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::cosmos::tx::v1beta1::_Tx_default_instance_._instance,
    &::cosmos::tx::v1beta1::_TxRaw_default_instance_._instance,
    &::cosmos::tx::v1beta1::_SignDoc_default_instance_._instance,
    &::cosmos::tx::v1beta1::_SignDocDirectAux_default_instance_._instance,
    &::cosmos::tx::v1beta1::_TxBody_default_instance_._instance,
    &::cosmos::tx::v1beta1::_AuthInfo_default_instance_._instance,
    &::cosmos::tx::v1beta1::_SignerInfo_default_instance_._instance,
    &::cosmos::tx::v1beta1::_ModeInfo_Single_default_instance_._instance,
    &::cosmos::tx::v1beta1::_ModeInfo_Multi_default_instance_._instance,
    &::cosmos::tx::v1beta1::_ModeInfo_default_instance_._instance,
    &::cosmos::tx::v1beta1::_Fee_default_instance_._instance,
    &::cosmos::tx::v1beta1::_Tip_default_instance_._instance,
    &::cosmos::tx::v1beta1::_AuxSignerData_default_instance_._instance,
};
const char descriptor_table_protodef_cosmos_2ftx_2fv1beta1_2ftx_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\032cosmos/tx/v1beta1/tx.proto\022\021cosmos.tx."
    "v1beta1\032\024gogoproto/gogo.proto\032-cosmos/cr"
    "ypto/multisig/v1beta1/multisig.proto\032\036co"
    "smos/base/v1beta1/coin.proto\032\'cosmos/tx/"
    "signing/v1beta1/signing.proto\032\031google/pr"
    "otobuf/any.proto\032\031cosmos_proto/cosmos.pr"
    "oto\"\215\001\n\002Tx\022-\n\004body\030\001 \001(\0132\031.cosmos.tx.v1b"
    "eta1.TxBodyR\004body\0228\n\tauth_info\030\002 \001(\0132\033.c"
    "osmos.tx.v1beta1.AuthInfoR\010authInfo\022\036\n\ns"
    "ignatures\030\003 \003(\014R\nsignatures\"n\n\005TxRaw\022\035\n\n"
    "body_bytes\030\001 \001(\014R\tbodyBytes\022&\n\017auth_info"
    "_bytes\030\002 \001(\014R\rauthInfoBytes\022\036\n\nsignature"
    "s\030\003 \003(\014R\nsignatures\"\222\001\n\007SignDoc\022\035\n\nbody_"
    "bytes\030\001 \001(\014R\tbodyBytes\022&\n\017auth_info_byte"
    "s\030\002 \001(\014R\rauthInfoBytes\022\031\n\010chain_id\030\003 \001(\t"
    "R\007chainId\022%\n\016account_number\030\004 \001(\004R\raccou"
    "ntNumber\"\356\001\n\020SignDocDirectAux\022\035\n\nbody_by"
    "tes\030\001 \001(\014R\tbodyBytes\0223\n\npublic_key\030\002 \001(\013"
    "2\024.google.protobuf.AnyR\tpublicKey\022\031\n\010cha"
    "in_id\030\003 \001(\tR\007chainId\022%\n\016account_number\030\004"
    " \001(\004R\raccountNumber\022\032\n\010sequence\030\005 \001(\004R\010s"
    "equence\022(\n\003tip\030\006 \001(\0132\026.cosmos.tx.v1beta1"
    ".TipR\003tip\"\225\002\n\006TxBody\0220\n\010messages\030\001 \003(\0132\024"
    ".google.protobuf.AnyR\010messages\022\022\n\004memo\030\002"
    " \001(\tR\004memo\022%\n\016timeout_height\030\003 \001(\004R\rtime"
    "outHeight\022B\n\021extension_options\030\377\007 \003(\0132\024."
    "google.protobuf.AnyR\020extensionOptions\022Z\n"
    "\036non_critical_extension_options\030\377\017 \003(\0132\024"
    ".google.protobuf.AnyR\033nonCriticalExtensi"
    "onOptions\"\240\001\n\010AuthInfo\022@\n\014signer_infos\030\001"
    " \003(\0132\035.cosmos.tx.v1beta1.SignerInfoR\013sig"
    "nerInfos\022(\n\003fee\030\002 \001(\0132\026.cosmos.tx.v1beta"
    "1.FeeR\003fee\022(\n\003tip\030\003 \001(\0132\026.cosmos.tx.v1be"
    "ta1.TipR\003tip\"\227\001\n\nSignerInfo\0223\n\npublic_ke"
    "y\030\001 \001(\0132\024.google.protobuf.AnyR\tpublicKey"
    "\0228\n\tmode_info\030\002 \001(\0132\033.cosmos.tx.v1beta1."
    "ModeInfoR\010modeInfo\022\032\n\010sequence\030\003 \001(\004R\010se"
    "quence\"\340\002\n\010ModeInfo\022<\n\006single\030\001 \001(\0132\".co"
    "smos.tx.v1beta1.ModeInfo.SingleH\000R\006singl"
    "e\0229\n\005multi\030\002 \001(\0132!.cosmos.tx.v1beta1.Mod"
    "eInfo.MultiH\000R\005multi\032A\n\006Single\0227\n\004mode\030\001"
    " \001(\0162#.cosmos.tx.signing.v1beta1.SignMod"
    "eR\004mode\032\220\001\n\005Multi\022K\n\010bitarray\030\001 \001(\0132/.co"
    "smos.crypto.multisig.v1beta1.CompactBitA"
    "rrayR\010bitarray\022:\n\nmode_infos\030\002 \003(\0132\033.cos"
    "mos.tx.v1beta1.ModeInfoR\tmodeInfosB\005\n\003su"
    "m\"\353\001\n\003Fee\022c\n\006amount\030\001 \003(\0132\031.cosmos.base."
    "v1beta1.CoinB0\310\336\037\000\252\337\037(github.com/cosmos/"
    "cosmos-sdk/types.CoinsR\006amount\022\033\n\tgas_li"
    "mit\030\002 \001(\004R\010gasLimit\022.\n\005payer\030\003 \001(\tB\030\322\264-\024"
    "cosmos.AddressStringR\005payer\0222\n\007granter\030\004"
    " \001(\tB\030\322\264-\024cosmos.AddressStringR\007granter\""
    "\234\001\n\003Tip\022c\n\006amount\030\001 \003(\0132\031.cosmos.base.v1"
    "beta1.CoinB0\310\336\037\000\252\337\037(github.com/cosmos/co"
    "smos-sdk/types.CoinsR\006amount\0220\n\006tipper\030\002"
    " \001(\tB\030\322\264-\024cosmos.AddressStringR\006tipper\"\316"
    "\001\n\rAuxSignerData\0222\n\007address\030\001 \001(\tB\030\322\264-\024c"
    "osmos.AddressStringR\007address\022>\n\010sign_doc"
    "\030\002 \001(\0132#.cosmos.tx.v1beta1.SignDocDirect"
    "AuxR\007signDoc\0227\n\004mode\030\003 \001(\0162#.cosmos.tx.s"
    "igning.v1beta1.SignModeR\004mode\022\020\n\003sig\030\004 \001"
    "(\014R\003sigB\255\001\n\025com.cosmos.tx.v1beta1B\007TxPro"
    "toP\001Z%github.com/cosmos/cosmos-sdk/types"
    "/tx\242\002\003CTX\252\002\021Cosmos.Tx.V1beta1\312\002\021Cosmos\\T"
    "x\\V1beta1\342\002\035Cosmos\\Tx\\V1beta1\\GPBMetadat"
    "a\352\002\023Cosmos::Tx::V1beta1b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_deps[6] =
    {
        &::descriptor_table_cosmos_2fbase_2fv1beta1_2fcoin_2eproto,
        &::descriptor_table_cosmos_2fcrypto_2fmultisig_2fv1beta1_2fmultisig_2eproto,
        &::descriptor_table_cosmos_2ftx_2fsigning_2fv1beta1_2fsigning_2eproto,
        &::descriptor_table_cosmos_5fproto_2fcosmos_2eproto,
        &::descriptor_table_gogoproto_2fgogo_2eproto,
        &::descriptor_table_google_2fprotobuf_2fany_2eproto,
};
static ::absl::once_flag descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto = {
    false,
    false,
    2631,
    descriptor_table_protodef_cosmos_2ftx_2fv1beta1_2ftx_2eproto,
    "cosmos/tx/v1beta1/tx.proto",
    &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
    descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_deps,
    6,
    13,
    schemas,
    file_default_instances,
    TableStruct_cosmos_2ftx_2fv1beta1_2ftx_2eproto::offsets,
    file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto,
    file_level_enum_descriptors_cosmos_2ftx_2fv1beta1_2ftx_2eproto,
    file_level_service_descriptors_cosmos_2ftx_2fv1beta1_2ftx_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter() {
  return &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_cosmos_2ftx_2fv1beta1_2ftx_2eproto(&descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto);
namespace cosmos {
namespace tx {
namespace v1beta1 {
// ===================================================================

class Tx::_Internal {
 public:
  using HasBits = decltype(std::declval<Tx>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Tx, _impl_._has_bits_);
  static const ::cosmos::tx::v1beta1::TxBody& body(const Tx* msg);
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::tx::v1beta1::AuthInfo& auth_info(const Tx* msg);
  static void set_has_auth_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cosmos::tx::v1beta1::TxBody&
Tx::_Internal::body(const Tx* msg) {
  return *msg->_impl_.body_;
}
const ::cosmos::tx::v1beta1::AuthInfo&
Tx::_Internal::auth_info(const Tx* msg) {
  return *msg->_impl_.auth_info_;
}
Tx::Tx(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.Tx)
}
Tx::Tx(const Tx& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tx* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signatures_){from._impl_.signatures_}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.auth_info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.body_ = new ::cosmos::tx::v1beta1::TxBody(*from._impl_.body_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.auth_info_ = new ::cosmos::tx::v1beta1::AuthInfo(*from._impl_.auth_info_);
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.Tx)
}

inline void Tx::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signatures_){arena}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.auth_info_){nullptr}
  };
}

Tx::~Tx() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.Tx)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tx::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_signatures()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.auth_info_;
}

void Tx::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tx::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.Tx)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_signatures()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.body_ != nullptr);
      _impl_.body_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.auth_info_ != nullptr);
      _impl_.auth_info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tx::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.tx.v1beta1.TxBody body = 1 [json_name = "body"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.v1beta1.AuthInfo auth_info = 2 [json_name = "authInfo"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_auth_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated bytes signatures = 3 [json_name = "signatures"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signatures();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Tx::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.Tx)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.tx.v1beta1.TxBody body = 1 [json_name = "body"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // .cosmos.tx.v1beta1.AuthInfo auth_info = 2 [json_name = "authInfo"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::auth_info(this),
        _Internal::auth_info(this).GetCachedSize(), target, stream);
  }

  // repeated bytes signatures = 3 [json_name = "signatures"];
  for (int i = 0, n = this->_internal_signatures_size(); i < n; ++i) {
    const auto& s = this->_internal_signatures(i);
    target = stream->WriteBytes(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.Tx)
  return target;
}

::size_t Tx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.Tx)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes signatures = 3 [json_name = "signatures"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_signatures().size());
  for (int i = 0, n = _internal_signatures().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        _internal_signatures().Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .cosmos.tx.v1beta1.TxBody body = 1 [json_name = "body"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_);
    }

    // .cosmos.tx.v1beta1.AuthInfo auth_info = 2 [json_name = "authInfo"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auth_info_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tx::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tx::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tx::GetClassData() const { return &_class_data_; }


void Tx::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tx*>(&to_msg);
  auto& from = static_cast<const Tx&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.Tx)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_signatures()->MergeFrom(from._internal_signatures());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_body()->::cosmos::tx::v1beta1::TxBody::MergeFrom(
          from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_auth_info()->::cosmos::tx::v1beta1::AuthInfo::MergeFrom(
          from._internal_auth_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tx::CopyFrom(const Tx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.Tx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tx::IsInitialized() const {
  return true;
}

void Tx::InternalSwap(Tx* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_signatures()->InternalSwap(
      other->_internal_mutable_signatures());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tx, _impl_.auth_info_)
      + sizeof(Tx::_impl_.auth_info_)
      - PROTOBUF_FIELD_OFFSET(Tx, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tx::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[0]);
}
// ===================================================================

class TxRaw::_Internal {
 public:
};

TxRaw::TxRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.TxRaw)
}
TxRaw::TxRaw(const TxRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TxRaw* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signatures_){from._impl_.signatures_}
    , decltype(_impl_.body_bytes_) {}

    , decltype(_impl_.auth_info_bytes_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.body_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.body_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_body_bytes().empty()) {
    _this->_impl_.body_bytes_.Set(from._internal_body_bytes(), _this->GetArenaForAllocation());
  }
  _impl_.auth_info_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.auth_info_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_auth_info_bytes().empty()) {
    _this->_impl_.auth_info_bytes_.Set(from._internal_auth_info_bytes(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.TxRaw)
}

inline void TxRaw::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.signatures_){arena}
    , decltype(_impl_.body_bytes_) {}

    , decltype(_impl_.auth_info_bytes_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.body_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.body_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_info_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.auth_info_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TxRaw::~TxRaw() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.TxRaw)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TxRaw::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_signatures()->~RepeatedPtrField();
  _impl_.body_bytes_.Destroy();
  _impl_.auth_info_bytes_.Destroy();
}

void TxRaw::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TxRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.TxRaw)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_signatures()->Clear();
  _impl_.body_bytes_.ClearToEmpty();
  _impl_.auth_info_bytes_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TxRaw::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes body_bytes = 1 [json_name = "bodyBytes"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_body_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes auth_info_bytes = 2 [json_name = "authInfoBytes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_auth_info_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated bytes signatures = 3 [json_name = "signatures"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signatures();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TxRaw::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.TxRaw)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes body_bytes = 1 [json_name = "bodyBytes"];
  if (!this->_internal_body_bytes().empty()) {
    const std::string& _s = this->_internal_body_bytes();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes auth_info_bytes = 2 [json_name = "authInfoBytes"];
  if (!this->_internal_auth_info_bytes().empty()) {
    const std::string& _s = this->_internal_auth_info_bytes();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // repeated bytes signatures = 3 [json_name = "signatures"];
  for (int i = 0, n = this->_internal_signatures_size(); i < n; ++i) {
    const auto& s = this->_internal_signatures(i);
    target = stream->WriteBytes(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.TxRaw)
  return target;
}

::size_t TxRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.TxRaw)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes signatures = 3 [json_name = "signatures"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_signatures().size());
  for (int i = 0, n = _internal_signatures().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        _internal_signatures().Get(i));
  }

  // bytes body_bytes = 1 [json_name = "bodyBytes"];
  if (!this->_internal_body_bytes().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_body_bytes());
  }

  // bytes auth_info_bytes = 2 [json_name = "authInfoBytes"];
  if (!this->_internal_auth_info_bytes().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_auth_info_bytes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TxRaw::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TxRaw::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TxRaw::GetClassData() const { return &_class_data_; }


void TxRaw::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TxRaw*>(&to_msg);
  auto& from = static_cast<const TxRaw&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.TxRaw)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_signatures()->MergeFrom(from._internal_signatures());
  if (!from._internal_body_bytes().empty()) {
    _this->_internal_set_body_bytes(from._internal_body_bytes());
  }
  if (!from._internal_auth_info_bytes().empty()) {
    _this->_internal_set_auth_info_bytes(from._internal_auth_info_bytes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TxRaw::CopyFrom(const TxRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.TxRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRaw::IsInitialized() const {
  return true;
}

void TxRaw::InternalSwap(TxRaw* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_signatures()->InternalSwap(
      other->_internal_mutable_signatures());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.body_bytes_, lhs_arena,
                                       &other->_impl_.body_bytes_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.auth_info_bytes_, lhs_arena,
                                       &other->_impl_.auth_info_bytes_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TxRaw::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[1]);
}
// ===================================================================

class SignDoc::_Internal {
 public:
};

SignDoc::SignDoc(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.SignDoc)
}
SignDoc::SignDoc(const SignDoc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignDoc* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.body_bytes_) {}

    , decltype(_impl_.auth_info_bytes_) {}

    , decltype(_impl_.chain_id_) {}

    , decltype(_impl_.account_number_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.body_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.body_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_body_bytes().empty()) {
    _this->_impl_.body_bytes_.Set(from._internal_body_bytes(), _this->GetArenaForAllocation());
  }
  _impl_.auth_info_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.auth_info_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_auth_info_bytes().empty()) {
    _this->_impl_.auth_info_bytes_.Set(from._internal_auth_info_bytes(), _this->GetArenaForAllocation());
  }
  _impl_.chain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.chain_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_chain_id().empty()) {
    _this->_impl_.chain_id_.Set(from._internal_chain_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.account_number_ = from._impl_.account_number_;
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.SignDoc)
}

inline void SignDoc::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.body_bytes_) {}

    , decltype(_impl_.auth_info_bytes_) {}

    , decltype(_impl_.chain_id_) {}

    , decltype(_impl_.account_number_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.body_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.body_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_info_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.auth_info_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.chain_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignDoc::~SignDoc() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.SignDoc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignDoc::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.body_bytes_.Destroy();
  _impl_.auth_info_bytes_.Destroy();
  _impl_.chain_id_.Destroy();
}

void SignDoc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignDoc::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.SignDoc)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.body_bytes_.ClearToEmpty();
  _impl_.auth_info_bytes_.ClearToEmpty();
  _impl_.chain_id_.ClearToEmpty();
  _impl_.account_number_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignDoc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes body_bytes = 1 [json_name = "bodyBytes"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_body_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes auth_info_bytes = 2 [json_name = "authInfoBytes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_auth_info_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string chain_id = 3 [json_name = "chainId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_chain_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "cosmos.tx.v1beta1.SignDoc.chain_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 account_number = 4 [json_name = "accountNumber"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.account_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SignDoc::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.SignDoc)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes body_bytes = 1 [json_name = "bodyBytes"];
  if (!this->_internal_body_bytes().empty()) {
    const std::string& _s = this->_internal_body_bytes();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bytes auth_info_bytes = 2 [json_name = "authInfoBytes"];
  if (!this->_internal_auth_info_bytes().empty()) {
    const std::string& _s = this->_internal_auth_info_bytes();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // string chain_id = 3 [json_name = "chainId"];
  if (!this->_internal_chain_id().empty()) {
    const std::string& _s = this->_internal_chain_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "cosmos.tx.v1beta1.SignDoc.chain_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // uint64 account_number = 4 [json_name = "accountNumber"];
  if (this->_internal_account_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_account_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.SignDoc)
  return target;
}

::size_t SignDoc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.SignDoc)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes body_bytes = 1 [json_name = "bodyBytes"];
  if (!this->_internal_body_bytes().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_body_bytes());
  }

  // bytes auth_info_bytes = 2 [json_name = "authInfoBytes"];
  if (!this->_internal_auth_info_bytes().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_auth_info_bytes());
  }

  // string chain_id = 3 [json_name = "chainId"];
  if (!this->_internal_chain_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_chain_id());
  }

  // uint64 account_number = 4 [json_name = "accountNumber"];
  if (this->_internal_account_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_account_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignDoc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignDoc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignDoc::GetClassData() const { return &_class_data_; }


void SignDoc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignDoc*>(&to_msg);
  auto& from = static_cast<const SignDoc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.SignDoc)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_body_bytes().empty()) {
    _this->_internal_set_body_bytes(from._internal_body_bytes());
  }
  if (!from._internal_auth_info_bytes().empty()) {
    _this->_internal_set_auth_info_bytes(from._internal_auth_info_bytes());
  }
  if (!from._internal_chain_id().empty()) {
    _this->_internal_set_chain_id(from._internal_chain_id());
  }
  if (from._internal_account_number() != 0) {
    _this->_internal_set_account_number(from._internal_account_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignDoc::CopyFrom(const SignDoc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.SignDoc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignDoc::IsInitialized() const {
  return true;
}

void SignDoc::InternalSwap(SignDoc* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.body_bytes_, lhs_arena,
                                       &other->_impl_.body_bytes_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.auth_info_bytes_, lhs_arena,
                                       &other->_impl_.auth_info_bytes_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.chain_id_, lhs_arena,
                                       &other->_impl_.chain_id_, rhs_arena);

  swap(_impl_.account_number_, other->_impl_.account_number_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignDoc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[2]);
}
// ===================================================================

class SignDocDirectAux::_Internal {
 public:
  using HasBits = decltype(std::declval<SignDocDirectAux>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SignDocDirectAux, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Any& public_key(const SignDocDirectAux* msg);
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::tx::v1beta1::Tip& tip(const SignDocDirectAux* msg);
  static void set_has_tip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Any&
SignDocDirectAux::_Internal::public_key(const SignDocDirectAux* msg) {
  return *msg->_impl_.public_key_;
}
const ::cosmos::tx::v1beta1::Tip&
SignDocDirectAux::_Internal::tip(const SignDocDirectAux* msg) {
  return *msg->_impl_.tip_;
}
void SignDocDirectAux::clear_public_key() {
  if (_impl_.public_key_ != nullptr) _impl_.public_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SignDocDirectAux::SignDocDirectAux(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.SignDocDirectAux)
}
SignDocDirectAux::SignDocDirectAux(const SignDocDirectAux& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignDocDirectAux* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_bytes_) {}

    , decltype(_impl_.chain_id_) {}

    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.tip_){nullptr}
    , decltype(_impl_.account_number_) {}

    , decltype(_impl_.sequence_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.body_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.body_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_body_bytes().empty()) {
    _this->_impl_.body_bytes_.Set(from._internal_body_bytes(), _this->GetArenaForAllocation());
  }
  _impl_.chain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.chain_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_chain_id().empty()) {
    _this->_impl_.chain_id_.Set(from._internal_chain_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.public_key_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.public_key_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.tip_ = new ::cosmos::tx::v1beta1::Tip(*from._impl_.tip_);
  }
  ::memcpy(&_impl_.account_number_, &from._impl_.account_number_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.sequence_) -
    reinterpret_cast<char*>(&_impl_.account_number_)) + sizeof(_impl_.sequence_));
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.SignDocDirectAux)
}

inline void SignDocDirectAux::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_bytes_) {}

    , decltype(_impl_.chain_id_) {}

    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.tip_){nullptr}
    , decltype(_impl_.account_number_) { ::uint64_t{0u} }

    , decltype(_impl_.sequence_) { ::uint64_t{0u} }

  };
  _impl_.body_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.body_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chain_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.chain_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignDocDirectAux::~SignDocDirectAux() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.SignDocDirectAux)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignDocDirectAux::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.body_bytes_.Destroy();
  _impl_.chain_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.public_key_;
  if (this != internal_default_instance()) delete _impl_.tip_;
}

void SignDocDirectAux::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignDocDirectAux::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.SignDocDirectAux)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.body_bytes_.ClearToEmpty();
  _impl_.chain_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.public_key_ != nullptr);
      _impl_.public_key_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.tip_ != nullptr);
      _impl_.tip_->Clear();
    }
  }
  ::memset(&_impl_.account_number_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.sequence_) -
      reinterpret_cast<char*>(&_impl_.account_number_)) + sizeof(_impl_.sequence_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignDocDirectAux::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes body_bytes = 1 [json_name = "bodyBytes"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_body_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Any public_key = 2 [json_name = "publicKey"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string chain_id = 3 [json_name = "chainId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_chain_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "cosmos.tx.v1beta1.SignDocDirectAux.chain_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 account_number = 4 [json_name = "accountNumber"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.account_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 sequence = 5 [json_name = "sequence"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.v1beta1.Tip tip = 6 [json_name = "tip"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_tip(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SignDocDirectAux::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.SignDocDirectAux)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes body_bytes = 1 [json_name = "bodyBytes"];
  if (!this->_internal_body_bytes().empty()) {
    const std::string& _s = this->_internal_body_bytes();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Any public_key = 2 [json_name = "publicKey"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // string chain_id = 3 [json_name = "chainId"];
  if (!this->_internal_chain_id().empty()) {
    const std::string& _s = this->_internal_chain_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "cosmos.tx.v1beta1.SignDocDirectAux.chain_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // uint64 account_number = 4 [json_name = "accountNumber"];
  if (this->_internal_account_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_account_number(), target);
  }

  // uint64 sequence = 5 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_sequence(), target);
  }

  // .cosmos.tx.v1beta1.Tip tip = 6 [json_name = "tip"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::tip(this),
        _Internal::tip(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.SignDocDirectAux)
  return target;
}

::size_t SignDocDirectAux::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.SignDocDirectAux)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes body_bytes = 1 [json_name = "bodyBytes"];
  if (!this->_internal_body_bytes().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_body_bytes());
  }

  // string chain_id = 3 [json_name = "chainId"];
  if (!this->_internal_chain_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_chain_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .google.protobuf.Any public_key = 2 [json_name = "publicKey"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.public_key_);
    }

    // .cosmos.tx.v1beta1.Tip tip = 6 [json_name = "tip"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tip_);
    }

  }
  // uint64 account_number = 4 [json_name = "accountNumber"];
  if (this->_internal_account_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_account_number());
  }

  // uint64 sequence = 5 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_sequence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignDocDirectAux::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignDocDirectAux::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignDocDirectAux::GetClassData() const { return &_class_data_; }


void SignDocDirectAux::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignDocDirectAux*>(&to_msg);
  auto& from = static_cast<const SignDocDirectAux&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.SignDocDirectAux)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_body_bytes().empty()) {
    _this->_internal_set_body_bytes(from._internal_body_bytes());
  }
  if (!from._internal_chain_id().empty()) {
    _this->_internal_set_chain_id(from._internal_chain_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_public_key()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
          from._internal_public_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tip()->::cosmos::tx::v1beta1::Tip::MergeFrom(
          from._internal_tip());
    }
  }
  if (from._internal_account_number() != 0) {
    _this->_internal_set_account_number(from._internal_account_number());
  }
  if (from._internal_sequence() != 0) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignDocDirectAux::CopyFrom(const SignDocDirectAux& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.SignDocDirectAux)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignDocDirectAux::IsInitialized() const {
  return true;
}

void SignDocDirectAux::InternalSwap(SignDocDirectAux* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.body_bytes_, lhs_arena,
                                       &other->_impl_.body_bytes_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.chain_id_, lhs_arena,
                                       &other->_impl_.chain_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignDocDirectAux, _impl_.sequence_)
      + sizeof(SignDocDirectAux::_impl_.sequence_)
      - PROTOBUF_FIELD_OFFSET(SignDocDirectAux, _impl_.public_key_)>(
          reinterpret_cast<char*>(&_impl_.public_key_),
          reinterpret_cast<char*>(&other->_impl_.public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SignDocDirectAux::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[3]);
}
// ===================================================================

class TxBody::_Internal {
 public:
};

void TxBody::clear_messages() {
  _internal_mutable_messages()->Clear();
}
void TxBody::clear_extension_options() {
  _internal_mutable_extension_options()->Clear();
}
void TxBody::clear_non_critical_extension_options() {
  _internal_mutable_non_critical_extension_options()->Clear();
}
TxBody::TxBody(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.TxBody)
}
TxBody::TxBody(const TxBody& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TxBody* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){from._impl_.messages_}
    , decltype(_impl_.extension_options_){from._impl_.extension_options_}
    , decltype(_impl_.non_critical_extension_options_){from._impl_.non_critical_extension_options_}
    , decltype(_impl_.memo_) {}

    , decltype(_impl_.timeout_height_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.memo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_memo().empty()) {
    _this->_impl_.memo_.Set(from._internal_memo(), _this->GetArenaForAllocation());
  }
  _this->_impl_.timeout_height_ = from._impl_.timeout_height_;
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.TxBody)
}

inline void TxBody::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){arena}
    , decltype(_impl_.extension_options_){arena}
    , decltype(_impl_.non_critical_extension_options_){arena}
    , decltype(_impl_.memo_) {}

    , decltype(_impl_.timeout_height_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.memo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.memo_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TxBody::~TxBody() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.TxBody)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TxBody::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_messages()->~RepeatedPtrField();
  _internal_mutable_extension_options()->~RepeatedPtrField();
  _internal_mutable_non_critical_extension_options()->~RepeatedPtrField();
  _impl_.memo_.Destroy();
}

void TxBody::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TxBody::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.TxBody)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_messages()->Clear();
  _internal_mutable_extension_options()->Clear();
  _internal_mutable_non_critical_extension_options()->Clear();
  _impl_.memo_.ClearToEmpty();
  _impl_.timeout_height_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TxBody::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .google.protobuf.Any messages = 1 [json_name = "messages"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_messages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string memo = 2 [json_name = "memo"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_memo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "cosmos.tx.v1beta1.TxBody.memo"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 timeout_height = 3 [json_name = "timeoutHeight"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timeout_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .google.protobuf.Any extension_options = 1023 [json_name = "extensionOptions"];
      case 1023:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_extension_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8186>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .google.protobuf.Any non_critical_extension_options = 2047 [json_name = "nonCriticalExtensionOptions"];
      case 2047:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_non_critical_extension_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16378>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TxBody::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.TxBody)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .google.protobuf.Any messages = 1 [json_name = "messages"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_messages_size()); i < n; i++) {
    const auto& repfield = this->_internal_messages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string memo = 2 [json_name = "memo"];
  if (!this->_internal_memo().empty()) {
    const std::string& _s = this->_internal_memo();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "cosmos.tx.v1beta1.TxBody.memo");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint64 timeout_height = 3 [json_name = "timeoutHeight"];
  if (this->_internal_timeout_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_timeout_height(), target);
  }

  // repeated .google.protobuf.Any extension_options = 1023 [json_name = "extensionOptions"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_options_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension_options(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1023, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any non_critical_extension_options = 2047 [json_name = "nonCriticalExtensionOptions"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_non_critical_extension_options_size()); i < n; i++) {
    const auto& repfield = this->_internal_non_critical_extension_options(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2047, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.TxBody)
  return target;
}

::size_t TxBody::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.TxBody)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any messages = 1 [json_name = "messages"];
  total_size += 1UL * this->_internal_messages_size();
  for (const auto& msg : this->_internal_messages()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.protobuf.Any extension_options = 1023 [json_name = "extensionOptions"];
  total_size += 2UL * this->_internal_extension_options_size();
  for (const auto& msg : this->_internal_extension_options()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.protobuf.Any non_critical_extension_options = 2047 [json_name = "nonCriticalExtensionOptions"];
  total_size += 2UL * this->_internal_non_critical_extension_options_size();
  for (const auto& msg : this->_internal_non_critical_extension_options()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string memo = 2 [json_name = "memo"];
  if (!this->_internal_memo().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_memo());
  }

  // uint64 timeout_height = 3 [json_name = "timeoutHeight"];
  if (this->_internal_timeout_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_timeout_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TxBody::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TxBody::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TxBody::GetClassData() const { return &_class_data_; }


void TxBody::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TxBody*>(&to_msg);
  auto& from = static_cast<const TxBody&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.TxBody)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_messages()->MergeFrom(from._internal_messages());
  _this->_internal_mutable_extension_options()->MergeFrom(from._internal_extension_options());
  _this->_internal_mutable_non_critical_extension_options()->MergeFrom(from._internal_non_critical_extension_options());
  if (!from._internal_memo().empty()) {
    _this->_internal_set_memo(from._internal_memo());
  }
  if (from._internal_timeout_height() != 0) {
    _this->_internal_set_timeout_height(from._internal_timeout_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TxBody::CopyFrom(const TxBody& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.TxBody)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxBody::IsInitialized() const {
  return true;
}

void TxBody::InternalSwap(TxBody* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_messages()->InternalSwap(other->_internal_mutable_messages());
  _internal_mutable_extension_options()->InternalSwap(other->_internal_mutable_extension_options());
  _internal_mutable_non_critical_extension_options()->InternalSwap(other->_internal_mutable_non_critical_extension_options());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.memo_, lhs_arena,
                                       &other->_impl_.memo_, rhs_arena);

  swap(_impl_.timeout_height_, other->_impl_.timeout_height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TxBody::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[4]);
}
// ===================================================================

class AuthInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthInfo, _impl_._has_bits_);
  static const ::cosmos::tx::v1beta1::Fee& fee(const AuthInfo* msg);
  static void set_has_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::tx::v1beta1::Tip& tip(const AuthInfo* msg);
  static void set_has_tip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cosmos::tx::v1beta1::Fee&
AuthInfo::_Internal::fee(const AuthInfo* msg) {
  return *msg->_impl_.fee_;
}
const ::cosmos::tx::v1beta1::Tip&
AuthInfo::_Internal::tip(const AuthInfo* msg) {
  return *msg->_impl_.tip_;
}
AuthInfo::AuthInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.AuthInfo)
}
AuthInfo::AuthInfo(const AuthInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signer_infos_){from._impl_.signer_infos_}
    , decltype(_impl_.fee_){nullptr}
    , decltype(_impl_.tip_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.fee_ = new ::cosmos::tx::v1beta1::Fee(*from._impl_.fee_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.tip_ = new ::cosmos::tx::v1beta1::Tip(*from._impl_.tip_);
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.AuthInfo)
}

inline void AuthInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signer_infos_){arena}
    , decltype(_impl_.fee_){nullptr}
    , decltype(_impl_.tip_){nullptr}
  };
}

AuthInfo::~AuthInfo() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.AuthInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_signer_infos()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.fee_;
  if (this != internal_default_instance()) delete _impl_.tip_;
}

void AuthInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.AuthInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_signer_infos()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.fee_ != nullptr);
      _impl_.fee_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.tip_ != nullptr);
      _impl_.tip_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cosmos.tx.v1beta1.SignerInfo signer_infos = 1 [json_name = "signerInfos"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_signer_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.v1beta1.Fee fee = 2 [json_name = "fee"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fee(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.v1beta1.Tip tip = 3 [json_name = "tip"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tip(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuthInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.AuthInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cosmos.tx.v1beta1.SignerInfo signer_infos = 1 [json_name = "signerInfos"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_signer_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_signer_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.tx.v1beta1.Fee fee = 2 [json_name = "fee"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fee(this),
        _Internal::fee(this).GetCachedSize(), target, stream);
  }

  // .cosmos.tx.v1beta1.Tip tip = 3 [json_name = "tip"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tip(this),
        _Internal::tip(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.AuthInfo)
  return target;
}

::size_t AuthInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.AuthInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.tx.v1beta1.SignerInfo signer_infos = 1 [json_name = "signerInfos"];
  total_size += 1UL * this->_internal_signer_infos_size();
  for (const auto& msg : this->_internal_signer_infos()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .cosmos.tx.v1beta1.Fee fee = 2 [json_name = "fee"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fee_);
    }

    // .cosmos.tx.v1beta1.Tip tip = 3 [json_name = "tip"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tip_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthInfo::GetClassData() const { return &_class_data_; }


void AuthInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthInfo*>(&to_msg);
  auto& from = static_cast<const AuthInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.AuthInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_signer_infos()->MergeFrom(from._internal_signer_infos());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_fee()->::cosmos::tx::v1beta1::Fee::MergeFrom(
          from._internal_fee());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tip()->::cosmos::tx::v1beta1::Tip::MergeFrom(
          from._internal_tip());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthInfo::CopyFrom(const AuthInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.AuthInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthInfo::IsInitialized() const {
  return true;
}

void AuthInfo::InternalSwap(AuthInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_signer_infos()->InternalSwap(other->_internal_mutable_signer_infos());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AuthInfo, _impl_.tip_)
      + sizeof(AuthInfo::_impl_.tip_)
      - PROTOBUF_FIELD_OFFSET(AuthInfo, _impl_.fee_)>(
          reinterpret_cast<char*>(&_impl_.fee_),
          reinterpret_cast<char*>(&other->_impl_.fee_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[5]);
}
// ===================================================================

class SignerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SignerInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SignerInfo, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Any& public_key(const SignerInfo* msg);
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::tx::v1beta1::ModeInfo& mode_info(const SignerInfo* msg);
  static void set_has_mode_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Any&
SignerInfo::_Internal::public_key(const SignerInfo* msg) {
  return *msg->_impl_.public_key_;
}
const ::cosmos::tx::v1beta1::ModeInfo&
SignerInfo::_Internal::mode_info(const SignerInfo* msg) {
  return *msg->_impl_.mode_info_;
}
void SignerInfo::clear_public_key() {
  if (_impl_.public_key_ != nullptr) _impl_.public_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SignerInfo::SignerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.SignerInfo)
}
SignerInfo::SignerInfo(const SignerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.mode_info_){nullptr}
    , decltype(_impl_.sequence_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.public_key_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.public_key_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.mode_info_ = new ::cosmos::tx::v1beta1::ModeInfo(*from._impl_.mode_info_);
  }
  _this->_impl_.sequence_ = from._impl_.sequence_;
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.SignerInfo)
}

inline void SignerInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_key_){nullptr}
    , decltype(_impl_.mode_info_){nullptr}
    , decltype(_impl_.sequence_) { ::uint64_t{0u} }

  };
}

SignerInfo::~SignerInfo() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.SignerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignerInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.public_key_;
  if (this != internal_default_instance()) delete _impl_.mode_info_;
}

void SignerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.SignerInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.public_key_ != nullptr);
      _impl_.public_key_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.mode_info_ != nullptr);
      _impl_.mode_info_->Clear();
    }
  }
  _impl_.sequence_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Any public_key = 1 [json_name = "publicKey"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.v1beta1.ModeInfo mode_info = 2 [json_name = "modeInfo"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mode_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 sequence = 3 [json_name = "sequence"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SignerInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.SignerInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Any public_key = 1 [json_name = "publicKey"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::public_key(this),
        _Internal::public_key(this).GetCachedSize(), target, stream);
  }

  // .cosmos.tx.v1beta1.ModeInfo mode_info = 2 [json_name = "modeInfo"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::mode_info(this),
        _Internal::mode_info(this).GetCachedSize(), target, stream);
  }

  // uint64 sequence = 3 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_sequence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.SignerInfo)
  return target;
}

::size_t SignerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.SignerInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .google.protobuf.Any public_key = 1 [json_name = "publicKey"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.public_key_);
    }

    // .cosmos.tx.v1beta1.ModeInfo mode_info = 2 [json_name = "modeInfo"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mode_info_);
    }

  }
  // uint64 sequence = 3 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_sequence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignerInfo::GetClassData() const { return &_class_data_; }


void SignerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignerInfo*>(&to_msg);
  auto& from = static_cast<const SignerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.SignerInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_public_key()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
          from._internal_public_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_mode_info()->::cosmos::tx::v1beta1::ModeInfo::MergeFrom(
          from._internal_mode_info());
    }
  }
  if (from._internal_sequence() != 0) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignerInfo::CopyFrom(const SignerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.SignerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignerInfo::IsInitialized() const {
  return true;
}

void SignerInfo::InternalSwap(SignerInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignerInfo, _impl_.sequence_)
      + sizeof(SignerInfo::_impl_.sequence_)
      - PROTOBUF_FIELD_OFFSET(SignerInfo, _impl_.public_key_)>(
          reinterpret_cast<char*>(&_impl_.public_key_),
          reinterpret_cast<char*>(&other->_impl_.public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SignerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[6]);
}
// ===================================================================

class ModeInfo_Single::_Internal {
 public:
};

ModeInfo_Single::ModeInfo_Single(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.ModeInfo.Single)
}
ModeInfo_Single::ModeInfo_Single(const ModeInfo_Single& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.ModeInfo.Single)
}

inline void ModeInfo_Single::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.mode_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModeInfo_Single::~ModeInfo_Single() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.ModeInfo.Single)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModeInfo_Single::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModeInfo_Single::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModeInfo_Single::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.ModeInfo.Single)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModeInfo_Single::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.tx.signing.v1beta1.SignMode mode = 1 [json_name = "mode"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::cosmos::tx::signing::v1beta1::SignMode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ModeInfo_Single::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.ModeInfo.Single)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .cosmos.tx.signing.v1beta1.SignMode mode = 1 [json_name = "mode"];
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.ModeInfo.Single)
  return target;
}

::size_t ModeInfo_Single::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.ModeInfo.Single)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .cosmos.tx.signing.v1beta1.SignMode mode = 1 [json_name = "mode"];
  if (this->_internal_mode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModeInfo_Single::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModeInfo_Single::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModeInfo_Single::GetClassData() const { return &_class_data_; }


void ModeInfo_Single::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModeInfo_Single*>(&to_msg);
  auto& from = static_cast<const ModeInfo_Single&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.ModeInfo.Single)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModeInfo_Single::CopyFrom(const ModeInfo_Single& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.ModeInfo.Single)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModeInfo_Single::IsInitialized() const {
  return true;
}

void ModeInfo_Single::InternalSwap(ModeInfo_Single* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModeInfo_Single::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[7]);
}
// ===================================================================

class ModeInfo_Multi::_Internal {
 public:
  using HasBits = decltype(std::declval<ModeInfo_Multi>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ModeInfo_Multi, _impl_._has_bits_);
  static const ::cosmos::crypto::multisig::v1beta1::CompactBitArray& bitarray(const ModeInfo_Multi* msg);
  static void set_has_bitarray(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::crypto::multisig::v1beta1::CompactBitArray&
ModeInfo_Multi::_Internal::bitarray(const ModeInfo_Multi* msg) {
  return *msg->_impl_.bitarray_;
}
void ModeInfo_Multi::clear_bitarray() {
  if (_impl_.bitarray_ != nullptr) _impl_.bitarray_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ModeInfo_Multi::ModeInfo_Multi(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.ModeInfo.Multi)
}
ModeInfo_Multi::ModeInfo_Multi(const ModeInfo_Multi& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModeInfo_Multi* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_infos_){from._impl_.mode_infos_}
    , decltype(_impl_.bitarray_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.bitarray_ = new ::cosmos::crypto::multisig::v1beta1::CompactBitArray(*from._impl_.bitarray_);
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.ModeInfo.Multi)
}

inline void ModeInfo_Multi::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_infos_){arena}
    , decltype(_impl_.bitarray_){nullptr}
  };
}

ModeInfo_Multi::~ModeInfo_Multi() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.ModeInfo.Multi)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModeInfo_Multi::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_mode_infos()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.bitarray_;
}

void ModeInfo_Multi::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModeInfo_Multi::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.ModeInfo.Multi)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_mode_infos()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.bitarray_ != nullptr);
    _impl_.bitarray_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModeInfo_Multi::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.crypto.multisig.v1beta1.CompactBitArray bitarray = 1 [json_name = "bitarray"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_bitarray(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .cosmos.tx.v1beta1.ModeInfo mode_infos = 2 [json_name = "modeInfos"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mode_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ModeInfo_Multi::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.ModeInfo.Multi)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.crypto.multisig.v1beta1.CompactBitArray bitarray = 1 [json_name = "bitarray"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::bitarray(this),
        _Internal::bitarray(this).GetCachedSize(), target, stream);
  }

  // repeated .cosmos.tx.v1beta1.ModeInfo mode_infos = 2 [json_name = "modeInfos"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mode_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_mode_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.ModeInfo.Multi)
  return target;
}

::size_t ModeInfo_Multi::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.ModeInfo.Multi)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.tx.v1beta1.ModeInfo mode_infos = 2 [json_name = "modeInfos"];
  total_size += 1UL * this->_internal_mode_infos_size();
  for (const auto& msg : this->_internal_mode_infos()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .cosmos.crypto.multisig.v1beta1.CompactBitArray bitarray = 1 [json_name = "bitarray"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bitarray_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModeInfo_Multi::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModeInfo_Multi::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModeInfo_Multi::GetClassData() const { return &_class_data_; }


void ModeInfo_Multi::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModeInfo_Multi*>(&to_msg);
  auto& from = static_cast<const ModeInfo_Multi&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.ModeInfo.Multi)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_mode_infos()->MergeFrom(from._internal_mode_infos());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_bitarray()->::cosmos::crypto::multisig::v1beta1::CompactBitArray::MergeFrom(
        from._internal_bitarray());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModeInfo_Multi::CopyFrom(const ModeInfo_Multi& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.ModeInfo.Multi)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModeInfo_Multi::IsInitialized() const {
  return true;
}

void ModeInfo_Multi::InternalSwap(ModeInfo_Multi* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_mode_infos()->InternalSwap(other->_internal_mutable_mode_infos());
  swap(_impl_.bitarray_, other->_impl_.bitarray_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModeInfo_Multi::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[8]);
}
// ===================================================================

class ModeInfo::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::cosmos::tx::v1beta1::ModeInfo, _impl_._oneof_case_);
  static const ::cosmos::tx::v1beta1::ModeInfo_Single& single(const ModeInfo* msg);
  static const ::cosmos::tx::v1beta1::ModeInfo_Multi& multi(const ModeInfo* msg);
};

const ::cosmos::tx::v1beta1::ModeInfo_Single&
ModeInfo::_Internal::single(const ModeInfo* msg) {
  return *msg->_impl_.sum_.single_;
}
const ::cosmos::tx::v1beta1::ModeInfo_Multi&
ModeInfo::_Internal::multi(const ModeInfo* msg) {
  return *msg->_impl_.sum_.multi_;
}
void ModeInfo::set_allocated_single(::cosmos::tx::v1beta1::ModeInfo_Single* single) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sum();
  if (single) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(single);
    if (message_arena != submessage_arena) {
      single = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, single, submessage_arena);
    }
    set_has_single();
    _impl_.sum_.single_ = single;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.tx.v1beta1.ModeInfo.single)
}
void ModeInfo::set_allocated_multi(::cosmos::tx::v1beta1::ModeInfo_Multi* multi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_sum();
  if (multi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multi);
    if (message_arena != submessage_arena) {
      multi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multi, submessage_arena);
    }
    set_has_multi();
    _impl_.sum_.multi_ = multi;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.tx.v1beta1.ModeInfo.multi)
}
ModeInfo::ModeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.ModeInfo)
}
ModeInfo::ModeInfo(const ModeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sum_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_sum();
  switch (from.sum_case()) {
    case kSingle: {
      _this->_internal_mutable_single()->::cosmos::tx::v1beta1::ModeInfo_Single::MergeFrom(
          from._internal_single());
      break;
    }
    case kMulti: {
      _this->_internal_mutable_multi()->::cosmos::tx::v1beta1::ModeInfo_Multi::MergeFrom(
          from._internal_multi());
      break;
    }
    case SUM_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.ModeInfo)
}

inline void ModeInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.sum_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_sum();
}

ModeInfo::~ModeInfo() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.ModeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModeInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_sum()) {
    clear_sum();
  }
}

void ModeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModeInfo::clear_sum() {
// @@protoc_insertion_point(one_of_clear_start:cosmos.tx.v1beta1.ModeInfo)
  switch (sum_case()) {
    case kSingle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sum_.single_;
      }
      break;
    }
    case kMulti: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.sum_.multi_;
      }
      break;
    }
    case SUM_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SUM_NOT_SET;
}


void ModeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.ModeInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_sum();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.tx.v1beta1.ModeInfo.Single single = 1 [json_name = "single"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_single(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.v1beta1.ModeInfo.Multi multi = 2 [json_name = "multi"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_multi(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ModeInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.ModeInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (sum_case()) {
    case kSingle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::single(this),
          _Internal::single(this).GetCachedSize(), target, stream);
      break;
    }
    case kMulti: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::multi(this),
          _Internal::multi(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.ModeInfo)
  return target;
}

::size_t ModeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.ModeInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (sum_case()) {
    // .cosmos.tx.v1beta1.ModeInfo.Single single = 1 [json_name = "single"];
    case kSingle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sum_.single_);
      break;
    }
    // .cosmos.tx.v1beta1.ModeInfo.Multi multi = 2 [json_name = "multi"];
    case kMulti: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sum_.multi_);
      break;
    }
    case SUM_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModeInfo::GetClassData() const { return &_class_data_; }


void ModeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModeInfo*>(&to_msg);
  auto& from = static_cast<const ModeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.ModeInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.sum_case()) {
    case kSingle: {
      _this->_internal_mutable_single()->::cosmos::tx::v1beta1::ModeInfo_Single::MergeFrom(
          from._internal_single());
      break;
    }
    case kMulti: {
      _this->_internal_mutable_multi()->::cosmos::tx::v1beta1::ModeInfo_Multi::MergeFrom(
          from._internal_multi());
      break;
    }
    case SUM_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModeInfo::CopyFrom(const ModeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.ModeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModeInfo::IsInitialized() const {
  return true;
}

void ModeInfo::InternalSwap(ModeInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.sum_, other->_impl_.sum_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModeInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[9]);
}
// ===================================================================

class Fee::_Internal {
 public:
};

void Fee::clear_amount() {
  _internal_mutable_amount()->Clear();
}
Fee::Fee(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.Fee)
}
Fee::Fee(const Fee& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Fee* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.amount_){from._impl_.amount_}
    , decltype(_impl_.payer_) {}

    , decltype(_impl_.granter_) {}

    , decltype(_impl_.gas_limit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.payer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payer().empty()) {
    _this->_impl_.payer_.Set(from._internal_payer(), _this->GetArenaForAllocation());
  }
  _impl_.granter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.granter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_granter().empty()) {
    _this->_impl_.granter_.Set(from._internal_granter(), _this->GetArenaForAllocation());
  }
  _this->_impl_.gas_limit_ = from._impl_.gas_limit_;
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.Fee)
}

inline void Fee::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.amount_){arena}
    , decltype(_impl_.payer_) {}

    , decltype(_impl_.granter_) {}

    , decltype(_impl_.gas_limit_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.payer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.granter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.granter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fee::~Fee() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.Fee)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fee::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_amount()->~RepeatedPtrField();
  _impl_.payer_.Destroy();
  _impl_.granter_.Destroy();
}

void Fee::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fee::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.Fee)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_amount()->Clear();
  _impl_.payer_.ClearToEmpty();
  _impl_.granter_.ClearToEmpty();
  _impl_.gas_limit_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fee::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cosmos.base.v1beta1.Coin amount = 1 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_amount(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 gas_limit = 2 [json_name = "gasLimit"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.gas_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string payer = 3 [json_name = "payer", (.cosmos_proto.scalar) = "cosmos.AddressString"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_payer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "cosmos.tx.v1beta1.Fee.payer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string granter = 4 [json_name = "granter", (.cosmos_proto.scalar) = "cosmos.AddressString"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_granter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "cosmos.tx.v1beta1.Fee.granter"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Fee::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.Fee)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin amount = 1 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_amount_size()); i < n; i++) {
    const auto& repfield = this->_internal_amount(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint64 gas_limit = 2 [json_name = "gasLimit"];
  if (this->_internal_gas_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_gas_limit(), target);
  }

  // string payer = 3 [json_name = "payer", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_payer().empty()) {
    const std::string& _s = this->_internal_payer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "cosmos.tx.v1beta1.Fee.payer");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string granter = 4 [json_name = "granter", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_granter().empty()) {
    const std::string& _s = this->_internal_granter();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "cosmos.tx.v1beta1.Fee.granter");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.Fee)
  return target;
}

::size_t Fee::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.Fee)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin amount = 1 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  total_size += 1UL * this->_internal_amount_size();
  for (const auto& msg : this->_internal_amount()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string payer = 3 [json_name = "payer", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_payer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_payer());
  }

  // string granter = 4 [json_name = "granter", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_granter().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_granter());
  }

  // uint64 gas_limit = 2 [json_name = "gasLimit"];
  if (this->_internal_gas_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_gas_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fee::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Fee::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fee::GetClassData() const { return &_class_data_; }


void Fee::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Fee*>(&to_msg);
  auto& from = static_cast<const Fee&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.Fee)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_amount()->MergeFrom(from._internal_amount());
  if (!from._internal_payer().empty()) {
    _this->_internal_set_payer(from._internal_payer());
  }
  if (!from._internal_granter().empty()) {
    _this->_internal_set_granter(from._internal_granter());
  }
  if (from._internal_gas_limit() != 0) {
    _this->_internal_set_gas_limit(from._internal_gas_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fee::CopyFrom(const Fee& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.Fee)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fee::IsInitialized() const {
  return true;
}

void Fee::InternalSwap(Fee* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_amount()->InternalSwap(other->_internal_mutable_amount());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payer_, lhs_arena,
                                       &other->_impl_.payer_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.granter_, lhs_arena,
                                       &other->_impl_.granter_, rhs_arena);

  swap(_impl_.gas_limit_, other->_impl_.gas_limit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Fee::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[10]);
}
// ===================================================================

class Tip::_Internal {
 public:
};

void Tip::clear_amount() {
  _internal_mutable_amount()->Clear();
}
Tip::Tip(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.Tip)
}
Tip::Tip(const Tip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.amount_){from._impl_.amount_}
    , decltype(_impl_.tipper_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tipper_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.tipper_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tipper().empty()) {
    _this->_impl_.tipper_.Set(from._internal_tipper(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.Tip)
}

inline void Tip::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.amount_){arena}
    , decltype(_impl_.tipper_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.tipper_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.tipper_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Tip::~Tip() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.Tip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tip::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_amount()->~RepeatedPtrField();
  _impl_.tipper_.Destroy();
}

void Tip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tip::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.Tip)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_amount()->Clear();
  _impl_.tipper_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cosmos.base.v1beta1.Coin amount = 1 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_amount(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string tipper = 2 [json_name = "tipper", (.cosmos_proto.scalar) = "cosmos.AddressString"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tipper();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "cosmos.tx.v1beta1.Tip.tipper"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Tip::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.Tip)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin amount = 1 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_amount_size()); i < n; i++) {
    const auto& repfield = this->_internal_amount(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string tipper = 2 [json_name = "tipper", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_tipper().empty()) {
    const std::string& _s = this->_internal_tipper();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "cosmos.tx.v1beta1.Tip.tipper");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.Tip)
  return target;
}

::size_t Tip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.Tip)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin amount = 1 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  total_size += 1UL * this->_internal_amount_size();
  for (const auto& msg : this->_internal_amount()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string tipper = 2 [json_name = "tipper", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_tipper().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_tipper());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tip::GetClassData() const { return &_class_data_; }


void Tip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tip*>(&to_msg);
  auto& from = static_cast<const Tip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.Tip)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_amount()->MergeFrom(from._internal_amount());
  if (!from._internal_tipper().empty()) {
    _this->_internal_set_tipper(from._internal_tipper());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tip::CopyFrom(const Tip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.Tip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tip::IsInitialized() const {
  return true;
}

void Tip::InternalSwap(Tip* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_amount()->InternalSwap(other->_internal_mutable_amount());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.tipper_, lhs_arena,
                                       &other->_impl_.tipper_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Tip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[11]);
}
// ===================================================================

class AuxSignerData::_Internal {
 public:
  using HasBits = decltype(std::declval<AuxSignerData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuxSignerData, _impl_._has_bits_);
  static const ::cosmos::tx::v1beta1::SignDocDirectAux& sign_doc(const AuxSignerData* msg);
  static void set_has_sign_doc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::tx::v1beta1::SignDocDirectAux&
AuxSignerData::_Internal::sign_doc(const AuxSignerData* msg) {
  return *msg->_impl_.sign_doc_;
}
AuxSignerData::AuxSignerData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.tx.v1beta1.AuxSignerData)
}
AuxSignerData::AuxSignerData(const AuxSignerData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuxSignerData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_) {}

    , decltype(_impl_.sig_) {}

    , decltype(_impl_.sign_doc_){nullptr}
    , decltype(_impl_.mode_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), _this->GetArenaForAllocation());
  }
  _impl_.sig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sig_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sig().empty()) {
    _this->_impl_.sig_.Set(from._internal_sig(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.sign_doc_ = new ::cosmos::tx::v1beta1::SignDocDirectAux(*from._impl_.sign_doc_);
  }
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:cosmos.tx.v1beta1.AuxSignerData)
}

inline void AuxSignerData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_) {}

    , decltype(_impl_.sig_) {}

    , decltype(_impl_.sign_doc_){nullptr}
    , decltype(_impl_.mode_) { 0 }

  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sig_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuxSignerData::~AuxSignerData() {
  // @@protoc_insertion_point(destructor:cosmos.tx.v1beta1.AuxSignerData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuxSignerData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
  _impl_.sig_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sign_doc_;
}

void AuxSignerData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuxSignerData::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.tx.v1beta1.AuxSignerData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  _impl_.sig_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.sign_doc_ != nullptr);
    _impl_.sign_doc_->Clear();
  }
  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuxSignerData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string address = 1 [json_name = "address", (.cosmos_proto.scalar) = "cosmos.AddressString"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "cosmos.tx.v1beta1.AuxSignerData.address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.v1beta1.SignDocDirectAux sign_doc = 2 [json_name = "signDoc"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign_doc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.tx.signing.v1beta1.SignMode mode = 3 [json_name = "mode"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::cosmos::tx::signing::v1beta1::SignMode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes sig = 4 [json_name = "sig"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_sig();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AuxSignerData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cosmos.tx.v1beta1.AuxSignerData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1 [json_name = "address", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_address().empty()) {
    const std::string& _s = this->_internal_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "cosmos.tx.v1beta1.AuxSignerData.address");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.tx.v1beta1.SignDocDirectAux sign_doc = 2 [json_name = "signDoc"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sign_doc(this),
        _Internal::sign_doc(this).GetCachedSize(), target, stream);
  }

  // .cosmos.tx.signing.v1beta1.SignMode mode = 3 [json_name = "mode"];
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_mode(), target);
  }

  // bytes sig = 4 [json_name = "sig"];
  if (!this->_internal_sig().empty()) {
    const std::string& _s = this->_internal_sig();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cosmos.tx.v1beta1.AuxSignerData)
  return target;
}

::size_t AuxSignerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cosmos.tx.v1beta1.AuxSignerData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 1 [json_name = "address", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  if (!this->_internal_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_address());
  }

  // bytes sig = 4 [json_name = "sig"];
  if (!this->_internal_sig().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_sig());
  }

  // .cosmos.tx.v1beta1.SignDocDirectAux sign_doc = 2 [json_name = "signDoc"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sign_doc_);
  }

  // .cosmos.tx.signing.v1beta1.SignMode mode = 3 [json_name = "mode"];
  if (this->_internal_mode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuxSignerData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuxSignerData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuxSignerData::GetClassData() const { return &_class_data_; }


void AuxSignerData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuxSignerData*>(&to_msg);
  auto& from = static_cast<const AuxSignerData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.tx.v1beta1.AuxSignerData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (!from._internal_sig().empty()) {
    _this->_internal_set_sig(from._internal_sig());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_sign_doc()->::cosmos::tx::v1beta1::SignDocDirectAux::MergeFrom(
        from._internal_sign_doc());
  }
  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuxSignerData::CopyFrom(const AuxSignerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.tx.v1beta1.AuxSignerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuxSignerData::IsInitialized() const {
  return true;
}

void AuxSignerData::InternalSwap(AuxSignerData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, lhs_arena,
                                       &other->_impl_.address_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.sig_, lhs_arena,
                                       &other->_impl_.sig_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AuxSignerData, _impl_.mode_)
      + sizeof(AuxSignerData::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(AuxSignerData, _impl_.sign_doc_)>(
          reinterpret_cast<char*>(&_impl_.sign_doc_),
          reinterpret_cast<char*>(&other->_impl_.sign_doc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AuxSignerData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_getter, &descriptor_table_cosmos_2ftx_2fv1beta1_2ftx_2eproto_once,
      file_level_metadata_cosmos_2ftx_2fv1beta1_2ftx_2eproto[12]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace tx
}  // namespace cosmos
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::Tx*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::Tx >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::Tx >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::TxRaw*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::TxRaw >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::TxRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::SignDoc*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::SignDoc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::SignDoc >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::SignDocDirectAux*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::SignDocDirectAux >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::SignDocDirectAux >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::TxBody*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::TxBody >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::TxBody >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::AuthInfo*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::AuthInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::AuthInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::SignerInfo*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::SignerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::SignerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::ModeInfo_Single*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::ModeInfo_Single >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::ModeInfo_Single >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::ModeInfo_Multi*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::ModeInfo_Multi >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::ModeInfo_Multi >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::ModeInfo*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::ModeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::ModeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::Fee*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::Fee >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::Fee >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::Tip*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::Tip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::Tip >(arena);
}
template<> PROTOBUF_NOINLINE ::cosmos::tx::v1beta1::AuxSignerData*
Arena::CreateMaybeMessage< ::cosmos::tx::v1beta1::AuxSignerData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cosmos::tx::v1beta1::AuxSignerData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
