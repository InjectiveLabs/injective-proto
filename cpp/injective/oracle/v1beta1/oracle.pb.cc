// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/oracle/v1beta1/oracle.proto

#include "injective/oracle/v1beta1/oracle.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace injective {
namespace oracle {
namespace v1beta1 {
template <typename>
PROTOBUF_CONSTEXPR Params::Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pyth_contract_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParamsDefaultTypeInternal() {}
  union {
    Params _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParamsDefaultTypeInternal _Params_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OracleInfo::OracleInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.symbol_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_type_)*/ 0

  , /*decltype(_impl_.scale_factor_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OracleInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OracleInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OracleInfoDefaultTypeInternal() {}
  union {
    OracleInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OracleInfoDefaultTypeInternal _OracleInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ChainlinkPriceState::ChainlinkPriceState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.feed_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.answer_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_state_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::uint64_t{0u}
} {}
struct ChainlinkPriceStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChainlinkPriceStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChainlinkPriceStateDefaultTypeInternal() {}
  union {
    ChainlinkPriceState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChainlinkPriceStateDefaultTypeInternal _ChainlinkPriceState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BandPriceState::BandPriceState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.symbol_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_state_)*/nullptr
  , /*decltype(_impl_.resolve_time_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.request_id_)*/ ::uint64_t{0u}
} {}
struct BandPriceStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandPriceStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandPriceStateDefaultTypeInternal() {}
  union {
    BandPriceState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandPriceStateDefaultTypeInternal _BandPriceState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceFeedState::PriceFeedState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.relayers_)*/{}
  , /*decltype(_impl_.base_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quote_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_state_)*/nullptr} {}
struct PriceFeedStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceFeedStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceFeedStateDefaultTypeInternal() {}
  union {
    PriceFeedState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceFeedStateDefaultTypeInternal _PriceFeedState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ProviderInfo::ProviderInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.relayers_)*/{}
  , /*decltype(_impl_.provider_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProviderInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProviderInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProviderInfoDefaultTypeInternal() {}
  union {
    ProviderInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProviderInfoDefaultTypeInternal _ProviderInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ProviderState::ProviderState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.provider_price_states_)*/{}
  , /*decltype(_impl_.provider_info_)*/nullptr} {}
struct ProviderStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProviderStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProviderStateDefaultTypeInternal() {}
  union {
    ProviderState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProviderStateDefaultTypeInternal _ProviderState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ProviderPriceState::ProviderPriceState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.symbol_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.state_)*/nullptr} {}
struct ProviderPriceStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProviderPriceStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProviderPriceStateDefaultTypeInternal() {}
  union {
    ProviderPriceState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProviderPriceStateDefaultTypeInternal _ProviderPriceState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceFeedInfo::PriceFeedInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.base_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quote_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceFeedInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceFeedInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceFeedInfoDefaultTypeInternal() {}
  union {
    PriceFeedInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceFeedInfoDefaultTypeInternal _PriceFeedInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceFeedPrice::PriceFeedPrice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceFeedPriceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceFeedPriceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceFeedPriceDefaultTypeInternal() {}
  union {
    PriceFeedPrice _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceFeedPriceDefaultTypeInternal _PriceFeedPrice_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CoinbasePriceState::CoinbasePriceState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.kind_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_state_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.value_)*/ ::uint64_t{0u}
} {}
struct CoinbasePriceStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoinbasePriceStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoinbasePriceStateDefaultTypeInternal() {}
  union {
    CoinbasePriceState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoinbasePriceStateDefaultTypeInternal _CoinbasePriceState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceState::PriceState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.cumulative_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceStateDefaultTypeInternal() {}
  union {
    PriceState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceStateDefaultTypeInternal _PriceState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PythPriceState::PythPriceState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.price_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ema_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ema_conf_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.conf_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_state_)*/nullptr
  , /*decltype(_impl_.publish_time_)*/ ::uint64_t{0u}
} {}
struct PythPriceStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PythPriceStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PythPriceStateDefaultTypeInternal() {}
  union {
    PythPriceState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PythPriceStateDefaultTypeInternal _PythPriceState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BandOracleRequest::BandOracleRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.symbols_)*/{}
  , /*decltype(_impl_.fee_limit_)*/{}
  , /*decltype(_impl_.request_id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.oracle_script_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.ask_count_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.min_count_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.prepare_gas_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.execute_gas_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.min_source_count_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BandOracleRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandOracleRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandOracleRequestDefaultTypeInternal() {}
  union {
    BandOracleRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandOracleRequestDefaultTypeInternal _BandOracleRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BandIBCParams::BandIBCParams(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.legacy_oracle_ids_)*/ {}
  ,/* _impl_._legacy_oracle_ids_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.ibc_source_channel_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ibc_version_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ibc_port_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.ibc_request_interval_)*/ ::int64_t{0}

  , /*decltype(_impl_.band_ibc_enabled_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BandIBCParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandIBCParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandIBCParamsDefaultTypeInternal() {}
  union {
    BandIBCParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandIBCParamsDefaultTypeInternal _BandIBCParams_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SymbolPriceTimestamp::SymbolPriceTimestamp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.symbol_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.oracle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SymbolPriceTimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SymbolPriceTimestampDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SymbolPriceTimestampDefaultTypeInternal() {}
  union {
    SymbolPriceTimestamp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SymbolPriceTimestampDefaultTypeInternal _SymbolPriceTimestamp_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LastPriceTimestamps::LastPriceTimestamps(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.last_price_timestamps_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LastPriceTimestampsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LastPriceTimestampsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LastPriceTimestampsDefaultTypeInternal() {}
  union {
    LastPriceTimestamps _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LastPriceTimestampsDefaultTypeInternal _LastPriceTimestamps_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceRecords::PriceRecords(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.latest_price_records_)*/{}
  , /*decltype(_impl_.symbol_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceRecordsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceRecordsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceRecordsDefaultTypeInternal() {}
  union {
    PriceRecords _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceRecordsDefaultTypeInternal _PriceRecords_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceRecord::PriceRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceRecordDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceRecordDefaultTypeInternal() {}
  union {
    PriceRecord _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceRecordDefaultTypeInternal _PriceRecord_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MetadataStatistics::MetadataStatistics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mean_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.twap_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.max_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.median_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.group_count_)*/ 0u

  , /*decltype(_impl_.records_sample_size_)*/ 0u

  , /*decltype(_impl_.first_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.last_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MetadataStatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MetadataStatisticsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MetadataStatisticsDefaultTypeInternal() {}
  union {
    MetadataStatistics _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MetadataStatisticsDefaultTypeInternal _MetadataStatistics_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PriceAttestation::PriceAttestation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_)*/ ::int64_t{0}

  , /*decltype(_impl_.conf_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ema_price_)*/ ::int64_t{0}

  , /*decltype(_impl_.expo_)*/ 0

  , /*decltype(_impl_.ema_expo_)*/ 0

  , /*decltype(_impl_.ema_conf_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.publish_time_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PriceAttestationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PriceAttestationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PriceAttestationDefaultTypeInternal() {}
  union {
    PriceAttestation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PriceAttestationDefaultTypeInternal _PriceAttestation_default_instance_;
}  // namespace v1beta1
}  // namespace oracle
}  // namespace injective
static ::_pb::Metadata file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[21];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_injective_2foracle_2fv1beta1_2foracle_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_injective_2foracle_2fv1beta1_2foracle_2eproto = nullptr;
const ::uint32_t TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::Params, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::Params, _impl_.pyth_contract_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::OracleInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::OracleInfo, _impl_.symbol_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::OracleInfo, _impl_.oracle_type_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::OracleInfo, _impl_.scale_factor_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ChainlinkPriceState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ChainlinkPriceState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ChainlinkPriceState, _impl_.feed_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ChainlinkPriceState, _impl_.answer_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ChainlinkPriceState, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ChainlinkPriceState, _impl_.price_state_),
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandPriceState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandPriceState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandPriceState, _impl_.symbol_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandPriceState, _impl_.rate_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandPriceState, _impl_.resolve_time_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandPriceState, _impl_.request_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandPriceState, _impl_.price_state_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedState, _impl_.base_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedState, _impl_.quote_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedState, _impl_.price_state_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedState, _impl_.relayers_),
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderInfo, _impl_.provider_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderInfo, _impl_.relayers_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderState, _impl_.provider_info_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderState, _impl_.provider_price_states_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderPriceState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderPriceState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderPriceState, _impl_.symbol_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::ProviderPriceState, _impl_.state_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedInfo, _impl_.base_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedInfo, _impl_.quote_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedPrice, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceFeedPrice, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::CoinbasePriceState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::CoinbasePriceState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::CoinbasePriceState, _impl_.kind_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::CoinbasePriceState, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::CoinbasePriceState, _impl_.key_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::CoinbasePriceState, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::CoinbasePriceState, _impl_.price_state_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceState, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceState, _impl_.cumulative_price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceState, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _impl_.price_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _impl_.ema_price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _impl_.ema_conf_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _impl_.conf_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _impl_.publish_time_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PythPriceState, _impl_.price_state_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.request_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.oracle_script_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.symbols_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.ask_count_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.min_count_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.fee_limit_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.prepare_gas_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.execute_gas_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandOracleRequest, _impl_.min_source_count_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandIBCParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandIBCParams, _impl_.band_ibc_enabled_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandIBCParams, _impl_.ibc_request_interval_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandIBCParams, _impl_.ibc_source_channel_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandIBCParams, _impl_.ibc_version_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandIBCParams, _impl_.ibc_port_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::BandIBCParams, _impl_.legacy_oracle_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::SymbolPriceTimestamp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::SymbolPriceTimestamp, _impl_.oracle_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::SymbolPriceTimestamp, _impl_.symbol_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::SymbolPriceTimestamp, _impl_.timestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::LastPriceTimestamps, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::LastPriceTimestamps, _impl_.last_price_timestamps_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceRecords, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceRecords, _impl_.oracle_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceRecords, _impl_.symbol_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceRecords, _impl_.latest_price_records_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceRecord, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceRecord, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceRecord, _impl_.price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.group_count_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.records_sample_size_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.mean_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.twap_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.first_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.last_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.min_price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.max_price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::MetadataStatistics, _impl_.median_price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.price_id_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.conf_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.expo_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.ema_price_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.ema_conf_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.ema_expo_),
    PROTOBUF_FIELD_OFFSET(::injective::oracle::v1beta1::PriceAttestation, _impl_.publish_time_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::injective::oracle::v1beta1::Params)},
        { 9, -1, -1, sizeof(::injective::oracle::v1beta1::OracleInfo)},
        { 20, 32, -1, sizeof(::injective::oracle::v1beta1::ChainlinkPriceState)},
        { 36, 49, -1, sizeof(::injective::oracle::v1beta1::BandPriceState)},
        { 54, 66, -1, sizeof(::injective::oracle::v1beta1::PriceFeedState)},
        { 70, -1, -1, sizeof(::injective::oracle::v1beta1::ProviderInfo)},
        { 80, 90, -1, sizeof(::injective::oracle::v1beta1::ProviderState)},
        { 92, 102, -1, sizeof(::injective::oracle::v1beta1::ProviderPriceState)},
        { 104, -1, -1, sizeof(::injective::oracle::v1beta1::PriceFeedInfo)},
        { 114, -1, -1, sizeof(::injective::oracle::v1beta1::PriceFeedPrice)},
        { 123, 136, -1, sizeof(::injective::oracle::v1beta1::CoinbasePriceState)},
        { 141, -1, -1, sizeof(::injective::oracle::v1beta1::PriceState)},
        { 152, 166, -1, sizeof(::injective::oracle::v1beta1::PythPriceState)},
        { 172, -1, -1, sizeof(::injective::oracle::v1beta1::BandOracleRequest)},
        { 189, -1, -1, sizeof(::injective::oracle::v1beta1::BandIBCParams)},
        { 203, -1, -1, sizeof(::injective::oracle::v1beta1::SymbolPriceTimestamp)},
        { 214, -1, -1, sizeof(::injective::oracle::v1beta1::LastPriceTimestamps)},
        { 223, -1, -1, sizeof(::injective::oracle::v1beta1::PriceRecords)},
        { 234, -1, -1, sizeof(::injective::oracle::v1beta1::PriceRecord)},
        { 244, -1, -1, sizeof(::injective::oracle::v1beta1::MetadataStatistics)},
        { 261, -1, -1, sizeof(::injective::oracle::v1beta1::PriceAttestation)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::injective::oracle::v1beta1::_Params_default_instance_._instance,
    &::injective::oracle::v1beta1::_OracleInfo_default_instance_._instance,
    &::injective::oracle::v1beta1::_ChainlinkPriceState_default_instance_._instance,
    &::injective::oracle::v1beta1::_BandPriceState_default_instance_._instance,
    &::injective::oracle::v1beta1::_PriceFeedState_default_instance_._instance,
    &::injective::oracle::v1beta1::_ProviderInfo_default_instance_._instance,
    &::injective::oracle::v1beta1::_ProviderState_default_instance_._instance,
    &::injective::oracle::v1beta1::_ProviderPriceState_default_instance_._instance,
    &::injective::oracle::v1beta1::_PriceFeedInfo_default_instance_._instance,
    &::injective::oracle::v1beta1::_PriceFeedPrice_default_instance_._instance,
    &::injective::oracle::v1beta1::_CoinbasePriceState_default_instance_._instance,
    &::injective::oracle::v1beta1::_PriceState_default_instance_._instance,
    &::injective::oracle::v1beta1::_PythPriceState_default_instance_._instance,
    &::injective::oracle::v1beta1::_BandOracleRequest_default_instance_._instance,
    &::injective::oracle::v1beta1::_BandIBCParams_default_instance_._instance,
    &::injective::oracle::v1beta1::_SymbolPriceTimestamp_default_instance_._instance,
    &::injective::oracle::v1beta1::_LastPriceTimestamps_default_instance_._instance,
    &::injective::oracle::v1beta1::_PriceRecords_default_instance_._instance,
    &::injective::oracle::v1beta1::_PriceRecord_default_instance_._instance,
    &::injective::oracle::v1beta1::_MetadataStatistics_default_instance_._instance,
    &::injective::oracle::v1beta1::_PriceAttestation_default_instance_._instance,
};
const char descriptor_table_protodef_injective_2foracle_2fv1beta1_2foracle_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n%injective/oracle/v1beta1/oracle.proto\022"
    "\030injective.oracle.v1beta1\032\024gogoproto/gog"
    "o.proto\032\036cosmos/base/v1beta1/coin.proto\""
    "3\n\006Params\022#\n\rpyth_contract\030\001 \001(\tR\014pythCo"
    "ntract:\004\350\240\037\001\"\216\001\n\nOracleInfo\022\026\n\006symbol\030\001 "
    "\001(\tR\006symbol\022E\n\013oracle_type\030\002 \001(\0162$.injec"
    "tive.oracle.v1beta1.OracleTypeR\noracleTy"
    "pe\022!\n\014scale_factor\030\003 \001(\rR\013scaleFactor\"\341\001"
    "\n\023ChainlinkPriceState\022\027\n\007feed_id\030\001 \001(\tR\006"
    "feedId\022F\n\006answer\030\002 \001(\tB.\310\336\037\000\332\336\037&github.c"
    "om/cosmos/cosmos-sdk/types.DecR\006answer\022\034"
    "\n\ttimestamp\030\003 \001(\004R\ttimestamp\022K\n\013price_st"
    "ate\030\004 \001(\0132$.injective.oracle.v1beta1.Pri"
    "ceStateB\004\310\336\037\000R\npriceState\"\373\001\n\016BandPriceS"
    "tate\022\026\n\006symbol\030\001 \001(\tR\006symbol\022B\n\004rate\030\002 \001"
    "(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk"
    "/types.IntR\004rate\022!\n\014resolve_time\030\003 \001(\004R\013"
    "resolveTime\022\035\n\nrequest_ID\030\004 \001(\004R\trequest"
    "ID\022K\n\013price_state\030\005 \001(\0132$.injective.orac"
    "le.v1beta1.PriceStateB\004\310\336\037\000R\npriceState\""
    "\235\001\n\016PriceFeedState\022\022\n\004base\030\001 \001(\tR\004base\022\024"
    "\n\005quote\030\002 \001(\tR\005quote\022E\n\013price_state\030\003 \001("
    "\0132$.injective.oracle.v1beta1.PriceStateR"
    "\npriceState\022\032\n\010relayers\030\004 \003(\tR\010relayers\""
    "F\n\014ProviderInfo\022\032\n\010provider\030\001 \001(\tR\010provi"
    "der\022\032\n\010relayers\030\002 \003(\tR\010relayers\"\276\001\n\rProv"
    "iderState\022K\n\rprovider_info\030\001 \001(\0132&.injec"
    "tive.oracle.v1beta1.ProviderInfoR\014provid"
    "erInfo\022`\n\025provider_price_states\030\002 \003(\0132,."
    "injective.oracle.v1beta1.ProviderPriceSt"
    "ateR\023providerPriceStates\"h\n\022ProviderPric"
    "eState\022\026\n\006symbol\030\001 \001(\tR\006symbol\022:\n\005state\030"
    "\002 \001(\0132$.injective.oracle.v1beta1.PriceSt"
    "ateR\005state\"9\n\rPriceFeedInfo\022\022\n\004base\030\001 \001("
    "\tR\004base\022\024\n\005quote\030\002 \001(\tR\005quote\"V\n\016PriceFe"
    "edPrice\022D\n\005price\030\001 \001(\tB.\310\336\037\000\332\336\037&github.c"
    "om/cosmos/cosmos-sdk/types.DecR\005price\"\273\001"
    "\n\022CoinbasePriceState\022\022\n\004kind\030\001 \001(\tR\004kind"
    "\022\034\n\ttimestamp\030\002 \001(\004R\ttimestamp\022\020\n\003key\030\003 "
    "\001(\tR\003key\022\024\n\005value\030\004 \001(\004R\005value\022K\n\013price_"
    "state\030\005 \001(\0132$.injective.oracle.v1beta1.P"
    "riceStateB\004\310\336\037\000R\npriceState\"\313\001\n\nPriceSta"
    "te\022D\n\005price\030\001 \001(\tB.\310\336\037\000\332\336\037&github.com/co"
    "smos/cosmos-sdk/types.DecR\005price\022Y\n\020cumu"
    "lative_price\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/c"
    "osmos/cosmos-sdk/types.DecR\017cumulativePr"
    "ice\022\034\n\ttimestamp\030\003 \001(\003R\ttimestamp\"\367\002\n\016Py"
    "thPriceState\022\031\n\010price_id\030\001 \001(\tR\007priceId\022"
    "K\n\tema_price\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/c"
    "osmos/cosmos-sdk/types.DecR\010emaPrice\022I\n\010"
    "ema_conf\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmo"
    "s/cosmos-sdk/types.DecR\007emaConf\022B\n\004conf\030"
    "\004 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-"
    "sdk/types.DecR\004conf\022!\n\014publish_time\030\005 \001("
    "\004R\013publishTime\022K\n\013price_state\030\006 \001(\0132$.in"
    "jective.oracle.v1beta1.PriceStateB\004\310\336\037\000R"
    "\npriceState\"\206\003\n\021BandOracleRequest\022\035\n\nreq"
    "uest_id\030\001 \001(\004R\trequestId\022(\n\020oracle_scrip"
    "t_id\030\002 \001(\003R\016oracleScriptId\022\030\n\007symbols\030\003 "
    "\003(\tR\007symbols\022\033\n\task_count\030\004 \001(\004R\010askCoun"
    "t\022\033\n\tmin_count\030\005 \001(\004R\010minCount\022h\n\tfee_li"
    "mit\030\006 \003(\0132\031.cosmos.base.v1beta1.CoinB0\310\336"
    "\037\000\252\337\037(github.com/cosmos/cosmos-sdk/types"
    ".CoinsR\010feeLimit\022\037\n\013prepare_gas\030\007 \001(\004R\np"
    "repareGas\022\037\n\013execute_gas\030\010 \001(\004R\nexecuteG"
    "as\022(\n\020min_source_count\030\t \001(\004R\016minSourceC"
    "ount\"\206\002\n\rBandIBCParams\022(\n\020band_ibc_enabl"
    "ed\030\001 \001(\010R\016bandIbcEnabled\0220\n\024ibc_request_"
    "interval\030\002 \001(\003R\022ibcRequestInterval\022,\n\022ib"
    "c_source_channel\030\003 \001(\tR\020ibcSourceChannel"
    "\022\037\n\013ibc_version\030\004 \001(\tR\nibcVersion\022\036\n\013ibc"
    "_port_id\030\005 \001(\tR\tibcPortId\022*\n\021legacy_orac"
    "le_ids\030\006 \003(\003R\017legacyOracleIds\"\217\001\n\024Symbol"
    "PriceTimestamp\022<\n\006oracle\030\001 \001(\0162$.injecti"
    "ve.oracle.v1beta1.OracleTypeR\006oracle\022\033\n\t"
    "symbol_id\030\002 \001(\tR\010symbolId\022\034\n\ttimestamp\030\003"
    " \001(\003R\ttimestamp\"y\n\023LastPriceTimestamps\022b"
    "\n\025last_price_timestamps\030\001 \003(\0132..injectiv"
    "e.oracle.v1beta1.SymbolPriceTimestampR\023l"
    "astPriceTimestamps\"\302\001\n\014PriceRecords\022<\n\006o"
    "racle\030\001 \001(\0162$.injective.oracle.v1beta1.O"
    "racleTypeR\006oracle\022\033\n\tsymbol_id\030\002 \001(\tR\010sy"
    "mbolId\022W\n\024latest_price_records\030\003 \003(\0132%.i"
    "njective.oracle.v1beta1.PriceRecordR\022lat"
    "estPriceRecords\"q\n\013PriceRecord\022\034\n\ttimest"
    "amp\030\001 \001(\003R\ttimestamp\022D\n\005price\030\002 \001(\tB.\310\336\037"
    "\000\332\336\037&github.com/cosmos/cosmos-sdk/types."
    "DecR\005price\"\252\004\n\022MetadataStatistics\022\037\n\013gro"
    "up_count\030\001 \001(\rR\ngroupCount\022.\n\023records_sa"
    "mple_size\030\002 \001(\rR\021recordsSampleSize\022B\n\004me"
    "an\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosm"
    "os-sdk/types.DecR\004mean\022B\n\004twap\030\004 \001(\tB.\310\336"
    "\037\000\332\336\037&github.com/cosmos/cosmos-sdk/types"
    ".DecR\004twap\022\'\n\017first_timestamp\030\005 \001(\003R\016fir"
    "stTimestamp\022%\n\016last_timestamp\030\006 \001(\003R\rlas"
    "tTimestamp\022K\n\tmin_price\030\007 \001(\tB.\310\336\037\000\332\336\037&g"
    "ithub.com/cosmos/cosmos-sdk/types.DecR\010m"
    "inPrice\022K\n\tmax_price\030\010 \001(\tB.\310\336\037\000\332\336\037&gith"
    "ub.com/cosmos/cosmos-sdk/types.DecR\010maxP"
    "rice\022Q\n\014median_price\030\t \001(\tB.\310\336\037\000\332\336\037&gith"
    "ub.com/cosmos/cosmos-sdk/types.DecR\013medi"
    "anPrice\"\341\001\n\020PriceAttestation\022\031\n\010price_id"
    "\030\001 \001(\tR\007priceId\022\024\n\005price\030\002 \001(\003R\005price\022\022\n"
    "\004conf\030\003 \001(\004R\004conf\022\022\n\004expo\030\004 \001(\005R\004expo\022\033\n"
    "\tema_price\030\005 \001(\003R\010emaPrice\022\031\n\010ema_conf\030\006"
    " \001(\004R\007emaConf\022\031\n\010ema_expo\030\007 \001(\005R\007emaExpo"
    "\022!\n\014publish_time\030\010 \001(\003R\013publishTime*\237\001\n\n"
    "OracleType\022\017\n\013Unspecified\020\000\022\010\n\004Band\020\001\022\r\n"
    "\tPriceFeed\020\002\022\014\n\010Coinbase\020\003\022\r\n\tChainlink\020"
    "\004\022\t\n\005Razor\020\005\022\007\n\003Dia\020\006\022\010\n\004API3\020\007\022\007\n\003Uma\020\010"
    "\022\010\n\004Pyth\020\t\022\013\n\007BandIBC\020\n\022\014\n\010Provider\020\013B\373\001"
    "\n\034com.injective.oracle.v1beta1B\013OraclePr"
    "otoP\001ZLgithub.com/InjectiveLabs/injectiv"
    "e-core/injective-chain/modules/oracle/ty"
    "pes\242\002\003IOX\252\002\030Injective.Oracle.V1beta1\312\002\030I"
    "njective\\Oracle\\V1beta1\342\002$Injective\\Orac"
    "le\\V1beta1\\GPBMetadata\352\002\032Injective::Orac"
    "le::V1beta1b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_deps[2] =
    {
        &::descriptor_table_cosmos_2fbase_2fv1beta1_2fcoin_2eproto,
        &::descriptor_table_gogoproto_2fgogo_2eproto,
};
static ::absl::once_flag descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto = {
    false,
    false,
    4699,
    descriptor_table_protodef_injective_2foracle_2fv1beta1_2foracle_2eproto,
    "injective/oracle/v1beta1/oracle.proto",
    &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
    descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_deps,
    2,
    21,
    schemas,
    file_default_instances,
    TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto::offsets,
    file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto,
    file_level_enum_descriptors_injective_2foracle_2fv1beta1_2foracle_2eproto,
    file_level_service_descriptors_injective_2foracle_2fv1beta1_2foracle_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter() {
  return &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_injective_2foracle_2fv1beta1_2foracle_2eproto(&descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto);
namespace injective {
namespace oracle {
namespace v1beta1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OracleType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto);
  return file_level_enum_descriptors_injective_2foracle_2fv1beta1_2foracle_2eproto[0];
}
bool OracleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Params::_Internal {
 public:
};

Params::Params(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.Params)
}
Params::Params(const Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pyth_contract_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pyth_contract_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pyth_contract_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pyth_contract().empty()) {
    _this->_impl_.pyth_contract_.Set(from._internal_pyth_contract(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.Params)
}

inline void Params::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.pyth_contract_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pyth_contract_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pyth_contract_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Params::~Params() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Params::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pyth_contract_.Destroy();
}

void Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Params::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.Params)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pyth_contract_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pyth_contract = 1 [json_name = "pythContract"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pyth_contract();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.Params.pyth_contract"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Params::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.Params)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pyth_contract = 1 [json_name = "pythContract"];
  if (!this->_internal_pyth_contract().empty()) {
    const std::string& _s = this->_internal_pyth_contract();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.Params.pyth_contract");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.Params)
  return target;
}

::size_t Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.Params)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pyth_contract = 1 [json_name = "pythContract"];
  if (!this->_internal_pyth_contract().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_pyth_contract());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Params::GetClassData() const { return &_class_data_; }


void Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Params*>(&to_msg);
  auto& from = static_cast<const Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.Params)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pyth_contract().empty()) {
    _this->_internal_set_pyth_contract(from._internal_pyth_contract());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Params::CopyFrom(const Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Params::IsInitialized() const {
  return true;
}

void Params::InternalSwap(Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pyth_contract_, lhs_arena,
                                       &other->_impl_.pyth_contract_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[0]);
}
// ===================================================================

class OracleInfo::_Internal {
 public:
};

OracleInfo::OracleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.OracleInfo)
}
OracleInfo::OracleInfo(const OracleInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OracleInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_) {}

    , decltype(_impl_.oracle_type_) {}

    , decltype(_impl_.scale_factor_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol().empty()) {
    _this->_impl_.symbol_.Set(from._internal_symbol(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.oracle_type_, &from._impl_.oracle_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.scale_factor_) -
    reinterpret_cast<char*>(&_impl_.oracle_type_)) + sizeof(_impl_.scale_factor_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.OracleInfo)
}

inline void OracleInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_) {}

    , decltype(_impl_.oracle_type_) { 0 }

    , decltype(_impl_.scale_factor_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OracleInfo::~OracleInfo() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.OracleInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OracleInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.symbol_.Destroy();
}

void OracleInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OracleInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.OracleInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.symbol_.ClearToEmpty();
  ::memset(&_impl_.oracle_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.scale_factor_) -
      reinterpret_cast<char*>(&_impl_.oracle_type_)) + sizeof(_impl_.scale_factor_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OracleInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string symbol = 1 [json_name = "symbol"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.OracleInfo.symbol"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.OracleType oracle_type = 2 [json_name = "oracleType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_oracle_type(static_cast<::injective::oracle::v1beta1::OracleType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 scale_factor = 3 [json_name = "scaleFactor"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OracleInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.OracleInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string symbol = 1 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    const std::string& _s = this->_internal_symbol();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.OracleInfo.symbol");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .injective.oracle.v1beta1.OracleType oracle_type = 2 [json_name = "oracleType"];
  if (this->_internal_oracle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_oracle_type(), target);
  }

  // uint32 scale_factor = 3 [json_name = "scaleFactor"];
  if (this->_internal_scale_factor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_scale_factor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.OracleInfo)
  return target;
}

::size_t OracleInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.OracleInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string symbol = 1 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_symbol());
  }

  // .injective.oracle.v1beta1.OracleType oracle_type = 2 [json_name = "oracleType"];
  if (this->_internal_oracle_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_oracle_type());
  }

  // uint32 scale_factor = 3 [json_name = "scaleFactor"];
  if (this->_internal_scale_factor() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_scale_factor());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OracleInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OracleInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OracleInfo::GetClassData() const { return &_class_data_; }


void OracleInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OracleInfo*>(&to_msg);
  auto& from = static_cast<const OracleInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.OracleInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_symbol().empty()) {
    _this->_internal_set_symbol(from._internal_symbol());
  }
  if (from._internal_oracle_type() != 0) {
    _this->_internal_set_oracle_type(from._internal_oracle_type());
  }
  if (from._internal_scale_factor() != 0) {
    _this->_internal_set_scale_factor(from._internal_scale_factor());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OracleInfo::CopyFrom(const OracleInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.OracleInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OracleInfo::IsInitialized() const {
  return true;
}

void OracleInfo::InternalSwap(OracleInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.symbol_, lhs_arena,
                                       &other->_impl_.symbol_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OracleInfo, _impl_.scale_factor_)
      + sizeof(OracleInfo::_impl_.scale_factor_)
      - PROTOBUF_FIELD_OFFSET(OracleInfo, _impl_.oracle_type_)>(
          reinterpret_cast<char*>(&_impl_.oracle_type_),
          reinterpret_cast<char*>(&other->_impl_.oracle_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OracleInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[1]);
}
// ===================================================================

class ChainlinkPriceState::_Internal {
 public:
  using HasBits = decltype(std::declval<ChainlinkPriceState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ChainlinkPriceState, _impl_._has_bits_);
  static const ::injective::oracle::v1beta1::PriceState& price_state(const ChainlinkPriceState* msg);
  static void set_has_price_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::oracle::v1beta1::PriceState&
ChainlinkPriceState::_Internal::price_state(const ChainlinkPriceState* msg) {
  return *msg->_impl_.price_state_;
}
ChainlinkPriceState::ChainlinkPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.ChainlinkPriceState)
}
ChainlinkPriceState::ChainlinkPriceState(const ChainlinkPriceState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChainlinkPriceState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feed_id_) {}

    , decltype(_impl_.answer_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_feed_id().empty()) {
    _this->_impl_.feed_id_.Set(from._internal_feed_id(), _this->GetArenaForAllocation());
  }
  _impl_.answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_answer().empty()) {
    _this->_impl_.answer_.Set(from._internal_answer(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.price_state_ = new ::injective::oracle::v1beta1::PriceState(*from._impl_.price_state_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.ChainlinkPriceState)
}

inline void ChainlinkPriceState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feed_id_) {}

    , decltype(_impl_.answer_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.timestamp_) { ::uint64_t{0u} }

  };
  _impl_.feed_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.feed_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.answer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.answer_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChainlinkPriceState::~ChainlinkPriceState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.ChainlinkPriceState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChainlinkPriceState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.feed_id_.Destroy();
  _impl_.answer_.Destroy();
  if (this != internal_default_instance()) delete _impl_.price_state_;
}

void ChainlinkPriceState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChainlinkPriceState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.ChainlinkPriceState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.feed_id_.ClearToEmpty();
  _impl_.answer_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.price_state_ != nullptr);
    _impl_.price_state_->Clear();
  }
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChainlinkPriceState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string feed_id = 1 [json_name = "feedId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_feed_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.ChainlinkPriceState.feed_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string answer = 2 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_answer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.ChainlinkPriceState.answer"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.PriceState price_state = 4 [json_name = "priceState", (.gogoproto.nullable) = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_price_state(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ChainlinkPriceState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.ChainlinkPriceState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    const std::string& _s = this->_internal_feed_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.ChainlinkPriceState.feed_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string answer = 2 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_answer().empty()) {
    const std::string& _s = this->_internal_answer();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.ChainlinkPriceState.answer");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.oracle.v1beta1.PriceState price_state = 4 [json_name = "priceState", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::price_state(this),
        _Internal::price_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.ChainlinkPriceState)
  return target;
}

::size_t ChainlinkPriceState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.ChainlinkPriceState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string feed_id = 1 [json_name = "feedId"];
  if (!this->_internal_feed_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_feed_id());
  }

  // string answer = 2 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_answer().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_answer());
  }

  // .injective.oracle.v1beta1.PriceState price_state = 4 [json_name = "priceState", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.price_state_);
  }

  // uint64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChainlinkPriceState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChainlinkPriceState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChainlinkPriceState::GetClassData() const { return &_class_data_; }


void ChainlinkPriceState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChainlinkPriceState*>(&to_msg);
  auto& from = static_cast<const ChainlinkPriceState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.ChainlinkPriceState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_feed_id().empty()) {
    _this->_internal_set_feed_id(from._internal_feed_id());
  }
  if (!from._internal_answer().empty()) {
    _this->_internal_set_answer(from._internal_answer());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_price_state()->::injective::oracle::v1beta1::PriceState::MergeFrom(
        from._internal_price_state());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChainlinkPriceState::CopyFrom(const ChainlinkPriceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.ChainlinkPriceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChainlinkPriceState::IsInitialized() const {
  return true;
}

void ChainlinkPriceState::InternalSwap(ChainlinkPriceState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.feed_id_, lhs_arena,
                                       &other->_impl_.feed_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.answer_, lhs_arena,
                                       &other->_impl_.answer_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChainlinkPriceState, _impl_.timestamp_)
      + sizeof(ChainlinkPriceState::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(ChainlinkPriceState, _impl_.price_state_)>(
          reinterpret_cast<char*>(&_impl_.price_state_),
          reinterpret_cast<char*>(&other->_impl_.price_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChainlinkPriceState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[2]);
}
// ===================================================================

class BandPriceState::_Internal {
 public:
  using HasBits = decltype(std::declval<BandPriceState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BandPriceState, _impl_._has_bits_);
  static const ::injective::oracle::v1beta1::PriceState& price_state(const BandPriceState* msg);
  static void set_has_price_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::oracle::v1beta1::PriceState&
BandPriceState::_Internal::price_state(const BandPriceState* msg) {
  return *msg->_impl_.price_state_;
}
BandPriceState::BandPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.BandPriceState)
}
BandPriceState::BandPriceState(const BandPriceState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BandPriceState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.symbol_) {}

    , decltype(_impl_.rate_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.resolve_time_) {}

    , decltype(_impl_.request_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol().empty()) {
    _this->_impl_.symbol_.Set(from._internal_symbol(), _this->GetArenaForAllocation());
  }
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_rate().empty()) {
    _this->_impl_.rate_.Set(from._internal_rate(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.price_state_ = new ::injective::oracle::v1beta1::PriceState(*from._impl_.price_state_);
  }
  ::memcpy(&_impl_.resolve_time_, &from._impl_.resolve_time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.request_id_) -
    reinterpret_cast<char*>(&_impl_.resolve_time_)) + sizeof(_impl_.request_id_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.BandPriceState)
}

inline void BandPriceState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.symbol_) {}

    , decltype(_impl_.rate_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.resolve_time_) { ::uint64_t{0u} }

    , decltype(_impl_.request_id_) { ::uint64_t{0u} }

  };
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BandPriceState::~BandPriceState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.BandPriceState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BandPriceState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.symbol_.Destroy();
  _impl_.rate_.Destroy();
  if (this != internal_default_instance()) delete _impl_.price_state_;
}

void BandPriceState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BandPriceState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.BandPriceState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.symbol_.ClearToEmpty();
  _impl_.rate_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.price_state_ != nullptr);
    _impl_.price_state_->Clear();
  }
  ::memset(&_impl_.resolve_time_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.request_id_) -
      reinterpret_cast<char*>(&_impl_.resolve_time_)) + sizeof(_impl_.request_id_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BandPriceState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string symbol = 1 [json_name = "symbol"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.BandPriceState.symbol"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string rate = 2 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.BandPriceState.rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 resolve_time = 3 [json_name = "resolveTime"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.resolve_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 request_ID = 4 [json_name = "requestID"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_price_state(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BandPriceState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.BandPriceState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string symbol = 1 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    const std::string& _s = this->_internal_symbol();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.BandPriceState.symbol");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string rate = 2 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_rate().empty()) {
    const std::string& _s = this->_internal_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.BandPriceState.rate");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // uint64 resolve_time = 3 [json_name = "resolveTime"];
  if (this->_internal_resolve_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_resolve_time(), target);
  }

  // uint64 request_ID = 4 [json_name = "requestID"];
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_request_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::price_state(this),
        _Internal::price_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.BandPriceState)
  return target;
}

::size_t BandPriceState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.BandPriceState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string symbol = 1 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_symbol());
  }

  // string rate = 2 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_rate());
  }

  // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.price_state_);
  }

  // uint64 resolve_time = 3 [json_name = "resolveTime"];
  if (this->_internal_resolve_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_resolve_time());
  }

  // uint64 request_ID = 4 [json_name = "requestID"];
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BandPriceState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BandPriceState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BandPriceState::GetClassData() const { return &_class_data_; }


void BandPriceState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BandPriceState*>(&to_msg);
  auto& from = static_cast<const BandPriceState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.BandPriceState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_symbol().empty()) {
    _this->_internal_set_symbol(from._internal_symbol());
  }
  if (!from._internal_rate().empty()) {
    _this->_internal_set_rate(from._internal_rate());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_price_state()->::injective::oracle::v1beta1::PriceState::MergeFrom(
        from._internal_price_state());
  }
  if (from._internal_resolve_time() != 0) {
    _this->_internal_set_resolve_time(from._internal_resolve_time());
  }
  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BandPriceState::CopyFrom(const BandPriceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.BandPriceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandPriceState::IsInitialized() const {
  return true;
}

void BandPriceState::InternalSwap(BandPriceState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.symbol_, lhs_arena,
                                       &other->_impl_.symbol_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.rate_, lhs_arena,
                                       &other->_impl_.rate_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandPriceState, _impl_.request_id_)
      + sizeof(BandPriceState::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(BandPriceState, _impl_.price_state_)>(
          reinterpret_cast<char*>(&_impl_.price_state_),
          reinterpret_cast<char*>(&other->_impl_.price_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BandPriceState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[3]);
}
// ===================================================================

class PriceFeedState::_Internal {
 public:
  using HasBits = decltype(std::declval<PriceFeedState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PriceFeedState, _impl_._has_bits_);
  static const ::injective::oracle::v1beta1::PriceState& price_state(const PriceFeedState* msg);
  static void set_has_price_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::oracle::v1beta1::PriceState&
PriceFeedState::_Internal::price_state(const PriceFeedState* msg) {
  return *msg->_impl_.price_state_;
}
PriceFeedState::PriceFeedState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PriceFeedState)
}
PriceFeedState::PriceFeedState(const PriceFeedState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceFeedState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relayers_){from._impl_.relayers_}
    , decltype(_impl_.base_) {}

    , decltype(_impl_.quote_) {}

    , decltype(_impl_.price_state_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.base_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base().empty()) {
    _this->_impl_.base_.Set(from._internal_base(), _this->GetArenaForAllocation());
  }
  _impl_.quote_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quote().empty()) {
    _this->_impl_.quote_.Set(from._internal_quote(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.price_state_ = new ::injective::oracle::v1beta1::PriceState(*from._impl_.price_state_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PriceFeedState)
}

inline void PriceFeedState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relayers_){arena}
    , decltype(_impl_.base_) {}

    , decltype(_impl_.quote_) {}

    , decltype(_impl_.price_state_){nullptr}
  };
  _impl_.base_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quote_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceFeedState::~PriceFeedState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PriceFeedState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceFeedState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_relayers()->~RepeatedPtrField();
  _impl_.base_.Destroy();
  _impl_.quote_.Destroy();
  if (this != internal_default_instance()) delete _impl_.price_state_;
}

void PriceFeedState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceFeedState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PriceFeedState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_relayers()->Clear();
  _impl_.base_.ClearToEmpty();
  _impl_.quote_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.price_state_ != nullptr);
    _impl_.price_state_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceFeedState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string base = 1 [json_name = "base"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_base();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceFeedState.base"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quote = 2 [json_name = "quote"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quote();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceFeedState.quote"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.PriceState price_state = 3 [json_name = "priceState"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_price_state(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string relayers = 4 [json_name = "relayers"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_relayers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceFeedState.relayers"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceFeedState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PriceFeedState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string base = 1 [json_name = "base"];
  if (!this->_internal_base().empty()) {
    const std::string& _s = this->_internal_base();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceFeedState.base");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string quote = 2 [json_name = "quote"];
  if (!this->_internal_quote().empty()) {
    const std::string& _s = this->_internal_quote();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceFeedState.quote");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.oracle.v1beta1.PriceState price_state = 3 [json_name = "priceState"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::price_state(this),
        _Internal::price_state(this).GetCachedSize(), target, stream);
  }

  // repeated string relayers = 4 [json_name = "relayers"];
  for (int i = 0, n = this->_internal_relayers_size(); i < n; ++i) {
    const auto& s = this->_internal_relayers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceFeedState.relayers");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PriceFeedState)
  return target;
}

::size_t PriceFeedState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PriceFeedState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string relayers = 4 [json_name = "relayers"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_relayers().size());
  for (int i = 0, n = _internal_relayers().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_relayers().Get(i));
  }

  // string base = 1 [json_name = "base"];
  if (!this->_internal_base().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_base());
  }

  // string quote = 2 [json_name = "quote"];
  if (!this->_internal_quote().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quote());
  }

  // .injective.oracle.v1beta1.PriceState price_state = 3 [json_name = "priceState"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.price_state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceFeedState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceFeedState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceFeedState::GetClassData() const { return &_class_data_; }


void PriceFeedState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceFeedState*>(&to_msg);
  auto& from = static_cast<const PriceFeedState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PriceFeedState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_relayers()->MergeFrom(from._internal_relayers());
  if (!from._internal_base().empty()) {
    _this->_internal_set_base(from._internal_base());
  }
  if (!from._internal_quote().empty()) {
    _this->_internal_set_quote(from._internal_quote());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_price_state()->::injective::oracle::v1beta1::PriceState::MergeFrom(
        from._internal_price_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceFeedState::CopyFrom(const PriceFeedState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PriceFeedState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceFeedState::IsInitialized() const {
  return true;
}

void PriceFeedState::InternalSwap(PriceFeedState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_relayers()->InternalSwap(
      other->_internal_mutable_relayers());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.base_, lhs_arena,
                                       &other->_impl_.base_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quote_, lhs_arena,
                                       &other->_impl_.quote_, rhs_arena);
  swap(_impl_.price_state_, other->_impl_.price_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceFeedState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[4]);
}
// ===================================================================

class ProviderInfo::_Internal {
 public:
};

ProviderInfo::ProviderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.ProviderInfo)
}
ProviderInfo::ProviderInfo(const ProviderInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProviderInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.relayers_){from._impl_.relayers_}
    , decltype(_impl_.provider_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.provider_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_provider().empty()) {
    _this->_impl_.provider_.Set(from._internal_provider(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.ProviderInfo)
}

inline void ProviderInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.relayers_){arena}
    , decltype(_impl_.provider_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.provider_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProviderInfo::~ProviderInfo() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.ProviderInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProviderInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_relayers()->~RepeatedPtrField();
  _impl_.provider_.Destroy();
}

void ProviderInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProviderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.ProviderInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_relayers()->Clear();
  _impl_.provider_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProviderInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string provider = 1 [json_name = "provider"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_provider();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.ProviderInfo.provider"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string relayers = 2 [json_name = "relayers"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_relayers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.ProviderInfo.relayers"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ProviderInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.ProviderInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string provider = 1 [json_name = "provider"];
  if (!this->_internal_provider().empty()) {
    const std::string& _s = this->_internal_provider();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.ProviderInfo.provider");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated string relayers = 2 [json_name = "relayers"];
  for (int i = 0, n = this->_internal_relayers_size(); i < n; ++i) {
    const auto& s = this->_internal_relayers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.ProviderInfo.relayers");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.ProviderInfo)
  return target;
}

::size_t ProviderInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.ProviderInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string relayers = 2 [json_name = "relayers"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_relayers().size());
  for (int i = 0, n = _internal_relayers().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_relayers().Get(i));
  }

  // string provider = 1 [json_name = "provider"];
  if (!this->_internal_provider().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_provider());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProviderInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProviderInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProviderInfo::GetClassData() const { return &_class_data_; }


void ProviderInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProviderInfo*>(&to_msg);
  auto& from = static_cast<const ProviderInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.ProviderInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_relayers()->MergeFrom(from._internal_relayers());
  if (!from._internal_provider().empty()) {
    _this->_internal_set_provider(from._internal_provider());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProviderInfo::CopyFrom(const ProviderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.ProviderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProviderInfo::IsInitialized() const {
  return true;
}

void ProviderInfo::InternalSwap(ProviderInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_relayers()->InternalSwap(
      other->_internal_mutable_relayers());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.provider_, lhs_arena,
                                       &other->_impl_.provider_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProviderInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[5]);
}
// ===================================================================

class ProviderState::_Internal {
 public:
  using HasBits = decltype(std::declval<ProviderState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ProviderState, _impl_._has_bits_);
  static const ::injective::oracle::v1beta1::ProviderInfo& provider_info(const ProviderState* msg);
  static void set_has_provider_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::oracle::v1beta1::ProviderInfo&
ProviderState::_Internal::provider_info(const ProviderState* msg) {
  return *msg->_impl_.provider_info_;
}
ProviderState::ProviderState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.ProviderState)
}
ProviderState::ProviderState(const ProviderState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProviderState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.provider_price_states_){from._impl_.provider_price_states_}
    , decltype(_impl_.provider_info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.provider_info_ = new ::injective::oracle::v1beta1::ProviderInfo(*from._impl_.provider_info_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.ProviderState)
}

inline void ProviderState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.provider_price_states_){arena}
    , decltype(_impl_.provider_info_){nullptr}
  };
}

ProviderState::~ProviderState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.ProviderState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProviderState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_provider_price_states()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.provider_info_;
}

void ProviderState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProviderState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.ProviderState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_provider_price_states()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.provider_info_ != nullptr);
    _impl_.provider_info_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProviderState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.oracle.v1beta1.ProviderInfo provider_info = 1 [json_name = "providerInfo"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_provider_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2 [json_name = "providerPriceStates"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_provider_price_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ProviderState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.ProviderState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.oracle.v1beta1.ProviderInfo provider_info = 1 [json_name = "providerInfo"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::provider_info(this),
        _Internal::provider_info(this).GetCachedSize(), target, stream);
  }

  // repeated .injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2 [json_name = "providerPriceStates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_provider_price_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_provider_price_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.ProviderState)
  return target;
}

::size_t ProviderState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.ProviderState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2 [json_name = "providerPriceStates"];
  total_size += 1UL * this->_internal_provider_price_states_size();
  for (const auto& msg : this->_internal_provider_price_states()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .injective.oracle.v1beta1.ProviderInfo provider_info = 1 [json_name = "providerInfo"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.provider_info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProviderState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProviderState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProviderState::GetClassData() const { return &_class_data_; }


void ProviderState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProviderState*>(&to_msg);
  auto& from = static_cast<const ProviderState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.ProviderState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_provider_price_states()->MergeFrom(from._internal_provider_price_states());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_provider_info()->::injective::oracle::v1beta1::ProviderInfo::MergeFrom(
        from._internal_provider_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProviderState::CopyFrom(const ProviderState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.ProviderState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProviderState::IsInitialized() const {
  return true;
}

void ProviderState::InternalSwap(ProviderState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_provider_price_states()->InternalSwap(other->_internal_mutable_provider_price_states());
  swap(_impl_.provider_info_, other->_impl_.provider_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProviderState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[6]);
}
// ===================================================================

class ProviderPriceState::_Internal {
 public:
  using HasBits = decltype(std::declval<ProviderPriceState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ProviderPriceState, _impl_._has_bits_);
  static const ::injective::oracle::v1beta1::PriceState& state(const ProviderPriceState* msg);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::oracle::v1beta1::PriceState&
ProviderPriceState::_Internal::state(const ProviderPriceState* msg) {
  return *msg->_impl_.state_;
}
ProviderPriceState::ProviderPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.ProviderPriceState)
}
ProviderPriceState::ProviderPriceState(const ProviderPriceState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProviderPriceState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.symbol_) {}

    , decltype(_impl_.state_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol().empty()) {
    _this->_impl_.symbol_.Set(from._internal_symbol(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.state_ = new ::injective::oracle::v1beta1::PriceState(*from._impl_.state_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.ProviderPriceState)
}

inline void ProviderPriceState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.symbol_) {}

    , decltype(_impl_.state_){nullptr}
  };
  _impl_.symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProviderPriceState::~ProviderPriceState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.ProviderPriceState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProviderPriceState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.symbol_.Destroy();
  if (this != internal_default_instance()) delete _impl_.state_;
}

void ProviderPriceState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProviderPriceState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.ProviderPriceState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.symbol_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.state_ != nullptr);
    _impl_.state_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProviderPriceState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string symbol = 1 [json_name = "symbol"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.ProviderPriceState.symbol"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.PriceState state = 2 [json_name = "state"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ProviderPriceState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.ProviderPriceState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string symbol = 1 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    const std::string& _s = this->_internal_symbol();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.ProviderPriceState.symbol");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.oracle.v1beta1.PriceState state = 2 [json_name = "state"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::state(this),
        _Internal::state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.ProviderPriceState)
  return target;
}

::size_t ProviderPriceState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.ProviderPriceState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string symbol = 1 [json_name = "symbol"];
  if (!this->_internal_symbol().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_symbol());
  }

  // .injective.oracle.v1beta1.PriceState state = 2 [json_name = "state"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProviderPriceState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProviderPriceState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProviderPriceState::GetClassData() const { return &_class_data_; }


void ProviderPriceState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProviderPriceState*>(&to_msg);
  auto& from = static_cast<const ProviderPriceState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.ProviderPriceState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_symbol().empty()) {
    _this->_internal_set_symbol(from._internal_symbol());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_state()->::injective::oracle::v1beta1::PriceState::MergeFrom(
        from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProviderPriceState::CopyFrom(const ProviderPriceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.ProviderPriceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProviderPriceState::IsInitialized() const {
  return true;
}

void ProviderPriceState::InternalSwap(ProviderPriceState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.symbol_, lhs_arena,
                                       &other->_impl_.symbol_, rhs_arena);
  swap(_impl_.state_, other->_impl_.state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProviderPriceState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[7]);
}
// ===================================================================

class PriceFeedInfo::_Internal {
 public:
};

PriceFeedInfo::PriceFeedInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PriceFeedInfo)
}
PriceFeedInfo::PriceFeedInfo(const PriceFeedInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceFeedInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.base_) {}

    , decltype(_impl_.quote_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.base_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base().empty()) {
    _this->_impl_.base_.Set(from._internal_base(), _this->GetArenaForAllocation());
  }
  _impl_.quote_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quote().empty()) {
    _this->_impl_.quote_.Set(from._internal_quote(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PriceFeedInfo)
}

inline void PriceFeedInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.base_) {}

    , decltype(_impl_.quote_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.base_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quote_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceFeedInfo::~PriceFeedInfo() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PriceFeedInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceFeedInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.base_.Destroy();
  _impl_.quote_.Destroy();
}

void PriceFeedInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceFeedInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PriceFeedInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.base_.ClearToEmpty();
  _impl_.quote_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceFeedInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string base = 1 [json_name = "base"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_base();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceFeedInfo.base"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quote = 2 [json_name = "quote"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quote();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceFeedInfo.quote"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceFeedInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PriceFeedInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string base = 1 [json_name = "base"];
  if (!this->_internal_base().empty()) {
    const std::string& _s = this->_internal_base();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceFeedInfo.base");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string quote = 2 [json_name = "quote"];
  if (!this->_internal_quote().empty()) {
    const std::string& _s = this->_internal_quote();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceFeedInfo.quote");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PriceFeedInfo)
  return target;
}

::size_t PriceFeedInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PriceFeedInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string base = 1 [json_name = "base"];
  if (!this->_internal_base().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_base());
  }

  // string quote = 2 [json_name = "quote"];
  if (!this->_internal_quote().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quote());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceFeedInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceFeedInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceFeedInfo::GetClassData() const { return &_class_data_; }


void PriceFeedInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceFeedInfo*>(&to_msg);
  auto& from = static_cast<const PriceFeedInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PriceFeedInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_base().empty()) {
    _this->_internal_set_base(from._internal_base());
  }
  if (!from._internal_quote().empty()) {
    _this->_internal_set_quote(from._internal_quote());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceFeedInfo::CopyFrom(const PriceFeedInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PriceFeedInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceFeedInfo::IsInitialized() const {
  return true;
}

void PriceFeedInfo::InternalSwap(PriceFeedInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.base_, lhs_arena,
                                       &other->_impl_.base_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quote_, lhs_arena,
                                       &other->_impl_.quote_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceFeedInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[8]);
}
// ===================================================================

class PriceFeedPrice::_Internal {
 public:
};

PriceFeedPrice::PriceFeedPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PriceFeedPrice)
}
PriceFeedPrice::PriceFeedPrice(const PriceFeedPrice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceFeedPrice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PriceFeedPrice)
}

inline void PriceFeedPrice::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceFeedPrice::~PriceFeedPrice() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PriceFeedPrice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceFeedPrice::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_.Destroy();
}

void PriceFeedPrice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceFeedPrice::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PriceFeedPrice)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceFeedPrice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceFeedPrice.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceFeedPrice::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PriceFeedPrice)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceFeedPrice.price");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PriceFeedPrice)
  return target;
}

::size_t PriceFeedPrice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PriceFeedPrice)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceFeedPrice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceFeedPrice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceFeedPrice::GetClassData() const { return &_class_data_; }


void PriceFeedPrice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceFeedPrice*>(&to_msg);
  auto& from = static_cast<const PriceFeedPrice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PriceFeedPrice)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceFeedPrice::CopyFrom(const PriceFeedPrice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PriceFeedPrice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceFeedPrice::IsInitialized() const {
  return true;
}

void PriceFeedPrice::InternalSwap(PriceFeedPrice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceFeedPrice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[9]);
}
// ===================================================================

class CoinbasePriceState::_Internal {
 public:
  using HasBits = decltype(std::declval<CoinbasePriceState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CoinbasePriceState, _impl_._has_bits_);
  static const ::injective::oracle::v1beta1::PriceState& price_state(const CoinbasePriceState* msg);
  static void set_has_price_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::oracle::v1beta1::PriceState&
CoinbasePriceState::_Internal::price_state(const CoinbasePriceState* msg) {
  return *msg->_impl_.price_state_;
}
CoinbasePriceState::CoinbasePriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.CoinbasePriceState)
}
CoinbasePriceState::CoinbasePriceState(const CoinbasePriceState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CoinbasePriceState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kind_) {}

    , decltype(_impl_.key_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.timestamp_) {}

    , decltype(_impl_.value_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.kind_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_kind().empty()) {
    _this->_impl_.kind_.Set(from._internal_kind(), _this->GetArenaForAllocation());
  }
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.price_state_ = new ::injective::oracle::v1beta1::PriceState(*from._impl_.price_state_);
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.CoinbasePriceState)
}

inline void CoinbasePriceState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kind_) {}

    , decltype(_impl_.key_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.timestamp_) { ::uint64_t{0u} }

    , decltype(_impl_.value_) { ::uint64_t{0u} }

  };
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.kind_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CoinbasePriceState::~CoinbasePriceState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.CoinbasePriceState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoinbasePriceState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.kind_.Destroy();
  _impl_.key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.price_state_;
}

void CoinbasePriceState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CoinbasePriceState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.CoinbasePriceState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.kind_.ClearToEmpty();
  _impl_.key_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.price_state_ != nullptr);
    _impl_.price_state_->Clear();
  }
  ::memset(&_impl_.timestamp_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.value_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoinbasePriceState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string kind = 1 [json_name = "kind"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_kind();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.CoinbasePriceState.kind"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 timestamp = 2 [json_name = "timestamp"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string key = 3 [json_name = "key"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.CoinbasePriceState.key"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 value = 4 [json_name = "value"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_price_state(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CoinbasePriceState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.CoinbasePriceState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string kind = 1 [json_name = "kind"];
  if (!this->_internal_kind().empty()) {
    const std::string& _s = this->_internal_kind();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.CoinbasePriceState.kind");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint64 timestamp = 2 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_timestamp(), target);
  }

  // string key = 3 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    const std::string& _s = this->_internal_key();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.CoinbasePriceState.key");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // uint64 value = 4 [json_name = "value"];
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_value(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::price_state(this),
        _Internal::price_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.CoinbasePriceState)
  return target;
}

::size_t CoinbasePriceState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.CoinbasePriceState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string kind = 1 [json_name = "kind"];
  if (!this->_internal_kind().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_kind());
  }

  // string key = 3 [json_name = "key"];
  if (!this->_internal_key().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_key());
  }

  // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.price_state_);
  }

  // uint64 timestamp = 2 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_timestamp());
  }

  // uint64 value = 4 [json_name = "value"];
  if (this->_internal_value() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoinbasePriceState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CoinbasePriceState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoinbasePriceState::GetClassData() const { return &_class_data_; }


void CoinbasePriceState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CoinbasePriceState*>(&to_msg);
  auto& from = static_cast<const CoinbasePriceState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.CoinbasePriceState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_kind().empty()) {
    _this->_internal_set_kind(from._internal_kind());
  }
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_price_state()->::injective::oracle::v1beta1::PriceState::MergeFrom(
        from._internal_price_state());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoinbasePriceState::CopyFrom(const CoinbasePriceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.CoinbasePriceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoinbasePriceState::IsInitialized() const {
  return true;
}

void CoinbasePriceState::InternalSwap(CoinbasePriceState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.kind_, lhs_arena,
                                       &other->_impl_.kind_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena,
                                       &other->_impl_.key_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CoinbasePriceState, _impl_.value_)
      + sizeof(CoinbasePriceState::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(CoinbasePriceState, _impl_.price_state_)>(
          reinterpret_cast<char*>(&_impl_.price_state_),
          reinterpret_cast<char*>(&other->_impl_.price_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CoinbasePriceState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[10]);
}
// ===================================================================

class PriceState::_Internal {
 public:
};

PriceState::PriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PriceState)
}
PriceState::PriceState(const PriceState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.cumulative_price_) {}

    , decltype(_impl_.timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.cumulative_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cumulative_price().empty()) {
    _this->_impl_.cumulative_price_.Set(from._internal_cumulative_price(), _this->GetArenaForAllocation());
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PriceState)
}

inline void PriceState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.cumulative_price_) {}

    , decltype(_impl_.timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cumulative_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceState::~PriceState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PriceState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_.Destroy();
  _impl_.cumulative_price_.Destroy();
}

void PriceState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PriceState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_.ClearToEmpty();
  _impl_.cumulative_price_.ClearToEmpty();
  _impl_.timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceState.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cumulative_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceState.cumulative_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PriceState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceState.price");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_price().empty()) {
    const std::string& _s = this->_internal_cumulative_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceState.cumulative_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PriceState)
  return target;
}

::size_t PriceState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PriceState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_cumulative_price());
  }

  // int64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceState::GetClassData() const { return &_class_data_; }


void PriceState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceState*>(&to_msg);
  auto& from = static_cast<const PriceState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PriceState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_cumulative_price().empty()) {
    _this->_internal_set_cumulative_price(from._internal_cumulative_price());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceState::CopyFrom(const PriceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PriceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceState::IsInitialized() const {
  return true;
}

void PriceState::InternalSwap(PriceState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.cumulative_price_, lhs_arena,
                                       &other->_impl_.cumulative_price_, rhs_arena);

  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[11]);
}
// ===================================================================

class PythPriceState::_Internal {
 public:
  using HasBits = decltype(std::declval<PythPriceState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PythPriceState, _impl_._has_bits_);
  static const ::injective::oracle::v1beta1::PriceState& price_state(const PythPriceState* msg);
  static void set_has_price_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::oracle::v1beta1::PriceState&
PythPriceState::_Internal::price_state(const PythPriceState* msg) {
  return *msg->_impl_.price_state_;
}
PythPriceState::PythPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PythPriceState)
}
PythPriceState::PythPriceState(const PythPriceState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PythPriceState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.price_id_) {}

    , decltype(_impl_.ema_price_) {}

    , decltype(_impl_.ema_conf_) {}

    , decltype(_impl_.conf_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.publish_time_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price_id().empty()) {
    _this->_impl_.price_id_.Set(from._internal_price_id(), _this->GetArenaForAllocation());
  }
  _impl_.ema_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ema_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ema_price().empty()) {
    _this->_impl_.ema_price_.Set(from._internal_ema_price(), _this->GetArenaForAllocation());
  }
  _impl_.ema_conf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ema_conf_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ema_conf().empty()) {
    _this->_impl_.ema_conf_.Set(from._internal_ema_conf(), _this->GetArenaForAllocation());
  }
  _impl_.conf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.conf_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_conf().empty()) {
    _this->_impl_.conf_.Set(from._internal_conf(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.price_state_ = new ::injective::oracle::v1beta1::PriceState(*from._impl_.price_state_);
  }
  _this->_impl_.publish_time_ = from._impl_.publish_time_;
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PythPriceState)
}

inline void PythPriceState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.price_id_) {}

    , decltype(_impl_.ema_price_) {}

    , decltype(_impl_.ema_conf_) {}

    , decltype(_impl_.conf_) {}

    , decltype(_impl_.price_state_){nullptr}
    , decltype(_impl_.publish_time_) { ::uint64_t{0u} }

  };
  _impl_.price_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ema_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ema_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ema_conf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ema_conf_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.conf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.conf_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PythPriceState::~PythPriceState() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PythPriceState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PythPriceState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_id_.Destroy();
  _impl_.ema_price_.Destroy();
  _impl_.ema_conf_.Destroy();
  _impl_.conf_.Destroy();
  if (this != internal_default_instance()) delete _impl_.price_state_;
}

void PythPriceState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PythPriceState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PythPriceState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_id_.ClearToEmpty();
  _impl_.ema_price_.ClearToEmpty();
  _impl_.ema_conf_.ClearToEmpty();
  _impl_.conf_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.price_state_ != nullptr);
    _impl_.price_state_->Clear();
  }
  _impl_.publish_time_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PythPriceState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string price_id = 1 [json_name = "priceId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_price_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PythPriceState.price_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string ema_price = 2 [json_name = "emaPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ema_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PythPriceState.ema_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string ema_conf = 3 [json_name = "emaConf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ema_conf();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PythPriceState.ema_conf"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string conf = 4 [json_name = "conf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_conf();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PythPriceState.conf"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 publish_time = 5 [json_name = "publishTime"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.publish_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.PriceState price_state = 6 [json_name = "priceState", (.gogoproto.nullable) = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_price_state(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PythPriceState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PythPriceState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string price_id = 1 [json_name = "priceId"];
  if (!this->_internal_price_id().empty()) {
    const std::string& _s = this->_internal_price_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PythPriceState.price_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string ema_price = 2 [json_name = "emaPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_ema_price().empty()) {
    const std::string& _s = this->_internal_ema_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PythPriceState.ema_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string ema_conf = 3 [json_name = "emaConf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_ema_conf().empty()) {
    const std::string& _s = this->_internal_ema_conf();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PythPriceState.ema_conf");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string conf = 4 [json_name = "conf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_conf().empty()) {
    const std::string& _s = this->_internal_conf();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PythPriceState.conf");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // uint64 publish_time = 5 [json_name = "publishTime"];
  if (this->_internal_publish_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_publish_time(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.oracle.v1beta1.PriceState price_state = 6 [json_name = "priceState", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::price_state(this),
        _Internal::price_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PythPriceState)
  return target;
}

::size_t PythPriceState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PythPriceState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price_id = 1 [json_name = "priceId"];
  if (!this->_internal_price_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price_id());
  }

  // string ema_price = 2 [json_name = "emaPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_ema_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ema_price());
  }

  // string ema_conf = 3 [json_name = "emaConf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_ema_conf().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ema_conf());
  }

  // string conf = 4 [json_name = "conf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_conf().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_conf());
  }

  // .injective.oracle.v1beta1.PriceState price_state = 6 [json_name = "priceState", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.price_state_);
  }

  // uint64 publish_time = 5 [json_name = "publishTime"];
  if (this->_internal_publish_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_publish_time());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PythPriceState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PythPriceState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PythPriceState::GetClassData() const { return &_class_data_; }


void PythPriceState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PythPriceState*>(&to_msg);
  auto& from = static_cast<const PythPriceState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PythPriceState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price_id().empty()) {
    _this->_internal_set_price_id(from._internal_price_id());
  }
  if (!from._internal_ema_price().empty()) {
    _this->_internal_set_ema_price(from._internal_ema_price());
  }
  if (!from._internal_ema_conf().empty()) {
    _this->_internal_set_ema_conf(from._internal_ema_conf());
  }
  if (!from._internal_conf().empty()) {
    _this->_internal_set_conf(from._internal_conf());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_price_state()->::injective::oracle::v1beta1::PriceState::MergeFrom(
        from._internal_price_state());
  }
  if (from._internal_publish_time() != 0) {
    _this->_internal_set_publish_time(from._internal_publish_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PythPriceState::CopyFrom(const PythPriceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PythPriceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PythPriceState::IsInitialized() const {
  return true;
}

void PythPriceState::InternalSwap(PythPriceState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_id_, lhs_arena,
                                       &other->_impl_.price_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ema_price_, lhs_arena,
                                       &other->_impl_.ema_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ema_conf_, lhs_arena,
                                       &other->_impl_.ema_conf_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.conf_, lhs_arena,
                                       &other->_impl_.conf_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PythPriceState, _impl_.publish_time_)
      + sizeof(PythPriceState::_impl_.publish_time_)
      - PROTOBUF_FIELD_OFFSET(PythPriceState, _impl_.price_state_)>(
          reinterpret_cast<char*>(&_impl_.price_state_),
          reinterpret_cast<char*>(&other->_impl_.price_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PythPriceState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[12]);
}
// ===================================================================

class BandOracleRequest::_Internal {
 public:
};

void BandOracleRequest::clear_fee_limit() {
  _internal_mutable_fee_limit()->Clear();
}
BandOracleRequest::BandOracleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.BandOracleRequest)
}
BandOracleRequest::BandOracleRequest(const BandOracleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BandOracleRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.symbols_){from._impl_.symbols_}
    , decltype(_impl_.fee_limit_){from._impl_.fee_limit_}
    , decltype(_impl_.request_id_) {}

    , decltype(_impl_.oracle_script_id_) {}

    , decltype(_impl_.ask_count_) {}

    , decltype(_impl_.min_count_) {}

    , decltype(_impl_.prepare_gas_) {}

    , decltype(_impl_.execute_gas_) {}

    , decltype(_impl_.min_source_count_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.request_id_, &from._impl_.request_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.min_source_count_) -
    reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.min_source_count_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.BandOracleRequest)
}

inline void BandOracleRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.symbols_){arena}
    , decltype(_impl_.fee_limit_){arena}
    , decltype(_impl_.request_id_) { ::uint64_t{0u} }

    , decltype(_impl_.oracle_script_id_) { ::int64_t{0} }

    , decltype(_impl_.ask_count_) { ::uint64_t{0u} }

    , decltype(_impl_.min_count_) { ::uint64_t{0u} }

    , decltype(_impl_.prepare_gas_) { ::uint64_t{0u} }

    , decltype(_impl_.execute_gas_) { ::uint64_t{0u} }

    , decltype(_impl_.min_source_count_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BandOracleRequest::~BandOracleRequest() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.BandOracleRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BandOracleRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_symbols()->~RepeatedPtrField();
  _internal_mutable_fee_limit()->~RepeatedPtrField();
}

void BandOracleRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BandOracleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.BandOracleRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_symbols()->Clear();
  _internal_mutable_fee_limit()->Clear();
  ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.min_source_count_) -
      reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.min_source_count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BandOracleRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 request_id = 1 [json_name = "requestId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 oracle_script_id = 2 [json_name = "oracleScriptId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.oracle_script_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string symbols = 3 [json_name = "symbols"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_symbols();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.BandOracleRequest.symbols"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 ask_count = 4 [json_name = "askCount"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.ask_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 min_count = 5 [json_name = "minCount"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.min_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .cosmos.base.v1beta1.Coin fee_limit = 6 [json_name = "feeLimit", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fee_limit(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 prepare_gas = 7 [json_name = "prepareGas"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.prepare_gas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 execute_gas = 8 [json_name = "executeGas"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.execute_gas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 min_source_count = 9 [json_name = "minSourceCount"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.min_source_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BandOracleRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.BandOracleRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 request_id = 1 [json_name = "requestId"];
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // int64 oracle_script_id = 2 [json_name = "oracleScriptId"];
  if (this->_internal_oracle_script_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_oracle_script_id(), target);
  }

  // repeated string symbols = 3 [json_name = "symbols"];
  for (int i = 0, n = this->_internal_symbols_size(); i < n; ++i) {
    const auto& s = this->_internal_symbols(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.BandOracleRequest.symbols");
    target = stream->WriteString(3, s, target);
  }

  // uint64 ask_count = 4 [json_name = "askCount"];
  if (this->_internal_ask_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_ask_count(), target);
  }

  // uint64 min_count = 5 [json_name = "minCount"];
  if (this->_internal_min_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_min_count(), target);
  }

  // repeated .cosmos.base.v1beta1.Coin fee_limit = 6 [json_name = "feeLimit", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fee_limit_size()); i < n; i++) {
    const auto& repfield = this->_internal_fee_limit(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint64 prepare_gas = 7 [json_name = "prepareGas"];
  if (this->_internal_prepare_gas() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_prepare_gas(), target);
  }

  // uint64 execute_gas = 8 [json_name = "executeGas"];
  if (this->_internal_execute_gas() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_execute_gas(), target);
  }

  // uint64 min_source_count = 9 [json_name = "minSourceCount"];
  if (this->_internal_min_source_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_min_source_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.BandOracleRequest)
  return target;
}

::size_t BandOracleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.BandOracleRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string symbols = 3 [json_name = "symbols"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_symbols().size());
  for (int i = 0, n = _internal_symbols().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_symbols().Get(i));
  }

  // repeated .cosmos.base.v1beta1.Coin fee_limit = 6 [json_name = "feeLimit", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  total_size += 1UL * this->_internal_fee_limit_size();
  for (const auto& msg : this->_internal_fee_limit()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 request_id = 1 [json_name = "requestId"];
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  // int64 oracle_script_id = 2 [json_name = "oracleScriptId"];
  if (this->_internal_oracle_script_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_oracle_script_id());
  }

  // uint64 ask_count = 4 [json_name = "askCount"];
  if (this->_internal_ask_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_ask_count());
  }

  // uint64 min_count = 5 [json_name = "minCount"];
  if (this->_internal_min_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_min_count());
  }

  // uint64 prepare_gas = 7 [json_name = "prepareGas"];
  if (this->_internal_prepare_gas() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_prepare_gas());
  }

  // uint64 execute_gas = 8 [json_name = "executeGas"];
  if (this->_internal_execute_gas() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_execute_gas());
  }

  // uint64 min_source_count = 9 [json_name = "minSourceCount"];
  if (this->_internal_min_source_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_min_source_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BandOracleRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BandOracleRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BandOracleRequest::GetClassData() const { return &_class_data_; }


void BandOracleRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BandOracleRequest*>(&to_msg);
  auto& from = static_cast<const BandOracleRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.BandOracleRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_symbols()->MergeFrom(from._internal_symbols());
  _this->_internal_mutable_fee_limit()->MergeFrom(from._internal_fee_limit());
  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  if (from._internal_oracle_script_id() != 0) {
    _this->_internal_set_oracle_script_id(from._internal_oracle_script_id());
  }
  if (from._internal_ask_count() != 0) {
    _this->_internal_set_ask_count(from._internal_ask_count());
  }
  if (from._internal_min_count() != 0) {
    _this->_internal_set_min_count(from._internal_min_count());
  }
  if (from._internal_prepare_gas() != 0) {
    _this->_internal_set_prepare_gas(from._internal_prepare_gas());
  }
  if (from._internal_execute_gas() != 0) {
    _this->_internal_set_execute_gas(from._internal_execute_gas());
  }
  if (from._internal_min_source_count() != 0) {
    _this->_internal_set_min_source_count(from._internal_min_source_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BandOracleRequest::CopyFrom(const BandOracleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.BandOracleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandOracleRequest::IsInitialized() const {
  return true;
}

void BandOracleRequest::InternalSwap(BandOracleRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_symbols()->InternalSwap(
      other->_internal_mutable_symbols());
  _internal_mutable_fee_limit()->InternalSwap(other->_internal_mutable_fee_limit());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandOracleRequest, _impl_.min_source_count_)
      + sizeof(BandOracleRequest::_impl_.min_source_count_)
      - PROTOBUF_FIELD_OFFSET(BandOracleRequest, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BandOracleRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[13]);
}
// ===================================================================

class BandIBCParams::_Internal {
 public:
};

BandIBCParams::BandIBCParams(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.BandIBCParams)
}
BandIBCParams::BandIBCParams(const BandIBCParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BandIBCParams* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.legacy_oracle_ids_) { from._impl_.legacy_oracle_ids_ }
    ,/* _impl_._legacy_oracle_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.ibc_source_channel_) {}

    , decltype(_impl_.ibc_version_) {}

    , decltype(_impl_.ibc_port_id_) {}

    , decltype(_impl_.ibc_request_interval_) {}

    , decltype(_impl_.band_ibc_enabled_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ibc_source_channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ibc_source_channel_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ibc_source_channel().empty()) {
    _this->_impl_.ibc_source_channel_.Set(from._internal_ibc_source_channel(), _this->GetArenaForAllocation());
  }
  _impl_.ibc_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ibc_version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ibc_version().empty()) {
    _this->_impl_.ibc_version_.Set(from._internal_ibc_version(), _this->GetArenaForAllocation());
  }
  _impl_.ibc_port_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ibc_port_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ibc_port_id().empty()) {
    _this->_impl_.ibc_port_id_.Set(from._internal_ibc_port_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ibc_request_interval_, &from._impl_.ibc_request_interval_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.band_ibc_enabled_) -
    reinterpret_cast<char*>(&_impl_.ibc_request_interval_)) + sizeof(_impl_.band_ibc_enabled_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.BandIBCParams)
}

inline void BandIBCParams::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.legacy_oracle_ids_) { arena }
    ,/* _impl_._legacy_oracle_ids_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.ibc_source_channel_) {}

    , decltype(_impl_.ibc_version_) {}

    , decltype(_impl_.ibc_port_id_) {}

    , decltype(_impl_.ibc_request_interval_) { ::int64_t{0} }

    , decltype(_impl_.band_ibc_enabled_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ibc_source_channel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ibc_source_channel_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ibc_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ibc_version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ibc_port_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ibc_port_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BandIBCParams::~BandIBCParams() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.BandIBCParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BandIBCParams::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.legacy_oracle_ids_.~RepeatedField();
  _impl_.ibc_source_channel_.Destroy();
  _impl_.ibc_version_.Destroy();
  _impl_.ibc_port_id_.Destroy();
}

void BandIBCParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BandIBCParams::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.BandIBCParams)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_legacy_oracle_ids()->Clear();
  _impl_.ibc_source_channel_.ClearToEmpty();
  _impl_.ibc_version_.ClearToEmpty();
  _impl_.ibc_port_id_.ClearToEmpty();
  ::memset(&_impl_.ibc_request_interval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.band_ibc_enabled_) -
      reinterpret_cast<char*>(&_impl_.ibc_request_interval_)) + sizeof(_impl_.band_ibc_enabled_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BandIBCParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool band_ibc_enabled = 1 [json_name = "bandIbcEnabled"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.band_ibc_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 ibc_request_interval = 2 [json_name = "ibcRequestInterval"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.ibc_request_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string ibc_source_channel = 3 [json_name = "ibcSourceChannel"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ibc_source_channel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.BandIBCParams.ibc_source_channel"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string ibc_version = 4 [json_name = "ibcVersion"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ibc_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.BandIBCParams.ibc_version"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string ibc_port_id = 5 [json_name = "ibcPortId"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ibc_port_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.BandIBCParams.ibc_port_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int64 legacy_oracle_ids = 6 [json_name = "legacyOracleIds"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_legacy_oracle_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 48) {
          _internal_add_legacy_oracle_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BandIBCParams::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.BandIBCParams)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool band_ibc_enabled = 1 [json_name = "bandIbcEnabled"];
  if (this->_internal_band_ibc_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_band_ibc_enabled(), target);
  }

  // int64 ibc_request_interval = 2 [json_name = "ibcRequestInterval"];
  if (this->_internal_ibc_request_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_ibc_request_interval(), target);
  }

  // string ibc_source_channel = 3 [json_name = "ibcSourceChannel"];
  if (!this->_internal_ibc_source_channel().empty()) {
    const std::string& _s = this->_internal_ibc_source_channel();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.BandIBCParams.ibc_source_channel");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string ibc_version = 4 [json_name = "ibcVersion"];
  if (!this->_internal_ibc_version().empty()) {
    const std::string& _s = this->_internal_ibc_version();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.BandIBCParams.ibc_version");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string ibc_port_id = 5 [json_name = "ibcPortId"];
  if (!this->_internal_ibc_port_id().empty()) {
    const std::string& _s = this->_internal_ibc_port_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.BandIBCParams.ibc_port_id");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // repeated int64 legacy_oracle_ids = 6 [json_name = "legacyOracleIds"];
  {
    int byte_size = _impl_._legacy_oracle_ids_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(6, _internal_legacy_oracle_ids(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.BandIBCParams)
  return target;
}

::size_t BandIBCParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.BandIBCParams)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 legacy_oracle_ids = 6 [json_name = "legacyOracleIds"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_legacy_oracle_ids())
    ;
    _impl_._legacy_oracle_ids_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // string ibc_source_channel = 3 [json_name = "ibcSourceChannel"];
  if (!this->_internal_ibc_source_channel().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ibc_source_channel());
  }

  // string ibc_version = 4 [json_name = "ibcVersion"];
  if (!this->_internal_ibc_version().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ibc_version());
  }

  // string ibc_port_id = 5 [json_name = "ibcPortId"];
  if (!this->_internal_ibc_port_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ibc_port_id());
  }

  // int64 ibc_request_interval = 2 [json_name = "ibcRequestInterval"];
  if (this->_internal_ibc_request_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_ibc_request_interval());
  }

  // bool band_ibc_enabled = 1 [json_name = "bandIbcEnabled"];
  if (this->_internal_band_ibc_enabled() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BandIBCParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BandIBCParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BandIBCParams::GetClassData() const { return &_class_data_; }


void BandIBCParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BandIBCParams*>(&to_msg);
  auto& from = static_cast<const BandIBCParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.BandIBCParams)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.legacy_oracle_ids_.MergeFrom(from._impl_.legacy_oracle_ids_);
  if (!from._internal_ibc_source_channel().empty()) {
    _this->_internal_set_ibc_source_channel(from._internal_ibc_source_channel());
  }
  if (!from._internal_ibc_version().empty()) {
    _this->_internal_set_ibc_version(from._internal_ibc_version());
  }
  if (!from._internal_ibc_port_id().empty()) {
    _this->_internal_set_ibc_port_id(from._internal_ibc_port_id());
  }
  if (from._internal_ibc_request_interval() != 0) {
    _this->_internal_set_ibc_request_interval(from._internal_ibc_request_interval());
  }
  if (from._internal_band_ibc_enabled() != 0) {
    _this->_internal_set_band_ibc_enabled(from._internal_band_ibc_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BandIBCParams::CopyFrom(const BandIBCParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.BandIBCParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BandIBCParams::IsInitialized() const {
  return true;
}

void BandIBCParams::InternalSwap(BandIBCParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.legacy_oracle_ids_.InternalSwap(&other->_impl_.legacy_oracle_ids_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ibc_source_channel_, lhs_arena,
                                       &other->_impl_.ibc_source_channel_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ibc_version_, lhs_arena,
                                       &other->_impl_.ibc_version_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ibc_port_id_, lhs_arena,
                                       &other->_impl_.ibc_port_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BandIBCParams, _impl_.band_ibc_enabled_)
      + sizeof(BandIBCParams::_impl_.band_ibc_enabled_)
      - PROTOBUF_FIELD_OFFSET(BandIBCParams, _impl_.ibc_request_interval_)>(
          reinterpret_cast<char*>(&_impl_.ibc_request_interval_),
          reinterpret_cast<char*>(&other->_impl_.ibc_request_interval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BandIBCParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[14]);
}
// ===================================================================

class SymbolPriceTimestamp::_Internal {
 public:
};

SymbolPriceTimestamp::SymbolPriceTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.SymbolPriceTimestamp)
}
SymbolPriceTimestamp::SymbolPriceTimestamp(const SymbolPriceTimestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SymbolPriceTimestamp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_id_) {}

    , decltype(_impl_.timestamp_) {}

    , decltype(_impl_.oracle_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol_id().empty()) {
    _this->_impl_.symbol_id_.Set(from._internal_symbol_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.oracle_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.oracle_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.SymbolPriceTimestamp)
}

inline void SymbolPriceTimestamp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.symbol_id_) {}

    , decltype(_impl_.timestamp_) { ::int64_t{0} }

    , decltype(_impl_.oracle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.symbol_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SymbolPriceTimestamp::~SymbolPriceTimestamp() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.SymbolPriceTimestamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SymbolPriceTimestamp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.symbol_id_.Destroy();
}

void SymbolPriceTimestamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SymbolPriceTimestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.SymbolPriceTimestamp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.symbol_id_.ClearToEmpty();
  ::memset(&_impl_.timestamp_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.oracle_) -
      reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.oracle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SymbolPriceTimestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_oracle(static_cast<::injective::oracle::v1beta1::OracleType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string symbol_id = 2 [json_name = "symbolId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_symbol_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.SymbolPriceTimestamp.symbol_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SymbolPriceTimestamp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.SymbolPriceTimestamp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
  if (this->_internal_oracle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_oracle(), target);
  }

  // string symbol_id = 2 [json_name = "symbolId"];
  if (!this->_internal_symbol_id().empty()) {
    const std::string& _s = this->_internal_symbol_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.SymbolPriceTimestamp.symbol_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.SymbolPriceTimestamp)
  return target;
}

::size_t SymbolPriceTimestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.SymbolPriceTimestamp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string symbol_id = 2 [json_name = "symbolId"];
  if (!this->_internal_symbol_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_symbol_id());
  }

  // int64 timestamp = 3 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_timestamp());
  }

  // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
  if (this->_internal_oracle() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_oracle());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SymbolPriceTimestamp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SymbolPriceTimestamp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SymbolPriceTimestamp::GetClassData() const { return &_class_data_; }


void SymbolPriceTimestamp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SymbolPriceTimestamp*>(&to_msg);
  auto& from = static_cast<const SymbolPriceTimestamp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.SymbolPriceTimestamp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_symbol_id().empty()) {
    _this->_internal_set_symbol_id(from._internal_symbol_id());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_oracle() != 0) {
    _this->_internal_set_oracle(from._internal_oracle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SymbolPriceTimestamp::CopyFrom(const SymbolPriceTimestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.SymbolPriceTimestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymbolPriceTimestamp::IsInitialized() const {
  return true;
}

void SymbolPriceTimestamp::InternalSwap(SymbolPriceTimestamp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.symbol_id_, lhs_arena,
                                       &other->_impl_.symbol_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SymbolPriceTimestamp, _impl_.oracle_)
      + sizeof(SymbolPriceTimestamp::_impl_.oracle_)
      - PROTOBUF_FIELD_OFFSET(SymbolPriceTimestamp, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SymbolPriceTimestamp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[15]);
}
// ===================================================================

class LastPriceTimestamps::_Internal {
 public:
};

LastPriceTimestamps::LastPriceTimestamps(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.LastPriceTimestamps)
}
LastPriceTimestamps::LastPriceTimestamps(const LastPriceTimestamps& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LastPriceTimestamps* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.last_price_timestamps_){from._impl_.last_price_timestamps_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.LastPriceTimestamps)
}

inline void LastPriceTimestamps::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.last_price_timestamps_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LastPriceTimestamps::~LastPriceTimestamps() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.LastPriceTimestamps)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LastPriceTimestamps::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_last_price_timestamps()->~RepeatedPtrField();
}

void LastPriceTimestamps::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LastPriceTimestamps::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.LastPriceTimestamps)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_last_price_timestamps()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LastPriceTimestamps::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1 [json_name = "lastPriceTimestamps"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_last_price_timestamps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LastPriceTimestamps::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.LastPriceTimestamps)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1 [json_name = "lastPriceTimestamps"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_last_price_timestamps_size()); i < n; i++) {
    const auto& repfield = this->_internal_last_price_timestamps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.LastPriceTimestamps)
  return target;
}

::size_t LastPriceTimestamps::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.LastPriceTimestamps)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1 [json_name = "lastPriceTimestamps"];
  total_size += 1UL * this->_internal_last_price_timestamps_size();
  for (const auto& msg : this->_internal_last_price_timestamps()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LastPriceTimestamps::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LastPriceTimestamps::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LastPriceTimestamps::GetClassData() const { return &_class_data_; }


void LastPriceTimestamps::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LastPriceTimestamps*>(&to_msg);
  auto& from = static_cast<const LastPriceTimestamps&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.LastPriceTimestamps)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_last_price_timestamps()->MergeFrom(from._internal_last_price_timestamps());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LastPriceTimestamps::CopyFrom(const LastPriceTimestamps& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.LastPriceTimestamps)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LastPriceTimestamps::IsInitialized() const {
  return true;
}

void LastPriceTimestamps::InternalSwap(LastPriceTimestamps* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_last_price_timestamps()->InternalSwap(other->_internal_mutable_last_price_timestamps());
}

::PROTOBUF_NAMESPACE_ID::Metadata LastPriceTimestamps::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[16]);
}
// ===================================================================

class PriceRecords::_Internal {
 public:
};

PriceRecords::PriceRecords(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PriceRecords)
}
PriceRecords::PriceRecords(const PriceRecords& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceRecords* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_price_records_){from._impl_.latest_price_records_}
    , decltype(_impl_.symbol_id_) {}

    , decltype(_impl_.oracle_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.symbol_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_symbol_id().empty()) {
    _this->_impl_.symbol_id_.Set(from._internal_symbol_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.oracle_ = from._impl_.oracle_;
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PriceRecords)
}

inline void PriceRecords::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_price_records_){arena}
    , decltype(_impl_.symbol_id_) {}

    , decltype(_impl_.oracle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.symbol_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.symbol_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceRecords::~PriceRecords() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PriceRecords)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceRecords::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_latest_price_records()->~RepeatedPtrField();
  _impl_.symbol_id_.Destroy();
}

void PriceRecords::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceRecords::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PriceRecords)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_latest_price_records()->Clear();
  _impl_.symbol_id_.ClearToEmpty();
  _impl_.oracle_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceRecords::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_oracle(static_cast<::injective::oracle::v1beta1::OracleType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string symbol_id = 2 [json_name = "symbolId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_symbol_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceRecords.symbol_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.oracle.v1beta1.PriceRecord latest_price_records = 3 [json_name = "latestPriceRecords"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_latest_price_records(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceRecords::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PriceRecords)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
  if (this->_internal_oracle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_oracle(), target);
  }

  // string symbol_id = 2 [json_name = "symbolId"];
  if (!this->_internal_symbol_id().empty()) {
    const std::string& _s = this->_internal_symbol_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceRecords.symbol_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated .injective.oracle.v1beta1.PriceRecord latest_price_records = 3 [json_name = "latestPriceRecords"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_latest_price_records_size()); i < n; i++) {
    const auto& repfield = this->_internal_latest_price_records(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PriceRecords)
  return target;
}

::size_t PriceRecords::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PriceRecords)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.oracle.v1beta1.PriceRecord latest_price_records = 3 [json_name = "latestPriceRecords"];
  total_size += 1UL * this->_internal_latest_price_records_size();
  for (const auto& msg : this->_internal_latest_price_records()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string symbol_id = 2 [json_name = "symbolId"];
  if (!this->_internal_symbol_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_symbol_id());
  }

  // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
  if (this->_internal_oracle() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_oracle());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceRecords::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceRecords::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceRecords::GetClassData() const { return &_class_data_; }


void PriceRecords::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceRecords*>(&to_msg);
  auto& from = static_cast<const PriceRecords&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PriceRecords)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_latest_price_records()->MergeFrom(from._internal_latest_price_records());
  if (!from._internal_symbol_id().empty()) {
    _this->_internal_set_symbol_id(from._internal_symbol_id());
  }
  if (from._internal_oracle() != 0) {
    _this->_internal_set_oracle(from._internal_oracle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceRecords::CopyFrom(const PriceRecords& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PriceRecords)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceRecords::IsInitialized() const {
  return true;
}

void PriceRecords::InternalSwap(PriceRecords* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_latest_price_records()->InternalSwap(other->_internal_mutable_latest_price_records());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.symbol_id_, lhs_arena,
                                       &other->_impl_.symbol_id_, rhs_arena);
  swap(_impl_.oracle_, other->_impl_.oracle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceRecords::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[17]);
}
// ===================================================================

class PriceRecord::_Internal {
 public:
};

PriceRecord::PriceRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PriceRecord)
}
PriceRecord::PriceRecord(const PriceRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PriceRecord)
}

inline void PriceRecord::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceRecord::~PriceRecord() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PriceRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceRecord::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_.Destroy();
}

void PriceRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PriceRecord)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_.ClearToEmpty();
  _impl_.timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 timestamp = 1 [json_name = "timestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceRecord.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceRecord::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PriceRecord)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 timestamp = 1 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_timestamp(), target);
  }

  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceRecord.price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PriceRecord)
  return target;
}

::size_t PriceRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PriceRecord)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // int64 timestamp = 1 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceRecord::GetClassData() const { return &_class_data_; }


void PriceRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceRecord*>(&to_msg);
  auto& from = static_cast<const PriceRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PriceRecord)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceRecord::CopyFrom(const PriceRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PriceRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceRecord::IsInitialized() const {
  return true;
}

void PriceRecord::InternalSwap(PriceRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);

  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[18]);
}
// ===================================================================

class MetadataStatistics::_Internal {
 public:
};

MetadataStatistics::MetadataStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.MetadataStatistics)
}
MetadataStatistics::MetadataStatistics(const MetadataStatistics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MetadataStatistics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mean_) {}

    , decltype(_impl_.twap_) {}

    , decltype(_impl_.min_price_) {}

    , decltype(_impl_.max_price_) {}

    , decltype(_impl_.median_price_) {}

    , decltype(_impl_.group_count_) {}

    , decltype(_impl_.records_sample_size_) {}

    , decltype(_impl_.first_timestamp_) {}

    , decltype(_impl_.last_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mean_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mean_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mean().empty()) {
    _this->_impl_.mean_.Set(from._internal_mean(), _this->GetArenaForAllocation());
  }
  _impl_.twap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.twap_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_twap().empty()) {
    _this->_impl_.twap_.Set(from._internal_twap(), _this->GetArenaForAllocation());
  }
  _impl_.min_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_price().empty()) {
    _this->_impl_.min_price_.Set(from._internal_min_price(), _this->GetArenaForAllocation());
  }
  _impl_.max_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.max_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_max_price().empty()) {
    _this->_impl_.max_price_.Set(from._internal_max_price(), _this->GetArenaForAllocation());
  }
  _impl_.median_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.median_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_median_price().empty()) {
    _this->_impl_.median_price_.Set(from._internal_median_price(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_count_, &from._impl_.group_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.last_timestamp_) -
    reinterpret_cast<char*>(&_impl_.group_count_)) + sizeof(_impl_.last_timestamp_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.MetadataStatistics)
}

inline void MetadataStatistics::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.mean_) {}

    , decltype(_impl_.twap_) {}

    , decltype(_impl_.min_price_) {}

    , decltype(_impl_.max_price_) {}

    , decltype(_impl_.median_price_) {}

    , decltype(_impl_.group_count_) { 0u }

    , decltype(_impl_.records_sample_size_) { 0u }

    , decltype(_impl_.first_timestamp_) { ::int64_t{0} }

    , decltype(_impl_.last_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mean_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mean_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.twap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.twap_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.max_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.max_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.median_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.median_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MetadataStatistics::~MetadataStatistics() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.MetadataStatistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MetadataStatistics::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mean_.Destroy();
  _impl_.twap_.Destroy();
  _impl_.min_price_.Destroy();
  _impl_.max_price_.Destroy();
  _impl_.median_price_.Destroy();
}

void MetadataStatistics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MetadataStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.MetadataStatistics)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mean_.ClearToEmpty();
  _impl_.twap_.ClearToEmpty();
  _impl_.min_price_.ClearToEmpty();
  _impl_.max_price_.ClearToEmpty();
  _impl_.median_price_.ClearToEmpty();
  ::memset(&_impl_.group_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.last_timestamp_) -
      reinterpret_cast<char*>(&_impl_.group_count_)) + sizeof(_impl_.last_timestamp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MetadataStatistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 group_count = 1 [json_name = "groupCount"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.group_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 records_sample_size = 2 [json_name = "recordsSampleSize"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.records_sample_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string mean = 3 [json_name = "mean", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mean();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.MetadataStatistics.mean"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string twap = 4 [json_name = "twap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_twap();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.MetadataStatistics.twap"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 first_timestamp = 5 [json_name = "firstTimestamp"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.first_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_timestamp = 6 [json_name = "lastTimestamp"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.last_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_price = 7 [json_name = "minPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_min_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.MetadataStatistics.min_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string max_price = 8 [json_name = "maxPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_max_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.MetadataStatistics.max_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string median_price = 9 [json_name = "medianPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_median_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.MetadataStatistics.median_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MetadataStatistics::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.MetadataStatistics)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 group_count = 1 [json_name = "groupCount"];
  if (this->_internal_group_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_group_count(), target);
  }

  // uint32 records_sample_size = 2 [json_name = "recordsSampleSize"];
  if (this->_internal_records_sample_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_records_sample_size(), target);
  }

  // string mean = 3 [json_name = "mean", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_mean().empty()) {
    const std::string& _s = this->_internal_mean();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.MetadataStatistics.mean");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string twap = 4 [json_name = "twap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_twap().empty()) {
    const std::string& _s = this->_internal_twap();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.MetadataStatistics.twap");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // int64 first_timestamp = 5 [json_name = "firstTimestamp"];
  if (this->_internal_first_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_first_timestamp(), target);
  }

  // int64 last_timestamp = 6 [json_name = "lastTimestamp"];
  if (this->_internal_last_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_last_timestamp(), target);
  }

  // string min_price = 7 [json_name = "minPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price().empty()) {
    const std::string& _s = this->_internal_min_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.MetadataStatistics.min_price");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // string max_price = 8 [json_name = "maxPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_max_price().empty()) {
    const std::string& _s = this->_internal_max_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.MetadataStatistics.max_price");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string median_price = 9 [json_name = "medianPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_median_price().empty()) {
    const std::string& _s = this->_internal_median_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.MetadataStatistics.median_price");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.MetadataStatistics)
  return target;
}

::size_t MetadataStatistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.MetadataStatistics)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mean = 3 [json_name = "mean", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_mean().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_mean());
  }

  // string twap = 4 [json_name = "twap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_twap().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_twap());
  }

  // string min_price = 7 [json_name = "minPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_price());
  }

  // string max_price = 8 [json_name = "maxPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_max_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_max_price());
  }

  // string median_price = 9 [json_name = "medianPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_median_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_median_price());
  }

  // uint32 group_count = 1 [json_name = "groupCount"];
  if (this->_internal_group_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_group_count());
  }

  // uint32 records_sample_size = 2 [json_name = "recordsSampleSize"];
  if (this->_internal_records_sample_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_records_sample_size());
  }

  // int64 first_timestamp = 5 [json_name = "firstTimestamp"];
  if (this->_internal_first_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_first_timestamp());
  }

  // int64 last_timestamp = 6 [json_name = "lastTimestamp"];
  if (this->_internal_last_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MetadataStatistics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MetadataStatistics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MetadataStatistics::GetClassData() const { return &_class_data_; }


void MetadataStatistics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MetadataStatistics*>(&to_msg);
  auto& from = static_cast<const MetadataStatistics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.MetadataStatistics)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mean().empty()) {
    _this->_internal_set_mean(from._internal_mean());
  }
  if (!from._internal_twap().empty()) {
    _this->_internal_set_twap(from._internal_twap());
  }
  if (!from._internal_min_price().empty()) {
    _this->_internal_set_min_price(from._internal_min_price());
  }
  if (!from._internal_max_price().empty()) {
    _this->_internal_set_max_price(from._internal_max_price());
  }
  if (!from._internal_median_price().empty()) {
    _this->_internal_set_median_price(from._internal_median_price());
  }
  if (from._internal_group_count() != 0) {
    _this->_internal_set_group_count(from._internal_group_count());
  }
  if (from._internal_records_sample_size() != 0) {
    _this->_internal_set_records_sample_size(from._internal_records_sample_size());
  }
  if (from._internal_first_timestamp() != 0) {
    _this->_internal_set_first_timestamp(from._internal_first_timestamp());
  }
  if (from._internal_last_timestamp() != 0) {
    _this->_internal_set_last_timestamp(from._internal_last_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MetadataStatistics::CopyFrom(const MetadataStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.MetadataStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MetadataStatistics::IsInitialized() const {
  return true;
}

void MetadataStatistics::InternalSwap(MetadataStatistics* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mean_, lhs_arena,
                                       &other->_impl_.mean_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.twap_, lhs_arena,
                                       &other->_impl_.twap_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_price_, lhs_arena,
                                       &other->_impl_.min_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.max_price_, lhs_arena,
                                       &other->_impl_.max_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.median_price_, lhs_arena,
                                       &other->_impl_.median_price_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MetadataStatistics, _impl_.last_timestamp_)
      + sizeof(MetadataStatistics::_impl_.last_timestamp_)
      - PROTOBUF_FIELD_OFFSET(MetadataStatistics, _impl_.group_count_)>(
          reinterpret_cast<char*>(&_impl_.group_count_),
          reinterpret_cast<char*>(&other->_impl_.group_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MetadataStatistics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[19]);
}
// ===================================================================

class PriceAttestation::_Internal {
 public:
};

PriceAttestation::PriceAttestation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.oracle.v1beta1.PriceAttestation)
}
PriceAttestation::PriceAttestation(const PriceAttestation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PriceAttestation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_id_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.conf_) {}

    , decltype(_impl_.ema_price_) {}

    , decltype(_impl_.expo_) {}

    , decltype(_impl_.ema_expo_) {}

    , decltype(_impl_.ema_conf_) {}

    , decltype(_impl_.publish_time_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price_id().empty()) {
    _this->_impl_.price_id_.Set(from._internal_price_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.price_, &from._impl_.price_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.publish_time_) -
    reinterpret_cast<char*>(&_impl_.price_)) + sizeof(_impl_.publish_time_));
  // @@protoc_insertion_point(copy_constructor:injective.oracle.v1beta1.PriceAttestation)
}

inline void PriceAttestation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_id_) {}

    , decltype(_impl_.price_) { ::int64_t{0} }

    , decltype(_impl_.conf_) { ::uint64_t{0u} }

    , decltype(_impl_.ema_price_) { ::int64_t{0} }

    , decltype(_impl_.expo_) { 0 }

    , decltype(_impl_.ema_expo_) { 0 }

    , decltype(_impl_.ema_conf_) { ::uint64_t{0u} }

    , decltype(_impl_.publish_time_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PriceAttestation::~PriceAttestation() {
  // @@protoc_insertion_point(destructor:injective.oracle.v1beta1.PriceAttestation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PriceAttestation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_id_.Destroy();
}

void PriceAttestation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PriceAttestation::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.oracle.v1beta1.PriceAttestation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_id_.ClearToEmpty();
  ::memset(&_impl_.price_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.publish_time_) -
      reinterpret_cast<char*>(&_impl_.price_)) + sizeof(_impl_.publish_time_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PriceAttestation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string price_id = 1 [json_name = "priceId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_price_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.oracle.v1beta1.PriceAttestation.price_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 price = 2 [json_name = "price"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 conf = 3 [json_name = "conf"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.conf_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 expo = 4 [json_name = "expo"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.expo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 ema_price = 5 [json_name = "emaPrice"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.ema_price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 ema_conf = 6 [json_name = "emaConf"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.ema_conf_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 ema_expo = 7 [json_name = "emaExpo"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.ema_expo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 publish_time = 8 [json_name = "publishTime"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.publish_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PriceAttestation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.oracle.v1beta1.PriceAttestation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string price_id = 1 [json_name = "priceId"];
  if (!this->_internal_price_id().empty()) {
    const std::string& _s = this->_internal_price_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.oracle.v1beta1.PriceAttestation.price_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int64 price = 2 [json_name = "price"];
  if (this->_internal_price() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_price(), target);
  }

  // uint64 conf = 3 [json_name = "conf"];
  if (this->_internal_conf() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_conf(), target);
  }

  // int32 expo = 4 [json_name = "expo"];
  if (this->_internal_expo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_expo(), target);
  }

  // int64 ema_price = 5 [json_name = "emaPrice"];
  if (this->_internal_ema_price() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_ema_price(), target);
  }

  // uint64 ema_conf = 6 [json_name = "emaConf"];
  if (this->_internal_ema_conf() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_ema_conf(), target);
  }

  // int32 ema_expo = 7 [json_name = "emaExpo"];
  if (this->_internal_ema_expo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_ema_expo(), target);
  }

  // int64 publish_time = 8 [json_name = "publishTime"];
  if (this->_internal_publish_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        8, this->_internal_publish_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.oracle.v1beta1.PriceAttestation)
  return target;
}

::size_t PriceAttestation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.oracle.v1beta1.PriceAttestation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price_id = 1 [json_name = "priceId"];
  if (!this->_internal_price_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price_id());
  }

  // int64 price = 2 [json_name = "price"];
  if (this->_internal_price() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_price());
  }

  // uint64 conf = 3 [json_name = "conf"];
  if (this->_internal_conf() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_conf());
  }

  // int64 ema_price = 5 [json_name = "emaPrice"];
  if (this->_internal_ema_price() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_ema_price());
  }

  // int32 expo = 4 [json_name = "expo"];
  if (this->_internal_expo() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_expo());
  }

  // int32 ema_expo = 7 [json_name = "emaExpo"];
  if (this->_internal_ema_expo() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_ema_expo());
  }

  // uint64 ema_conf = 6 [json_name = "emaConf"];
  if (this->_internal_ema_conf() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_ema_conf());
  }

  // int64 publish_time = 8 [json_name = "publishTime"];
  if (this->_internal_publish_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_publish_time());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PriceAttestation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PriceAttestation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PriceAttestation::GetClassData() const { return &_class_data_; }


void PriceAttestation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PriceAttestation*>(&to_msg);
  auto& from = static_cast<const PriceAttestation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.oracle.v1beta1.PriceAttestation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price_id().empty()) {
    _this->_internal_set_price_id(from._internal_price_id());
  }
  if (from._internal_price() != 0) {
    _this->_internal_set_price(from._internal_price());
  }
  if (from._internal_conf() != 0) {
    _this->_internal_set_conf(from._internal_conf());
  }
  if (from._internal_ema_price() != 0) {
    _this->_internal_set_ema_price(from._internal_ema_price());
  }
  if (from._internal_expo() != 0) {
    _this->_internal_set_expo(from._internal_expo());
  }
  if (from._internal_ema_expo() != 0) {
    _this->_internal_set_ema_expo(from._internal_ema_expo());
  }
  if (from._internal_ema_conf() != 0) {
    _this->_internal_set_ema_conf(from._internal_ema_conf());
  }
  if (from._internal_publish_time() != 0) {
    _this->_internal_set_publish_time(from._internal_publish_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PriceAttestation::CopyFrom(const PriceAttestation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.oracle.v1beta1.PriceAttestation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceAttestation::IsInitialized() const {
  return true;
}

void PriceAttestation::InternalSwap(PriceAttestation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_id_, lhs_arena,
                                       &other->_impl_.price_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PriceAttestation, _impl_.publish_time_)
      + sizeof(PriceAttestation::_impl_.publish_time_)
      - PROTOBUF_FIELD_OFFSET(PriceAttestation, _impl_.price_)>(
          reinterpret_cast<char*>(&_impl_.price_),
          reinterpret_cast<char*>(&other->_impl_.price_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PriceAttestation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_getter, &descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto_once,
      file_level_metadata_injective_2foracle_2fv1beta1_2foracle_2eproto[20]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace oracle
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::Params*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::Params >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::OracleInfo*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::OracleInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::OracleInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::ChainlinkPriceState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::ChainlinkPriceState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::ChainlinkPriceState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::BandPriceState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::BandPriceState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::BandPriceState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PriceFeedState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PriceFeedState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PriceFeedState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::ProviderInfo*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::ProviderInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::ProviderInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::ProviderState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::ProviderState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::ProviderState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::ProviderPriceState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::ProviderPriceState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::ProviderPriceState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PriceFeedInfo*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PriceFeedInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PriceFeedInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PriceFeedPrice*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PriceFeedPrice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PriceFeedPrice >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::CoinbasePriceState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::CoinbasePriceState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::CoinbasePriceState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PriceState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PriceState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PriceState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PythPriceState*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PythPriceState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PythPriceState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::BandOracleRequest*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::BandOracleRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::BandOracleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::BandIBCParams*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::BandIBCParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::BandIBCParams >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::SymbolPriceTimestamp*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::SymbolPriceTimestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::SymbolPriceTimestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::LastPriceTimestamps*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::LastPriceTimestamps >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::LastPriceTimestamps >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PriceRecords*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PriceRecords >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PriceRecords >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PriceRecord*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PriceRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PriceRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::MetadataStatistics*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::MetadataStatistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::MetadataStatistics >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::oracle::v1beta1::PriceAttestation*
Arena::CreateMaybeMessage< ::injective::oracle::v1beta1::PriceAttestation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::oracle::v1beta1::PriceAttestation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
