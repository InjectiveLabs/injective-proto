// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/oracle/v1beta1/oracle.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2foracle_2fv1beta1_2foracle_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2foracle_2fv1beta1_2foracle_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2foracle_2fv1beta1_2foracle_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto;
namespace injective {
namespace oracle {
namespace v1beta1 {
class BandIBCParams;
struct BandIBCParamsDefaultTypeInternal;
extern BandIBCParamsDefaultTypeInternal _BandIBCParams_default_instance_;
class BandOracleRequest;
struct BandOracleRequestDefaultTypeInternal;
extern BandOracleRequestDefaultTypeInternal _BandOracleRequest_default_instance_;
class BandPriceState;
struct BandPriceStateDefaultTypeInternal;
extern BandPriceStateDefaultTypeInternal _BandPriceState_default_instance_;
class ChainlinkPriceState;
struct ChainlinkPriceStateDefaultTypeInternal;
extern ChainlinkPriceStateDefaultTypeInternal _ChainlinkPriceState_default_instance_;
class CoinbasePriceState;
struct CoinbasePriceStateDefaultTypeInternal;
extern CoinbasePriceStateDefaultTypeInternal _CoinbasePriceState_default_instance_;
class LastPriceTimestamps;
struct LastPriceTimestampsDefaultTypeInternal;
extern LastPriceTimestampsDefaultTypeInternal _LastPriceTimestamps_default_instance_;
class MetadataStatistics;
struct MetadataStatisticsDefaultTypeInternal;
extern MetadataStatisticsDefaultTypeInternal _MetadataStatistics_default_instance_;
class OracleInfo;
struct OracleInfoDefaultTypeInternal;
extern OracleInfoDefaultTypeInternal _OracleInfo_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
class PriceAttestation;
struct PriceAttestationDefaultTypeInternal;
extern PriceAttestationDefaultTypeInternal _PriceAttestation_default_instance_;
class PriceFeedInfo;
struct PriceFeedInfoDefaultTypeInternal;
extern PriceFeedInfoDefaultTypeInternal _PriceFeedInfo_default_instance_;
class PriceFeedPrice;
struct PriceFeedPriceDefaultTypeInternal;
extern PriceFeedPriceDefaultTypeInternal _PriceFeedPrice_default_instance_;
class PriceFeedState;
struct PriceFeedStateDefaultTypeInternal;
extern PriceFeedStateDefaultTypeInternal _PriceFeedState_default_instance_;
class PriceRecord;
struct PriceRecordDefaultTypeInternal;
extern PriceRecordDefaultTypeInternal _PriceRecord_default_instance_;
class PriceRecords;
struct PriceRecordsDefaultTypeInternal;
extern PriceRecordsDefaultTypeInternal _PriceRecords_default_instance_;
class PriceState;
struct PriceStateDefaultTypeInternal;
extern PriceStateDefaultTypeInternal _PriceState_default_instance_;
class ProviderInfo;
struct ProviderInfoDefaultTypeInternal;
extern ProviderInfoDefaultTypeInternal _ProviderInfo_default_instance_;
class ProviderPriceState;
struct ProviderPriceStateDefaultTypeInternal;
extern ProviderPriceStateDefaultTypeInternal _ProviderPriceState_default_instance_;
class ProviderState;
struct ProviderStateDefaultTypeInternal;
extern ProviderStateDefaultTypeInternal _ProviderState_default_instance_;
class PythPriceState;
struct PythPriceStateDefaultTypeInternal;
extern PythPriceStateDefaultTypeInternal _PythPriceState_default_instance_;
class SymbolPriceTimestamp;
struct SymbolPriceTimestampDefaultTypeInternal;
extern SymbolPriceTimestampDefaultTypeInternal _SymbolPriceTimestamp_default_instance_;
}  // namespace v1beta1
}  // namespace oracle
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::oracle::v1beta1::BandIBCParams* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::BandIBCParams>(Arena*);
template <>
::injective::oracle::v1beta1::BandOracleRequest* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::BandOracleRequest>(Arena*);
template <>
::injective::oracle::v1beta1::BandPriceState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::BandPriceState>(Arena*);
template <>
::injective::oracle::v1beta1::ChainlinkPriceState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::ChainlinkPriceState>(Arena*);
template <>
::injective::oracle::v1beta1::CoinbasePriceState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::CoinbasePriceState>(Arena*);
template <>
::injective::oracle::v1beta1::LastPriceTimestamps* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::LastPriceTimestamps>(Arena*);
template <>
::injective::oracle::v1beta1::MetadataStatistics* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::MetadataStatistics>(Arena*);
template <>
::injective::oracle::v1beta1::OracleInfo* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::OracleInfo>(Arena*);
template <>
::injective::oracle::v1beta1::Params* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::Params>(Arena*);
template <>
::injective::oracle::v1beta1::PriceAttestation* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PriceAttestation>(Arena*);
template <>
::injective::oracle::v1beta1::PriceFeedInfo* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PriceFeedInfo>(Arena*);
template <>
::injective::oracle::v1beta1::PriceFeedPrice* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PriceFeedPrice>(Arena*);
template <>
::injective::oracle::v1beta1::PriceFeedState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PriceFeedState>(Arena*);
template <>
::injective::oracle::v1beta1::PriceRecord* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PriceRecord>(Arena*);
template <>
::injective::oracle::v1beta1::PriceRecords* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PriceRecords>(Arena*);
template <>
::injective::oracle::v1beta1::PriceState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PriceState>(Arena*);
template <>
::injective::oracle::v1beta1::ProviderInfo* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::ProviderInfo>(Arena*);
template <>
::injective::oracle::v1beta1::ProviderPriceState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::ProviderPriceState>(Arena*);
template <>
::injective::oracle::v1beta1::ProviderState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::ProviderState>(Arena*);
template <>
::injective::oracle::v1beta1::PythPriceState* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::PythPriceState>(Arena*);
template <>
::injective::oracle::v1beta1::SymbolPriceTimestamp* Arena::CreateMaybeMessage<::injective::oracle::v1beta1::SymbolPriceTimestamp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace oracle {
namespace v1beta1 {
enum OracleType : int {
  Unspecified = 0,
  Band = 1,
  PriceFeed = 2,
  Coinbase = 3,
  Chainlink = 4,
  Razor = 5,
  Dia = 6,
  API3 = 7,
  Uma = 8,
  Pyth = 9,
  BandIBC = 10,
  Provider = 11,
  OracleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OracleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OracleType_IsValid(int value);
constexpr OracleType OracleType_MIN = static_cast<OracleType>(0);
constexpr OracleType OracleType_MAX = static_cast<OracleType>(11);
constexpr int OracleType_ARRAYSIZE = 11 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OracleType_descriptor();
template <typename T>
const std::string& OracleType_Name(T value) {
  static_assert(std::is_same<T, OracleType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OracleType_Name().");
  return OracleType_Name(static_cast<OracleType>(value));
}
template <>
inline const std::string& OracleType_Name(OracleType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OracleType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool OracleType_Parse(absl::string_view name, OracleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OracleType>(
      OracleType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Params(const Params& from);
  Params(Params&& from) noexcept
    : Params() {
    *this = ::std::move(from);
  }

  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
               &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Params& a, Params& b) {
    a.Swap(&b);
  }
  inline void Swap(Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Params& from) {
    Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.Params";
  }
  protected:
  explicit Params(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPythContractFieldNumber = 1,
  };
  // string pyth_contract = 1 [json_name = "pythContract"];
  void clear_pyth_contract() ;
  const std::string& pyth_contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pyth_contract(Arg_&& arg, Args_... args);
  std::string* mutable_pyth_contract();
  PROTOBUF_NODISCARD std::string* release_pyth_contract();
  void set_allocated_pyth_contract(std::string* ptr);

  private:
  const std::string& _internal_pyth_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pyth_contract(
      const std::string& value);
  std::string* _internal_mutable_pyth_contract();

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pyth_contract_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class OracleInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.OracleInfo) */ {
 public:
  inline OracleInfo() : OracleInfo(nullptr) {}
  ~OracleInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OracleInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OracleInfo(const OracleInfo& from);
  OracleInfo(OracleInfo&& from) noexcept
    : OracleInfo() {
    *this = ::std::move(from);
  }

  inline OracleInfo& operator=(const OracleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OracleInfo& operator=(OracleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OracleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OracleInfo* internal_default_instance() {
    return reinterpret_cast<const OracleInfo*>(
               &_OracleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OracleInfo& a, OracleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OracleInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OracleInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OracleInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OracleInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OracleInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OracleInfo& from) {
    OracleInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OracleInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.OracleInfo";
  }
  protected:
  explicit OracleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kOracleTypeFieldNumber = 2,
    kScaleFactorFieldNumber = 3,
  };
  // string symbol = 1 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 2 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // uint32 scale_factor = 3 [json_name = "scaleFactor"];
  void clear_scale_factor() ;
  ::uint32_t scale_factor() const;
  void set_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_scale_factor() const;
  void _internal_set_scale_factor(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.OracleInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    int oracle_type_;
    ::uint32_t scale_factor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class ChainlinkPriceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.ChainlinkPriceState) */ {
 public:
  inline ChainlinkPriceState() : ChainlinkPriceState(nullptr) {}
  ~ChainlinkPriceState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChainlinkPriceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChainlinkPriceState(const ChainlinkPriceState& from);
  ChainlinkPriceState(ChainlinkPriceState&& from) noexcept
    : ChainlinkPriceState() {
    *this = ::std::move(from);
  }

  inline ChainlinkPriceState& operator=(const ChainlinkPriceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainlinkPriceState& operator=(ChainlinkPriceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChainlinkPriceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChainlinkPriceState* internal_default_instance() {
    return reinterpret_cast<const ChainlinkPriceState*>(
               &_ChainlinkPriceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChainlinkPriceState& a, ChainlinkPriceState& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainlinkPriceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainlinkPriceState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChainlinkPriceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChainlinkPriceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChainlinkPriceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChainlinkPriceState& from) {
    ChainlinkPriceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainlinkPriceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.ChainlinkPriceState";
  }
  protected:
  explicit ChainlinkPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedIdFieldNumber = 1,
    kAnswerFieldNumber = 2,
    kPriceStateFieldNumber = 4,
    kTimestampFieldNumber = 3,
  };
  // string feed_id = 1 [json_name = "feedId"];
  void clear_feed_id() ;
  const std::string& feed_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_id(Arg_&& arg, Args_... args);
  std::string* mutable_feed_id();
  PROTOBUF_NODISCARD std::string* release_feed_id();
  void set_allocated_feed_id(std::string* ptr);

  private:
  const std::string& _internal_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_id(
      const std::string& value);
  std::string* _internal_mutable_feed_id();

  public:
  // string answer = 2 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_answer() ;
  const std::string& answer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_answer(Arg_&& arg, Args_... args);
  std::string* mutable_answer();
  PROTOBUF_NODISCARD std::string* release_answer();
  void set_allocated_answer(std::string* ptr);

  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(
      const std::string& value);
  std::string* _internal_mutable_answer();

  public:
  // .injective.oracle.v1beta1.PriceState price_state = 4 [json_name = "priceState", (.gogoproto.nullable) = false];
  bool has_price_state() const;
  void clear_price_state() ;
  const ::injective::oracle::v1beta1::PriceState& price_state() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::PriceState* release_price_state();
  ::injective::oracle::v1beta1::PriceState* mutable_price_state();
  void set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state);
  private:
  const ::injective::oracle::v1beta1::PriceState& _internal_price_state() const;
  ::injective::oracle::v1beta1::PriceState* _internal_mutable_price_state();
  public:
  void unsafe_arena_set_allocated_price_state(
      ::injective::oracle::v1beta1::PriceState* price_state);
  ::injective::oracle::v1beta1::PriceState* unsafe_arena_release_price_state();
  // uint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.ChainlinkPriceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feed_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr answer_;
    ::injective::oracle::v1beta1::PriceState* price_state_;
    ::uint64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class BandPriceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.BandPriceState) */ {
 public:
  inline BandPriceState() : BandPriceState(nullptr) {}
  ~BandPriceState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BandPriceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandPriceState(const BandPriceState& from);
  BandPriceState(BandPriceState&& from) noexcept
    : BandPriceState() {
    *this = ::std::move(from);
  }

  inline BandPriceState& operator=(const BandPriceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandPriceState& operator=(BandPriceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BandPriceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandPriceState* internal_default_instance() {
    return reinterpret_cast<const BandPriceState*>(
               &_BandPriceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BandPriceState& a, BandPriceState& b) {
    a.Swap(&b);
  }
  inline void Swap(BandPriceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandPriceState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandPriceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandPriceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BandPriceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BandPriceState& from) {
    BandPriceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BandPriceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.BandPriceState";
  }
  protected:
  explicit BandPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kRateFieldNumber = 2,
    kPriceStateFieldNumber = 5,
    kResolveTimeFieldNumber = 3,
    kRequestIDFieldNumber = 4,
  };
  // string symbol = 1 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string rate = 2 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_rate() ;
  const std::string& rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rate(Arg_&& arg, Args_... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* ptr);

  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(
      const std::string& value);
  std::string* _internal_mutable_rate();

  public:
  // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
  bool has_price_state() const;
  void clear_price_state() ;
  const ::injective::oracle::v1beta1::PriceState& price_state() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::PriceState* release_price_state();
  ::injective::oracle::v1beta1::PriceState* mutable_price_state();
  void set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state);
  private:
  const ::injective::oracle::v1beta1::PriceState& _internal_price_state() const;
  ::injective::oracle::v1beta1::PriceState* _internal_mutable_price_state();
  public:
  void unsafe_arena_set_allocated_price_state(
      ::injective::oracle::v1beta1::PriceState* price_state);
  ::injective::oracle::v1beta1::PriceState* unsafe_arena_release_price_state();
  // uint64 resolve_time = 3 [json_name = "resolveTime"];
  void clear_resolve_time() ;
  ::uint64_t resolve_time() const;
  void set_resolve_time(::uint64_t value);

  private:
  ::uint64_t _internal_resolve_time() const;
  void _internal_set_resolve_time(::uint64_t value);

  public:
  // uint64 request_ID = 4 [json_name = "requestID"];
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.BandPriceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
    ::injective::oracle::v1beta1::PriceState* price_state_;
    ::uint64_t resolve_time_;
    ::uint64_t request_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PriceFeedState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PriceFeedState) */ {
 public:
  inline PriceFeedState() : PriceFeedState(nullptr) {}
  ~PriceFeedState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceFeedState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceFeedState(const PriceFeedState& from);
  PriceFeedState(PriceFeedState&& from) noexcept
    : PriceFeedState() {
    *this = ::std::move(from);
  }

  inline PriceFeedState& operator=(const PriceFeedState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceFeedState& operator=(PriceFeedState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceFeedState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceFeedState* internal_default_instance() {
    return reinterpret_cast<const PriceFeedState*>(
               &_PriceFeedState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PriceFeedState& a, PriceFeedState& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceFeedState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceFeedState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceFeedState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceFeedState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceFeedState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceFeedState& from) {
    PriceFeedState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceFeedState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PriceFeedState";
  }
  protected:
  explicit PriceFeedState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelayersFieldNumber = 4,
    kBaseFieldNumber = 1,
    kQuoteFieldNumber = 2,
    kPriceStateFieldNumber = 3,
  };
  // repeated string relayers = 4 [json_name = "relayers"];
  int relayers_size() const;
  private:
  int _internal_relayers_size() const;

  public:
  void clear_relayers() ;
  const std::string& relayers(int index) const;
  std::string* mutable_relayers(int index);
  void set_relayers(int index, const std::string& value);
  void set_relayers(int index, std::string&& value);
  void set_relayers(int index, const char* value);
  void set_relayers(int index, const char* value, std::size_t size);
  void set_relayers(int index, absl::string_view value);
  std::string* add_relayers();
  void add_relayers(const std::string& value);
  void add_relayers(std::string&& value);
  void add_relayers(const char* value);
  void add_relayers(const char* value, std::size_t size);
  void add_relayers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& relayers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_relayers();

  private:
  const std::string& _internal_relayers(int index) const;
  std::string* _internal_add_relayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_relayers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_relayers();

  public:
  // string base = 1 [json_name = "base"];
  void clear_base() ;
  const std::string& base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base(Arg_&& arg, Args_... args);
  std::string* mutable_base();
  PROTOBUF_NODISCARD std::string* release_base();
  void set_allocated_base(std::string* ptr);

  private:
  const std::string& _internal_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base(
      const std::string& value);
  std::string* _internal_mutable_base();

  public:
  // string quote = 2 [json_name = "quote"];
  void clear_quote() ;
  const std::string& quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote(Arg_&& arg, Args_... args);
  std::string* mutable_quote();
  PROTOBUF_NODISCARD std::string* release_quote();
  void set_allocated_quote(std::string* ptr);

  private:
  const std::string& _internal_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote(
      const std::string& value);
  std::string* _internal_mutable_quote();

  public:
  // .injective.oracle.v1beta1.PriceState price_state = 3 [json_name = "priceState"];
  bool has_price_state() const;
  void clear_price_state() ;
  const ::injective::oracle::v1beta1::PriceState& price_state() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::PriceState* release_price_state();
  ::injective::oracle::v1beta1::PriceState* mutable_price_state();
  void set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state);
  private:
  const ::injective::oracle::v1beta1::PriceState& _internal_price_state() const;
  ::injective::oracle::v1beta1::PriceState* _internal_mutable_price_state();
  public:
  void unsafe_arena_set_allocated_price_state(
      ::injective::oracle::v1beta1::PriceState* price_state);
  ::injective::oracle::v1beta1::PriceState* unsafe_arena_release_price_state();
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PriceFeedState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> relayers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_;
    ::injective::oracle::v1beta1::PriceState* price_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class ProviderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.ProviderInfo) */ {
 public:
  inline ProviderInfo() : ProviderInfo(nullptr) {}
  ~ProviderInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProviderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProviderInfo(const ProviderInfo& from);
  ProviderInfo(ProviderInfo&& from) noexcept
    : ProviderInfo() {
    *this = ::std::move(from);
  }

  inline ProviderInfo& operator=(const ProviderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProviderInfo& operator=(ProviderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProviderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProviderInfo* internal_default_instance() {
    return reinterpret_cast<const ProviderInfo*>(
               &_ProviderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProviderInfo& a, ProviderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ProviderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProviderInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProviderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProviderInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProviderInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProviderInfo& from) {
    ProviderInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProviderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.ProviderInfo";
  }
  protected:
  explicit ProviderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelayersFieldNumber = 2,
    kProviderFieldNumber = 1,
  };
  // repeated string relayers = 2 [json_name = "relayers"];
  int relayers_size() const;
  private:
  int _internal_relayers_size() const;

  public:
  void clear_relayers() ;
  const std::string& relayers(int index) const;
  std::string* mutable_relayers(int index);
  void set_relayers(int index, const std::string& value);
  void set_relayers(int index, std::string&& value);
  void set_relayers(int index, const char* value);
  void set_relayers(int index, const char* value, std::size_t size);
  void set_relayers(int index, absl::string_view value);
  std::string* add_relayers();
  void add_relayers(const std::string& value);
  void add_relayers(std::string&& value);
  void add_relayers(const char* value);
  void add_relayers(const char* value, std::size_t size);
  void add_relayers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& relayers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_relayers();

  private:
  const std::string& _internal_relayers(int index) const;
  std::string* _internal_add_relayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_relayers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_relayers();

  public:
  // string provider = 1 [json_name = "provider"];
  void clear_provider() ;
  const std::string& provider() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_provider(Arg_&& arg, Args_... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* ptr);

  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(
      const std::string& value);
  std::string* _internal_mutable_provider();

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.ProviderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> relayers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class ProviderState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.ProviderState) */ {
 public:
  inline ProviderState() : ProviderState(nullptr) {}
  ~ProviderState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProviderState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProviderState(const ProviderState& from);
  ProviderState(ProviderState&& from) noexcept
    : ProviderState() {
    *this = ::std::move(from);
  }

  inline ProviderState& operator=(const ProviderState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProviderState& operator=(ProviderState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProviderState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProviderState* internal_default_instance() {
    return reinterpret_cast<const ProviderState*>(
               &_ProviderState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProviderState& a, ProviderState& b) {
    a.Swap(&b);
  }
  inline void Swap(ProviderState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProviderState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProviderState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProviderState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProviderState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProviderState& from) {
    ProviderState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProviderState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.ProviderState";
  }
  protected:
  explicit ProviderState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProviderPriceStatesFieldNumber = 2,
    kProviderInfoFieldNumber = 1,
  };
  // repeated .injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2 [json_name = "providerPriceStates"];
  int provider_price_states_size() const;
  private:
  int _internal_provider_price_states_size() const;

  public:
  void clear_provider_price_states() ;
  ::injective::oracle::v1beta1::ProviderPriceState* mutable_provider_price_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::ProviderPriceState >*
      mutable_provider_price_states();
  private:
  const ::injective::oracle::v1beta1::ProviderPriceState& _internal_provider_price_states(int index) const;
  ::injective::oracle::v1beta1::ProviderPriceState* _internal_add_provider_price_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::ProviderPriceState>& _internal_provider_price_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::ProviderPriceState>* _internal_mutable_provider_price_states();
  public:
  const ::injective::oracle::v1beta1::ProviderPriceState& provider_price_states(int index) const;
  ::injective::oracle::v1beta1::ProviderPriceState* add_provider_price_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::ProviderPriceState >&
      provider_price_states() const;
  // .injective.oracle.v1beta1.ProviderInfo provider_info = 1 [json_name = "providerInfo"];
  bool has_provider_info() const;
  void clear_provider_info() ;
  const ::injective::oracle::v1beta1::ProviderInfo& provider_info() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::ProviderInfo* release_provider_info();
  ::injective::oracle::v1beta1::ProviderInfo* mutable_provider_info();
  void set_allocated_provider_info(::injective::oracle::v1beta1::ProviderInfo* provider_info);
  private:
  const ::injective::oracle::v1beta1::ProviderInfo& _internal_provider_info() const;
  ::injective::oracle::v1beta1::ProviderInfo* _internal_mutable_provider_info();
  public:
  void unsafe_arena_set_allocated_provider_info(
      ::injective::oracle::v1beta1::ProviderInfo* provider_info);
  ::injective::oracle::v1beta1::ProviderInfo* unsafe_arena_release_provider_info();
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.ProviderState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::ProviderPriceState > provider_price_states_;
    ::injective::oracle::v1beta1::ProviderInfo* provider_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class ProviderPriceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.ProviderPriceState) */ {
 public:
  inline ProviderPriceState() : ProviderPriceState(nullptr) {}
  ~ProviderPriceState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProviderPriceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProviderPriceState(const ProviderPriceState& from);
  ProviderPriceState(ProviderPriceState&& from) noexcept
    : ProviderPriceState() {
    *this = ::std::move(from);
  }

  inline ProviderPriceState& operator=(const ProviderPriceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProviderPriceState& operator=(ProviderPriceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProviderPriceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProviderPriceState* internal_default_instance() {
    return reinterpret_cast<const ProviderPriceState*>(
               &_ProviderPriceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProviderPriceState& a, ProviderPriceState& b) {
    a.Swap(&b);
  }
  inline void Swap(ProviderPriceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProviderPriceState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProviderPriceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProviderPriceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProviderPriceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProviderPriceState& from) {
    ProviderPriceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProviderPriceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.ProviderPriceState";
  }
  protected:
  explicit ProviderPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string symbol = 1 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // .injective.oracle.v1beta1.PriceState state = 2 [json_name = "state"];
  bool has_state() const;
  void clear_state() ;
  const ::injective::oracle::v1beta1::PriceState& state() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::PriceState* release_state();
  ::injective::oracle::v1beta1::PriceState* mutable_state();
  void set_allocated_state(::injective::oracle::v1beta1::PriceState* state);
  private:
  const ::injective::oracle::v1beta1::PriceState& _internal_state() const;
  ::injective::oracle::v1beta1::PriceState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::injective::oracle::v1beta1::PriceState* state);
  ::injective::oracle::v1beta1::PriceState* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.ProviderPriceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::injective::oracle::v1beta1::PriceState* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PriceFeedInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PriceFeedInfo) */ {
 public:
  inline PriceFeedInfo() : PriceFeedInfo(nullptr) {}
  ~PriceFeedInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceFeedInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceFeedInfo(const PriceFeedInfo& from);
  PriceFeedInfo(PriceFeedInfo&& from) noexcept
    : PriceFeedInfo() {
    *this = ::std::move(from);
  }

  inline PriceFeedInfo& operator=(const PriceFeedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceFeedInfo& operator=(PriceFeedInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceFeedInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceFeedInfo* internal_default_instance() {
    return reinterpret_cast<const PriceFeedInfo*>(
               &_PriceFeedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PriceFeedInfo& a, PriceFeedInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceFeedInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceFeedInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceFeedInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceFeedInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceFeedInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceFeedInfo& from) {
    PriceFeedInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceFeedInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PriceFeedInfo";
  }
  protected:
  explicit PriceFeedInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kQuoteFieldNumber = 2,
  };
  // string base = 1 [json_name = "base"];
  void clear_base() ;
  const std::string& base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base(Arg_&& arg, Args_... args);
  std::string* mutable_base();
  PROTOBUF_NODISCARD std::string* release_base();
  void set_allocated_base(std::string* ptr);

  private:
  const std::string& _internal_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base(
      const std::string& value);
  std::string* _internal_mutable_base();

  public:
  // string quote = 2 [json_name = "quote"];
  void clear_quote() ;
  const std::string& quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote(Arg_&& arg, Args_... args);
  std::string* mutable_quote();
  PROTOBUF_NODISCARD std::string* release_quote();
  void set_allocated_quote(std::string* ptr);

  private:
  const std::string& _internal_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote(
      const std::string& value);
  std::string* _internal_mutable_quote();

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PriceFeedInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PriceFeedPrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PriceFeedPrice) */ {
 public:
  inline PriceFeedPrice() : PriceFeedPrice(nullptr) {}
  ~PriceFeedPrice() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceFeedPrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceFeedPrice(const PriceFeedPrice& from);
  PriceFeedPrice(PriceFeedPrice&& from) noexcept
    : PriceFeedPrice() {
    *this = ::std::move(from);
  }

  inline PriceFeedPrice& operator=(const PriceFeedPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceFeedPrice& operator=(PriceFeedPrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceFeedPrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceFeedPrice* internal_default_instance() {
    return reinterpret_cast<const PriceFeedPrice*>(
               &_PriceFeedPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PriceFeedPrice& a, PriceFeedPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceFeedPrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceFeedPrice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceFeedPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceFeedPrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceFeedPrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceFeedPrice& from) {
    PriceFeedPrice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceFeedPrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PriceFeedPrice";
  }
  protected:
  explicit PriceFeedPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
  };
  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PriceFeedPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class CoinbasePriceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.CoinbasePriceState) */ {
 public:
  inline CoinbasePriceState() : CoinbasePriceState(nullptr) {}
  ~CoinbasePriceState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CoinbasePriceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoinbasePriceState(const CoinbasePriceState& from);
  CoinbasePriceState(CoinbasePriceState&& from) noexcept
    : CoinbasePriceState() {
    *this = ::std::move(from);
  }

  inline CoinbasePriceState& operator=(const CoinbasePriceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoinbasePriceState& operator=(CoinbasePriceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoinbasePriceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoinbasePriceState* internal_default_instance() {
    return reinterpret_cast<const CoinbasePriceState*>(
               &_CoinbasePriceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CoinbasePriceState& a, CoinbasePriceState& b) {
    a.Swap(&b);
  }
  inline void Swap(CoinbasePriceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoinbasePriceState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoinbasePriceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoinbasePriceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoinbasePriceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoinbasePriceState& from) {
    CoinbasePriceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoinbasePriceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.CoinbasePriceState";
  }
  protected:
  explicit CoinbasePriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kKeyFieldNumber = 3,
    kPriceStateFieldNumber = 5,
    kTimestampFieldNumber = 2,
    kValueFieldNumber = 4,
  };
  // string kind = 1 [json_name = "kind"];
  void clear_kind() ;
  const std::string& kind() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_kind(Arg_&& arg, Args_... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* ptr);

  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(
      const std::string& value);
  std::string* _internal_mutable_kind();

  public:
  // string key = 3 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
  bool has_price_state() const;
  void clear_price_state() ;
  const ::injective::oracle::v1beta1::PriceState& price_state() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::PriceState* release_price_state();
  ::injective::oracle::v1beta1::PriceState* mutable_price_state();
  void set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state);
  private:
  const ::injective::oracle::v1beta1::PriceState& _internal_price_state() const;
  ::injective::oracle::v1beta1::PriceState* _internal_mutable_price_state();
  public:
  void unsafe_arena_set_allocated_price_state(
      ::injective::oracle::v1beta1::PriceState* price_state);
  ::injective::oracle::v1beta1::PriceState* unsafe_arena_release_price_state();
  // uint64 timestamp = 2 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // uint64 value = 4 [json_name = "value"];
  void clear_value() ;
  ::uint64_t value() const;
  void set_value(::uint64_t value);

  private:
  ::uint64_t _internal_value() const;
  void _internal_set_value(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.CoinbasePriceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::injective::oracle::v1beta1::PriceState* price_state_;
    ::uint64_t timestamp_;
    ::uint64_t value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PriceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PriceState) */ {
 public:
  inline PriceState() : PriceState(nullptr) {}
  ~PriceState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceState(const PriceState& from);
  PriceState(PriceState&& from) noexcept
    : PriceState() {
    *this = ::std::move(from);
  }

  inline PriceState& operator=(const PriceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceState& operator=(PriceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceState* internal_default_instance() {
    return reinterpret_cast<const PriceState*>(
               &_PriceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PriceState& a, PriceState& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceState& from) {
    PriceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PriceState";
  }
  protected:
  explicit PriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kCumulativePriceFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_cumulative_price() ;
  const std::string& cumulative_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cumulative_price(Arg_&& arg, Args_... args);
  std::string* mutable_cumulative_price();
  PROTOBUF_NODISCARD std::string* release_cumulative_price();
  void set_allocated_cumulative_price(std::string* ptr);

  private:
  const std::string& _internal_cumulative_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cumulative_price(
      const std::string& value);
  std::string* _internal_mutable_cumulative_price();

  public:
  // int64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PriceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cumulative_price_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PythPriceState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PythPriceState) */ {
 public:
  inline PythPriceState() : PythPriceState(nullptr) {}
  ~PythPriceState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PythPriceState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PythPriceState(const PythPriceState& from);
  PythPriceState(PythPriceState&& from) noexcept
    : PythPriceState() {
    *this = ::std::move(from);
  }

  inline PythPriceState& operator=(const PythPriceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PythPriceState& operator=(PythPriceState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PythPriceState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PythPriceState* internal_default_instance() {
    return reinterpret_cast<const PythPriceState*>(
               &_PythPriceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PythPriceState& a, PythPriceState& b) {
    a.Swap(&b);
  }
  inline void Swap(PythPriceState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PythPriceState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PythPriceState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PythPriceState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PythPriceState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PythPriceState& from) {
    PythPriceState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PythPriceState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PythPriceState";
  }
  protected:
  explicit PythPriceState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceIdFieldNumber = 1,
    kEmaPriceFieldNumber = 2,
    kEmaConfFieldNumber = 3,
    kConfFieldNumber = 4,
    kPriceStateFieldNumber = 6,
    kPublishTimeFieldNumber = 5,
  };
  // string price_id = 1 [json_name = "priceId"];
  void clear_price_id() ;
  const std::string& price_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price_id(Arg_&& arg, Args_... args);
  std::string* mutable_price_id();
  PROTOBUF_NODISCARD std::string* release_price_id();
  void set_allocated_price_id(std::string* ptr);

  private:
  const std::string& _internal_price_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price_id(
      const std::string& value);
  std::string* _internal_mutable_price_id();

  public:
  // string ema_price = 2 [json_name = "emaPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_ema_price() ;
  const std::string& ema_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ema_price(Arg_&& arg, Args_... args);
  std::string* mutable_ema_price();
  PROTOBUF_NODISCARD std::string* release_ema_price();
  void set_allocated_ema_price(std::string* ptr);

  private:
  const std::string& _internal_ema_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ema_price(
      const std::string& value);
  std::string* _internal_mutable_ema_price();

  public:
  // string ema_conf = 3 [json_name = "emaConf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_ema_conf() ;
  const std::string& ema_conf() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ema_conf(Arg_&& arg, Args_... args);
  std::string* mutable_ema_conf();
  PROTOBUF_NODISCARD std::string* release_ema_conf();
  void set_allocated_ema_conf(std::string* ptr);

  private:
  const std::string& _internal_ema_conf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ema_conf(
      const std::string& value);
  std::string* _internal_mutable_ema_conf();

  public:
  // string conf = 4 [json_name = "conf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_conf() ;
  const std::string& conf() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conf(Arg_&& arg, Args_... args);
  std::string* mutable_conf();
  PROTOBUF_NODISCARD std::string* release_conf();
  void set_allocated_conf(std::string* ptr);

  private:
  const std::string& _internal_conf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conf(
      const std::string& value);
  std::string* _internal_mutable_conf();

  public:
  // .injective.oracle.v1beta1.PriceState price_state = 6 [json_name = "priceState", (.gogoproto.nullable) = false];
  bool has_price_state() const;
  void clear_price_state() ;
  const ::injective::oracle::v1beta1::PriceState& price_state() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::PriceState* release_price_state();
  ::injective::oracle::v1beta1::PriceState* mutable_price_state();
  void set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state);
  private:
  const ::injective::oracle::v1beta1::PriceState& _internal_price_state() const;
  ::injective::oracle::v1beta1::PriceState* _internal_mutable_price_state();
  public:
  void unsafe_arena_set_allocated_price_state(
      ::injective::oracle::v1beta1::PriceState* price_state);
  ::injective::oracle::v1beta1::PriceState* unsafe_arena_release_price_state();
  // uint64 publish_time = 5 [json_name = "publishTime"];
  void clear_publish_time() ;
  ::uint64_t publish_time() const;
  void set_publish_time(::uint64_t value);

  private:
  ::uint64_t _internal_publish_time() const;
  void _internal_set_publish_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PythPriceState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ema_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ema_conf_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conf_;
    ::injective::oracle::v1beta1::PriceState* price_state_;
    ::uint64_t publish_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class BandOracleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.BandOracleRequest) */ {
 public:
  inline BandOracleRequest() : BandOracleRequest(nullptr) {}
  ~BandOracleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BandOracleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandOracleRequest(const BandOracleRequest& from);
  BandOracleRequest(BandOracleRequest&& from) noexcept
    : BandOracleRequest() {
    *this = ::std::move(from);
  }

  inline BandOracleRequest& operator=(const BandOracleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandOracleRequest& operator=(BandOracleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BandOracleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandOracleRequest* internal_default_instance() {
    return reinterpret_cast<const BandOracleRequest*>(
               &_BandOracleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BandOracleRequest& a, BandOracleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BandOracleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandOracleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandOracleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandOracleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BandOracleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BandOracleRequest& from) {
    BandOracleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BandOracleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.BandOracleRequest";
  }
  protected:
  explicit BandOracleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolsFieldNumber = 3,
    kFeeLimitFieldNumber = 6,
    kRequestIdFieldNumber = 1,
    kOracleScriptIdFieldNumber = 2,
    kAskCountFieldNumber = 4,
    kMinCountFieldNumber = 5,
    kPrepareGasFieldNumber = 7,
    kExecuteGasFieldNumber = 8,
    kMinSourceCountFieldNumber = 9,
  };
  // repeated string symbols = 3 [json_name = "symbols"];
  int symbols_size() const;
  private:
  int _internal_symbols_size() const;

  public:
  void clear_symbols() ;
  const std::string& symbols(int index) const;
  std::string* mutable_symbols(int index);
  void set_symbols(int index, const std::string& value);
  void set_symbols(int index, std::string&& value);
  void set_symbols(int index, const char* value);
  void set_symbols(int index, const char* value, std::size_t size);
  void set_symbols(int index, absl::string_view value);
  std::string* add_symbols();
  void add_symbols(const std::string& value);
  void add_symbols(std::string&& value);
  void add_symbols(const char* value);
  void add_symbols(const char* value, std::size_t size);
  void add_symbols(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& symbols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_symbols();

  private:
  const std::string& _internal_symbols(int index) const;
  std::string* _internal_add_symbols();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_symbols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_symbols();

  public:
  // repeated .cosmos.base.v1beta1.Coin fee_limit = 6 [json_name = "feeLimit", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  int fee_limit_size() const;
  private:
  int _internal_fee_limit_size() const;

  public:
  void clear_fee_limit() ;
  ::cosmos::base::v1beta1::Coin* mutable_fee_limit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_fee_limit();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_fee_limit(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_fee_limit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_fee_limit() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_fee_limit();
  public:
  const ::cosmos::base::v1beta1::Coin& fee_limit(int index) const;
  ::cosmos::base::v1beta1::Coin* add_fee_limit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      fee_limit() const;
  // uint64 request_id = 1 [json_name = "requestId"];
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // int64 oracle_script_id = 2 [json_name = "oracleScriptId"];
  void clear_oracle_script_id() ;
  ::int64_t oracle_script_id() const;
  void set_oracle_script_id(::int64_t value);

  private:
  ::int64_t _internal_oracle_script_id() const;
  void _internal_set_oracle_script_id(::int64_t value);

  public:
  // uint64 ask_count = 4 [json_name = "askCount"];
  void clear_ask_count() ;
  ::uint64_t ask_count() const;
  void set_ask_count(::uint64_t value);

  private:
  ::uint64_t _internal_ask_count() const;
  void _internal_set_ask_count(::uint64_t value);

  public:
  // uint64 min_count = 5 [json_name = "minCount"];
  void clear_min_count() ;
  ::uint64_t min_count() const;
  void set_min_count(::uint64_t value);

  private:
  ::uint64_t _internal_min_count() const;
  void _internal_set_min_count(::uint64_t value);

  public:
  // uint64 prepare_gas = 7 [json_name = "prepareGas"];
  void clear_prepare_gas() ;
  ::uint64_t prepare_gas() const;
  void set_prepare_gas(::uint64_t value);

  private:
  ::uint64_t _internal_prepare_gas() const;
  void _internal_set_prepare_gas(::uint64_t value);

  public:
  // uint64 execute_gas = 8 [json_name = "executeGas"];
  void clear_execute_gas() ;
  ::uint64_t execute_gas() const;
  void set_execute_gas(::uint64_t value);

  private:
  ::uint64_t _internal_execute_gas() const;
  void _internal_set_execute_gas(::uint64_t value);

  public:
  // uint64 min_source_count = 9 [json_name = "minSourceCount"];
  void clear_min_source_count() ;
  ::uint64_t min_source_count() const;
  void set_min_source_count(::uint64_t value);

  private:
  ::uint64_t _internal_min_source_count() const;
  void _internal_set_min_source_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.BandOracleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> symbols_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > fee_limit_;
    ::uint64_t request_id_;
    ::int64_t oracle_script_id_;
    ::uint64_t ask_count_;
    ::uint64_t min_count_;
    ::uint64_t prepare_gas_;
    ::uint64_t execute_gas_;
    ::uint64_t min_source_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class BandIBCParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.BandIBCParams) */ {
 public:
  inline BandIBCParams() : BandIBCParams(nullptr) {}
  ~BandIBCParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BandIBCParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandIBCParams(const BandIBCParams& from);
  BandIBCParams(BandIBCParams&& from) noexcept
    : BandIBCParams() {
    *this = ::std::move(from);
  }

  inline BandIBCParams& operator=(const BandIBCParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandIBCParams& operator=(BandIBCParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BandIBCParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandIBCParams* internal_default_instance() {
    return reinterpret_cast<const BandIBCParams*>(
               &_BandIBCParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BandIBCParams& a, BandIBCParams& b) {
    a.Swap(&b);
  }
  inline void Swap(BandIBCParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandIBCParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandIBCParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandIBCParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BandIBCParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BandIBCParams& from) {
    BandIBCParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BandIBCParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.BandIBCParams";
  }
  protected:
  explicit BandIBCParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegacyOracleIdsFieldNumber = 6,
    kIbcSourceChannelFieldNumber = 3,
    kIbcVersionFieldNumber = 4,
    kIbcPortIdFieldNumber = 5,
    kIbcRequestIntervalFieldNumber = 2,
    kBandIbcEnabledFieldNumber = 1,
  };
  // repeated int64 legacy_oracle_ids = 6 [json_name = "legacyOracleIds"];
  int legacy_oracle_ids_size() const;
  private:
  int _internal_legacy_oracle_ids_size() const;

  public:
  void clear_legacy_oracle_ids() ;
  ::int64_t legacy_oracle_ids(int index) const;
  void set_legacy_oracle_ids(int index, ::int64_t value);
  void add_legacy_oracle_ids(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& legacy_oracle_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* mutable_legacy_oracle_ids();

  private:
  ::int64_t _internal_legacy_oracle_ids(int index) const;
  void _internal_add_legacy_oracle_ids(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& _internal_legacy_oracle_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* _internal_mutable_legacy_oracle_ids();

  public:
  // string ibc_source_channel = 3 [json_name = "ibcSourceChannel"];
  void clear_ibc_source_channel() ;
  const std::string& ibc_source_channel() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ibc_source_channel(Arg_&& arg, Args_... args);
  std::string* mutable_ibc_source_channel();
  PROTOBUF_NODISCARD std::string* release_ibc_source_channel();
  void set_allocated_ibc_source_channel(std::string* ptr);

  private:
  const std::string& _internal_ibc_source_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ibc_source_channel(
      const std::string& value);
  std::string* _internal_mutable_ibc_source_channel();

  public:
  // string ibc_version = 4 [json_name = "ibcVersion"];
  void clear_ibc_version() ;
  const std::string& ibc_version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ibc_version(Arg_&& arg, Args_... args);
  std::string* mutable_ibc_version();
  PROTOBUF_NODISCARD std::string* release_ibc_version();
  void set_allocated_ibc_version(std::string* ptr);

  private:
  const std::string& _internal_ibc_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ibc_version(
      const std::string& value);
  std::string* _internal_mutable_ibc_version();

  public:
  // string ibc_port_id = 5 [json_name = "ibcPortId"];
  void clear_ibc_port_id() ;
  const std::string& ibc_port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ibc_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_ibc_port_id();
  PROTOBUF_NODISCARD std::string* release_ibc_port_id();
  void set_allocated_ibc_port_id(std::string* ptr);

  private:
  const std::string& _internal_ibc_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ibc_port_id(
      const std::string& value);
  std::string* _internal_mutable_ibc_port_id();

  public:
  // int64 ibc_request_interval = 2 [json_name = "ibcRequestInterval"];
  void clear_ibc_request_interval() ;
  ::int64_t ibc_request_interval() const;
  void set_ibc_request_interval(::int64_t value);

  private:
  ::int64_t _internal_ibc_request_interval() const;
  void _internal_set_ibc_request_interval(::int64_t value);

  public:
  // bool band_ibc_enabled = 1 [json_name = "bandIbcEnabled"];
  void clear_band_ibc_enabled() ;
  bool band_ibc_enabled() const;
  void set_band_ibc_enabled(bool value);

  private:
  bool _internal_band_ibc_enabled() const;
  void _internal_set_band_ibc_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.BandIBCParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t> legacy_oracle_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _legacy_oracle_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ibc_source_channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ibc_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ibc_port_id_;
    ::int64_t ibc_request_interval_;
    bool band_ibc_enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class SymbolPriceTimestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.SymbolPriceTimestamp) */ {
 public:
  inline SymbolPriceTimestamp() : SymbolPriceTimestamp(nullptr) {}
  ~SymbolPriceTimestamp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SymbolPriceTimestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SymbolPriceTimestamp(const SymbolPriceTimestamp& from);
  SymbolPriceTimestamp(SymbolPriceTimestamp&& from) noexcept
    : SymbolPriceTimestamp() {
    *this = ::std::move(from);
  }

  inline SymbolPriceTimestamp& operator=(const SymbolPriceTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolPriceTimestamp& operator=(SymbolPriceTimestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymbolPriceTimestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolPriceTimestamp* internal_default_instance() {
    return reinterpret_cast<const SymbolPriceTimestamp*>(
               &_SymbolPriceTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SymbolPriceTimestamp& a, SymbolPriceTimestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(SymbolPriceTimestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolPriceTimestamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolPriceTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SymbolPriceTimestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SymbolPriceTimestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SymbolPriceTimestamp& from) {
    SymbolPriceTimestamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolPriceTimestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.SymbolPriceTimestamp";
  }
  protected:
  explicit SymbolPriceTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolIdFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kOracleFieldNumber = 1,
  };
  // string symbol_id = 2 [json_name = "symbolId"];
  void clear_symbol_id() ;
  const std::string& symbol_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol_id(Arg_&& arg, Args_... args);
  std::string* mutable_symbol_id();
  PROTOBUF_NODISCARD std::string* release_symbol_id();
  void set_allocated_symbol_id(std::string* ptr);

  private:
  const std::string& _internal_symbol_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol_id(
      const std::string& value);
  std::string* _internal_mutable_symbol_id();

  public:
  // int64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
  void clear_oracle() ;
  ::injective::oracle::v1beta1::OracleType oracle() const;
  void set_oracle(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle() const;
  void _internal_set_oracle(::injective::oracle::v1beta1::OracleType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.SymbolPriceTimestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_id_;
    ::int64_t timestamp_;
    int oracle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class LastPriceTimestamps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.LastPriceTimestamps) */ {
 public:
  inline LastPriceTimestamps() : LastPriceTimestamps(nullptr) {}
  ~LastPriceTimestamps() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LastPriceTimestamps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LastPriceTimestamps(const LastPriceTimestamps& from);
  LastPriceTimestamps(LastPriceTimestamps&& from) noexcept
    : LastPriceTimestamps() {
    *this = ::std::move(from);
  }

  inline LastPriceTimestamps& operator=(const LastPriceTimestamps& from) {
    CopyFrom(from);
    return *this;
  }
  inline LastPriceTimestamps& operator=(LastPriceTimestamps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LastPriceTimestamps& default_instance() {
    return *internal_default_instance();
  }
  static inline const LastPriceTimestamps* internal_default_instance() {
    return reinterpret_cast<const LastPriceTimestamps*>(
               &_LastPriceTimestamps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LastPriceTimestamps& a, LastPriceTimestamps& b) {
    a.Swap(&b);
  }
  inline void Swap(LastPriceTimestamps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LastPriceTimestamps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LastPriceTimestamps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LastPriceTimestamps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LastPriceTimestamps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LastPriceTimestamps& from) {
    LastPriceTimestamps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LastPriceTimestamps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.LastPriceTimestamps";
  }
  protected:
  explicit LastPriceTimestamps(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastPriceTimestampsFieldNumber = 1,
  };
  // repeated .injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1 [json_name = "lastPriceTimestamps"];
  int last_price_timestamps_size() const;
  private:
  int _internal_last_price_timestamps_size() const;

  public:
  void clear_last_price_timestamps() ;
  ::injective::oracle::v1beta1::SymbolPriceTimestamp* mutable_last_price_timestamps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::SymbolPriceTimestamp >*
      mutable_last_price_timestamps();
  private:
  const ::injective::oracle::v1beta1::SymbolPriceTimestamp& _internal_last_price_timestamps(int index) const;
  ::injective::oracle::v1beta1::SymbolPriceTimestamp* _internal_add_last_price_timestamps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::SymbolPriceTimestamp>& _internal_last_price_timestamps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::SymbolPriceTimestamp>* _internal_mutable_last_price_timestamps();
  public:
  const ::injective::oracle::v1beta1::SymbolPriceTimestamp& last_price_timestamps(int index) const;
  ::injective::oracle::v1beta1::SymbolPriceTimestamp* add_last_price_timestamps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::SymbolPriceTimestamp >&
      last_price_timestamps() const;
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.LastPriceTimestamps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::SymbolPriceTimestamp > last_price_timestamps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PriceRecords final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PriceRecords) */ {
 public:
  inline PriceRecords() : PriceRecords(nullptr) {}
  ~PriceRecords() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceRecords(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceRecords(const PriceRecords& from);
  PriceRecords(PriceRecords&& from) noexcept
    : PriceRecords() {
    *this = ::std::move(from);
  }

  inline PriceRecords& operator=(const PriceRecords& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceRecords& operator=(PriceRecords&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceRecords& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceRecords* internal_default_instance() {
    return reinterpret_cast<const PriceRecords*>(
               &_PriceRecords_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PriceRecords& a, PriceRecords& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceRecords* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceRecords* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceRecords* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceRecords>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceRecords& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceRecords& from) {
    PriceRecords::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceRecords* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PriceRecords";
  }
  protected:
  explicit PriceRecords(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestPriceRecordsFieldNumber = 3,
    kSymbolIdFieldNumber = 2,
    kOracleFieldNumber = 1,
  };
  // repeated .injective.oracle.v1beta1.PriceRecord latest_price_records = 3 [json_name = "latestPriceRecords"];
  int latest_price_records_size() const;
  private:
  int _internal_latest_price_records_size() const;

  public:
  void clear_latest_price_records() ;
  ::injective::oracle::v1beta1::PriceRecord* mutable_latest_price_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::PriceRecord >*
      mutable_latest_price_records();
  private:
  const ::injective::oracle::v1beta1::PriceRecord& _internal_latest_price_records(int index) const;
  ::injective::oracle::v1beta1::PriceRecord* _internal_add_latest_price_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::PriceRecord>& _internal_latest_price_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::PriceRecord>* _internal_mutable_latest_price_records();
  public:
  const ::injective::oracle::v1beta1::PriceRecord& latest_price_records(int index) const;
  ::injective::oracle::v1beta1::PriceRecord* add_latest_price_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::PriceRecord >&
      latest_price_records() const;
  // string symbol_id = 2 [json_name = "symbolId"];
  void clear_symbol_id() ;
  const std::string& symbol_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol_id(Arg_&& arg, Args_... args);
  std::string* mutable_symbol_id();
  PROTOBUF_NODISCARD std::string* release_symbol_id();
  void set_allocated_symbol_id(std::string* ptr);

  private:
  const std::string& _internal_symbol_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol_id(
      const std::string& value);
  std::string* _internal_mutable_symbol_id();

  public:
  // .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
  void clear_oracle() ;
  ::injective::oracle::v1beta1::OracleType oracle() const;
  void set_oracle(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle() const;
  void _internal_set_oracle(::injective::oracle::v1beta1::OracleType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PriceRecords)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::PriceRecord > latest_price_records_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_id_;
    int oracle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PriceRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PriceRecord) */ {
 public:
  inline PriceRecord() : PriceRecord(nullptr) {}
  ~PriceRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceRecord(const PriceRecord& from);
  PriceRecord(PriceRecord&& from) noexcept
    : PriceRecord() {
    *this = ::std::move(from);
  }

  inline PriceRecord& operator=(const PriceRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceRecord& operator=(PriceRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceRecord* internal_default_instance() {
    return reinterpret_cast<const PriceRecord*>(
               &_PriceRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PriceRecord& a, PriceRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceRecord& from) {
    PriceRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PriceRecord";
  }
  protected:
  explicit PriceRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // int64 timestamp = 1 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PriceRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class MetadataStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.MetadataStatistics) */ {
 public:
  inline MetadataStatistics() : MetadataStatistics(nullptr) {}
  ~MetadataStatistics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MetadataStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetadataStatistics(const MetadataStatistics& from);
  MetadataStatistics(MetadataStatistics&& from) noexcept
    : MetadataStatistics() {
    *this = ::std::move(from);
  }

  inline MetadataStatistics& operator=(const MetadataStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataStatistics& operator=(MetadataStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataStatistics* internal_default_instance() {
    return reinterpret_cast<const MetadataStatistics*>(
               &_MetadataStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MetadataStatistics& a, MetadataStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataStatistics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetadataStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetadataStatistics& from) {
    MetadataStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.MetadataStatistics";
  }
  protected:
  explicit MetadataStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeanFieldNumber = 3,
    kTwapFieldNumber = 4,
    kMinPriceFieldNumber = 7,
    kMaxPriceFieldNumber = 8,
    kMedianPriceFieldNumber = 9,
    kGroupCountFieldNumber = 1,
    kRecordsSampleSizeFieldNumber = 2,
    kFirstTimestampFieldNumber = 5,
    kLastTimestampFieldNumber = 6,
  };
  // string mean = 3 [json_name = "mean", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_mean() ;
  const std::string& mean() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mean(Arg_&& arg, Args_... args);
  std::string* mutable_mean();
  PROTOBUF_NODISCARD std::string* release_mean();
  void set_allocated_mean(std::string* ptr);

  private:
  const std::string& _internal_mean() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mean(
      const std::string& value);
  std::string* _internal_mutable_mean();

  public:
  // string twap = 4 [json_name = "twap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_twap() ;
  const std::string& twap() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_twap(Arg_&& arg, Args_... args);
  std::string* mutable_twap();
  PROTOBUF_NODISCARD std::string* release_twap();
  void set_allocated_twap(std::string* ptr);

  private:
  const std::string& _internal_twap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_twap(
      const std::string& value);
  std::string* _internal_mutable_twap();

  public:
  // string min_price = 7 [json_name = "minPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price() ;
  const std::string& min_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price(Arg_&& arg, Args_... args);
  std::string* mutable_min_price();
  PROTOBUF_NODISCARD std::string* release_min_price();
  void set_allocated_min_price(std::string* ptr);

  private:
  const std::string& _internal_min_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price(
      const std::string& value);
  std::string* _internal_mutable_min_price();

  public:
  // string max_price = 8 [json_name = "maxPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_max_price() ;
  const std::string& max_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_price(Arg_&& arg, Args_... args);
  std::string* mutable_max_price();
  PROTOBUF_NODISCARD std::string* release_max_price();
  void set_allocated_max_price(std::string* ptr);

  private:
  const std::string& _internal_max_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_price(
      const std::string& value);
  std::string* _internal_mutable_max_price();

  public:
  // string median_price = 9 [json_name = "medianPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_median_price() ;
  const std::string& median_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_median_price(Arg_&& arg, Args_... args);
  std::string* mutable_median_price();
  PROTOBUF_NODISCARD std::string* release_median_price();
  void set_allocated_median_price(std::string* ptr);

  private:
  const std::string& _internal_median_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_median_price(
      const std::string& value);
  std::string* _internal_mutable_median_price();

  public:
  // uint32 group_count = 1 [json_name = "groupCount"];
  void clear_group_count() ;
  ::uint32_t group_count() const;
  void set_group_count(::uint32_t value);

  private:
  ::uint32_t _internal_group_count() const;
  void _internal_set_group_count(::uint32_t value);

  public:
  // uint32 records_sample_size = 2 [json_name = "recordsSampleSize"];
  void clear_records_sample_size() ;
  ::uint32_t records_sample_size() const;
  void set_records_sample_size(::uint32_t value);

  private:
  ::uint32_t _internal_records_sample_size() const;
  void _internal_set_records_sample_size(::uint32_t value);

  public:
  // int64 first_timestamp = 5 [json_name = "firstTimestamp"];
  void clear_first_timestamp() ;
  ::int64_t first_timestamp() const;
  void set_first_timestamp(::int64_t value);

  private:
  ::int64_t _internal_first_timestamp() const;
  void _internal_set_first_timestamp(::int64_t value);

  public:
  // int64 last_timestamp = 6 [json_name = "lastTimestamp"];
  void clear_last_timestamp() ;
  ::int64_t last_timestamp() const;
  void set_last_timestamp(::int64_t value);

  private:
  ::int64_t _internal_last_timestamp() const;
  void _internal_set_last_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.MetadataStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mean_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr twap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr median_price_;
    ::uint32_t group_count_;
    ::uint32_t records_sample_size_;
    ::int64_t first_timestamp_;
    ::int64_t last_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};// -------------------------------------------------------------------

class PriceAttestation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.oracle.v1beta1.PriceAttestation) */ {
 public:
  inline PriceAttestation() : PriceAttestation(nullptr) {}
  ~PriceAttestation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceAttestation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceAttestation(const PriceAttestation& from);
  PriceAttestation(PriceAttestation&& from) noexcept
    : PriceAttestation() {
    *this = ::std::move(from);
  }

  inline PriceAttestation& operator=(const PriceAttestation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceAttestation& operator=(PriceAttestation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceAttestation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceAttestation* internal_default_instance() {
    return reinterpret_cast<const PriceAttestation*>(
               &_PriceAttestation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PriceAttestation& a, PriceAttestation& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceAttestation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceAttestation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceAttestation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceAttestation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceAttestation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceAttestation& from) {
    PriceAttestation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceAttestation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.oracle.v1beta1.PriceAttestation";
  }
  protected:
  explicit PriceAttestation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceIdFieldNumber = 1,
    kPriceFieldNumber = 2,
    kConfFieldNumber = 3,
    kEmaPriceFieldNumber = 5,
    kExpoFieldNumber = 4,
    kEmaExpoFieldNumber = 7,
    kEmaConfFieldNumber = 6,
    kPublishTimeFieldNumber = 8,
  };
  // string price_id = 1 [json_name = "priceId"];
  void clear_price_id() ;
  const std::string& price_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price_id(Arg_&& arg, Args_... args);
  std::string* mutable_price_id();
  PROTOBUF_NODISCARD std::string* release_price_id();
  void set_allocated_price_id(std::string* ptr);

  private:
  const std::string& _internal_price_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price_id(
      const std::string& value);
  std::string* _internal_mutable_price_id();

  public:
  // int64 price = 2 [json_name = "price"];
  void clear_price() ;
  ::int64_t price() const;
  void set_price(::int64_t value);

  private:
  ::int64_t _internal_price() const;
  void _internal_set_price(::int64_t value);

  public:
  // uint64 conf = 3 [json_name = "conf"];
  void clear_conf() ;
  ::uint64_t conf() const;
  void set_conf(::uint64_t value);

  private:
  ::uint64_t _internal_conf() const;
  void _internal_set_conf(::uint64_t value);

  public:
  // int64 ema_price = 5 [json_name = "emaPrice"];
  void clear_ema_price() ;
  ::int64_t ema_price() const;
  void set_ema_price(::int64_t value);

  private:
  ::int64_t _internal_ema_price() const;
  void _internal_set_ema_price(::int64_t value);

  public:
  // int32 expo = 4 [json_name = "expo"];
  void clear_expo() ;
  ::int32_t expo() const;
  void set_expo(::int32_t value);

  private:
  ::int32_t _internal_expo() const;
  void _internal_set_expo(::int32_t value);

  public:
  // int32 ema_expo = 7 [json_name = "emaExpo"];
  void clear_ema_expo() ;
  ::int32_t ema_expo() const;
  void set_ema_expo(::int32_t value);

  private:
  ::int32_t _internal_ema_expo() const;
  void _internal_set_ema_expo(::int32_t value);

  public:
  // uint64 ema_conf = 6 [json_name = "emaConf"];
  void clear_ema_conf() ;
  ::uint64_t ema_conf() const;
  void set_ema_conf(::uint64_t value);

  private:
  ::uint64_t _internal_ema_conf() const;
  void _internal_set_ema_conf(::uint64_t value);

  public:
  // int64 publish_time = 8 [json_name = "publishTime"];
  void clear_publish_time() ;
  ::int64_t publish_time() const;
  void set_publish_time(::int64_t value);

  private:
  ::int64_t _internal_publish_time() const;
  void _internal_set_publish_time(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.oracle.v1beta1.PriceAttestation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_id_;
    ::int64_t price_;
    ::uint64_t conf_;
    ::int64_t ema_price_;
    ::int32_t expo_;
    ::int32_t ema_expo_;
    ::uint64_t ema_conf_;
    ::int64_t publish_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2foracle_2fv1beta1_2foracle_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Params

// string pyth_contract = 1 [json_name = "pythContract"];
inline void Params::clear_pyth_contract() {
  _impl_.pyth_contract_.ClearToEmpty();
}
inline const std::string& Params::pyth_contract() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.Params.pyth_contract)
  return _internal_pyth_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_pyth_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.pyth_contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.Params.pyth_contract)
}
inline std::string* Params::mutable_pyth_contract() {
  std::string* _s = _internal_mutable_pyth_contract();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.Params.pyth_contract)
  return _s;
}
inline const std::string& Params::_internal_pyth_contract() const {
  return _impl_.pyth_contract_.Get();
}
inline void Params::_internal_set_pyth_contract(const std::string& value) {
  ;


  _impl_.pyth_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* Params::_internal_mutable_pyth_contract() {
  ;
  return _impl_.pyth_contract_.Mutable( GetArenaForAllocation());
}
inline std::string* Params::release_pyth_contract() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.Params.pyth_contract)
  return _impl_.pyth_contract_.Release();
}
inline void Params::set_allocated_pyth_contract(std::string* value) {
  _impl_.pyth_contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pyth_contract_.IsDefault()) {
          _impl_.pyth_contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.Params.pyth_contract)
}

// -------------------------------------------------------------------

// OracleInfo

// string symbol = 1 [json_name = "symbol"];
inline void OracleInfo::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& OracleInfo::symbol() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.OracleInfo.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OracleInfo::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.OracleInfo.symbol)
}
inline std::string* OracleInfo::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.OracleInfo.symbol)
  return _s;
}
inline const std::string& OracleInfo::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void OracleInfo::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* OracleInfo::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* OracleInfo::release_symbol() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.OracleInfo.symbol)
  return _impl_.symbol_.Release();
}
inline void OracleInfo::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.OracleInfo.symbol)
}

// .injective.oracle.v1beta1.OracleType oracle_type = 2 [json_name = "oracleType"];
inline void OracleInfo::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType OracleInfo::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.OracleInfo.oracle_type)
  return _internal_oracle_type();
}
inline void OracleInfo::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.OracleInfo.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType OracleInfo::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void OracleInfo::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// uint32 scale_factor = 3 [json_name = "scaleFactor"];
inline void OracleInfo::clear_scale_factor() {
  _impl_.scale_factor_ = 0u;
}
inline ::uint32_t OracleInfo::scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.OracleInfo.scale_factor)
  return _internal_scale_factor();
}
inline void OracleInfo::set_scale_factor(::uint32_t value) {
  _internal_set_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.OracleInfo.scale_factor)
}
inline ::uint32_t OracleInfo::_internal_scale_factor() const {
  return _impl_.scale_factor_;
}
inline void OracleInfo::_internal_set_scale_factor(::uint32_t value) {
  ;
  _impl_.scale_factor_ = value;
}

// -------------------------------------------------------------------

// ChainlinkPriceState

// string feed_id = 1 [json_name = "feedId"];
inline void ChainlinkPriceState::clear_feed_id() {
  _impl_.feed_id_.ClearToEmpty();
}
inline const std::string& ChainlinkPriceState::feed_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ChainlinkPriceState.feed_id)
  return _internal_feed_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChainlinkPriceState::set_feed_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.feed_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.ChainlinkPriceState.feed_id)
}
inline std::string* ChainlinkPriceState::mutable_feed_id() {
  std::string* _s = _internal_mutable_feed_id();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ChainlinkPriceState.feed_id)
  return _s;
}
inline const std::string& ChainlinkPriceState::_internal_feed_id() const {
  return _impl_.feed_id_.Get();
}
inline void ChainlinkPriceState::_internal_set_feed_id(const std::string& value) {
  ;


  _impl_.feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChainlinkPriceState::_internal_mutable_feed_id() {
  ;
  return _impl_.feed_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChainlinkPriceState::release_feed_id() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.ChainlinkPriceState.feed_id)
  return _impl_.feed_id_.Release();
}
inline void ChainlinkPriceState::set_allocated_feed_id(std::string* value) {
  _impl_.feed_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.feed_id_.IsDefault()) {
          _impl_.feed_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.ChainlinkPriceState.feed_id)
}

// string answer = 2 [json_name = "answer", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ChainlinkPriceState::clear_answer() {
  _impl_.answer_.ClearToEmpty();
}
inline const std::string& ChainlinkPriceState::answer() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ChainlinkPriceState.answer)
  return _internal_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChainlinkPriceState::set_answer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.ChainlinkPriceState.answer)
}
inline std::string* ChainlinkPriceState::mutable_answer() {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ChainlinkPriceState.answer)
  return _s;
}
inline const std::string& ChainlinkPriceState::_internal_answer() const {
  return _impl_.answer_.Get();
}
inline void ChainlinkPriceState::_internal_set_answer(const std::string& value) {
  ;


  _impl_.answer_.Set(value, GetArenaForAllocation());
}
inline std::string* ChainlinkPriceState::_internal_mutable_answer() {
  ;
  return _impl_.answer_.Mutable( GetArenaForAllocation());
}
inline std::string* ChainlinkPriceState::release_answer() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.ChainlinkPriceState.answer)
  return _impl_.answer_.Release();
}
inline void ChainlinkPriceState::set_allocated_answer(std::string* value) {
  _impl_.answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.answer_.IsDefault()) {
          _impl_.answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.ChainlinkPriceState.answer)
}

// uint64 timestamp = 3 [json_name = "timestamp"];
inline void ChainlinkPriceState::clear_timestamp() {
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t ChainlinkPriceState::timestamp() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ChainlinkPriceState.timestamp)
  return _internal_timestamp();
}
inline void ChainlinkPriceState::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.ChainlinkPriceState.timestamp)
}
inline ::uint64_t ChainlinkPriceState::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void ChainlinkPriceState::_internal_set_timestamp(::uint64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// .injective.oracle.v1beta1.PriceState price_state = 4 [json_name = "priceState", (.gogoproto.nullable) = false];
inline bool ChainlinkPriceState::has_price_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.price_state_ != nullptr);
  return value;
}
inline void ChainlinkPriceState::clear_price_state() {
  if (_impl_.price_state_ != nullptr) _impl_.price_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::oracle::v1beta1::PriceState& ChainlinkPriceState::_internal_price_state() const {
  const ::injective::oracle::v1beta1::PriceState* p = _impl_.price_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::PriceState&>(
      ::injective::oracle::v1beta1::_PriceState_default_instance_);
}
inline const ::injective::oracle::v1beta1::PriceState& ChainlinkPriceState::price_state() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ChainlinkPriceState.price_state)
  return _internal_price_state();
}
inline void ChainlinkPriceState::unsafe_arena_set_allocated_price_state(
    ::injective::oracle::v1beta1::PriceState* price_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_state_);
  }
  _impl_.price_state_ = price_state;
  if (price_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.oracle.v1beta1.ChainlinkPriceState.price_state)
}
inline ::injective::oracle::v1beta1::PriceState* ChainlinkPriceState::release_price_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* ChainlinkPriceState::unsafe_arena_release_price_state() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.ChainlinkPriceState.price_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* ChainlinkPriceState::_internal_mutable_price_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.price_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::PriceState>(GetArenaForAllocation());
    _impl_.price_state_ = p;
  }
  return _impl_.price_state_;
}
inline ::injective::oracle::v1beta1::PriceState* ChainlinkPriceState::mutable_price_state() {
  ::injective::oracle::v1beta1::PriceState* _msg = _internal_mutable_price_state();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ChainlinkPriceState.price_state)
  return _msg;
}
inline void ChainlinkPriceState::set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.price_state_;
  }
  if (price_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_state);
    if (message_arena != submessage_arena) {
      price_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.price_state_ = price_state;
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.ChainlinkPriceState.price_state)
}

// -------------------------------------------------------------------

// BandPriceState

// string symbol = 1 [json_name = "symbol"];
inline void BandPriceState::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& BandPriceState::symbol() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandPriceState.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandPriceState::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandPriceState.symbol)
}
inline std::string* BandPriceState::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandPriceState.symbol)
  return _s;
}
inline const std::string& BandPriceState::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void BandPriceState::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* BandPriceState::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* BandPriceState::release_symbol() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.BandPriceState.symbol)
  return _impl_.symbol_.Release();
}
inline void BandPriceState::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.BandPriceState.symbol)
}

// string rate = 2 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void BandPriceState::clear_rate() {
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& BandPriceState::rate() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandPriceState.rate)
  return _internal_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandPriceState::set_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandPriceState.rate)
}
inline std::string* BandPriceState::mutable_rate() {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandPriceState.rate)
  return _s;
}
inline const std::string& BandPriceState::_internal_rate() const {
  return _impl_.rate_.Get();
}
inline void BandPriceState::_internal_set_rate(const std::string& value) {
  ;


  _impl_.rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BandPriceState::_internal_mutable_rate() {
  ;
  return _impl_.rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BandPriceState::release_rate() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.BandPriceState.rate)
  return _impl_.rate_.Release();
}
inline void BandPriceState::set_allocated_rate(std::string* value) {
  _impl_.rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rate_.IsDefault()) {
          _impl_.rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.BandPriceState.rate)
}

// uint64 resolve_time = 3 [json_name = "resolveTime"];
inline void BandPriceState::clear_resolve_time() {
  _impl_.resolve_time_ = ::uint64_t{0u};
}
inline ::uint64_t BandPriceState::resolve_time() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandPriceState.resolve_time)
  return _internal_resolve_time();
}
inline void BandPriceState::set_resolve_time(::uint64_t value) {
  _internal_set_resolve_time(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandPriceState.resolve_time)
}
inline ::uint64_t BandPriceState::_internal_resolve_time() const {
  return _impl_.resolve_time_;
}
inline void BandPriceState::_internal_set_resolve_time(::uint64_t value) {
  ;
  _impl_.resolve_time_ = value;
}

// uint64 request_ID = 4 [json_name = "requestID"];
inline void BandPriceState::clear_request_id() {
  _impl_.request_id_ = ::uint64_t{0u};
}
inline ::uint64_t BandPriceState::request_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandPriceState.request_ID)
  return _internal_request_id();
}
inline void BandPriceState::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandPriceState.request_ID)
}
inline ::uint64_t BandPriceState::_internal_request_id() const {
  return _impl_.request_id_;
}
inline void BandPriceState::_internal_set_request_id(::uint64_t value) {
  ;
  _impl_.request_id_ = value;
}

// .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
inline bool BandPriceState::has_price_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.price_state_ != nullptr);
  return value;
}
inline void BandPriceState::clear_price_state() {
  if (_impl_.price_state_ != nullptr) _impl_.price_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::oracle::v1beta1::PriceState& BandPriceState::_internal_price_state() const {
  const ::injective::oracle::v1beta1::PriceState* p = _impl_.price_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::PriceState&>(
      ::injective::oracle::v1beta1::_PriceState_default_instance_);
}
inline const ::injective::oracle::v1beta1::PriceState& BandPriceState::price_state() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandPriceState.price_state)
  return _internal_price_state();
}
inline void BandPriceState::unsafe_arena_set_allocated_price_state(
    ::injective::oracle::v1beta1::PriceState* price_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_state_);
  }
  _impl_.price_state_ = price_state;
  if (price_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.oracle.v1beta1.BandPriceState.price_state)
}
inline ::injective::oracle::v1beta1::PriceState* BandPriceState::release_price_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* BandPriceState::unsafe_arena_release_price_state() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.BandPriceState.price_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* BandPriceState::_internal_mutable_price_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.price_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::PriceState>(GetArenaForAllocation());
    _impl_.price_state_ = p;
  }
  return _impl_.price_state_;
}
inline ::injective::oracle::v1beta1::PriceState* BandPriceState::mutable_price_state() {
  ::injective::oracle::v1beta1::PriceState* _msg = _internal_mutable_price_state();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandPriceState.price_state)
  return _msg;
}
inline void BandPriceState::set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.price_state_;
  }
  if (price_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_state);
    if (message_arena != submessage_arena) {
      price_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.price_state_ = price_state;
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.BandPriceState.price_state)
}

// -------------------------------------------------------------------

// PriceFeedState

// string base = 1 [json_name = "base"];
inline void PriceFeedState::clear_base() {
  _impl_.base_.ClearToEmpty();
}
inline const std::string& PriceFeedState::base() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceFeedState.base)
  return _internal_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceFeedState::set_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceFeedState.base)
}
inline std::string* PriceFeedState::mutable_base() {
  std::string* _s = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceFeedState.base)
  return _s;
}
inline const std::string& PriceFeedState::_internal_base() const {
  return _impl_.base_.Get();
}
inline void PriceFeedState::_internal_set_base(const std::string& value) {
  ;


  _impl_.base_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceFeedState::_internal_mutable_base() {
  ;
  return _impl_.base_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceFeedState::release_base() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceFeedState.base)
  return _impl_.base_.Release();
}
inline void PriceFeedState::set_allocated_base(std::string* value) {
  _impl_.base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_.IsDefault()) {
          _impl_.base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceFeedState.base)
}

// string quote = 2 [json_name = "quote"];
inline void PriceFeedState::clear_quote() {
  _impl_.quote_.ClearToEmpty();
}
inline const std::string& PriceFeedState::quote() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceFeedState.quote)
  return _internal_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceFeedState::set_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceFeedState.quote)
}
inline std::string* PriceFeedState::mutable_quote() {
  std::string* _s = _internal_mutable_quote();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceFeedState.quote)
  return _s;
}
inline const std::string& PriceFeedState::_internal_quote() const {
  return _impl_.quote_.Get();
}
inline void PriceFeedState::_internal_set_quote(const std::string& value) {
  ;


  _impl_.quote_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceFeedState::_internal_mutable_quote() {
  ;
  return _impl_.quote_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceFeedState::release_quote() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceFeedState.quote)
  return _impl_.quote_.Release();
}
inline void PriceFeedState::set_allocated_quote(std::string* value) {
  _impl_.quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_.IsDefault()) {
          _impl_.quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceFeedState.quote)
}

// .injective.oracle.v1beta1.PriceState price_state = 3 [json_name = "priceState"];
inline bool PriceFeedState::has_price_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.price_state_ != nullptr);
  return value;
}
inline void PriceFeedState::clear_price_state() {
  if (_impl_.price_state_ != nullptr) _impl_.price_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::oracle::v1beta1::PriceState& PriceFeedState::_internal_price_state() const {
  const ::injective::oracle::v1beta1::PriceState* p = _impl_.price_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::PriceState&>(
      ::injective::oracle::v1beta1::_PriceState_default_instance_);
}
inline const ::injective::oracle::v1beta1::PriceState& PriceFeedState::price_state() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceFeedState.price_state)
  return _internal_price_state();
}
inline void PriceFeedState::unsafe_arena_set_allocated_price_state(
    ::injective::oracle::v1beta1::PriceState* price_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_state_);
  }
  _impl_.price_state_ = price_state;
  if (price_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.oracle.v1beta1.PriceFeedState.price_state)
}
inline ::injective::oracle::v1beta1::PriceState* PriceFeedState::release_price_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* PriceFeedState::unsafe_arena_release_price_state() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceFeedState.price_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* PriceFeedState::_internal_mutable_price_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.price_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::PriceState>(GetArenaForAllocation());
    _impl_.price_state_ = p;
  }
  return _impl_.price_state_;
}
inline ::injective::oracle::v1beta1::PriceState* PriceFeedState::mutable_price_state() {
  ::injective::oracle::v1beta1::PriceState* _msg = _internal_mutable_price_state();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceFeedState.price_state)
  return _msg;
}
inline void PriceFeedState::set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.price_state_;
  }
  if (price_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_state);
    if (message_arena != submessage_arena) {
      price_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.price_state_ = price_state;
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceFeedState.price_state)
}

// repeated string relayers = 4 [json_name = "relayers"];
inline int PriceFeedState::_internal_relayers_size() const {
  return _impl_.relayers_.size();
}
inline int PriceFeedState::relayers_size() const {
  return _internal_relayers_size();
}
inline void PriceFeedState::clear_relayers() {
  _internal_mutable_relayers()->Clear();
}
inline std::string* PriceFeedState::add_relayers() {
  std::string* _s = _internal_add_relayers();
  // @@protoc_insertion_point(field_add_mutable:injective.oracle.v1beta1.PriceFeedState.relayers)
  return _s;
}
inline const std::string& PriceFeedState::relayers(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceFeedState.relayers)
  return _internal_relayers(index);
}
inline std::string* PriceFeedState::mutable_relayers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceFeedState.relayers)
  return _internal_mutable_relayers()->Mutable(index);
}
inline void PriceFeedState::set_relayers(int index, const std::string& value) {
  _internal_mutable_relayers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::set_relayers(int index, std::string&& value) {
  _internal_mutable_relayers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::set_relayers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_relayers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::set_relayers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_relayers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::set_relayers(int index, absl::string_view value) {
  _internal_mutable_relayers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::add_relayers(const std::string& value) {
  _internal_mutable_relayers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::add_relayers(std::string&& value) {
  _internal_mutable_relayers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::add_relayers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_relayers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::add_relayers(const char* value, std::size_t size) {
  _internal_mutable_relayers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline void PriceFeedState::add_relayers(absl::string_view value) {
  _internal_mutable_relayers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.oracle.v1beta1.PriceFeedState.relayers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PriceFeedState::relayers() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.PriceFeedState.relayers)
  return _internal_relayers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* PriceFeedState::mutable_relayers() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.PriceFeedState.relayers)
  return _internal_mutable_relayers();
}
inline const std::string& PriceFeedState::_internal_relayers(int index) const {
  return _internal_relayers().Get(index);
}
inline std::string* PriceFeedState::_internal_add_relayers() {
  return _internal_mutable_relayers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PriceFeedState::_internal_relayers() const {
  return _impl_.relayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PriceFeedState::_internal_mutable_relayers() {
  return &_impl_.relayers_;
}

// -------------------------------------------------------------------

// ProviderInfo

// string provider = 1 [json_name = "provider"];
inline void ProviderInfo::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& ProviderInfo::provider() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ProviderInfo.provider)
  return _internal_provider();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProviderInfo::set_provider(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.provider_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.ProviderInfo.provider)
}
inline std::string* ProviderInfo::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ProviderInfo.provider)
  return _s;
}
inline const std::string& ProviderInfo::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void ProviderInfo::_internal_set_provider(const std::string& value) {
  ;


  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* ProviderInfo::_internal_mutable_provider() {
  ;
  return _impl_.provider_.Mutable( GetArenaForAllocation());
}
inline std::string* ProviderInfo::release_provider() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.ProviderInfo.provider)
  return _impl_.provider_.Release();
}
inline void ProviderInfo::set_allocated_provider(std::string* value) {
  _impl_.provider_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.provider_.IsDefault()) {
          _impl_.provider_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.ProviderInfo.provider)
}

// repeated string relayers = 2 [json_name = "relayers"];
inline int ProviderInfo::_internal_relayers_size() const {
  return _impl_.relayers_.size();
}
inline int ProviderInfo::relayers_size() const {
  return _internal_relayers_size();
}
inline void ProviderInfo::clear_relayers() {
  _internal_mutable_relayers()->Clear();
}
inline std::string* ProviderInfo::add_relayers() {
  std::string* _s = _internal_add_relayers();
  // @@protoc_insertion_point(field_add_mutable:injective.oracle.v1beta1.ProviderInfo.relayers)
  return _s;
}
inline const std::string& ProviderInfo::relayers(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ProviderInfo.relayers)
  return _internal_relayers(index);
}
inline std::string* ProviderInfo::mutable_relayers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ProviderInfo.relayers)
  return _internal_mutable_relayers()->Mutable(index);
}
inline void ProviderInfo::set_relayers(int index, const std::string& value) {
  _internal_mutable_relayers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::set_relayers(int index, std::string&& value) {
  _internal_mutable_relayers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::set_relayers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_relayers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::set_relayers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_relayers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::set_relayers(int index, absl::string_view value) {
  _internal_mutable_relayers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::add_relayers(const std::string& value) {
  _internal_mutable_relayers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::add_relayers(std::string&& value) {
  _internal_mutable_relayers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::add_relayers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_relayers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::add_relayers(const char* value, std::size_t size) {
  _internal_mutable_relayers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline void ProviderInfo::add_relayers(absl::string_view value) {
  _internal_mutable_relayers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.oracle.v1beta1.ProviderInfo.relayers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProviderInfo::relayers() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.ProviderInfo.relayers)
  return _internal_relayers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ProviderInfo::mutable_relayers() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.ProviderInfo.relayers)
  return _internal_mutable_relayers();
}
inline const std::string& ProviderInfo::_internal_relayers(int index) const {
  return _internal_relayers().Get(index);
}
inline std::string* ProviderInfo::_internal_add_relayers() {
  return _internal_mutable_relayers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProviderInfo::_internal_relayers() const {
  return _impl_.relayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProviderInfo::_internal_mutable_relayers() {
  return &_impl_.relayers_;
}

// -------------------------------------------------------------------

// ProviderState

// .injective.oracle.v1beta1.ProviderInfo provider_info = 1 [json_name = "providerInfo"];
inline bool ProviderState::has_provider_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provider_info_ != nullptr);
  return value;
}
inline void ProviderState::clear_provider_info() {
  if (_impl_.provider_info_ != nullptr) _impl_.provider_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::oracle::v1beta1::ProviderInfo& ProviderState::_internal_provider_info() const {
  const ::injective::oracle::v1beta1::ProviderInfo* p = _impl_.provider_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::ProviderInfo&>(
      ::injective::oracle::v1beta1::_ProviderInfo_default_instance_);
}
inline const ::injective::oracle::v1beta1::ProviderInfo& ProviderState::provider_info() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ProviderState.provider_info)
  return _internal_provider_info();
}
inline void ProviderState::unsafe_arena_set_allocated_provider_info(
    ::injective::oracle::v1beta1::ProviderInfo* provider_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.provider_info_);
  }
  _impl_.provider_info_ = provider_info;
  if (provider_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.oracle.v1beta1.ProviderState.provider_info)
}
inline ::injective::oracle::v1beta1::ProviderInfo* ProviderState::release_provider_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::ProviderInfo* temp = _impl_.provider_info_;
  _impl_.provider_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::ProviderInfo* ProviderState::unsafe_arena_release_provider_info() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.ProviderState.provider_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::ProviderInfo* temp = _impl_.provider_info_;
  _impl_.provider_info_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::ProviderInfo* ProviderState::_internal_mutable_provider_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.provider_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::ProviderInfo>(GetArenaForAllocation());
    _impl_.provider_info_ = p;
  }
  return _impl_.provider_info_;
}
inline ::injective::oracle::v1beta1::ProviderInfo* ProviderState::mutable_provider_info() {
  ::injective::oracle::v1beta1::ProviderInfo* _msg = _internal_mutable_provider_info();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ProviderState.provider_info)
  return _msg;
}
inline void ProviderState::set_allocated_provider_info(::injective::oracle::v1beta1::ProviderInfo* provider_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.provider_info_;
  }
  if (provider_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(provider_info);
    if (message_arena != submessage_arena) {
      provider_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.provider_info_ = provider_info;
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.ProviderState.provider_info)
}

// repeated .injective.oracle.v1beta1.ProviderPriceState provider_price_states = 2 [json_name = "providerPriceStates"];
inline int ProviderState::_internal_provider_price_states_size() const {
  return _impl_.provider_price_states_.size();
}
inline int ProviderState::provider_price_states_size() const {
  return _internal_provider_price_states_size();
}
inline void ProviderState::clear_provider_price_states() {
  _internal_mutable_provider_price_states()->Clear();
}
inline ::injective::oracle::v1beta1::ProviderPriceState* ProviderState::mutable_provider_price_states(int index) {
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ProviderState.provider_price_states)
  return _internal_mutable_provider_price_states()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::ProviderPriceState >*
ProviderState::mutable_provider_price_states() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.ProviderState.provider_price_states)
  return _internal_mutable_provider_price_states();
}
inline const ::injective::oracle::v1beta1::ProviderPriceState& ProviderState::_internal_provider_price_states(int index) const {
  return _internal_provider_price_states().Get(index);
}
inline const ::injective::oracle::v1beta1::ProviderPriceState& ProviderState::provider_price_states(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ProviderState.provider_price_states)
  return _internal_provider_price_states(index);
}
inline ::injective::oracle::v1beta1::ProviderPriceState* ProviderState::_internal_add_provider_price_states() {
  return _internal_mutable_provider_price_states()->Add();
}
inline ::injective::oracle::v1beta1::ProviderPriceState* ProviderState::add_provider_price_states() {
  ::injective::oracle::v1beta1::ProviderPriceState* _add = _internal_add_provider_price_states();
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.ProviderState.provider_price_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::ProviderPriceState >&
ProviderState::provider_price_states() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.ProviderState.provider_price_states)
  return _internal_provider_price_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::ProviderPriceState>&
ProviderState::_internal_provider_price_states() const {
  return _impl_.provider_price_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::ProviderPriceState>*
ProviderState::_internal_mutable_provider_price_states() {
  return &_impl_.provider_price_states_;
}

// -------------------------------------------------------------------

// ProviderPriceState

// string symbol = 1 [json_name = "symbol"];
inline void ProviderPriceState::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ProviderPriceState::symbol() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ProviderPriceState.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProviderPriceState::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.ProviderPriceState.symbol)
}
inline std::string* ProviderPriceState::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ProviderPriceState.symbol)
  return _s;
}
inline const std::string& ProviderPriceState::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void ProviderPriceState::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* ProviderPriceState::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* ProviderPriceState::release_symbol() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.ProviderPriceState.symbol)
  return _impl_.symbol_.Release();
}
inline void ProviderPriceState::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.ProviderPriceState.symbol)
}

// .injective.oracle.v1beta1.PriceState state = 2 [json_name = "state"];
inline bool ProviderPriceState::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void ProviderPriceState::clear_state() {
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::oracle::v1beta1::PriceState& ProviderPriceState::_internal_state() const {
  const ::injective::oracle::v1beta1::PriceState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::PriceState&>(
      ::injective::oracle::v1beta1::_PriceState_default_instance_);
}
inline const ::injective::oracle::v1beta1::PriceState& ProviderPriceState::state() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.ProviderPriceState.state)
  return _internal_state();
}
inline void ProviderPriceState::unsafe_arena_set_allocated_state(
    ::injective::oracle::v1beta1::PriceState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.oracle.v1beta1.ProviderPriceState.state)
}
inline ::injective::oracle::v1beta1::PriceState* ProviderPriceState::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* ProviderPriceState::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.ProviderPriceState.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* ProviderPriceState::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::PriceState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::injective::oracle::v1beta1::PriceState* ProviderPriceState::mutable_state() {
  ::injective::oracle::v1beta1::PriceState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.ProviderPriceState.state)
  return _msg;
}
inline void ProviderPriceState::set_allocated_state(::injective::oracle::v1beta1::PriceState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.ProviderPriceState.state)
}

// -------------------------------------------------------------------

// PriceFeedInfo

// string base = 1 [json_name = "base"];
inline void PriceFeedInfo::clear_base() {
  _impl_.base_.ClearToEmpty();
}
inline const std::string& PriceFeedInfo::base() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceFeedInfo.base)
  return _internal_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceFeedInfo::set_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceFeedInfo.base)
}
inline std::string* PriceFeedInfo::mutable_base() {
  std::string* _s = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceFeedInfo.base)
  return _s;
}
inline const std::string& PriceFeedInfo::_internal_base() const {
  return _impl_.base_.Get();
}
inline void PriceFeedInfo::_internal_set_base(const std::string& value) {
  ;


  _impl_.base_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceFeedInfo::_internal_mutable_base() {
  ;
  return _impl_.base_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceFeedInfo::release_base() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceFeedInfo.base)
  return _impl_.base_.Release();
}
inline void PriceFeedInfo::set_allocated_base(std::string* value) {
  _impl_.base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_.IsDefault()) {
          _impl_.base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceFeedInfo.base)
}

// string quote = 2 [json_name = "quote"];
inline void PriceFeedInfo::clear_quote() {
  _impl_.quote_.ClearToEmpty();
}
inline const std::string& PriceFeedInfo::quote() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceFeedInfo.quote)
  return _internal_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceFeedInfo::set_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceFeedInfo.quote)
}
inline std::string* PriceFeedInfo::mutable_quote() {
  std::string* _s = _internal_mutable_quote();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceFeedInfo.quote)
  return _s;
}
inline const std::string& PriceFeedInfo::_internal_quote() const {
  return _impl_.quote_.Get();
}
inline void PriceFeedInfo::_internal_set_quote(const std::string& value) {
  ;


  _impl_.quote_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceFeedInfo::_internal_mutable_quote() {
  ;
  return _impl_.quote_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceFeedInfo::release_quote() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceFeedInfo.quote)
  return _impl_.quote_.Release();
}
inline void PriceFeedInfo::set_allocated_quote(std::string* value) {
  _impl_.quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_.IsDefault()) {
          _impl_.quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceFeedInfo.quote)
}

// -------------------------------------------------------------------

// PriceFeedPrice

// string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PriceFeedPrice::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceFeedPrice::price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceFeedPrice.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceFeedPrice::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceFeedPrice.price)
}
inline std::string* PriceFeedPrice::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceFeedPrice.price)
  return _s;
}
inline const std::string& PriceFeedPrice::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceFeedPrice::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceFeedPrice::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceFeedPrice::release_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceFeedPrice.price)
  return _impl_.price_.Release();
}
inline void PriceFeedPrice::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceFeedPrice.price)
}

// -------------------------------------------------------------------

// CoinbasePriceState

// string kind = 1 [json_name = "kind"];
inline void CoinbasePriceState::clear_kind() {
  _impl_.kind_.ClearToEmpty();
}
inline const std::string& CoinbasePriceState::kind() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.CoinbasePriceState.kind)
  return _internal_kind();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CoinbasePriceState::set_kind(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.kind_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.CoinbasePriceState.kind)
}
inline std::string* CoinbasePriceState::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.CoinbasePriceState.kind)
  return _s;
}
inline const std::string& CoinbasePriceState::_internal_kind() const {
  return _impl_.kind_.Get();
}
inline void CoinbasePriceState::_internal_set_kind(const std::string& value) {
  ;


  _impl_.kind_.Set(value, GetArenaForAllocation());
}
inline std::string* CoinbasePriceState::_internal_mutable_kind() {
  ;
  return _impl_.kind_.Mutable( GetArenaForAllocation());
}
inline std::string* CoinbasePriceState::release_kind() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.CoinbasePriceState.kind)
  return _impl_.kind_.Release();
}
inline void CoinbasePriceState::set_allocated_kind(std::string* value) {
  _impl_.kind_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.kind_.IsDefault()) {
          _impl_.kind_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.CoinbasePriceState.kind)
}

// uint64 timestamp = 2 [json_name = "timestamp"];
inline void CoinbasePriceState::clear_timestamp() {
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t CoinbasePriceState::timestamp() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.CoinbasePriceState.timestamp)
  return _internal_timestamp();
}
inline void CoinbasePriceState::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.CoinbasePriceState.timestamp)
}
inline ::uint64_t CoinbasePriceState::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void CoinbasePriceState::_internal_set_timestamp(::uint64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string key = 3 [json_name = "key"];
inline void CoinbasePriceState::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CoinbasePriceState::key() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.CoinbasePriceState.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CoinbasePriceState::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.CoinbasePriceState.key)
}
inline std::string* CoinbasePriceState::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.CoinbasePriceState.key)
  return _s;
}
inline const std::string& CoinbasePriceState::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CoinbasePriceState::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CoinbasePriceState::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* CoinbasePriceState::release_key() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.CoinbasePriceState.key)
  return _impl_.key_.Release();
}
inline void CoinbasePriceState::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.CoinbasePriceState.key)
}

// uint64 value = 4 [json_name = "value"];
inline void CoinbasePriceState::clear_value() {
  _impl_.value_ = ::uint64_t{0u};
}
inline ::uint64_t CoinbasePriceState::value() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.CoinbasePriceState.value)
  return _internal_value();
}
inline void CoinbasePriceState::set_value(::uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.CoinbasePriceState.value)
}
inline ::uint64_t CoinbasePriceState::_internal_value() const {
  return _impl_.value_;
}
inline void CoinbasePriceState::_internal_set_value(::uint64_t value) {
  ;
  _impl_.value_ = value;
}

// .injective.oracle.v1beta1.PriceState price_state = 5 [json_name = "priceState", (.gogoproto.nullable) = false];
inline bool CoinbasePriceState::has_price_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.price_state_ != nullptr);
  return value;
}
inline void CoinbasePriceState::clear_price_state() {
  if (_impl_.price_state_ != nullptr) _impl_.price_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::oracle::v1beta1::PriceState& CoinbasePriceState::_internal_price_state() const {
  const ::injective::oracle::v1beta1::PriceState* p = _impl_.price_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::PriceState&>(
      ::injective::oracle::v1beta1::_PriceState_default_instance_);
}
inline const ::injective::oracle::v1beta1::PriceState& CoinbasePriceState::price_state() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.CoinbasePriceState.price_state)
  return _internal_price_state();
}
inline void CoinbasePriceState::unsafe_arena_set_allocated_price_state(
    ::injective::oracle::v1beta1::PriceState* price_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_state_);
  }
  _impl_.price_state_ = price_state;
  if (price_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.oracle.v1beta1.CoinbasePriceState.price_state)
}
inline ::injective::oracle::v1beta1::PriceState* CoinbasePriceState::release_price_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* CoinbasePriceState::unsafe_arena_release_price_state() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.CoinbasePriceState.price_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* CoinbasePriceState::_internal_mutable_price_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.price_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::PriceState>(GetArenaForAllocation());
    _impl_.price_state_ = p;
  }
  return _impl_.price_state_;
}
inline ::injective::oracle::v1beta1::PriceState* CoinbasePriceState::mutable_price_state() {
  ::injective::oracle::v1beta1::PriceState* _msg = _internal_mutable_price_state();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.CoinbasePriceState.price_state)
  return _msg;
}
inline void CoinbasePriceState::set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.price_state_;
  }
  if (price_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_state);
    if (message_arena != submessage_arena) {
      price_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.price_state_ = price_state;
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.CoinbasePriceState.price_state)
}

// -------------------------------------------------------------------

// PriceState

// string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PriceState::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceState::price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceState.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceState::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceState.price)
}
inline std::string* PriceState::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceState.price)
  return _s;
}
inline const std::string& PriceState::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceState::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceState::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceState::release_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceState.price)
  return _impl_.price_.Release();
}
inline void PriceState::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceState.price)
}

// string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PriceState::clear_cumulative_price() {
  _impl_.cumulative_price_.ClearToEmpty();
}
inline const std::string& PriceState::cumulative_price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceState.cumulative_price)
  return _internal_cumulative_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceState::set_cumulative_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cumulative_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceState.cumulative_price)
}
inline std::string* PriceState::mutable_cumulative_price() {
  std::string* _s = _internal_mutable_cumulative_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceState.cumulative_price)
  return _s;
}
inline const std::string& PriceState::_internal_cumulative_price() const {
  return _impl_.cumulative_price_.Get();
}
inline void PriceState::_internal_set_cumulative_price(const std::string& value) {
  ;


  _impl_.cumulative_price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceState::_internal_mutable_cumulative_price() {
  ;
  return _impl_.cumulative_price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceState::release_cumulative_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceState.cumulative_price)
  return _impl_.cumulative_price_.Release();
}
inline void PriceState::set_allocated_cumulative_price(std::string* value) {
  _impl_.cumulative_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cumulative_price_.IsDefault()) {
          _impl_.cumulative_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceState.cumulative_price)
}

// int64 timestamp = 3 [json_name = "timestamp"];
inline void PriceState::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t PriceState::timestamp() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceState.timestamp)
  return _internal_timestamp();
}
inline void PriceState::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceState.timestamp)
}
inline ::int64_t PriceState::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void PriceState::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// PythPriceState

// string price_id = 1 [json_name = "priceId"];
inline void PythPriceState::clear_price_id() {
  _impl_.price_id_.ClearToEmpty();
}
inline const std::string& PythPriceState::price_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PythPriceState.price_id)
  return _internal_price_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PythPriceState::set_price_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PythPriceState.price_id)
}
inline std::string* PythPriceState::mutable_price_id() {
  std::string* _s = _internal_mutable_price_id();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PythPriceState.price_id)
  return _s;
}
inline const std::string& PythPriceState::_internal_price_id() const {
  return _impl_.price_id_.Get();
}
inline void PythPriceState::_internal_set_price_id(const std::string& value) {
  ;


  _impl_.price_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PythPriceState::_internal_mutable_price_id() {
  ;
  return _impl_.price_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PythPriceState::release_price_id() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PythPriceState.price_id)
  return _impl_.price_id_.Release();
}
inline void PythPriceState::set_allocated_price_id(std::string* value) {
  _impl_.price_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_id_.IsDefault()) {
          _impl_.price_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PythPriceState.price_id)
}

// string ema_price = 2 [json_name = "emaPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PythPriceState::clear_ema_price() {
  _impl_.ema_price_.ClearToEmpty();
}
inline const std::string& PythPriceState::ema_price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PythPriceState.ema_price)
  return _internal_ema_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PythPriceState::set_ema_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ema_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PythPriceState.ema_price)
}
inline std::string* PythPriceState::mutable_ema_price() {
  std::string* _s = _internal_mutable_ema_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PythPriceState.ema_price)
  return _s;
}
inline const std::string& PythPriceState::_internal_ema_price() const {
  return _impl_.ema_price_.Get();
}
inline void PythPriceState::_internal_set_ema_price(const std::string& value) {
  ;


  _impl_.ema_price_.Set(value, GetArenaForAllocation());
}
inline std::string* PythPriceState::_internal_mutable_ema_price() {
  ;
  return _impl_.ema_price_.Mutable( GetArenaForAllocation());
}
inline std::string* PythPriceState::release_ema_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PythPriceState.ema_price)
  return _impl_.ema_price_.Release();
}
inline void PythPriceState::set_allocated_ema_price(std::string* value) {
  _impl_.ema_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ema_price_.IsDefault()) {
          _impl_.ema_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PythPriceState.ema_price)
}

// string ema_conf = 3 [json_name = "emaConf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PythPriceState::clear_ema_conf() {
  _impl_.ema_conf_.ClearToEmpty();
}
inline const std::string& PythPriceState::ema_conf() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PythPriceState.ema_conf)
  return _internal_ema_conf();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PythPriceState::set_ema_conf(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ema_conf_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PythPriceState.ema_conf)
}
inline std::string* PythPriceState::mutable_ema_conf() {
  std::string* _s = _internal_mutable_ema_conf();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PythPriceState.ema_conf)
  return _s;
}
inline const std::string& PythPriceState::_internal_ema_conf() const {
  return _impl_.ema_conf_.Get();
}
inline void PythPriceState::_internal_set_ema_conf(const std::string& value) {
  ;


  _impl_.ema_conf_.Set(value, GetArenaForAllocation());
}
inline std::string* PythPriceState::_internal_mutable_ema_conf() {
  ;
  return _impl_.ema_conf_.Mutable( GetArenaForAllocation());
}
inline std::string* PythPriceState::release_ema_conf() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PythPriceState.ema_conf)
  return _impl_.ema_conf_.Release();
}
inline void PythPriceState::set_allocated_ema_conf(std::string* value) {
  _impl_.ema_conf_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ema_conf_.IsDefault()) {
          _impl_.ema_conf_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PythPriceState.ema_conf)
}

// string conf = 4 [json_name = "conf", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PythPriceState::clear_conf() {
  _impl_.conf_.ClearToEmpty();
}
inline const std::string& PythPriceState::conf() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PythPriceState.conf)
  return _internal_conf();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PythPriceState::set_conf(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.conf_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PythPriceState.conf)
}
inline std::string* PythPriceState::mutable_conf() {
  std::string* _s = _internal_mutable_conf();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PythPriceState.conf)
  return _s;
}
inline const std::string& PythPriceState::_internal_conf() const {
  return _impl_.conf_.Get();
}
inline void PythPriceState::_internal_set_conf(const std::string& value) {
  ;


  _impl_.conf_.Set(value, GetArenaForAllocation());
}
inline std::string* PythPriceState::_internal_mutable_conf() {
  ;
  return _impl_.conf_.Mutable( GetArenaForAllocation());
}
inline std::string* PythPriceState::release_conf() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PythPriceState.conf)
  return _impl_.conf_.Release();
}
inline void PythPriceState::set_allocated_conf(std::string* value) {
  _impl_.conf_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.conf_.IsDefault()) {
          _impl_.conf_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PythPriceState.conf)
}

// uint64 publish_time = 5 [json_name = "publishTime"];
inline void PythPriceState::clear_publish_time() {
  _impl_.publish_time_ = ::uint64_t{0u};
}
inline ::uint64_t PythPriceState::publish_time() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PythPriceState.publish_time)
  return _internal_publish_time();
}
inline void PythPriceState::set_publish_time(::uint64_t value) {
  _internal_set_publish_time(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PythPriceState.publish_time)
}
inline ::uint64_t PythPriceState::_internal_publish_time() const {
  return _impl_.publish_time_;
}
inline void PythPriceState::_internal_set_publish_time(::uint64_t value) {
  ;
  _impl_.publish_time_ = value;
}

// .injective.oracle.v1beta1.PriceState price_state = 6 [json_name = "priceState", (.gogoproto.nullable) = false];
inline bool PythPriceState::has_price_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.price_state_ != nullptr);
  return value;
}
inline void PythPriceState::clear_price_state() {
  if (_impl_.price_state_ != nullptr) _impl_.price_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::oracle::v1beta1::PriceState& PythPriceState::_internal_price_state() const {
  const ::injective::oracle::v1beta1::PriceState* p = _impl_.price_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::PriceState&>(
      ::injective::oracle::v1beta1::_PriceState_default_instance_);
}
inline const ::injective::oracle::v1beta1::PriceState& PythPriceState::price_state() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PythPriceState.price_state)
  return _internal_price_state();
}
inline void PythPriceState::unsafe_arena_set_allocated_price_state(
    ::injective::oracle::v1beta1::PriceState* price_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_state_);
  }
  _impl_.price_state_ = price_state;
  if (price_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.oracle.v1beta1.PythPriceState.price_state)
}
inline ::injective::oracle::v1beta1::PriceState* PythPriceState::release_price_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* PythPriceState::unsafe_arena_release_price_state() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PythPriceState.price_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::PriceState* temp = _impl_.price_state_;
  _impl_.price_state_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::PriceState* PythPriceState::_internal_mutable_price_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.price_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::PriceState>(GetArenaForAllocation());
    _impl_.price_state_ = p;
  }
  return _impl_.price_state_;
}
inline ::injective::oracle::v1beta1::PriceState* PythPriceState::mutable_price_state() {
  ::injective::oracle::v1beta1::PriceState* _msg = _internal_mutable_price_state();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PythPriceState.price_state)
  return _msg;
}
inline void PythPriceState::set_allocated_price_state(::injective::oracle::v1beta1::PriceState* price_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.price_state_;
  }
  if (price_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_state);
    if (message_arena != submessage_arena) {
      price_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.price_state_ = price_state;
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PythPriceState.price_state)
}

// -------------------------------------------------------------------

// BandOracleRequest

// uint64 request_id = 1 [json_name = "requestId"];
inline void BandOracleRequest::clear_request_id() {
  _impl_.request_id_ = ::uint64_t{0u};
}
inline ::uint64_t BandOracleRequest::request_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.request_id)
  return _internal_request_id();
}
inline void BandOracleRequest::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.request_id)
}
inline ::uint64_t BandOracleRequest::_internal_request_id() const {
  return _impl_.request_id_;
}
inline void BandOracleRequest::_internal_set_request_id(::uint64_t value) {
  ;
  _impl_.request_id_ = value;
}

// int64 oracle_script_id = 2 [json_name = "oracleScriptId"];
inline void BandOracleRequest::clear_oracle_script_id() {
  _impl_.oracle_script_id_ = ::int64_t{0};
}
inline ::int64_t BandOracleRequest::oracle_script_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.oracle_script_id)
  return _internal_oracle_script_id();
}
inline void BandOracleRequest::set_oracle_script_id(::int64_t value) {
  _internal_set_oracle_script_id(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.oracle_script_id)
}
inline ::int64_t BandOracleRequest::_internal_oracle_script_id() const {
  return _impl_.oracle_script_id_;
}
inline void BandOracleRequest::_internal_set_oracle_script_id(::int64_t value) {
  ;
  _impl_.oracle_script_id_ = value;
}

// repeated string symbols = 3 [json_name = "symbols"];
inline int BandOracleRequest::_internal_symbols_size() const {
  return _impl_.symbols_.size();
}
inline int BandOracleRequest::symbols_size() const {
  return _internal_symbols_size();
}
inline void BandOracleRequest::clear_symbols() {
  _internal_mutable_symbols()->Clear();
}
inline std::string* BandOracleRequest::add_symbols() {
  std::string* _s = _internal_add_symbols();
  // @@protoc_insertion_point(field_add_mutable:injective.oracle.v1beta1.BandOracleRequest.symbols)
  return _s;
}
inline const std::string& BandOracleRequest::symbols(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.symbols)
  return _internal_symbols(index);
}
inline std::string* BandOracleRequest::mutable_symbols(int index) {
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandOracleRequest.symbols)
  return _internal_mutable_symbols()->Mutable(index);
}
inline void BandOracleRequest::set_symbols(int index, const std::string& value) {
  _internal_mutable_symbols()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::set_symbols(int index, std::string&& value) {
  _internal_mutable_symbols()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::set_symbols(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_symbols()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::set_symbols(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_symbols()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::set_symbols(int index, absl::string_view value) {
  _internal_mutable_symbols()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::add_symbols(const std::string& value) {
  _internal_mutable_symbols()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::add_symbols(std::string&& value) {
  _internal_mutable_symbols()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::add_symbols(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_symbols()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::add_symbols(const char* value, std::size_t size) {
  _internal_mutable_symbols()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline void BandOracleRequest::add_symbols(absl::string_view value) {
  _internal_mutable_symbols()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.oracle.v1beta1.BandOracleRequest.symbols)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BandOracleRequest::symbols() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.BandOracleRequest.symbols)
  return _internal_symbols();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* BandOracleRequest::mutable_symbols() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.BandOracleRequest.symbols)
  return _internal_mutable_symbols();
}
inline const std::string& BandOracleRequest::_internal_symbols(int index) const {
  return _internal_symbols().Get(index);
}
inline std::string* BandOracleRequest::_internal_add_symbols() {
  return _internal_mutable_symbols()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BandOracleRequest::_internal_symbols() const {
  return _impl_.symbols_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BandOracleRequest::_internal_mutable_symbols() {
  return &_impl_.symbols_;
}

// uint64 ask_count = 4 [json_name = "askCount"];
inline void BandOracleRequest::clear_ask_count() {
  _impl_.ask_count_ = ::uint64_t{0u};
}
inline ::uint64_t BandOracleRequest::ask_count() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.ask_count)
  return _internal_ask_count();
}
inline void BandOracleRequest::set_ask_count(::uint64_t value) {
  _internal_set_ask_count(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.ask_count)
}
inline ::uint64_t BandOracleRequest::_internal_ask_count() const {
  return _impl_.ask_count_;
}
inline void BandOracleRequest::_internal_set_ask_count(::uint64_t value) {
  ;
  _impl_.ask_count_ = value;
}

// uint64 min_count = 5 [json_name = "minCount"];
inline void BandOracleRequest::clear_min_count() {
  _impl_.min_count_ = ::uint64_t{0u};
}
inline ::uint64_t BandOracleRequest::min_count() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.min_count)
  return _internal_min_count();
}
inline void BandOracleRequest::set_min_count(::uint64_t value) {
  _internal_set_min_count(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.min_count)
}
inline ::uint64_t BandOracleRequest::_internal_min_count() const {
  return _impl_.min_count_;
}
inline void BandOracleRequest::_internal_set_min_count(::uint64_t value) {
  ;
  _impl_.min_count_ = value;
}

// repeated .cosmos.base.v1beta1.Coin fee_limit = 6 [json_name = "feeLimit", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
inline int BandOracleRequest::_internal_fee_limit_size() const {
  return _impl_.fee_limit_.size();
}
inline int BandOracleRequest::fee_limit_size() const {
  return _internal_fee_limit_size();
}
inline ::cosmos::base::v1beta1::Coin* BandOracleRequest::mutable_fee_limit(int index) {
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandOracleRequest.fee_limit)
  return _internal_mutable_fee_limit()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
BandOracleRequest::mutable_fee_limit() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.BandOracleRequest.fee_limit)
  return _internal_mutable_fee_limit();
}
inline const ::cosmos::base::v1beta1::Coin& BandOracleRequest::_internal_fee_limit(int index) const {
  return _internal_fee_limit().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& BandOracleRequest::fee_limit(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.fee_limit)
  return _internal_fee_limit(index);
}
inline ::cosmos::base::v1beta1::Coin* BandOracleRequest::_internal_add_fee_limit() {
  return _internal_mutable_fee_limit()->Add();
}
inline ::cosmos::base::v1beta1::Coin* BandOracleRequest::add_fee_limit() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_fee_limit();
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.BandOracleRequest.fee_limit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
BandOracleRequest::fee_limit() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.BandOracleRequest.fee_limit)
  return _internal_fee_limit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
BandOracleRequest::_internal_fee_limit() const {
  return _impl_.fee_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
BandOracleRequest::_internal_mutable_fee_limit() {
  return &_impl_.fee_limit_;
}

// uint64 prepare_gas = 7 [json_name = "prepareGas"];
inline void BandOracleRequest::clear_prepare_gas() {
  _impl_.prepare_gas_ = ::uint64_t{0u};
}
inline ::uint64_t BandOracleRequest::prepare_gas() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.prepare_gas)
  return _internal_prepare_gas();
}
inline void BandOracleRequest::set_prepare_gas(::uint64_t value) {
  _internal_set_prepare_gas(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.prepare_gas)
}
inline ::uint64_t BandOracleRequest::_internal_prepare_gas() const {
  return _impl_.prepare_gas_;
}
inline void BandOracleRequest::_internal_set_prepare_gas(::uint64_t value) {
  ;
  _impl_.prepare_gas_ = value;
}

// uint64 execute_gas = 8 [json_name = "executeGas"];
inline void BandOracleRequest::clear_execute_gas() {
  _impl_.execute_gas_ = ::uint64_t{0u};
}
inline ::uint64_t BandOracleRequest::execute_gas() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.execute_gas)
  return _internal_execute_gas();
}
inline void BandOracleRequest::set_execute_gas(::uint64_t value) {
  _internal_set_execute_gas(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.execute_gas)
}
inline ::uint64_t BandOracleRequest::_internal_execute_gas() const {
  return _impl_.execute_gas_;
}
inline void BandOracleRequest::_internal_set_execute_gas(::uint64_t value) {
  ;
  _impl_.execute_gas_ = value;
}

// uint64 min_source_count = 9 [json_name = "minSourceCount"];
inline void BandOracleRequest::clear_min_source_count() {
  _impl_.min_source_count_ = ::uint64_t{0u};
}
inline ::uint64_t BandOracleRequest::min_source_count() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandOracleRequest.min_source_count)
  return _internal_min_source_count();
}
inline void BandOracleRequest::set_min_source_count(::uint64_t value) {
  _internal_set_min_source_count(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandOracleRequest.min_source_count)
}
inline ::uint64_t BandOracleRequest::_internal_min_source_count() const {
  return _impl_.min_source_count_;
}
inline void BandOracleRequest::_internal_set_min_source_count(::uint64_t value) {
  ;
  _impl_.min_source_count_ = value;
}

// -------------------------------------------------------------------

// BandIBCParams

// bool band_ibc_enabled = 1 [json_name = "bandIbcEnabled"];
inline void BandIBCParams::clear_band_ibc_enabled() {
  _impl_.band_ibc_enabled_ = false;
}
inline bool BandIBCParams::band_ibc_enabled() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandIBCParams.band_ibc_enabled)
  return _internal_band_ibc_enabled();
}
inline void BandIBCParams::set_band_ibc_enabled(bool value) {
  _internal_set_band_ibc_enabled(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandIBCParams.band_ibc_enabled)
}
inline bool BandIBCParams::_internal_band_ibc_enabled() const {
  return _impl_.band_ibc_enabled_;
}
inline void BandIBCParams::_internal_set_band_ibc_enabled(bool value) {
  ;
  _impl_.band_ibc_enabled_ = value;
}

// int64 ibc_request_interval = 2 [json_name = "ibcRequestInterval"];
inline void BandIBCParams::clear_ibc_request_interval() {
  _impl_.ibc_request_interval_ = ::int64_t{0};
}
inline ::int64_t BandIBCParams::ibc_request_interval() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandIBCParams.ibc_request_interval)
  return _internal_ibc_request_interval();
}
inline void BandIBCParams::set_ibc_request_interval(::int64_t value) {
  _internal_set_ibc_request_interval(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandIBCParams.ibc_request_interval)
}
inline ::int64_t BandIBCParams::_internal_ibc_request_interval() const {
  return _impl_.ibc_request_interval_;
}
inline void BandIBCParams::_internal_set_ibc_request_interval(::int64_t value) {
  ;
  _impl_.ibc_request_interval_ = value;
}

// string ibc_source_channel = 3 [json_name = "ibcSourceChannel"];
inline void BandIBCParams::clear_ibc_source_channel() {
  _impl_.ibc_source_channel_.ClearToEmpty();
}
inline const std::string& BandIBCParams::ibc_source_channel() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandIBCParams.ibc_source_channel)
  return _internal_ibc_source_channel();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandIBCParams::set_ibc_source_channel(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ibc_source_channel_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandIBCParams.ibc_source_channel)
}
inline std::string* BandIBCParams::mutable_ibc_source_channel() {
  std::string* _s = _internal_mutable_ibc_source_channel();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandIBCParams.ibc_source_channel)
  return _s;
}
inline const std::string& BandIBCParams::_internal_ibc_source_channel() const {
  return _impl_.ibc_source_channel_.Get();
}
inline void BandIBCParams::_internal_set_ibc_source_channel(const std::string& value) {
  ;


  _impl_.ibc_source_channel_.Set(value, GetArenaForAllocation());
}
inline std::string* BandIBCParams::_internal_mutable_ibc_source_channel() {
  ;
  return _impl_.ibc_source_channel_.Mutable( GetArenaForAllocation());
}
inline std::string* BandIBCParams::release_ibc_source_channel() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.BandIBCParams.ibc_source_channel)
  return _impl_.ibc_source_channel_.Release();
}
inline void BandIBCParams::set_allocated_ibc_source_channel(std::string* value) {
  _impl_.ibc_source_channel_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ibc_source_channel_.IsDefault()) {
          _impl_.ibc_source_channel_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.BandIBCParams.ibc_source_channel)
}

// string ibc_version = 4 [json_name = "ibcVersion"];
inline void BandIBCParams::clear_ibc_version() {
  _impl_.ibc_version_.ClearToEmpty();
}
inline const std::string& BandIBCParams::ibc_version() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandIBCParams.ibc_version)
  return _internal_ibc_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandIBCParams::set_ibc_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ibc_version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandIBCParams.ibc_version)
}
inline std::string* BandIBCParams::mutable_ibc_version() {
  std::string* _s = _internal_mutable_ibc_version();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandIBCParams.ibc_version)
  return _s;
}
inline const std::string& BandIBCParams::_internal_ibc_version() const {
  return _impl_.ibc_version_.Get();
}
inline void BandIBCParams::_internal_set_ibc_version(const std::string& value) {
  ;


  _impl_.ibc_version_.Set(value, GetArenaForAllocation());
}
inline std::string* BandIBCParams::_internal_mutable_ibc_version() {
  ;
  return _impl_.ibc_version_.Mutable( GetArenaForAllocation());
}
inline std::string* BandIBCParams::release_ibc_version() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.BandIBCParams.ibc_version)
  return _impl_.ibc_version_.Release();
}
inline void BandIBCParams::set_allocated_ibc_version(std::string* value) {
  _impl_.ibc_version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ibc_version_.IsDefault()) {
          _impl_.ibc_version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.BandIBCParams.ibc_version)
}

// string ibc_port_id = 5 [json_name = "ibcPortId"];
inline void BandIBCParams::clear_ibc_port_id() {
  _impl_.ibc_port_id_.ClearToEmpty();
}
inline const std::string& BandIBCParams::ibc_port_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandIBCParams.ibc_port_id)
  return _internal_ibc_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandIBCParams::set_ibc_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ibc_port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandIBCParams.ibc_port_id)
}
inline std::string* BandIBCParams::mutable_ibc_port_id() {
  std::string* _s = _internal_mutable_ibc_port_id();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.BandIBCParams.ibc_port_id)
  return _s;
}
inline const std::string& BandIBCParams::_internal_ibc_port_id() const {
  return _impl_.ibc_port_id_.Get();
}
inline void BandIBCParams::_internal_set_ibc_port_id(const std::string& value) {
  ;


  _impl_.ibc_port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BandIBCParams::_internal_mutable_ibc_port_id() {
  ;
  return _impl_.ibc_port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BandIBCParams::release_ibc_port_id() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.BandIBCParams.ibc_port_id)
  return _impl_.ibc_port_id_.Release();
}
inline void BandIBCParams::set_allocated_ibc_port_id(std::string* value) {
  _impl_.ibc_port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ibc_port_id_.IsDefault()) {
          _impl_.ibc_port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.BandIBCParams.ibc_port_id)
}

// repeated int64 legacy_oracle_ids = 6 [json_name = "legacyOracleIds"];
inline int BandIBCParams::_internal_legacy_oracle_ids_size() const {
  return _impl_.legacy_oracle_ids_.size();
}
inline int BandIBCParams::legacy_oracle_ids_size() const {
  return _internal_legacy_oracle_ids_size();
}
inline void BandIBCParams::clear_legacy_oracle_ids() {
  _internal_mutable_legacy_oracle_ids()->Clear();
}
inline ::int64_t BandIBCParams::legacy_oracle_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.BandIBCParams.legacy_oracle_ids)
  return _internal_legacy_oracle_ids(index);
}
inline void BandIBCParams::set_legacy_oracle_ids(int index, ::int64_t value) {
  _internal_mutable_legacy_oracle_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.BandIBCParams.legacy_oracle_ids)
}
inline void BandIBCParams::add_legacy_oracle_ids(::int64_t value) {
  _internal_add_legacy_oracle_ids(value);
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.BandIBCParams.legacy_oracle_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& BandIBCParams::legacy_oracle_ids() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.BandIBCParams.legacy_oracle_ids)
  return _internal_legacy_oracle_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* BandIBCParams::mutable_legacy_oracle_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.BandIBCParams.legacy_oracle_ids)
  return _internal_mutable_legacy_oracle_ids();
}

inline ::int64_t BandIBCParams::_internal_legacy_oracle_ids(int index) const {
  return _internal_legacy_oracle_ids().Get(index);
}
inline void BandIBCParams::_internal_add_legacy_oracle_ids(::int64_t value) {
  _internal_mutable_legacy_oracle_ids()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& BandIBCParams::_internal_legacy_oracle_ids() const {
  return _impl_.legacy_oracle_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* BandIBCParams::_internal_mutable_legacy_oracle_ids() {
  return &_impl_.legacy_oracle_ids_;
}

// -------------------------------------------------------------------

// SymbolPriceTimestamp

// .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
inline void SymbolPriceTimestamp::clear_oracle() {
  _impl_.oracle_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType SymbolPriceTimestamp::oracle() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.SymbolPriceTimestamp.oracle)
  return _internal_oracle();
}
inline void SymbolPriceTimestamp::set_oracle(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.SymbolPriceTimestamp.oracle)
}
inline ::injective::oracle::v1beta1::OracleType SymbolPriceTimestamp::_internal_oracle() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_);
}
inline void SymbolPriceTimestamp::_internal_set_oracle(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_ = value;
}

// string symbol_id = 2 [json_name = "symbolId"];
inline void SymbolPriceTimestamp::clear_symbol_id() {
  _impl_.symbol_id_.ClearToEmpty();
}
inline const std::string& SymbolPriceTimestamp::symbol_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.SymbolPriceTimestamp.symbol_id)
  return _internal_symbol_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymbolPriceTimestamp::set_symbol_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.SymbolPriceTimestamp.symbol_id)
}
inline std::string* SymbolPriceTimestamp::mutable_symbol_id() {
  std::string* _s = _internal_mutable_symbol_id();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.SymbolPriceTimestamp.symbol_id)
  return _s;
}
inline const std::string& SymbolPriceTimestamp::_internal_symbol_id() const {
  return _impl_.symbol_id_.Get();
}
inline void SymbolPriceTimestamp::_internal_set_symbol_id(const std::string& value) {
  ;


  _impl_.symbol_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SymbolPriceTimestamp::_internal_mutable_symbol_id() {
  ;
  return _impl_.symbol_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SymbolPriceTimestamp::release_symbol_id() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.SymbolPriceTimestamp.symbol_id)
  return _impl_.symbol_id_.Release();
}
inline void SymbolPriceTimestamp::set_allocated_symbol_id(std::string* value) {
  _impl_.symbol_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_id_.IsDefault()) {
          _impl_.symbol_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.SymbolPriceTimestamp.symbol_id)
}

// int64 timestamp = 3 [json_name = "timestamp"];
inline void SymbolPriceTimestamp::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t SymbolPriceTimestamp::timestamp() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.SymbolPriceTimestamp.timestamp)
  return _internal_timestamp();
}
inline void SymbolPriceTimestamp::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.SymbolPriceTimestamp.timestamp)
}
inline ::int64_t SymbolPriceTimestamp::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void SymbolPriceTimestamp::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// LastPriceTimestamps

// repeated .injective.oracle.v1beta1.SymbolPriceTimestamp last_price_timestamps = 1 [json_name = "lastPriceTimestamps"];
inline int LastPriceTimestamps::_internal_last_price_timestamps_size() const {
  return _impl_.last_price_timestamps_.size();
}
inline int LastPriceTimestamps::last_price_timestamps_size() const {
  return _internal_last_price_timestamps_size();
}
inline void LastPriceTimestamps::clear_last_price_timestamps() {
  _internal_mutable_last_price_timestamps()->Clear();
}
inline ::injective::oracle::v1beta1::SymbolPriceTimestamp* LastPriceTimestamps::mutable_last_price_timestamps(int index) {
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.LastPriceTimestamps.last_price_timestamps)
  return _internal_mutable_last_price_timestamps()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::SymbolPriceTimestamp >*
LastPriceTimestamps::mutable_last_price_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.LastPriceTimestamps.last_price_timestamps)
  return _internal_mutable_last_price_timestamps();
}
inline const ::injective::oracle::v1beta1::SymbolPriceTimestamp& LastPriceTimestamps::_internal_last_price_timestamps(int index) const {
  return _internal_last_price_timestamps().Get(index);
}
inline const ::injective::oracle::v1beta1::SymbolPriceTimestamp& LastPriceTimestamps::last_price_timestamps(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.LastPriceTimestamps.last_price_timestamps)
  return _internal_last_price_timestamps(index);
}
inline ::injective::oracle::v1beta1::SymbolPriceTimestamp* LastPriceTimestamps::_internal_add_last_price_timestamps() {
  return _internal_mutable_last_price_timestamps()->Add();
}
inline ::injective::oracle::v1beta1::SymbolPriceTimestamp* LastPriceTimestamps::add_last_price_timestamps() {
  ::injective::oracle::v1beta1::SymbolPriceTimestamp* _add = _internal_add_last_price_timestamps();
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.LastPriceTimestamps.last_price_timestamps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::SymbolPriceTimestamp >&
LastPriceTimestamps::last_price_timestamps() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.LastPriceTimestamps.last_price_timestamps)
  return _internal_last_price_timestamps();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::SymbolPriceTimestamp>&
LastPriceTimestamps::_internal_last_price_timestamps() const {
  return _impl_.last_price_timestamps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::SymbolPriceTimestamp>*
LastPriceTimestamps::_internal_mutable_last_price_timestamps() {
  return &_impl_.last_price_timestamps_;
}

// -------------------------------------------------------------------

// PriceRecords

// .injective.oracle.v1beta1.OracleType oracle = 1 [json_name = "oracle"];
inline void PriceRecords::clear_oracle() {
  _impl_.oracle_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType PriceRecords::oracle() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceRecords.oracle)
  return _internal_oracle();
}
inline void PriceRecords::set_oracle(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceRecords.oracle)
}
inline ::injective::oracle::v1beta1::OracleType PriceRecords::_internal_oracle() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_);
}
inline void PriceRecords::_internal_set_oracle(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_ = value;
}

// string symbol_id = 2 [json_name = "symbolId"];
inline void PriceRecords::clear_symbol_id() {
  _impl_.symbol_id_.ClearToEmpty();
}
inline const std::string& PriceRecords::symbol_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceRecords.symbol_id)
  return _internal_symbol_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceRecords::set_symbol_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceRecords.symbol_id)
}
inline std::string* PriceRecords::mutable_symbol_id() {
  std::string* _s = _internal_mutable_symbol_id();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceRecords.symbol_id)
  return _s;
}
inline const std::string& PriceRecords::_internal_symbol_id() const {
  return _impl_.symbol_id_.Get();
}
inline void PriceRecords::_internal_set_symbol_id(const std::string& value) {
  ;


  _impl_.symbol_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceRecords::_internal_mutable_symbol_id() {
  ;
  return _impl_.symbol_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceRecords::release_symbol_id() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceRecords.symbol_id)
  return _impl_.symbol_id_.Release();
}
inline void PriceRecords::set_allocated_symbol_id(std::string* value) {
  _impl_.symbol_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_id_.IsDefault()) {
          _impl_.symbol_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceRecords.symbol_id)
}

// repeated .injective.oracle.v1beta1.PriceRecord latest_price_records = 3 [json_name = "latestPriceRecords"];
inline int PriceRecords::_internal_latest_price_records_size() const {
  return _impl_.latest_price_records_.size();
}
inline int PriceRecords::latest_price_records_size() const {
  return _internal_latest_price_records_size();
}
inline void PriceRecords::clear_latest_price_records() {
  _internal_mutable_latest_price_records()->Clear();
}
inline ::injective::oracle::v1beta1::PriceRecord* PriceRecords::mutable_latest_price_records(int index) {
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceRecords.latest_price_records)
  return _internal_mutable_latest_price_records()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::PriceRecord >*
PriceRecords::mutable_latest_price_records() {
  // @@protoc_insertion_point(field_mutable_list:injective.oracle.v1beta1.PriceRecords.latest_price_records)
  return _internal_mutable_latest_price_records();
}
inline const ::injective::oracle::v1beta1::PriceRecord& PriceRecords::_internal_latest_price_records(int index) const {
  return _internal_latest_price_records().Get(index);
}
inline const ::injective::oracle::v1beta1::PriceRecord& PriceRecords::latest_price_records(int index) const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceRecords.latest_price_records)
  return _internal_latest_price_records(index);
}
inline ::injective::oracle::v1beta1::PriceRecord* PriceRecords::_internal_add_latest_price_records() {
  return _internal_mutable_latest_price_records()->Add();
}
inline ::injective::oracle::v1beta1::PriceRecord* PriceRecords::add_latest_price_records() {
  ::injective::oracle::v1beta1::PriceRecord* _add = _internal_add_latest_price_records();
  // @@protoc_insertion_point(field_add:injective.oracle.v1beta1.PriceRecords.latest_price_records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::oracle::v1beta1::PriceRecord >&
PriceRecords::latest_price_records() const {
  // @@protoc_insertion_point(field_list:injective.oracle.v1beta1.PriceRecords.latest_price_records)
  return _internal_latest_price_records();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::PriceRecord>&
PriceRecords::_internal_latest_price_records() const {
  return _impl_.latest_price_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::oracle::v1beta1::PriceRecord>*
PriceRecords::_internal_mutable_latest_price_records() {
  return &_impl_.latest_price_records_;
}

// -------------------------------------------------------------------

// PriceRecord

// int64 timestamp = 1 [json_name = "timestamp"];
inline void PriceRecord::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t PriceRecord::timestamp() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceRecord.timestamp)
  return _internal_timestamp();
}
inline void PriceRecord::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceRecord.timestamp)
}
inline ::int64_t PriceRecord::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void PriceRecord::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PriceRecord::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceRecord::price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceRecord.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceRecord::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceRecord.price)
}
inline std::string* PriceRecord::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceRecord.price)
  return _s;
}
inline const std::string& PriceRecord::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceRecord::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceRecord::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceRecord::release_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceRecord.price)
  return _impl_.price_.Release();
}
inline void PriceRecord::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceRecord.price)
}

// -------------------------------------------------------------------

// MetadataStatistics

// uint32 group_count = 1 [json_name = "groupCount"];
inline void MetadataStatistics::clear_group_count() {
  _impl_.group_count_ = 0u;
}
inline ::uint32_t MetadataStatistics::group_count() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.group_count)
  return _internal_group_count();
}
inline void MetadataStatistics::set_group_count(::uint32_t value) {
  _internal_set_group_count(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.group_count)
}
inline ::uint32_t MetadataStatistics::_internal_group_count() const {
  return _impl_.group_count_;
}
inline void MetadataStatistics::_internal_set_group_count(::uint32_t value) {
  ;
  _impl_.group_count_ = value;
}

// uint32 records_sample_size = 2 [json_name = "recordsSampleSize"];
inline void MetadataStatistics::clear_records_sample_size() {
  _impl_.records_sample_size_ = 0u;
}
inline ::uint32_t MetadataStatistics::records_sample_size() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.records_sample_size)
  return _internal_records_sample_size();
}
inline void MetadataStatistics::set_records_sample_size(::uint32_t value) {
  _internal_set_records_sample_size(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.records_sample_size)
}
inline ::uint32_t MetadataStatistics::_internal_records_sample_size() const {
  return _impl_.records_sample_size_;
}
inline void MetadataStatistics::_internal_set_records_sample_size(::uint32_t value) {
  ;
  _impl_.records_sample_size_ = value;
}

// string mean = 3 [json_name = "mean", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MetadataStatistics::clear_mean() {
  _impl_.mean_.ClearToEmpty();
}
inline const std::string& MetadataStatistics::mean() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.mean)
  return _internal_mean();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataStatistics::set_mean(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mean_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.mean)
}
inline std::string* MetadataStatistics::mutable_mean() {
  std::string* _s = _internal_mutable_mean();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.MetadataStatistics.mean)
  return _s;
}
inline const std::string& MetadataStatistics::_internal_mean() const {
  return _impl_.mean_.Get();
}
inline void MetadataStatistics::_internal_set_mean(const std::string& value) {
  ;


  _impl_.mean_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStatistics::_internal_mutable_mean() {
  ;
  return _impl_.mean_.Mutable( GetArenaForAllocation());
}
inline std::string* MetadataStatistics::release_mean() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.MetadataStatistics.mean)
  return _impl_.mean_.Release();
}
inline void MetadataStatistics::set_allocated_mean(std::string* value) {
  _impl_.mean_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mean_.IsDefault()) {
          _impl_.mean_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.MetadataStatistics.mean)
}

// string twap = 4 [json_name = "twap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MetadataStatistics::clear_twap() {
  _impl_.twap_.ClearToEmpty();
}
inline const std::string& MetadataStatistics::twap() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.twap)
  return _internal_twap();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataStatistics::set_twap(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.twap_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.twap)
}
inline std::string* MetadataStatistics::mutable_twap() {
  std::string* _s = _internal_mutable_twap();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.MetadataStatistics.twap)
  return _s;
}
inline const std::string& MetadataStatistics::_internal_twap() const {
  return _impl_.twap_.Get();
}
inline void MetadataStatistics::_internal_set_twap(const std::string& value) {
  ;


  _impl_.twap_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStatistics::_internal_mutable_twap() {
  ;
  return _impl_.twap_.Mutable( GetArenaForAllocation());
}
inline std::string* MetadataStatistics::release_twap() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.MetadataStatistics.twap)
  return _impl_.twap_.Release();
}
inline void MetadataStatistics::set_allocated_twap(std::string* value) {
  _impl_.twap_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.twap_.IsDefault()) {
          _impl_.twap_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.MetadataStatistics.twap)
}

// int64 first_timestamp = 5 [json_name = "firstTimestamp"];
inline void MetadataStatistics::clear_first_timestamp() {
  _impl_.first_timestamp_ = ::int64_t{0};
}
inline ::int64_t MetadataStatistics::first_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.first_timestamp)
  return _internal_first_timestamp();
}
inline void MetadataStatistics::set_first_timestamp(::int64_t value) {
  _internal_set_first_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.first_timestamp)
}
inline ::int64_t MetadataStatistics::_internal_first_timestamp() const {
  return _impl_.first_timestamp_;
}
inline void MetadataStatistics::_internal_set_first_timestamp(::int64_t value) {
  ;
  _impl_.first_timestamp_ = value;
}

// int64 last_timestamp = 6 [json_name = "lastTimestamp"];
inline void MetadataStatistics::clear_last_timestamp() {
  _impl_.last_timestamp_ = ::int64_t{0};
}
inline ::int64_t MetadataStatistics::last_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.last_timestamp)
  return _internal_last_timestamp();
}
inline void MetadataStatistics::set_last_timestamp(::int64_t value) {
  _internal_set_last_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.last_timestamp)
}
inline ::int64_t MetadataStatistics::_internal_last_timestamp() const {
  return _impl_.last_timestamp_;
}
inline void MetadataStatistics::_internal_set_last_timestamp(::int64_t value) {
  ;
  _impl_.last_timestamp_ = value;
}

// string min_price = 7 [json_name = "minPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MetadataStatistics::clear_min_price() {
  _impl_.min_price_.ClearToEmpty();
}
inline const std::string& MetadataStatistics::min_price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.min_price)
  return _internal_min_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataStatistics::set_min_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.min_price)
}
inline std::string* MetadataStatistics::mutable_min_price() {
  std::string* _s = _internal_mutable_min_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.MetadataStatistics.min_price)
  return _s;
}
inline const std::string& MetadataStatistics::_internal_min_price() const {
  return _impl_.min_price_.Get();
}
inline void MetadataStatistics::_internal_set_min_price(const std::string& value) {
  ;


  _impl_.min_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStatistics::_internal_mutable_min_price() {
  ;
  return _impl_.min_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MetadataStatistics::release_min_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.MetadataStatistics.min_price)
  return _impl_.min_price_.Release();
}
inline void MetadataStatistics::set_allocated_min_price(std::string* value) {
  _impl_.min_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_.IsDefault()) {
          _impl_.min_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.MetadataStatistics.min_price)
}

// string max_price = 8 [json_name = "maxPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MetadataStatistics::clear_max_price() {
  _impl_.max_price_.ClearToEmpty();
}
inline const std::string& MetadataStatistics::max_price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.max_price)
  return _internal_max_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataStatistics::set_max_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.max_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.max_price)
}
inline std::string* MetadataStatistics::mutable_max_price() {
  std::string* _s = _internal_mutable_max_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.MetadataStatistics.max_price)
  return _s;
}
inline const std::string& MetadataStatistics::_internal_max_price() const {
  return _impl_.max_price_.Get();
}
inline void MetadataStatistics::_internal_set_max_price(const std::string& value) {
  ;


  _impl_.max_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStatistics::_internal_mutable_max_price() {
  ;
  return _impl_.max_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MetadataStatistics::release_max_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.MetadataStatistics.max_price)
  return _impl_.max_price_.Release();
}
inline void MetadataStatistics::set_allocated_max_price(std::string* value) {
  _impl_.max_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.max_price_.IsDefault()) {
          _impl_.max_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.MetadataStatistics.max_price)
}

// string median_price = 9 [json_name = "medianPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MetadataStatistics::clear_median_price() {
  _impl_.median_price_.ClearToEmpty();
}
inline const std::string& MetadataStatistics::median_price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.MetadataStatistics.median_price)
  return _internal_median_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MetadataStatistics::set_median_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.median_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.MetadataStatistics.median_price)
}
inline std::string* MetadataStatistics::mutable_median_price() {
  std::string* _s = _internal_mutable_median_price();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.MetadataStatistics.median_price)
  return _s;
}
inline const std::string& MetadataStatistics::_internal_median_price() const {
  return _impl_.median_price_.Get();
}
inline void MetadataStatistics::_internal_set_median_price(const std::string& value) {
  ;


  _impl_.median_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MetadataStatistics::_internal_mutable_median_price() {
  ;
  return _impl_.median_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MetadataStatistics::release_median_price() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.MetadataStatistics.median_price)
  return _impl_.median_price_.Release();
}
inline void MetadataStatistics::set_allocated_median_price(std::string* value) {
  _impl_.median_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.median_price_.IsDefault()) {
          _impl_.median_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.MetadataStatistics.median_price)
}

// -------------------------------------------------------------------

// PriceAttestation

// string price_id = 1 [json_name = "priceId"];
inline void PriceAttestation::clear_price_id() {
  _impl_.price_id_.ClearToEmpty();
}
inline const std::string& PriceAttestation::price_id() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.price_id)
  return _internal_price_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceAttestation::set_price_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.price_id)
}
inline std::string* PriceAttestation::mutable_price_id() {
  std::string* _s = _internal_mutable_price_id();
  // @@protoc_insertion_point(field_mutable:injective.oracle.v1beta1.PriceAttestation.price_id)
  return _s;
}
inline const std::string& PriceAttestation::_internal_price_id() const {
  return _impl_.price_id_.Get();
}
inline void PriceAttestation::_internal_set_price_id(const std::string& value) {
  ;


  _impl_.price_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceAttestation::_internal_mutable_price_id() {
  ;
  return _impl_.price_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceAttestation::release_price_id() {
  // @@protoc_insertion_point(field_release:injective.oracle.v1beta1.PriceAttestation.price_id)
  return _impl_.price_id_.Release();
}
inline void PriceAttestation::set_allocated_price_id(std::string* value) {
  _impl_.price_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_id_.IsDefault()) {
          _impl_.price_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.oracle.v1beta1.PriceAttestation.price_id)
}

// int64 price = 2 [json_name = "price"];
inline void PriceAttestation::clear_price() {
  _impl_.price_ = ::int64_t{0};
}
inline ::int64_t PriceAttestation::price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.price)
  return _internal_price();
}
inline void PriceAttestation::set_price(::int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.price)
}
inline ::int64_t PriceAttestation::_internal_price() const {
  return _impl_.price_;
}
inline void PriceAttestation::_internal_set_price(::int64_t value) {
  ;
  _impl_.price_ = value;
}

// uint64 conf = 3 [json_name = "conf"];
inline void PriceAttestation::clear_conf() {
  _impl_.conf_ = ::uint64_t{0u};
}
inline ::uint64_t PriceAttestation::conf() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.conf)
  return _internal_conf();
}
inline void PriceAttestation::set_conf(::uint64_t value) {
  _internal_set_conf(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.conf)
}
inline ::uint64_t PriceAttestation::_internal_conf() const {
  return _impl_.conf_;
}
inline void PriceAttestation::_internal_set_conf(::uint64_t value) {
  ;
  _impl_.conf_ = value;
}

// int32 expo = 4 [json_name = "expo"];
inline void PriceAttestation::clear_expo() {
  _impl_.expo_ = 0;
}
inline ::int32_t PriceAttestation::expo() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.expo)
  return _internal_expo();
}
inline void PriceAttestation::set_expo(::int32_t value) {
  _internal_set_expo(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.expo)
}
inline ::int32_t PriceAttestation::_internal_expo() const {
  return _impl_.expo_;
}
inline void PriceAttestation::_internal_set_expo(::int32_t value) {
  ;
  _impl_.expo_ = value;
}

// int64 ema_price = 5 [json_name = "emaPrice"];
inline void PriceAttestation::clear_ema_price() {
  _impl_.ema_price_ = ::int64_t{0};
}
inline ::int64_t PriceAttestation::ema_price() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.ema_price)
  return _internal_ema_price();
}
inline void PriceAttestation::set_ema_price(::int64_t value) {
  _internal_set_ema_price(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.ema_price)
}
inline ::int64_t PriceAttestation::_internal_ema_price() const {
  return _impl_.ema_price_;
}
inline void PriceAttestation::_internal_set_ema_price(::int64_t value) {
  ;
  _impl_.ema_price_ = value;
}

// uint64 ema_conf = 6 [json_name = "emaConf"];
inline void PriceAttestation::clear_ema_conf() {
  _impl_.ema_conf_ = ::uint64_t{0u};
}
inline ::uint64_t PriceAttestation::ema_conf() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.ema_conf)
  return _internal_ema_conf();
}
inline void PriceAttestation::set_ema_conf(::uint64_t value) {
  _internal_set_ema_conf(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.ema_conf)
}
inline ::uint64_t PriceAttestation::_internal_ema_conf() const {
  return _impl_.ema_conf_;
}
inline void PriceAttestation::_internal_set_ema_conf(::uint64_t value) {
  ;
  _impl_.ema_conf_ = value;
}

// int32 ema_expo = 7 [json_name = "emaExpo"];
inline void PriceAttestation::clear_ema_expo() {
  _impl_.ema_expo_ = 0;
}
inline ::int32_t PriceAttestation::ema_expo() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.ema_expo)
  return _internal_ema_expo();
}
inline void PriceAttestation::set_ema_expo(::int32_t value) {
  _internal_set_ema_expo(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.ema_expo)
}
inline ::int32_t PriceAttestation::_internal_ema_expo() const {
  return _impl_.ema_expo_;
}
inline void PriceAttestation::_internal_set_ema_expo(::int32_t value) {
  ;
  _impl_.ema_expo_ = value;
}

// int64 publish_time = 8 [json_name = "publishTime"];
inline void PriceAttestation::clear_publish_time() {
  _impl_.publish_time_ = ::int64_t{0};
}
inline ::int64_t PriceAttestation::publish_time() const {
  // @@protoc_insertion_point(field_get:injective.oracle.v1beta1.PriceAttestation.publish_time)
  return _internal_publish_time();
}
inline void PriceAttestation::set_publish_time(::int64_t value) {
  _internal_set_publish_time(value);
  // @@protoc_insertion_point(field_set:injective.oracle.v1beta1.PriceAttestation.publish_time)
}
inline ::int64_t PriceAttestation::_internal_publish_time() const {
  return _impl_.publish_time_;
}
inline void PriceAttestation::_internal_set_publish_time(::int64_t value) {
  ;
  _impl_.publish_time_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace oracle
}  // namespace injective


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::injective::oracle::v1beta1::OracleType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::oracle::v1beta1::OracleType>() {
  return ::injective::oracle::v1beta1::OracleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2foracle_2fv1beta1_2foracle_2eproto_2epb_2eh
