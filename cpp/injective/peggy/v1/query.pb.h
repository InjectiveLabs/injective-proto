// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/peggy/v1/query.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2fpeggy_2fv1_2fquery_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2fpeggy_2fv1_2fquery_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "injective/peggy/v1/genesis.pb.h"
#include "injective/peggy/v1/params.pb.h"
#include "injective/peggy/v1/types.pb.h"
#include "injective/peggy/v1/msgs.pb.h"
#include "injective/peggy/v1/pool.pb.h"
#include "injective/peggy/v1/batch.pb.h"
#include "google/api/annotations.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2fpeggy_2fv1_2fquery_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2fpeggy_2fv1_2fquery_2eproto;
namespace injective {
namespace peggy {
namespace v1 {
class MissingNoncesRequest;
struct MissingNoncesRequestDefaultTypeInternal;
extern MissingNoncesRequestDefaultTypeInternal _MissingNoncesRequest_default_instance_;
class MissingNoncesResponse;
struct MissingNoncesResponseDefaultTypeInternal;
extern MissingNoncesResponseDefaultTypeInternal _MissingNoncesResponse_default_instance_;
class QueryBatchConfirmsRequest;
struct QueryBatchConfirmsRequestDefaultTypeInternal;
extern QueryBatchConfirmsRequestDefaultTypeInternal _QueryBatchConfirmsRequest_default_instance_;
class QueryBatchConfirmsResponse;
struct QueryBatchConfirmsResponseDefaultTypeInternal;
extern QueryBatchConfirmsResponseDefaultTypeInternal _QueryBatchConfirmsResponse_default_instance_;
class QueryBatchFeeRequest;
struct QueryBatchFeeRequestDefaultTypeInternal;
extern QueryBatchFeeRequestDefaultTypeInternal _QueryBatchFeeRequest_default_instance_;
class QueryBatchFeeResponse;
struct QueryBatchFeeResponseDefaultTypeInternal;
extern QueryBatchFeeResponseDefaultTypeInternal _QueryBatchFeeResponse_default_instance_;
class QueryBatchRequestByNonceRequest;
struct QueryBatchRequestByNonceRequestDefaultTypeInternal;
extern QueryBatchRequestByNonceRequestDefaultTypeInternal _QueryBatchRequestByNonceRequest_default_instance_;
class QueryBatchRequestByNonceResponse;
struct QueryBatchRequestByNonceResponseDefaultTypeInternal;
extern QueryBatchRequestByNonceResponseDefaultTypeInternal _QueryBatchRequestByNonceResponse_default_instance_;
class QueryCurrentValsetRequest;
struct QueryCurrentValsetRequestDefaultTypeInternal;
extern QueryCurrentValsetRequestDefaultTypeInternal _QueryCurrentValsetRequest_default_instance_;
class QueryCurrentValsetResponse;
struct QueryCurrentValsetResponseDefaultTypeInternal;
extern QueryCurrentValsetResponseDefaultTypeInternal _QueryCurrentValsetResponse_default_instance_;
class QueryDelegateKeysByEthAddress;
struct QueryDelegateKeysByEthAddressDefaultTypeInternal;
extern QueryDelegateKeysByEthAddressDefaultTypeInternal _QueryDelegateKeysByEthAddress_default_instance_;
class QueryDelegateKeysByEthAddressResponse;
struct QueryDelegateKeysByEthAddressResponseDefaultTypeInternal;
extern QueryDelegateKeysByEthAddressResponseDefaultTypeInternal _QueryDelegateKeysByEthAddressResponse_default_instance_;
class QueryDelegateKeysByOrchestratorAddress;
struct QueryDelegateKeysByOrchestratorAddressDefaultTypeInternal;
extern QueryDelegateKeysByOrchestratorAddressDefaultTypeInternal _QueryDelegateKeysByOrchestratorAddress_default_instance_;
class QueryDelegateKeysByOrchestratorAddressResponse;
struct QueryDelegateKeysByOrchestratorAddressResponseDefaultTypeInternal;
extern QueryDelegateKeysByOrchestratorAddressResponseDefaultTypeInternal _QueryDelegateKeysByOrchestratorAddressResponse_default_instance_;
class QueryDelegateKeysByValidatorAddress;
struct QueryDelegateKeysByValidatorAddressDefaultTypeInternal;
extern QueryDelegateKeysByValidatorAddressDefaultTypeInternal _QueryDelegateKeysByValidatorAddress_default_instance_;
class QueryDelegateKeysByValidatorAddressResponse;
struct QueryDelegateKeysByValidatorAddressResponseDefaultTypeInternal;
extern QueryDelegateKeysByValidatorAddressResponseDefaultTypeInternal _QueryDelegateKeysByValidatorAddressResponse_default_instance_;
class QueryDenomToERC20Request;
struct QueryDenomToERC20RequestDefaultTypeInternal;
extern QueryDenomToERC20RequestDefaultTypeInternal _QueryDenomToERC20Request_default_instance_;
class QueryDenomToERC20Response;
struct QueryDenomToERC20ResponseDefaultTypeInternal;
extern QueryDenomToERC20ResponseDefaultTypeInternal _QueryDenomToERC20Response_default_instance_;
class QueryERC20ToDenomRequest;
struct QueryERC20ToDenomRequestDefaultTypeInternal;
extern QueryERC20ToDenomRequestDefaultTypeInternal _QueryERC20ToDenomRequest_default_instance_;
class QueryERC20ToDenomResponse;
struct QueryERC20ToDenomResponseDefaultTypeInternal;
extern QueryERC20ToDenomResponseDefaultTypeInternal _QueryERC20ToDenomResponse_default_instance_;
class QueryLastEventByAddrRequest;
struct QueryLastEventByAddrRequestDefaultTypeInternal;
extern QueryLastEventByAddrRequestDefaultTypeInternal _QueryLastEventByAddrRequest_default_instance_;
class QueryLastEventByAddrResponse;
struct QueryLastEventByAddrResponseDefaultTypeInternal;
extern QueryLastEventByAddrResponseDefaultTypeInternal _QueryLastEventByAddrResponse_default_instance_;
class QueryLastPendingBatchRequestByAddrRequest;
struct QueryLastPendingBatchRequestByAddrRequestDefaultTypeInternal;
extern QueryLastPendingBatchRequestByAddrRequestDefaultTypeInternal _QueryLastPendingBatchRequestByAddrRequest_default_instance_;
class QueryLastPendingBatchRequestByAddrResponse;
struct QueryLastPendingBatchRequestByAddrResponseDefaultTypeInternal;
extern QueryLastPendingBatchRequestByAddrResponseDefaultTypeInternal _QueryLastPendingBatchRequestByAddrResponse_default_instance_;
class QueryLastPendingValsetRequestByAddrRequest;
struct QueryLastPendingValsetRequestByAddrRequestDefaultTypeInternal;
extern QueryLastPendingValsetRequestByAddrRequestDefaultTypeInternal _QueryLastPendingValsetRequestByAddrRequest_default_instance_;
class QueryLastPendingValsetRequestByAddrResponse;
struct QueryLastPendingValsetRequestByAddrResponseDefaultTypeInternal;
extern QueryLastPendingValsetRequestByAddrResponseDefaultTypeInternal _QueryLastPendingValsetRequestByAddrResponse_default_instance_;
class QueryLastValsetRequestsRequest;
struct QueryLastValsetRequestsRequestDefaultTypeInternal;
extern QueryLastValsetRequestsRequestDefaultTypeInternal _QueryLastValsetRequestsRequest_default_instance_;
class QueryLastValsetRequestsResponse;
struct QueryLastValsetRequestsResponseDefaultTypeInternal;
extern QueryLastValsetRequestsResponseDefaultTypeInternal _QueryLastValsetRequestsResponse_default_instance_;
class QueryModuleStateRequest;
struct QueryModuleStateRequestDefaultTypeInternal;
extern QueryModuleStateRequestDefaultTypeInternal _QueryModuleStateRequest_default_instance_;
class QueryModuleStateResponse;
struct QueryModuleStateResponseDefaultTypeInternal;
extern QueryModuleStateResponseDefaultTypeInternal _QueryModuleStateResponse_default_instance_;
class QueryOutgoingTxBatchesRequest;
struct QueryOutgoingTxBatchesRequestDefaultTypeInternal;
extern QueryOutgoingTxBatchesRequestDefaultTypeInternal _QueryOutgoingTxBatchesRequest_default_instance_;
class QueryOutgoingTxBatchesResponse;
struct QueryOutgoingTxBatchesResponseDefaultTypeInternal;
extern QueryOutgoingTxBatchesResponseDefaultTypeInternal _QueryOutgoingTxBatchesResponse_default_instance_;
class QueryParamsRequest;
struct QueryParamsRequestDefaultTypeInternal;
extern QueryParamsRequestDefaultTypeInternal _QueryParamsRequest_default_instance_;
class QueryParamsResponse;
struct QueryParamsResponseDefaultTypeInternal;
extern QueryParamsResponseDefaultTypeInternal _QueryParamsResponse_default_instance_;
class QueryPendingSendToEth;
struct QueryPendingSendToEthDefaultTypeInternal;
extern QueryPendingSendToEthDefaultTypeInternal _QueryPendingSendToEth_default_instance_;
class QueryPendingSendToEthResponse;
struct QueryPendingSendToEthResponseDefaultTypeInternal;
extern QueryPendingSendToEthResponseDefaultTypeInternal _QueryPendingSendToEthResponse_default_instance_;
class QueryValsetConfirmRequest;
struct QueryValsetConfirmRequestDefaultTypeInternal;
extern QueryValsetConfirmRequestDefaultTypeInternal _QueryValsetConfirmRequest_default_instance_;
class QueryValsetConfirmResponse;
struct QueryValsetConfirmResponseDefaultTypeInternal;
extern QueryValsetConfirmResponseDefaultTypeInternal _QueryValsetConfirmResponse_default_instance_;
class QueryValsetConfirmsByNonceRequest;
struct QueryValsetConfirmsByNonceRequestDefaultTypeInternal;
extern QueryValsetConfirmsByNonceRequestDefaultTypeInternal _QueryValsetConfirmsByNonceRequest_default_instance_;
class QueryValsetConfirmsByNonceResponse;
struct QueryValsetConfirmsByNonceResponseDefaultTypeInternal;
extern QueryValsetConfirmsByNonceResponseDefaultTypeInternal _QueryValsetConfirmsByNonceResponse_default_instance_;
class QueryValsetRequestRequest;
struct QueryValsetRequestRequestDefaultTypeInternal;
extern QueryValsetRequestRequestDefaultTypeInternal _QueryValsetRequestRequest_default_instance_;
class QueryValsetRequestResponse;
struct QueryValsetRequestResponseDefaultTypeInternal;
extern QueryValsetRequestResponseDefaultTypeInternal _QueryValsetRequestResponse_default_instance_;
}  // namespace v1
}  // namespace peggy
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::peggy::v1::MissingNoncesRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::MissingNoncesRequest>(Arena*);
template <>
::injective::peggy::v1::MissingNoncesResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::MissingNoncesResponse>(Arena*);
template <>
::injective::peggy::v1::QueryBatchConfirmsRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryBatchConfirmsRequest>(Arena*);
template <>
::injective::peggy::v1::QueryBatchConfirmsResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryBatchConfirmsResponse>(Arena*);
template <>
::injective::peggy::v1::QueryBatchFeeRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryBatchFeeRequest>(Arena*);
template <>
::injective::peggy::v1::QueryBatchFeeResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryBatchFeeResponse>(Arena*);
template <>
::injective::peggy::v1::QueryBatchRequestByNonceRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryBatchRequestByNonceRequest>(Arena*);
template <>
::injective::peggy::v1::QueryBatchRequestByNonceResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryBatchRequestByNonceResponse>(Arena*);
template <>
::injective::peggy::v1::QueryCurrentValsetRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryCurrentValsetRequest>(Arena*);
template <>
::injective::peggy::v1::QueryCurrentValsetResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryCurrentValsetResponse>(Arena*);
template <>
::injective::peggy::v1::QueryDelegateKeysByEthAddress* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDelegateKeysByEthAddress>(Arena*);
template <>
::injective::peggy::v1::QueryDelegateKeysByEthAddressResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDelegateKeysByEthAddressResponse>(Arena*);
template <>
::injective::peggy::v1::QueryDelegateKeysByOrchestratorAddress* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDelegateKeysByOrchestratorAddress>(Arena*);
template <>
::injective::peggy::v1::QueryDelegateKeysByOrchestratorAddressResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDelegateKeysByOrchestratorAddressResponse>(Arena*);
template <>
::injective::peggy::v1::QueryDelegateKeysByValidatorAddress* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDelegateKeysByValidatorAddress>(Arena*);
template <>
::injective::peggy::v1::QueryDelegateKeysByValidatorAddressResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDelegateKeysByValidatorAddressResponse>(Arena*);
template <>
::injective::peggy::v1::QueryDenomToERC20Request* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDenomToERC20Request>(Arena*);
template <>
::injective::peggy::v1::QueryDenomToERC20Response* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryDenomToERC20Response>(Arena*);
template <>
::injective::peggy::v1::QueryERC20ToDenomRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryERC20ToDenomRequest>(Arena*);
template <>
::injective::peggy::v1::QueryERC20ToDenomResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryERC20ToDenomResponse>(Arena*);
template <>
::injective::peggy::v1::QueryLastEventByAddrRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastEventByAddrRequest>(Arena*);
template <>
::injective::peggy::v1::QueryLastEventByAddrResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastEventByAddrResponse>(Arena*);
template <>
::injective::peggy::v1::QueryLastPendingBatchRequestByAddrRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastPendingBatchRequestByAddrRequest>(Arena*);
template <>
::injective::peggy::v1::QueryLastPendingBatchRequestByAddrResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastPendingBatchRequestByAddrResponse>(Arena*);
template <>
::injective::peggy::v1::QueryLastPendingValsetRequestByAddrRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastPendingValsetRequestByAddrRequest>(Arena*);
template <>
::injective::peggy::v1::QueryLastPendingValsetRequestByAddrResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastPendingValsetRequestByAddrResponse>(Arena*);
template <>
::injective::peggy::v1::QueryLastValsetRequestsRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastValsetRequestsRequest>(Arena*);
template <>
::injective::peggy::v1::QueryLastValsetRequestsResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryLastValsetRequestsResponse>(Arena*);
template <>
::injective::peggy::v1::QueryModuleStateRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryModuleStateRequest>(Arena*);
template <>
::injective::peggy::v1::QueryModuleStateResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryModuleStateResponse>(Arena*);
template <>
::injective::peggy::v1::QueryOutgoingTxBatchesRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryOutgoingTxBatchesRequest>(Arena*);
template <>
::injective::peggy::v1::QueryOutgoingTxBatchesResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryOutgoingTxBatchesResponse>(Arena*);
template <>
::injective::peggy::v1::QueryParamsRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryParamsRequest>(Arena*);
template <>
::injective::peggy::v1::QueryParamsResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryParamsResponse>(Arena*);
template <>
::injective::peggy::v1::QueryPendingSendToEth* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryPendingSendToEth>(Arena*);
template <>
::injective::peggy::v1::QueryPendingSendToEthResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryPendingSendToEthResponse>(Arena*);
template <>
::injective::peggy::v1::QueryValsetConfirmRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryValsetConfirmRequest>(Arena*);
template <>
::injective::peggy::v1::QueryValsetConfirmResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryValsetConfirmResponse>(Arena*);
template <>
::injective::peggy::v1::QueryValsetConfirmsByNonceRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryValsetConfirmsByNonceRequest>(Arena*);
template <>
::injective::peggy::v1::QueryValsetConfirmsByNonceResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryValsetConfirmsByNonceResponse>(Arena*);
template <>
::injective::peggy::v1::QueryValsetRequestRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryValsetRequestRequest>(Arena*);
template <>
::injective::peggy::v1::QueryValsetRequestResponse* Arena::CreateMaybeMessage<::injective::peggy::v1::QueryValsetRequestResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace peggy {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class QueryParamsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryParamsRequest) */ {
 public:
  inline QueryParamsRequest() : QueryParamsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryParamsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryParamsRequest(const QueryParamsRequest& from);
  QueryParamsRequest(QueryParamsRequest&& from) noexcept
    : QueryParamsRequest() {
    *this = ::std::move(from);
  }

  inline QueryParamsRequest& operator=(const QueryParamsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryParamsRequest& operator=(QueryParamsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryParamsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryParamsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryParamsRequest*>(
               &_QueryParamsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(QueryParamsRequest& a, QueryParamsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryParamsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryParamsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryParamsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryParamsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryParamsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryParamsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryParamsRequest";
  }
  protected:
  explicit QueryParamsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryParamsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryParamsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryParamsResponse) */ {
 public:
  inline QueryParamsResponse() : QueryParamsResponse(nullptr) {}
  ~QueryParamsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryParamsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryParamsResponse(const QueryParamsResponse& from);
  QueryParamsResponse(QueryParamsResponse&& from) noexcept
    : QueryParamsResponse() {
    *this = ::std::move(from);
  }

  inline QueryParamsResponse& operator=(const QueryParamsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryParamsResponse& operator=(QueryParamsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryParamsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryParamsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryParamsResponse*>(
               &_QueryParamsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QueryParamsResponse& a, QueryParamsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryParamsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryParamsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryParamsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryParamsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryParamsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryParamsResponse& from) {
    QueryParamsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryParamsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryParamsResponse";
  }
  protected:
  explicit QueryParamsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .injective.peggy.v1.Params params = 1 [json_name = "params", (.gogoproto.nullable) = false];
  bool has_params() const;
  void clear_params() ;
  const ::injective::peggy::v1::Params& params() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::Params* release_params();
  ::injective::peggy::v1::Params* mutable_params();
  void set_allocated_params(::injective::peggy::v1::Params* params);
  private:
  const ::injective::peggy::v1::Params& _internal_params() const;
  ::injective::peggy::v1::Params* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::injective::peggy::v1::Params* params);
  ::injective::peggy::v1::Params* unsafe_arena_release_params();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryParamsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::Params* params_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryCurrentValsetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryCurrentValsetRequest) */ {
 public:
  inline QueryCurrentValsetRequest() : QueryCurrentValsetRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryCurrentValsetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryCurrentValsetRequest(const QueryCurrentValsetRequest& from);
  QueryCurrentValsetRequest(QueryCurrentValsetRequest&& from) noexcept
    : QueryCurrentValsetRequest() {
    *this = ::std::move(from);
  }

  inline QueryCurrentValsetRequest& operator=(const QueryCurrentValsetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryCurrentValsetRequest& operator=(QueryCurrentValsetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryCurrentValsetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryCurrentValsetRequest* internal_default_instance() {
    return reinterpret_cast<const QueryCurrentValsetRequest*>(
               &_QueryCurrentValsetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QueryCurrentValsetRequest& a, QueryCurrentValsetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryCurrentValsetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryCurrentValsetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryCurrentValsetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryCurrentValsetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryCurrentValsetRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryCurrentValsetRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryCurrentValsetRequest";
  }
  protected:
  explicit QueryCurrentValsetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryCurrentValsetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryCurrentValsetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryCurrentValsetResponse) */ {
 public:
  inline QueryCurrentValsetResponse() : QueryCurrentValsetResponse(nullptr) {}
  ~QueryCurrentValsetResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryCurrentValsetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryCurrentValsetResponse(const QueryCurrentValsetResponse& from);
  QueryCurrentValsetResponse(QueryCurrentValsetResponse&& from) noexcept
    : QueryCurrentValsetResponse() {
    *this = ::std::move(from);
  }

  inline QueryCurrentValsetResponse& operator=(const QueryCurrentValsetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryCurrentValsetResponse& operator=(QueryCurrentValsetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryCurrentValsetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryCurrentValsetResponse* internal_default_instance() {
    return reinterpret_cast<const QueryCurrentValsetResponse*>(
               &_QueryCurrentValsetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(QueryCurrentValsetResponse& a, QueryCurrentValsetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryCurrentValsetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryCurrentValsetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryCurrentValsetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryCurrentValsetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryCurrentValsetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryCurrentValsetResponse& from) {
    QueryCurrentValsetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryCurrentValsetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryCurrentValsetResponse";
  }
  protected:
  explicit QueryCurrentValsetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsetFieldNumber = 1,
  };
  // .injective.peggy.v1.Valset valset = 1 [json_name = "valset"];
  bool has_valset() const;
  void clear_valset() ;
  const ::injective::peggy::v1::Valset& valset() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::Valset* release_valset();
  ::injective::peggy::v1::Valset* mutable_valset();
  void set_allocated_valset(::injective::peggy::v1::Valset* valset);
  private:
  const ::injective::peggy::v1::Valset& _internal_valset() const;
  ::injective::peggy::v1::Valset* _internal_mutable_valset();
  public:
  void unsafe_arena_set_allocated_valset(
      ::injective::peggy::v1::Valset* valset);
  ::injective::peggy::v1::Valset* unsafe_arena_release_valset();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryCurrentValsetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::Valset* valset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryValsetRequestRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryValsetRequestRequest) */ {
 public:
  inline QueryValsetRequestRequest() : QueryValsetRequestRequest(nullptr) {}
  ~QueryValsetRequestRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryValsetRequestRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryValsetRequestRequest(const QueryValsetRequestRequest& from);
  QueryValsetRequestRequest(QueryValsetRequestRequest&& from) noexcept
    : QueryValsetRequestRequest() {
    *this = ::std::move(from);
  }

  inline QueryValsetRequestRequest& operator=(const QueryValsetRequestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryValsetRequestRequest& operator=(QueryValsetRequestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryValsetRequestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryValsetRequestRequest* internal_default_instance() {
    return reinterpret_cast<const QueryValsetRequestRequest*>(
               &_QueryValsetRequestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QueryValsetRequestRequest& a, QueryValsetRequestRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryValsetRequestRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryValsetRequestRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryValsetRequestRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryValsetRequestRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryValsetRequestRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryValsetRequestRequest& from) {
    QueryValsetRequestRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryValsetRequestRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryValsetRequestRequest";
  }
  protected:
  explicit QueryValsetRequestRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint64 nonce = 1 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryValsetRequestRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryValsetRequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryValsetRequestResponse) */ {
 public:
  inline QueryValsetRequestResponse() : QueryValsetRequestResponse(nullptr) {}
  ~QueryValsetRequestResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryValsetRequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryValsetRequestResponse(const QueryValsetRequestResponse& from);
  QueryValsetRequestResponse(QueryValsetRequestResponse&& from) noexcept
    : QueryValsetRequestResponse() {
    *this = ::std::move(from);
  }

  inline QueryValsetRequestResponse& operator=(const QueryValsetRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryValsetRequestResponse& operator=(QueryValsetRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryValsetRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryValsetRequestResponse* internal_default_instance() {
    return reinterpret_cast<const QueryValsetRequestResponse*>(
               &_QueryValsetRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(QueryValsetRequestResponse& a, QueryValsetRequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryValsetRequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryValsetRequestResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryValsetRequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryValsetRequestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryValsetRequestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryValsetRequestResponse& from) {
    QueryValsetRequestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryValsetRequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryValsetRequestResponse";
  }
  protected:
  explicit QueryValsetRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsetFieldNumber = 1,
  };
  // .injective.peggy.v1.Valset valset = 1 [json_name = "valset"];
  bool has_valset() const;
  void clear_valset() ;
  const ::injective::peggy::v1::Valset& valset() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::Valset* release_valset();
  ::injective::peggy::v1::Valset* mutable_valset();
  void set_allocated_valset(::injective::peggy::v1::Valset* valset);
  private:
  const ::injective::peggy::v1::Valset& _internal_valset() const;
  ::injective::peggy::v1::Valset* _internal_mutable_valset();
  public:
  void unsafe_arena_set_allocated_valset(
      ::injective::peggy::v1::Valset* valset);
  ::injective::peggy::v1::Valset* unsafe_arena_release_valset();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryValsetRequestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::Valset* valset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryValsetConfirmRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryValsetConfirmRequest) */ {
 public:
  inline QueryValsetConfirmRequest() : QueryValsetConfirmRequest(nullptr) {}
  ~QueryValsetConfirmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryValsetConfirmRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryValsetConfirmRequest(const QueryValsetConfirmRequest& from);
  QueryValsetConfirmRequest(QueryValsetConfirmRequest&& from) noexcept
    : QueryValsetConfirmRequest() {
    *this = ::std::move(from);
  }

  inline QueryValsetConfirmRequest& operator=(const QueryValsetConfirmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryValsetConfirmRequest& operator=(QueryValsetConfirmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryValsetConfirmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryValsetConfirmRequest* internal_default_instance() {
    return reinterpret_cast<const QueryValsetConfirmRequest*>(
               &_QueryValsetConfirmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryValsetConfirmRequest& a, QueryValsetConfirmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryValsetConfirmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryValsetConfirmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryValsetConfirmRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryValsetConfirmRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryValsetConfirmRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryValsetConfirmRequest& from) {
    QueryValsetConfirmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryValsetConfirmRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryValsetConfirmRequest";
  }
  protected:
  explicit QueryValsetConfirmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kNonceFieldNumber = 1,
  };
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // uint64 nonce = 1 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryValsetConfirmRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryValsetConfirmResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryValsetConfirmResponse) */ {
 public:
  inline QueryValsetConfirmResponse() : QueryValsetConfirmResponse(nullptr) {}
  ~QueryValsetConfirmResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryValsetConfirmResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryValsetConfirmResponse(const QueryValsetConfirmResponse& from);
  QueryValsetConfirmResponse(QueryValsetConfirmResponse&& from) noexcept
    : QueryValsetConfirmResponse() {
    *this = ::std::move(from);
  }

  inline QueryValsetConfirmResponse& operator=(const QueryValsetConfirmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryValsetConfirmResponse& operator=(QueryValsetConfirmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryValsetConfirmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryValsetConfirmResponse* internal_default_instance() {
    return reinterpret_cast<const QueryValsetConfirmResponse*>(
               &_QueryValsetConfirmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QueryValsetConfirmResponse& a, QueryValsetConfirmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryValsetConfirmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryValsetConfirmResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryValsetConfirmResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryValsetConfirmResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryValsetConfirmResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryValsetConfirmResponse& from) {
    QueryValsetConfirmResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryValsetConfirmResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryValsetConfirmResponse";
  }
  protected:
  explicit QueryValsetConfirmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfirmFieldNumber = 1,
  };
  // .injective.peggy.v1.MsgValsetConfirm confirm = 1 [json_name = "confirm"];
  bool has_confirm() const;
  void clear_confirm() ;
  const ::injective::peggy::v1::MsgValsetConfirm& confirm() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::MsgValsetConfirm* release_confirm();
  ::injective::peggy::v1::MsgValsetConfirm* mutable_confirm();
  void set_allocated_confirm(::injective::peggy::v1::MsgValsetConfirm* confirm);
  private:
  const ::injective::peggy::v1::MsgValsetConfirm& _internal_confirm() const;
  ::injective::peggy::v1::MsgValsetConfirm* _internal_mutable_confirm();
  public:
  void unsafe_arena_set_allocated_confirm(
      ::injective::peggy::v1::MsgValsetConfirm* confirm);
  ::injective::peggy::v1::MsgValsetConfirm* unsafe_arena_release_confirm();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryValsetConfirmResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::MsgValsetConfirm* confirm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryValsetConfirmsByNonceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryValsetConfirmsByNonceRequest) */ {
 public:
  inline QueryValsetConfirmsByNonceRequest() : QueryValsetConfirmsByNonceRequest(nullptr) {}
  ~QueryValsetConfirmsByNonceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryValsetConfirmsByNonceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryValsetConfirmsByNonceRequest(const QueryValsetConfirmsByNonceRequest& from);
  QueryValsetConfirmsByNonceRequest(QueryValsetConfirmsByNonceRequest&& from) noexcept
    : QueryValsetConfirmsByNonceRequest() {
    *this = ::std::move(from);
  }

  inline QueryValsetConfirmsByNonceRequest& operator=(const QueryValsetConfirmsByNonceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryValsetConfirmsByNonceRequest& operator=(QueryValsetConfirmsByNonceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryValsetConfirmsByNonceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryValsetConfirmsByNonceRequest* internal_default_instance() {
    return reinterpret_cast<const QueryValsetConfirmsByNonceRequest*>(
               &_QueryValsetConfirmsByNonceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(QueryValsetConfirmsByNonceRequest& a, QueryValsetConfirmsByNonceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryValsetConfirmsByNonceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryValsetConfirmsByNonceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryValsetConfirmsByNonceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryValsetConfirmsByNonceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryValsetConfirmsByNonceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryValsetConfirmsByNonceRequest& from) {
    QueryValsetConfirmsByNonceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryValsetConfirmsByNonceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryValsetConfirmsByNonceRequest";
  }
  protected:
  explicit QueryValsetConfirmsByNonceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint64 nonce = 1 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryValsetConfirmsByNonceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryValsetConfirmsByNonceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryValsetConfirmsByNonceResponse) */ {
 public:
  inline QueryValsetConfirmsByNonceResponse() : QueryValsetConfirmsByNonceResponse(nullptr) {}
  ~QueryValsetConfirmsByNonceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryValsetConfirmsByNonceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryValsetConfirmsByNonceResponse(const QueryValsetConfirmsByNonceResponse& from);
  QueryValsetConfirmsByNonceResponse(QueryValsetConfirmsByNonceResponse&& from) noexcept
    : QueryValsetConfirmsByNonceResponse() {
    *this = ::std::move(from);
  }

  inline QueryValsetConfirmsByNonceResponse& operator=(const QueryValsetConfirmsByNonceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryValsetConfirmsByNonceResponse& operator=(QueryValsetConfirmsByNonceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryValsetConfirmsByNonceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryValsetConfirmsByNonceResponse* internal_default_instance() {
    return reinterpret_cast<const QueryValsetConfirmsByNonceResponse*>(
               &_QueryValsetConfirmsByNonceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(QueryValsetConfirmsByNonceResponse& a, QueryValsetConfirmsByNonceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryValsetConfirmsByNonceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryValsetConfirmsByNonceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryValsetConfirmsByNonceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryValsetConfirmsByNonceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryValsetConfirmsByNonceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryValsetConfirmsByNonceResponse& from) {
    QueryValsetConfirmsByNonceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryValsetConfirmsByNonceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryValsetConfirmsByNonceResponse";
  }
  protected:
  explicit QueryValsetConfirmsByNonceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfirmsFieldNumber = 1,
  };
  // repeated .injective.peggy.v1.MsgValsetConfirm confirms = 1 [json_name = "confirms"];
  int confirms_size() const;
  private:
  int _internal_confirms_size() const;

  public:
  void clear_confirms() ;
  ::injective::peggy::v1::MsgValsetConfirm* mutable_confirms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgValsetConfirm >*
      mutable_confirms();
  private:
  const ::injective::peggy::v1::MsgValsetConfirm& _internal_confirms(int index) const;
  ::injective::peggy::v1::MsgValsetConfirm* _internal_add_confirms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgValsetConfirm>& _internal_confirms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgValsetConfirm>* _internal_mutable_confirms();
  public:
  const ::injective::peggy::v1::MsgValsetConfirm& confirms(int index) const;
  ::injective::peggy::v1::MsgValsetConfirm* add_confirms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgValsetConfirm >&
      confirms() const;
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryValsetConfirmsByNonceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgValsetConfirm > confirms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastValsetRequestsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastValsetRequestsRequest) */ {
 public:
  inline QueryLastValsetRequestsRequest() : QueryLastValsetRequestsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastValsetRequestsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastValsetRequestsRequest(const QueryLastValsetRequestsRequest& from);
  QueryLastValsetRequestsRequest(QueryLastValsetRequestsRequest&& from) noexcept
    : QueryLastValsetRequestsRequest() {
    *this = ::std::move(from);
  }

  inline QueryLastValsetRequestsRequest& operator=(const QueryLastValsetRequestsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastValsetRequestsRequest& operator=(QueryLastValsetRequestsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastValsetRequestsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastValsetRequestsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryLastValsetRequestsRequest*>(
               &_QueryLastValsetRequestsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(QueryLastValsetRequestsRequest& a, QueryLastValsetRequestsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastValsetRequestsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastValsetRequestsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastValsetRequestsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastValsetRequestsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryLastValsetRequestsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryLastValsetRequestsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastValsetRequestsRequest";
  }
  protected:
  explicit QueryLastValsetRequestsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastValsetRequestsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastValsetRequestsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastValsetRequestsResponse) */ {
 public:
  inline QueryLastValsetRequestsResponse() : QueryLastValsetRequestsResponse(nullptr) {}
  ~QueryLastValsetRequestsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastValsetRequestsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastValsetRequestsResponse(const QueryLastValsetRequestsResponse& from);
  QueryLastValsetRequestsResponse(QueryLastValsetRequestsResponse&& from) noexcept
    : QueryLastValsetRequestsResponse() {
    *this = ::std::move(from);
  }

  inline QueryLastValsetRequestsResponse& operator=(const QueryLastValsetRequestsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastValsetRequestsResponse& operator=(QueryLastValsetRequestsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastValsetRequestsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastValsetRequestsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLastValsetRequestsResponse*>(
               &_QueryLastValsetRequestsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(QueryLastValsetRequestsResponse& a, QueryLastValsetRequestsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastValsetRequestsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastValsetRequestsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastValsetRequestsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastValsetRequestsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLastValsetRequestsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryLastValsetRequestsResponse& from) {
    QueryLastValsetRequestsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLastValsetRequestsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastValsetRequestsResponse";
  }
  protected:
  explicit QueryLastValsetRequestsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsetsFieldNumber = 1,
  };
  // repeated .injective.peggy.v1.Valset valsets = 1 [json_name = "valsets"];
  int valsets_size() const;
  private:
  int _internal_valsets_size() const;

  public:
  void clear_valsets() ;
  ::injective::peggy::v1::Valset* mutable_valsets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >*
      mutable_valsets();
  private:
  const ::injective::peggy::v1::Valset& _internal_valsets(int index) const;
  ::injective::peggy::v1::Valset* _internal_add_valsets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>& _internal_valsets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>* _internal_mutable_valsets();
  public:
  const ::injective::peggy::v1::Valset& valsets(int index) const;
  ::injective::peggy::v1::Valset* add_valsets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >&
      valsets() const;
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastValsetRequestsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset > valsets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastPendingValsetRequestByAddrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest) */ {
 public:
  inline QueryLastPendingValsetRequestByAddrRequest() : QueryLastPendingValsetRequestByAddrRequest(nullptr) {}
  ~QueryLastPendingValsetRequestByAddrRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastPendingValsetRequestByAddrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastPendingValsetRequestByAddrRequest(const QueryLastPendingValsetRequestByAddrRequest& from);
  QueryLastPendingValsetRequestByAddrRequest(QueryLastPendingValsetRequestByAddrRequest&& from) noexcept
    : QueryLastPendingValsetRequestByAddrRequest() {
    *this = ::std::move(from);
  }

  inline QueryLastPendingValsetRequestByAddrRequest& operator=(const QueryLastPendingValsetRequestByAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastPendingValsetRequestByAddrRequest& operator=(QueryLastPendingValsetRequestByAddrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastPendingValsetRequestByAddrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastPendingValsetRequestByAddrRequest* internal_default_instance() {
    return reinterpret_cast<const QueryLastPendingValsetRequestByAddrRequest*>(
               &_QueryLastPendingValsetRequestByAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(QueryLastPendingValsetRequestByAddrRequest& a, QueryLastPendingValsetRequestByAddrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastPendingValsetRequestByAddrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastPendingValsetRequestByAddrRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastPendingValsetRequestByAddrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastPendingValsetRequestByAddrRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLastPendingValsetRequestByAddrRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryLastPendingValsetRequestByAddrRequest& from) {
    QueryLastPendingValsetRequestByAddrRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLastPendingValsetRequestByAddrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest";
  }
  protected:
  explicit QueryLastPendingValsetRequestByAddrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastPendingValsetRequestByAddrResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse) */ {
 public:
  inline QueryLastPendingValsetRequestByAddrResponse() : QueryLastPendingValsetRequestByAddrResponse(nullptr) {}
  ~QueryLastPendingValsetRequestByAddrResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastPendingValsetRequestByAddrResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastPendingValsetRequestByAddrResponse(const QueryLastPendingValsetRequestByAddrResponse& from);
  QueryLastPendingValsetRequestByAddrResponse(QueryLastPendingValsetRequestByAddrResponse&& from) noexcept
    : QueryLastPendingValsetRequestByAddrResponse() {
    *this = ::std::move(from);
  }

  inline QueryLastPendingValsetRequestByAddrResponse& operator=(const QueryLastPendingValsetRequestByAddrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastPendingValsetRequestByAddrResponse& operator=(QueryLastPendingValsetRequestByAddrResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastPendingValsetRequestByAddrResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastPendingValsetRequestByAddrResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLastPendingValsetRequestByAddrResponse*>(
               &_QueryLastPendingValsetRequestByAddrResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(QueryLastPendingValsetRequestByAddrResponse& a, QueryLastPendingValsetRequestByAddrResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastPendingValsetRequestByAddrResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastPendingValsetRequestByAddrResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastPendingValsetRequestByAddrResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastPendingValsetRequestByAddrResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLastPendingValsetRequestByAddrResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryLastPendingValsetRequestByAddrResponse& from) {
    QueryLastPendingValsetRequestByAddrResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLastPendingValsetRequestByAddrResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse";
  }
  protected:
  explicit QueryLastPendingValsetRequestByAddrResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsetsFieldNumber = 1,
  };
  // repeated .injective.peggy.v1.Valset valsets = 1 [json_name = "valsets"];
  int valsets_size() const;
  private:
  int _internal_valsets_size() const;

  public:
  void clear_valsets() ;
  ::injective::peggy::v1::Valset* mutable_valsets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >*
      mutable_valsets();
  private:
  const ::injective::peggy::v1::Valset& _internal_valsets(int index) const;
  ::injective::peggy::v1::Valset* _internal_add_valsets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>& _internal_valsets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>* _internal_mutable_valsets();
  public:
  const ::injective::peggy::v1::Valset& valsets(int index) const;
  ::injective::peggy::v1::Valset* add_valsets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >&
      valsets() const;
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset > valsets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBatchFeeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryBatchFeeRequest) */ {
 public:
  inline QueryBatchFeeRequest() : QueryBatchFeeRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchFeeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBatchFeeRequest(const QueryBatchFeeRequest& from);
  QueryBatchFeeRequest(QueryBatchFeeRequest&& from) noexcept
    : QueryBatchFeeRequest() {
    *this = ::std::move(from);
  }

  inline QueryBatchFeeRequest& operator=(const QueryBatchFeeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchFeeRequest& operator=(QueryBatchFeeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchFeeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBatchFeeRequest* internal_default_instance() {
    return reinterpret_cast<const QueryBatchFeeRequest*>(
               &_QueryBatchFeeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(QueryBatchFeeRequest& a, QueryBatchFeeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBatchFeeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchFeeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchFeeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBatchFeeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryBatchFeeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryBatchFeeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryBatchFeeRequest";
  }
  protected:
  explicit QueryBatchFeeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryBatchFeeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBatchFeeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryBatchFeeResponse) */ {
 public:
  inline QueryBatchFeeResponse() : QueryBatchFeeResponse(nullptr) {}
  ~QueryBatchFeeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchFeeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBatchFeeResponse(const QueryBatchFeeResponse& from);
  QueryBatchFeeResponse(QueryBatchFeeResponse&& from) noexcept
    : QueryBatchFeeResponse() {
    *this = ::std::move(from);
  }

  inline QueryBatchFeeResponse& operator=(const QueryBatchFeeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchFeeResponse& operator=(QueryBatchFeeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchFeeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBatchFeeResponse* internal_default_instance() {
    return reinterpret_cast<const QueryBatchFeeResponse*>(
               &_QueryBatchFeeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(QueryBatchFeeResponse& a, QueryBatchFeeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBatchFeeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchFeeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchFeeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBatchFeeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBatchFeeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBatchFeeResponse& from) {
    QueryBatchFeeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBatchFeeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryBatchFeeResponse";
  }
  protected:
  explicit QueryBatchFeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchFeesFieldNumber = 1,
  };
  // repeated .injective.peggy.v1.BatchFees batchFees = 1 [json_name = "batchFees"];
  int batchfees_size() const;
  private:
  int _internal_batchfees_size() const;

  public:
  void clear_batchfees() ;
  ::injective::peggy::v1::BatchFees* mutable_batchfees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BatchFees >*
      mutable_batchfees();
  private:
  const ::injective::peggy::v1::BatchFees& _internal_batchfees(int index) const;
  ::injective::peggy::v1::BatchFees* _internal_add_batchfees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BatchFees>& _internal_batchfees() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BatchFees>* _internal_mutable_batchfees();
  public:
  const ::injective::peggy::v1::BatchFees& batchfees(int index) const;
  ::injective::peggy::v1::BatchFees* add_batchfees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BatchFees >&
      batchfees() const;
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryBatchFeeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BatchFees > batchfees_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastPendingBatchRequestByAddrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest) */ {
 public:
  inline QueryLastPendingBatchRequestByAddrRequest() : QueryLastPendingBatchRequestByAddrRequest(nullptr) {}
  ~QueryLastPendingBatchRequestByAddrRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastPendingBatchRequestByAddrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastPendingBatchRequestByAddrRequest(const QueryLastPendingBatchRequestByAddrRequest& from);
  QueryLastPendingBatchRequestByAddrRequest(QueryLastPendingBatchRequestByAddrRequest&& from) noexcept
    : QueryLastPendingBatchRequestByAddrRequest() {
    *this = ::std::move(from);
  }

  inline QueryLastPendingBatchRequestByAddrRequest& operator=(const QueryLastPendingBatchRequestByAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastPendingBatchRequestByAddrRequest& operator=(QueryLastPendingBatchRequestByAddrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastPendingBatchRequestByAddrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastPendingBatchRequestByAddrRequest* internal_default_instance() {
    return reinterpret_cast<const QueryLastPendingBatchRequestByAddrRequest*>(
               &_QueryLastPendingBatchRequestByAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(QueryLastPendingBatchRequestByAddrRequest& a, QueryLastPendingBatchRequestByAddrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastPendingBatchRequestByAddrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastPendingBatchRequestByAddrRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastPendingBatchRequestByAddrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastPendingBatchRequestByAddrRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLastPendingBatchRequestByAddrRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryLastPendingBatchRequestByAddrRequest& from) {
    QueryLastPendingBatchRequestByAddrRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLastPendingBatchRequestByAddrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest";
  }
  protected:
  explicit QueryLastPendingBatchRequestByAddrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastPendingBatchRequestByAddrResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse) */ {
 public:
  inline QueryLastPendingBatchRequestByAddrResponse() : QueryLastPendingBatchRequestByAddrResponse(nullptr) {}
  ~QueryLastPendingBatchRequestByAddrResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastPendingBatchRequestByAddrResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastPendingBatchRequestByAddrResponse(const QueryLastPendingBatchRequestByAddrResponse& from);
  QueryLastPendingBatchRequestByAddrResponse(QueryLastPendingBatchRequestByAddrResponse&& from) noexcept
    : QueryLastPendingBatchRequestByAddrResponse() {
    *this = ::std::move(from);
  }

  inline QueryLastPendingBatchRequestByAddrResponse& operator=(const QueryLastPendingBatchRequestByAddrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastPendingBatchRequestByAddrResponse& operator=(QueryLastPendingBatchRequestByAddrResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastPendingBatchRequestByAddrResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastPendingBatchRequestByAddrResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLastPendingBatchRequestByAddrResponse*>(
               &_QueryLastPendingBatchRequestByAddrResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(QueryLastPendingBatchRequestByAddrResponse& a, QueryLastPendingBatchRequestByAddrResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastPendingBatchRequestByAddrResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastPendingBatchRequestByAddrResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastPendingBatchRequestByAddrResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastPendingBatchRequestByAddrResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLastPendingBatchRequestByAddrResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryLastPendingBatchRequestByAddrResponse& from) {
    QueryLastPendingBatchRequestByAddrResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLastPendingBatchRequestByAddrResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse";
  }
  protected:
  explicit QueryLastPendingBatchRequestByAddrResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchFieldNumber = 1,
  };
  // .injective.peggy.v1.OutgoingTxBatch batch = 1 [json_name = "batch"];
  bool has_batch() const;
  void clear_batch() ;
  const ::injective::peggy::v1::OutgoingTxBatch& batch() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::OutgoingTxBatch* release_batch();
  ::injective::peggy::v1::OutgoingTxBatch* mutable_batch();
  void set_allocated_batch(::injective::peggy::v1::OutgoingTxBatch* batch);
  private:
  const ::injective::peggy::v1::OutgoingTxBatch& _internal_batch() const;
  ::injective::peggy::v1::OutgoingTxBatch* _internal_mutable_batch();
  public:
  void unsafe_arena_set_allocated_batch(
      ::injective::peggy::v1::OutgoingTxBatch* batch);
  ::injective::peggy::v1::OutgoingTxBatch* unsafe_arena_release_batch();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::OutgoingTxBatch* batch_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryOutgoingTxBatchesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryOutgoingTxBatchesRequest) */ {
 public:
  inline QueryOutgoingTxBatchesRequest() : QueryOutgoingTxBatchesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryOutgoingTxBatchesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryOutgoingTxBatchesRequest(const QueryOutgoingTxBatchesRequest& from);
  QueryOutgoingTxBatchesRequest(QueryOutgoingTxBatchesRequest&& from) noexcept
    : QueryOutgoingTxBatchesRequest() {
    *this = ::std::move(from);
  }

  inline QueryOutgoingTxBatchesRequest& operator=(const QueryOutgoingTxBatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryOutgoingTxBatchesRequest& operator=(QueryOutgoingTxBatchesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryOutgoingTxBatchesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryOutgoingTxBatchesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryOutgoingTxBatchesRequest*>(
               &_QueryOutgoingTxBatchesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(QueryOutgoingTxBatchesRequest& a, QueryOutgoingTxBatchesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryOutgoingTxBatchesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryOutgoingTxBatchesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryOutgoingTxBatchesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryOutgoingTxBatchesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryOutgoingTxBatchesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryOutgoingTxBatchesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryOutgoingTxBatchesRequest";
  }
  protected:
  explicit QueryOutgoingTxBatchesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryOutgoingTxBatchesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryOutgoingTxBatchesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryOutgoingTxBatchesResponse) */ {
 public:
  inline QueryOutgoingTxBatchesResponse() : QueryOutgoingTxBatchesResponse(nullptr) {}
  ~QueryOutgoingTxBatchesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryOutgoingTxBatchesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryOutgoingTxBatchesResponse(const QueryOutgoingTxBatchesResponse& from);
  QueryOutgoingTxBatchesResponse(QueryOutgoingTxBatchesResponse&& from) noexcept
    : QueryOutgoingTxBatchesResponse() {
    *this = ::std::move(from);
  }

  inline QueryOutgoingTxBatchesResponse& operator=(const QueryOutgoingTxBatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryOutgoingTxBatchesResponse& operator=(QueryOutgoingTxBatchesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryOutgoingTxBatchesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryOutgoingTxBatchesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryOutgoingTxBatchesResponse*>(
               &_QueryOutgoingTxBatchesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(QueryOutgoingTxBatchesResponse& a, QueryOutgoingTxBatchesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryOutgoingTxBatchesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryOutgoingTxBatchesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryOutgoingTxBatchesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryOutgoingTxBatchesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryOutgoingTxBatchesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryOutgoingTxBatchesResponse& from) {
    QueryOutgoingTxBatchesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryOutgoingTxBatchesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryOutgoingTxBatchesResponse";
  }
  protected:
  explicit QueryOutgoingTxBatchesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchesFieldNumber = 1,
  };
  // repeated .injective.peggy.v1.OutgoingTxBatch batches = 1 [json_name = "batches"];
  int batches_size() const;
  private:
  int _internal_batches_size() const;

  public:
  void clear_batches() ;
  ::injective::peggy::v1::OutgoingTxBatch* mutable_batches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTxBatch >*
      mutable_batches();
  private:
  const ::injective::peggy::v1::OutgoingTxBatch& _internal_batches(int index) const;
  ::injective::peggy::v1::OutgoingTxBatch* _internal_add_batches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTxBatch>& _internal_batches() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTxBatch>* _internal_mutable_batches();
  public:
  const ::injective::peggy::v1::OutgoingTxBatch& batches(int index) const;
  ::injective::peggy::v1::OutgoingTxBatch* add_batches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTxBatch >&
      batches() const;
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryOutgoingTxBatchesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTxBatch > batches_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBatchRequestByNonceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryBatchRequestByNonceRequest) */ {
 public:
  inline QueryBatchRequestByNonceRequest() : QueryBatchRequestByNonceRequest(nullptr) {}
  ~QueryBatchRequestByNonceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchRequestByNonceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBatchRequestByNonceRequest(const QueryBatchRequestByNonceRequest& from);
  QueryBatchRequestByNonceRequest(QueryBatchRequestByNonceRequest&& from) noexcept
    : QueryBatchRequestByNonceRequest() {
    *this = ::std::move(from);
  }

  inline QueryBatchRequestByNonceRequest& operator=(const QueryBatchRequestByNonceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchRequestByNonceRequest& operator=(QueryBatchRequestByNonceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchRequestByNonceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBatchRequestByNonceRequest* internal_default_instance() {
    return reinterpret_cast<const QueryBatchRequestByNonceRequest*>(
               &_QueryBatchRequestByNonceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(QueryBatchRequestByNonceRequest& a, QueryBatchRequestByNonceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBatchRequestByNonceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchRequestByNonceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchRequestByNonceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBatchRequestByNonceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBatchRequestByNonceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBatchRequestByNonceRequest& from) {
    QueryBatchRequestByNonceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBatchRequestByNonceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryBatchRequestByNonceRequest";
  }
  protected:
  explicit QueryBatchRequestByNonceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractAddressFieldNumber = 2,
    kNonceFieldNumber = 1,
  };
  // string contract_address = 2 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // uint64 nonce = 1 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryBatchRequestByNonceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    ::uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBatchRequestByNonceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryBatchRequestByNonceResponse) */ {
 public:
  inline QueryBatchRequestByNonceResponse() : QueryBatchRequestByNonceResponse(nullptr) {}
  ~QueryBatchRequestByNonceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchRequestByNonceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBatchRequestByNonceResponse(const QueryBatchRequestByNonceResponse& from);
  QueryBatchRequestByNonceResponse(QueryBatchRequestByNonceResponse&& from) noexcept
    : QueryBatchRequestByNonceResponse() {
    *this = ::std::move(from);
  }

  inline QueryBatchRequestByNonceResponse& operator=(const QueryBatchRequestByNonceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchRequestByNonceResponse& operator=(QueryBatchRequestByNonceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchRequestByNonceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBatchRequestByNonceResponse* internal_default_instance() {
    return reinterpret_cast<const QueryBatchRequestByNonceResponse*>(
               &_QueryBatchRequestByNonceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(QueryBatchRequestByNonceResponse& a, QueryBatchRequestByNonceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBatchRequestByNonceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchRequestByNonceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchRequestByNonceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBatchRequestByNonceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBatchRequestByNonceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBatchRequestByNonceResponse& from) {
    QueryBatchRequestByNonceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBatchRequestByNonceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryBatchRequestByNonceResponse";
  }
  protected:
  explicit QueryBatchRequestByNonceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchFieldNumber = 1,
  };
  // .injective.peggy.v1.OutgoingTxBatch batch = 1 [json_name = "batch"];
  bool has_batch() const;
  void clear_batch() ;
  const ::injective::peggy::v1::OutgoingTxBatch& batch() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::OutgoingTxBatch* release_batch();
  ::injective::peggy::v1::OutgoingTxBatch* mutable_batch();
  void set_allocated_batch(::injective::peggy::v1::OutgoingTxBatch* batch);
  private:
  const ::injective::peggy::v1::OutgoingTxBatch& _internal_batch() const;
  ::injective::peggy::v1::OutgoingTxBatch* _internal_mutable_batch();
  public:
  void unsafe_arena_set_allocated_batch(
      ::injective::peggy::v1::OutgoingTxBatch* batch);
  ::injective::peggy::v1::OutgoingTxBatch* unsafe_arena_release_batch();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryBatchRequestByNonceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::OutgoingTxBatch* batch_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBatchConfirmsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryBatchConfirmsRequest) */ {
 public:
  inline QueryBatchConfirmsRequest() : QueryBatchConfirmsRequest(nullptr) {}
  ~QueryBatchConfirmsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchConfirmsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBatchConfirmsRequest(const QueryBatchConfirmsRequest& from);
  QueryBatchConfirmsRequest(QueryBatchConfirmsRequest&& from) noexcept
    : QueryBatchConfirmsRequest() {
    *this = ::std::move(from);
  }

  inline QueryBatchConfirmsRequest& operator=(const QueryBatchConfirmsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchConfirmsRequest& operator=(QueryBatchConfirmsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchConfirmsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBatchConfirmsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryBatchConfirmsRequest*>(
               &_QueryBatchConfirmsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(QueryBatchConfirmsRequest& a, QueryBatchConfirmsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBatchConfirmsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchConfirmsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchConfirmsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBatchConfirmsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBatchConfirmsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBatchConfirmsRequest& from) {
    QueryBatchConfirmsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBatchConfirmsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryBatchConfirmsRequest";
  }
  protected:
  explicit QueryBatchConfirmsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractAddressFieldNumber = 2,
    kNonceFieldNumber = 1,
  };
  // string contract_address = 2 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // uint64 nonce = 1 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryBatchConfirmsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    ::uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBatchConfirmsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryBatchConfirmsResponse) */ {
 public:
  inline QueryBatchConfirmsResponse() : QueryBatchConfirmsResponse(nullptr) {}
  ~QueryBatchConfirmsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBatchConfirmsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBatchConfirmsResponse(const QueryBatchConfirmsResponse& from);
  QueryBatchConfirmsResponse(QueryBatchConfirmsResponse&& from) noexcept
    : QueryBatchConfirmsResponse() {
    *this = ::std::move(from);
  }

  inline QueryBatchConfirmsResponse& operator=(const QueryBatchConfirmsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBatchConfirmsResponse& operator=(QueryBatchConfirmsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBatchConfirmsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBatchConfirmsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryBatchConfirmsResponse*>(
               &_QueryBatchConfirmsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(QueryBatchConfirmsResponse& a, QueryBatchConfirmsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBatchConfirmsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBatchConfirmsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBatchConfirmsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBatchConfirmsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBatchConfirmsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBatchConfirmsResponse& from) {
    QueryBatchConfirmsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBatchConfirmsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryBatchConfirmsResponse";
  }
  protected:
  explicit QueryBatchConfirmsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfirmsFieldNumber = 1,
  };
  // repeated .injective.peggy.v1.MsgConfirmBatch confirms = 1 [json_name = "confirms"];
  int confirms_size() const;
  private:
  int _internal_confirms_size() const;

  public:
  void clear_confirms() ;
  ::injective::peggy::v1::MsgConfirmBatch* mutable_confirms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgConfirmBatch >*
      mutable_confirms();
  private:
  const ::injective::peggy::v1::MsgConfirmBatch& _internal_confirms(int index) const;
  ::injective::peggy::v1::MsgConfirmBatch* _internal_add_confirms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgConfirmBatch>& _internal_confirms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgConfirmBatch>* _internal_mutable_confirms();
  public:
  const ::injective::peggy::v1::MsgConfirmBatch& confirms(int index) const;
  ::injective::peggy::v1::MsgConfirmBatch* add_confirms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgConfirmBatch >&
      confirms() const;
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryBatchConfirmsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgConfirmBatch > confirms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastEventByAddrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastEventByAddrRequest) */ {
 public:
  inline QueryLastEventByAddrRequest() : QueryLastEventByAddrRequest(nullptr) {}
  ~QueryLastEventByAddrRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastEventByAddrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastEventByAddrRequest(const QueryLastEventByAddrRequest& from);
  QueryLastEventByAddrRequest(QueryLastEventByAddrRequest&& from) noexcept
    : QueryLastEventByAddrRequest() {
    *this = ::std::move(from);
  }

  inline QueryLastEventByAddrRequest& operator=(const QueryLastEventByAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastEventByAddrRequest& operator=(QueryLastEventByAddrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastEventByAddrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastEventByAddrRequest* internal_default_instance() {
    return reinterpret_cast<const QueryLastEventByAddrRequest*>(
               &_QueryLastEventByAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(QueryLastEventByAddrRequest& a, QueryLastEventByAddrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastEventByAddrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastEventByAddrRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastEventByAddrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastEventByAddrRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLastEventByAddrRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryLastEventByAddrRequest& from) {
    QueryLastEventByAddrRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLastEventByAddrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastEventByAddrRequest";
  }
  protected:
  explicit QueryLastEventByAddrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastEventByAddrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryLastEventByAddrResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryLastEventByAddrResponse) */ {
 public:
  inline QueryLastEventByAddrResponse() : QueryLastEventByAddrResponse(nullptr) {}
  ~QueryLastEventByAddrResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryLastEventByAddrResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryLastEventByAddrResponse(const QueryLastEventByAddrResponse& from);
  QueryLastEventByAddrResponse(QueryLastEventByAddrResponse&& from) noexcept
    : QueryLastEventByAddrResponse() {
    *this = ::std::move(from);
  }

  inline QueryLastEventByAddrResponse& operator=(const QueryLastEventByAddrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryLastEventByAddrResponse& operator=(QueryLastEventByAddrResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryLastEventByAddrResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryLastEventByAddrResponse* internal_default_instance() {
    return reinterpret_cast<const QueryLastEventByAddrResponse*>(
               &_QueryLastEventByAddrResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(QueryLastEventByAddrResponse& a, QueryLastEventByAddrResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryLastEventByAddrResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryLastEventByAddrResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryLastEventByAddrResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryLastEventByAddrResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryLastEventByAddrResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryLastEventByAddrResponse& from) {
    QueryLastEventByAddrResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryLastEventByAddrResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryLastEventByAddrResponse";
  }
  protected:
  explicit QueryLastEventByAddrResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastClaimEventFieldNumber = 1,
  };
  // .injective.peggy.v1.LastClaimEvent last_claim_event = 1 [json_name = "lastClaimEvent"];
  bool has_last_claim_event() const;
  void clear_last_claim_event() ;
  const ::injective::peggy::v1::LastClaimEvent& last_claim_event() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::LastClaimEvent* release_last_claim_event();
  ::injective::peggy::v1::LastClaimEvent* mutable_last_claim_event();
  void set_allocated_last_claim_event(::injective::peggy::v1::LastClaimEvent* last_claim_event);
  private:
  const ::injective::peggy::v1::LastClaimEvent& _internal_last_claim_event() const;
  ::injective::peggy::v1::LastClaimEvent* _internal_mutable_last_claim_event();
  public:
  void unsafe_arena_set_allocated_last_claim_event(
      ::injective::peggy::v1::LastClaimEvent* last_claim_event);
  ::injective::peggy::v1::LastClaimEvent* unsafe_arena_release_last_claim_event();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryLastEventByAddrResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::LastClaimEvent* last_claim_event_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryERC20ToDenomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryERC20ToDenomRequest) */ {
 public:
  inline QueryERC20ToDenomRequest() : QueryERC20ToDenomRequest(nullptr) {}
  ~QueryERC20ToDenomRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryERC20ToDenomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryERC20ToDenomRequest(const QueryERC20ToDenomRequest& from);
  QueryERC20ToDenomRequest(QueryERC20ToDenomRequest&& from) noexcept
    : QueryERC20ToDenomRequest() {
    *this = ::std::move(from);
  }

  inline QueryERC20ToDenomRequest& operator=(const QueryERC20ToDenomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryERC20ToDenomRequest& operator=(QueryERC20ToDenomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryERC20ToDenomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryERC20ToDenomRequest* internal_default_instance() {
    return reinterpret_cast<const QueryERC20ToDenomRequest*>(
               &_QueryERC20ToDenomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(QueryERC20ToDenomRequest& a, QueryERC20ToDenomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryERC20ToDenomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryERC20ToDenomRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryERC20ToDenomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryERC20ToDenomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryERC20ToDenomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryERC20ToDenomRequest& from) {
    QueryERC20ToDenomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryERC20ToDenomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryERC20ToDenomRequest";
  }
  protected:
  explicit QueryERC20ToDenomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErc20FieldNumber = 1,
  };
  // string erc20 = 1 [json_name = "erc20"];
  void clear_erc20() ;
  const std::string& erc20() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_erc20(Arg_&& arg, Args_... args);
  std::string* mutable_erc20();
  PROTOBUF_NODISCARD std::string* release_erc20();
  void set_allocated_erc20(std::string* ptr);

  private:
  const std::string& _internal_erc20() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_erc20(
      const std::string& value);
  std::string* _internal_mutable_erc20();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryERC20ToDenomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr erc20_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryERC20ToDenomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryERC20ToDenomResponse) */ {
 public:
  inline QueryERC20ToDenomResponse() : QueryERC20ToDenomResponse(nullptr) {}
  ~QueryERC20ToDenomResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryERC20ToDenomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryERC20ToDenomResponse(const QueryERC20ToDenomResponse& from);
  QueryERC20ToDenomResponse(QueryERC20ToDenomResponse&& from) noexcept
    : QueryERC20ToDenomResponse() {
    *this = ::std::move(from);
  }

  inline QueryERC20ToDenomResponse& operator=(const QueryERC20ToDenomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryERC20ToDenomResponse& operator=(QueryERC20ToDenomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryERC20ToDenomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryERC20ToDenomResponse* internal_default_instance() {
    return reinterpret_cast<const QueryERC20ToDenomResponse*>(
               &_QueryERC20ToDenomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(QueryERC20ToDenomResponse& a, QueryERC20ToDenomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryERC20ToDenomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryERC20ToDenomResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryERC20ToDenomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryERC20ToDenomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryERC20ToDenomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryERC20ToDenomResponse& from) {
    QueryERC20ToDenomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryERC20ToDenomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryERC20ToDenomResponse";
  }
  protected:
  explicit QueryERC20ToDenomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kCosmosOriginatedFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // bool cosmos_originated = 2 [json_name = "cosmosOriginated"];
  void clear_cosmos_originated() ;
  bool cosmos_originated() const;
  void set_cosmos_originated(bool value);

  private:
  bool _internal_cosmos_originated() const;
  void _internal_set_cosmos_originated(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryERC20ToDenomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    bool cosmos_originated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDenomToERC20Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDenomToERC20Request) */ {
 public:
  inline QueryDenomToERC20Request() : QueryDenomToERC20Request(nullptr) {}
  ~QueryDenomToERC20Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDenomToERC20Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDenomToERC20Request(const QueryDenomToERC20Request& from);
  QueryDenomToERC20Request(QueryDenomToERC20Request&& from) noexcept
    : QueryDenomToERC20Request() {
    *this = ::std::move(from);
  }

  inline QueryDenomToERC20Request& operator=(const QueryDenomToERC20Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDenomToERC20Request& operator=(QueryDenomToERC20Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDenomToERC20Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDenomToERC20Request* internal_default_instance() {
    return reinterpret_cast<const QueryDenomToERC20Request*>(
               &_QueryDenomToERC20Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(QueryDenomToERC20Request& a, QueryDenomToERC20Request& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDenomToERC20Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDenomToERC20Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDenomToERC20Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDenomToERC20Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDenomToERC20Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDenomToERC20Request& from) {
    QueryDenomToERC20Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDenomToERC20Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDenomToERC20Request";
  }
  protected:
  explicit QueryDenomToERC20Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDenomToERC20Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDenomToERC20Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDenomToERC20Response) */ {
 public:
  inline QueryDenomToERC20Response() : QueryDenomToERC20Response(nullptr) {}
  ~QueryDenomToERC20Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDenomToERC20Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDenomToERC20Response(const QueryDenomToERC20Response& from);
  QueryDenomToERC20Response(QueryDenomToERC20Response&& from) noexcept
    : QueryDenomToERC20Response() {
    *this = ::std::move(from);
  }

  inline QueryDenomToERC20Response& operator=(const QueryDenomToERC20Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDenomToERC20Response& operator=(QueryDenomToERC20Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDenomToERC20Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDenomToERC20Response* internal_default_instance() {
    return reinterpret_cast<const QueryDenomToERC20Response*>(
               &_QueryDenomToERC20Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(QueryDenomToERC20Response& a, QueryDenomToERC20Response& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDenomToERC20Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDenomToERC20Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDenomToERC20Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDenomToERC20Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDenomToERC20Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDenomToERC20Response& from) {
    QueryDenomToERC20Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDenomToERC20Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDenomToERC20Response";
  }
  protected:
  explicit QueryDenomToERC20Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErc20FieldNumber = 1,
    kCosmosOriginatedFieldNumber = 2,
  };
  // string erc20 = 1 [json_name = "erc20"];
  void clear_erc20() ;
  const std::string& erc20() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_erc20(Arg_&& arg, Args_... args);
  std::string* mutable_erc20();
  PROTOBUF_NODISCARD std::string* release_erc20();
  void set_allocated_erc20(std::string* ptr);

  private:
  const std::string& _internal_erc20() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_erc20(
      const std::string& value);
  std::string* _internal_mutable_erc20();

  public:
  // bool cosmos_originated = 2 [json_name = "cosmosOriginated"];
  void clear_cosmos_originated() ;
  bool cosmos_originated() const;
  void set_cosmos_originated(bool value);

  private:
  bool _internal_cosmos_originated() const;
  void _internal_set_cosmos_originated(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDenomToERC20Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr erc20_;
    bool cosmos_originated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDelegateKeysByValidatorAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDelegateKeysByValidatorAddress) */ {
 public:
  inline QueryDelegateKeysByValidatorAddress() : QueryDelegateKeysByValidatorAddress(nullptr) {}
  ~QueryDelegateKeysByValidatorAddress() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDelegateKeysByValidatorAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDelegateKeysByValidatorAddress(const QueryDelegateKeysByValidatorAddress& from);
  QueryDelegateKeysByValidatorAddress(QueryDelegateKeysByValidatorAddress&& from) noexcept
    : QueryDelegateKeysByValidatorAddress() {
    *this = ::std::move(from);
  }

  inline QueryDelegateKeysByValidatorAddress& operator=(const QueryDelegateKeysByValidatorAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDelegateKeysByValidatorAddress& operator=(QueryDelegateKeysByValidatorAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDelegateKeysByValidatorAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDelegateKeysByValidatorAddress* internal_default_instance() {
    return reinterpret_cast<const QueryDelegateKeysByValidatorAddress*>(
               &_QueryDelegateKeysByValidatorAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(QueryDelegateKeysByValidatorAddress& a, QueryDelegateKeysByValidatorAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDelegateKeysByValidatorAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDelegateKeysByValidatorAddress* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDelegateKeysByValidatorAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDelegateKeysByValidatorAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDelegateKeysByValidatorAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDelegateKeysByValidatorAddress& from) {
    QueryDelegateKeysByValidatorAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDelegateKeysByValidatorAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDelegateKeysByValidatorAddress";
  }
  protected:
  explicit QueryDelegateKeysByValidatorAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorAddressFieldNumber = 1,
  };
  // string validator_address = 1 [json_name = "validatorAddress"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDelegateKeysByValidatorAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDelegateKeysByValidatorAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse) */ {
 public:
  inline QueryDelegateKeysByValidatorAddressResponse() : QueryDelegateKeysByValidatorAddressResponse(nullptr) {}
  ~QueryDelegateKeysByValidatorAddressResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDelegateKeysByValidatorAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDelegateKeysByValidatorAddressResponse(const QueryDelegateKeysByValidatorAddressResponse& from);
  QueryDelegateKeysByValidatorAddressResponse(QueryDelegateKeysByValidatorAddressResponse&& from) noexcept
    : QueryDelegateKeysByValidatorAddressResponse() {
    *this = ::std::move(from);
  }

  inline QueryDelegateKeysByValidatorAddressResponse& operator=(const QueryDelegateKeysByValidatorAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDelegateKeysByValidatorAddressResponse& operator=(QueryDelegateKeysByValidatorAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDelegateKeysByValidatorAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDelegateKeysByValidatorAddressResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDelegateKeysByValidatorAddressResponse*>(
               &_QueryDelegateKeysByValidatorAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(QueryDelegateKeysByValidatorAddressResponse& a, QueryDelegateKeysByValidatorAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDelegateKeysByValidatorAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDelegateKeysByValidatorAddressResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDelegateKeysByValidatorAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDelegateKeysByValidatorAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDelegateKeysByValidatorAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDelegateKeysByValidatorAddressResponse& from) {
    QueryDelegateKeysByValidatorAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDelegateKeysByValidatorAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse";
  }
  protected:
  explicit QueryDelegateKeysByValidatorAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEthAddressFieldNumber = 1,
    kOrchestratorAddressFieldNumber = 2,
  };
  // string eth_address = 1 [json_name = "ethAddress"];
  void clear_eth_address() ;
  const std::string& eth_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_eth_address(Arg_&& arg, Args_... args);
  std::string* mutable_eth_address();
  PROTOBUF_NODISCARD std::string* release_eth_address();
  void set_allocated_eth_address(std::string* ptr);

  private:
  const std::string& _internal_eth_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eth_address(
      const std::string& value);
  std::string* _internal_mutable_eth_address();

  public:
  // string orchestrator_address = 2 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eth_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDelegateKeysByEthAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDelegateKeysByEthAddress) */ {
 public:
  inline QueryDelegateKeysByEthAddress() : QueryDelegateKeysByEthAddress(nullptr) {}
  ~QueryDelegateKeysByEthAddress() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDelegateKeysByEthAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDelegateKeysByEthAddress(const QueryDelegateKeysByEthAddress& from);
  QueryDelegateKeysByEthAddress(QueryDelegateKeysByEthAddress&& from) noexcept
    : QueryDelegateKeysByEthAddress() {
    *this = ::std::move(from);
  }

  inline QueryDelegateKeysByEthAddress& operator=(const QueryDelegateKeysByEthAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDelegateKeysByEthAddress& operator=(QueryDelegateKeysByEthAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDelegateKeysByEthAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDelegateKeysByEthAddress* internal_default_instance() {
    return reinterpret_cast<const QueryDelegateKeysByEthAddress*>(
               &_QueryDelegateKeysByEthAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(QueryDelegateKeysByEthAddress& a, QueryDelegateKeysByEthAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDelegateKeysByEthAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDelegateKeysByEthAddress* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDelegateKeysByEthAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDelegateKeysByEthAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDelegateKeysByEthAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDelegateKeysByEthAddress& from) {
    QueryDelegateKeysByEthAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDelegateKeysByEthAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDelegateKeysByEthAddress";
  }
  protected:
  explicit QueryDelegateKeysByEthAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEthAddressFieldNumber = 1,
  };
  // string eth_address = 1 [json_name = "ethAddress"];
  void clear_eth_address() ;
  const std::string& eth_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_eth_address(Arg_&& arg, Args_... args);
  std::string* mutable_eth_address();
  PROTOBUF_NODISCARD std::string* release_eth_address();
  void set_allocated_eth_address(std::string* ptr);

  private:
  const std::string& _internal_eth_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eth_address(
      const std::string& value);
  std::string* _internal_mutable_eth_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDelegateKeysByEthAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eth_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDelegateKeysByEthAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse) */ {
 public:
  inline QueryDelegateKeysByEthAddressResponse() : QueryDelegateKeysByEthAddressResponse(nullptr) {}
  ~QueryDelegateKeysByEthAddressResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDelegateKeysByEthAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDelegateKeysByEthAddressResponse(const QueryDelegateKeysByEthAddressResponse& from);
  QueryDelegateKeysByEthAddressResponse(QueryDelegateKeysByEthAddressResponse&& from) noexcept
    : QueryDelegateKeysByEthAddressResponse() {
    *this = ::std::move(from);
  }

  inline QueryDelegateKeysByEthAddressResponse& operator=(const QueryDelegateKeysByEthAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDelegateKeysByEthAddressResponse& operator=(QueryDelegateKeysByEthAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDelegateKeysByEthAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDelegateKeysByEthAddressResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDelegateKeysByEthAddressResponse*>(
               &_QueryDelegateKeysByEthAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(QueryDelegateKeysByEthAddressResponse& a, QueryDelegateKeysByEthAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDelegateKeysByEthAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDelegateKeysByEthAddressResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDelegateKeysByEthAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDelegateKeysByEthAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDelegateKeysByEthAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDelegateKeysByEthAddressResponse& from) {
    QueryDelegateKeysByEthAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDelegateKeysByEthAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDelegateKeysByEthAddressResponse";
  }
  protected:
  explicit QueryDelegateKeysByEthAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorAddressFieldNumber = 1,
    kOrchestratorAddressFieldNumber = 2,
  };
  // string validator_address = 1 [json_name = "validatorAddress"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // string orchestrator_address = 2 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDelegateKeysByOrchestratorAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress) */ {
 public:
  inline QueryDelegateKeysByOrchestratorAddress() : QueryDelegateKeysByOrchestratorAddress(nullptr) {}
  ~QueryDelegateKeysByOrchestratorAddress() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDelegateKeysByOrchestratorAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDelegateKeysByOrchestratorAddress(const QueryDelegateKeysByOrchestratorAddress& from);
  QueryDelegateKeysByOrchestratorAddress(QueryDelegateKeysByOrchestratorAddress&& from) noexcept
    : QueryDelegateKeysByOrchestratorAddress() {
    *this = ::std::move(from);
  }

  inline QueryDelegateKeysByOrchestratorAddress& operator=(const QueryDelegateKeysByOrchestratorAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDelegateKeysByOrchestratorAddress& operator=(QueryDelegateKeysByOrchestratorAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDelegateKeysByOrchestratorAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDelegateKeysByOrchestratorAddress* internal_default_instance() {
    return reinterpret_cast<const QueryDelegateKeysByOrchestratorAddress*>(
               &_QueryDelegateKeysByOrchestratorAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(QueryDelegateKeysByOrchestratorAddress& a, QueryDelegateKeysByOrchestratorAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDelegateKeysByOrchestratorAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDelegateKeysByOrchestratorAddress* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDelegateKeysByOrchestratorAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDelegateKeysByOrchestratorAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDelegateKeysByOrchestratorAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDelegateKeysByOrchestratorAddress& from) {
    QueryDelegateKeysByOrchestratorAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDelegateKeysByOrchestratorAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress";
  }
  protected:
  explicit QueryDelegateKeysByOrchestratorAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrchestratorAddressFieldNumber = 1,
  };
  // string orchestrator_address = 1 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDelegateKeysByOrchestratorAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse) */ {
 public:
  inline QueryDelegateKeysByOrchestratorAddressResponse() : QueryDelegateKeysByOrchestratorAddressResponse(nullptr) {}
  ~QueryDelegateKeysByOrchestratorAddressResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDelegateKeysByOrchestratorAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDelegateKeysByOrchestratorAddressResponse(const QueryDelegateKeysByOrchestratorAddressResponse& from);
  QueryDelegateKeysByOrchestratorAddressResponse(QueryDelegateKeysByOrchestratorAddressResponse&& from) noexcept
    : QueryDelegateKeysByOrchestratorAddressResponse() {
    *this = ::std::move(from);
  }

  inline QueryDelegateKeysByOrchestratorAddressResponse& operator=(const QueryDelegateKeysByOrchestratorAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDelegateKeysByOrchestratorAddressResponse& operator=(QueryDelegateKeysByOrchestratorAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDelegateKeysByOrchestratorAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDelegateKeysByOrchestratorAddressResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDelegateKeysByOrchestratorAddressResponse*>(
               &_QueryDelegateKeysByOrchestratorAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(QueryDelegateKeysByOrchestratorAddressResponse& a, QueryDelegateKeysByOrchestratorAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDelegateKeysByOrchestratorAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDelegateKeysByOrchestratorAddressResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDelegateKeysByOrchestratorAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDelegateKeysByOrchestratorAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDelegateKeysByOrchestratorAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDelegateKeysByOrchestratorAddressResponse& from) {
    QueryDelegateKeysByOrchestratorAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDelegateKeysByOrchestratorAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse";
  }
  protected:
  explicit QueryDelegateKeysByOrchestratorAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorAddressFieldNumber = 1,
    kEthAddressFieldNumber = 2,
  };
  // string validator_address = 1 [json_name = "validatorAddress"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // string eth_address = 2 [json_name = "ethAddress"];
  void clear_eth_address() ;
  const std::string& eth_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_eth_address(Arg_&& arg, Args_... args);
  std::string* mutable_eth_address();
  PROTOBUF_NODISCARD std::string* release_eth_address();
  void set_allocated_eth_address(std::string* ptr);

  private:
  const std::string& _internal_eth_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eth_address(
      const std::string& value);
  std::string* _internal_mutable_eth_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eth_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPendingSendToEth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryPendingSendToEth) */ {
 public:
  inline QueryPendingSendToEth() : QueryPendingSendToEth(nullptr) {}
  ~QueryPendingSendToEth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPendingSendToEth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPendingSendToEth(const QueryPendingSendToEth& from);
  QueryPendingSendToEth(QueryPendingSendToEth&& from) noexcept
    : QueryPendingSendToEth() {
    *this = ::std::move(from);
  }

  inline QueryPendingSendToEth& operator=(const QueryPendingSendToEth& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPendingSendToEth& operator=(QueryPendingSendToEth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPendingSendToEth& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPendingSendToEth* internal_default_instance() {
    return reinterpret_cast<const QueryPendingSendToEth*>(
               &_QueryPendingSendToEth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(QueryPendingSendToEth& a, QueryPendingSendToEth& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPendingSendToEth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPendingSendToEth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPendingSendToEth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPendingSendToEth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPendingSendToEth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPendingSendToEth& from) {
    QueryPendingSendToEth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPendingSendToEth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryPendingSendToEth";
  }
  protected:
  explicit QueryPendingSendToEth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderAddressFieldNumber = 1,
  };
  // string sender_address = 1 [json_name = "senderAddress"];
  void clear_sender_address() ;
  const std::string& sender_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_address(Arg_&& arg, Args_... args);
  std::string* mutable_sender_address();
  PROTOBUF_NODISCARD std::string* release_sender_address();
  void set_allocated_sender_address(std::string* ptr);

  private:
  const std::string& _internal_sender_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_address(
      const std::string& value);
  std::string* _internal_mutable_sender_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryPendingSendToEth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPendingSendToEthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryPendingSendToEthResponse) */ {
 public:
  inline QueryPendingSendToEthResponse() : QueryPendingSendToEthResponse(nullptr) {}
  ~QueryPendingSendToEthResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPendingSendToEthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPendingSendToEthResponse(const QueryPendingSendToEthResponse& from);
  QueryPendingSendToEthResponse(QueryPendingSendToEthResponse&& from) noexcept
    : QueryPendingSendToEthResponse() {
    *this = ::std::move(from);
  }

  inline QueryPendingSendToEthResponse& operator=(const QueryPendingSendToEthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPendingSendToEthResponse& operator=(QueryPendingSendToEthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPendingSendToEthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPendingSendToEthResponse* internal_default_instance() {
    return reinterpret_cast<const QueryPendingSendToEthResponse*>(
               &_QueryPendingSendToEthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(QueryPendingSendToEthResponse& a, QueryPendingSendToEthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPendingSendToEthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPendingSendToEthResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPendingSendToEthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPendingSendToEthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPendingSendToEthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPendingSendToEthResponse& from) {
    QueryPendingSendToEthResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPendingSendToEthResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryPendingSendToEthResponse";
  }
  protected:
  explicit QueryPendingSendToEthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransfersInBatchesFieldNumber = 1,
    kUnbatchedTransfersFieldNumber = 2,
  };
  // repeated .injective.peggy.v1.OutgoingTransferTx transfers_in_batches = 1 [json_name = "transfersInBatches"];
  int transfers_in_batches_size() const;
  private:
  int _internal_transfers_in_batches_size() const;

  public:
  void clear_transfers_in_batches() ;
  ::injective::peggy::v1::OutgoingTransferTx* mutable_transfers_in_batches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >*
      mutable_transfers_in_batches();
  private:
  const ::injective::peggy::v1::OutgoingTransferTx& _internal_transfers_in_batches(int index) const;
  ::injective::peggy::v1::OutgoingTransferTx* _internal_add_transfers_in_batches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>& _internal_transfers_in_batches() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>* _internal_mutable_transfers_in_batches();
  public:
  const ::injective::peggy::v1::OutgoingTransferTx& transfers_in_batches(int index) const;
  ::injective::peggy::v1::OutgoingTransferTx* add_transfers_in_batches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >&
      transfers_in_batches() const;
  // repeated .injective.peggy.v1.OutgoingTransferTx unbatched_transfers = 2 [json_name = "unbatchedTransfers"];
  int unbatched_transfers_size() const;
  private:
  int _internal_unbatched_transfers_size() const;

  public:
  void clear_unbatched_transfers() ;
  ::injective::peggy::v1::OutgoingTransferTx* mutable_unbatched_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >*
      mutable_unbatched_transfers();
  private:
  const ::injective::peggy::v1::OutgoingTransferTx& _internal_unbatched_transfers(int index) const;
  ::injective::peggy::v1::OutgoingTransferTx* _internal_add_unbatched_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>& _internal_unbatched_transfers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>* _internal_mutable_unbatched_transfers();
  public:
  const ::injective::peggy::v1::OutgoingTransferTx& unbatched_transfers(int index) const;
  ::injective::peggy::v1::OutgoingTransferTx* add_unbatched_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >&
      unbatched_transfers() const;
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryPendingSendToEthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx > transfers_in_batches_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx > unbatched_transfers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryModuleStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryModuleStateRequest) */ {
 public:
  inline QueryModuleStateRequest() : QueryModuleStateRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryModuleStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryModuleStateRequest(const QueryModuleStateRequest& from);
  QueryModuleStateRequest(QueryModuleStateRequest&& from) noexcept
    : QueryModuleStateRequest() {
    *this = ::std::move(from);
  }

  inline QueryModuleStateRequest& operator=(const QueryModuleStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryModuleStateRequest& operator=(QueryModuleStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryModuleStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryModuleStateRequest* internal_default_instance() {
    return reinterpret_cast<const QueryModuleStateRequest*>(
               &_QueryModuleStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(QueryModuleStateRequest& a, QueryModuleStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryModuleStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryModuleStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryModuleStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryModuleStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryModuleStateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryModuleStateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryModuleStateRequest";
  }
  protected:
  explicit QueryModuleStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryModuleStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryModuleStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.QueryModuleStateResponse) */ {
 public:
  inline QueryModuleStateResponse() : QueryModuleStateResponse(nullptr) {}
  ~QueryModuleStateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryModuleStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryModuleStateResponse(const QueryModuleStateResponse& from);
  QueryModuleStateResponse(QueryModuleStateResponse&& from) noexcept
    : QueryModuleStateResponse() {
    *this = ::std::move(from);
  }

  inline QueryModuleStateResponse& operator=(const QueryModuleStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryModuleStateResponse& operator=(QueryModuleStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryModuleStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryModuleStateResponse* internal_default_instance() {
    return reinterpret_cast<const QueryModuleStateResponse*>(
               &_QueryModuleStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(QueryModuleStateResponse& a, QueryModuleStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryModuleStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryModuleStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryModuleStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryModuleStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryModuleStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryModuleStateResponse& from) {
    QueryModuleStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryModuleStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.QueryModuleStateResponse";
  }
  protected:
  explicit QueryModuleStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .injective.peggy.v1.GenesisState state = 1 [json_name = "state"];
  bool has_state() const;
  void clear_state() ;
  const ::injective::peggy::v1::GenesisState& state() const;
  PROTOBUF_NODISCARD ::injective::peggy::v1::GenesisState* release_state();
  ::injective::peggy::v1::GenesisState* mutable_state();
  void set_allocated_state(::injective::peggy::v1::GenesisState* state);
  private:
  const ::injective::peggy::v1::GenesisState& _internal_state() const;
  ::injective::peggy::v1::GenesisState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::injective::peggy::v1::GenesisState* state);
  ::injective::peggy::v1::GenesisState* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.QueryModuleStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::peggy::v1::GenesisState* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class MissingNoncesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.peggy.v1.MissingNoncesRequest) */ {
 public:
  inline MissingNoncesRequest() : MissingNoncesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MissingNoncesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissingNoncesRequest(const MissingNoncesRequest& from);
  MissingNoncesRequest(MissingNoncesRequest&& from) noexcept
    : MissingNoncesRequest() {
    *this = ::std::move(from);
  }

  inline MissingNoncesRequest& operator=(const MissingNoncesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissingNoncesRequest& operator=(MissingNoncesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissingNoncesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissingNoncesRequest* internal_default_instance() {
    return reinterpret_cast<const MissingNoncesRequest*>(
               &_MissingNoncesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MissingNoncesRequest& a, MissingNoncesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MissingNoncesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissingNoncesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissingNoncesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissingNoncesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MissingNoncesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MissingNoncesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.MissingNoncesRequest";
  }
  protected:
  explicit MissingNoncesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.peggy.v1.MissingNoncesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};// -------------------------------------------------------------------

class MissingNoncesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.MissingNoncesResponse) */ {
 public:
  inline MissingNoncesResponse() : MissingNoncesResponse(nullptr) {}
  ~MissingNoncesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MissingNoncesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissingNoncesResponse(const MissingNoncesResponse& from);
  MissingNoncesResponse(MissingNoncesResponse&& from) noexcept
    : MissingNoncesResponse() {
    *this = ::std::move(from);
  }

  inline MissingNoncesResponse& operator=(const MissingNoncesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissingNoncesResponse& operator=(MissingNoncesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissingNoncesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissingNoncesResponse* internal_default_instance() {
    return reinterpret_cast<const MissingNoncesResponse*>(
               &_MissingNoncesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MissingNoncesResponse& a, MissingNoncesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MissingNoncesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissingNoncesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissingNoncesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissingNoncesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MissingNoncesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MissingNoncesResponse& from) {
    MissingNoncesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissingNoncesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.MissingNoncesResponse";
  }
  protected:
  explicit MissingNoncesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperatorAddressesFieldNumber = 1,
  };
  // repeated string operator_addresses = 1 [json_name = "operatorAddresses"];
  int operator_addresses_size() const;
  private:
  int _internal_operator_addresses_size() const;

  public:
  void clear_operator_addresses() ;
  const std::string& operator_addresses(int index) const;
  std::string* mutable_operator_addresses(int index);
  void set_operator_addresses(int index, const std::string& value);
  void set_operator_addresses(int index, std::string&& value);
  void set_operator_addresses(int index, const char* value);
  void set_operator_addresses(int index, const char* value, std::size_t size);
  void set_operator_addresses(int index, absl::string_view value);
  std::string* add_operator_addresses();
  void add_operator_addresses(const std::string& value);
  void add_operator_addresses(std::string&& value);
  void add_operator_addresses(const char* value);
  void add_operator_addresses(const char* value, std::size_t size);
  void add_operator_addresses(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& operator_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_operator_addresses();

  private:
  const std::string& _internal_operator_addresses(int index) const;
  std::string* _internal_add_operator_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_operator_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_operator_addresses();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.MissingNoncesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> operator_addresses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fquery_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// QueryParamsRequest

// -------------------------------------------------------------------

// QueryParamsResponse

// .injective.peggy.v1.Params params = 1 [json_name = "params", (.gogoproto.nullable) = false];
inline bool QueryParamsResponse::has_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::Params& QueryParamsResponse::_internal_params() const {
  const ::injective::peggy::v1::Params* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::Params&>(
      ::injective::peggy::v1::_Params_default_instance_);
}
inline const ::injective::peggy::v1::Params& QueryParamsResponse::params() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryParamsResponse.params)
  return _internal_params();
}
inline void QueryParamsResponse::unsafe_arena_set_allocated_params(
    ::injective::peggy::v1::Params* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryParamsResponse.params)
}
inline ::injective::peggy::v1::Params* QueryParamsResponse::release_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::Params* QueryParamsResponse::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryParamsResponse.params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::Params* QueryParamsResponse::_internal_mutable_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::Params>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::injective::peggy::v1::Params* QueryParamsResponse::mutable_params() {
  ::injective::peggy::v1::Params* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryParamsResponse.params)
  return _msg;
}
inline void QueryParamsResponse::set_allocated_params(::injective::peggy::v1::Params* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryParamsResponse.params)
}

// -------------------------------------------------------------------

// QueryCurrentValsetRequest

// -------------------------------------------------------------------

// QueryCurrentValsetResponse

// .injective.peggy.v1.Valset valset = 1 [json_name = "valset"];
inline bool QueryCurrentValsetResponse::has_valset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.valset_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::Valset& QueryCurrentValsetResponse::_internal_valset() const {
  const ::injective::peggy::v1::Valset* p = _impl_.valset_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::Valset&>(
      ::injective::peggy::v1::_Valset_default_instance_);
}
inline const ::injective::peggy::v1::Valset& QueryCurrentValsetResponse::valset() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryCurrentValsetResponse.valset)
  return _internal_valset();
}
inline void QueryCurrentValsetResponse::unsafe_arena_set_allocated_valset(
    ::injective::peggy::v1::Valset* valset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valset_);
  }
  _impl_.valset_ = valset;
  if (valset) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryCurrentValsetResponse.valset)
}
inline ::injective::peggy::v1::Valset* QueryCurrentValsetResponse::release_valset() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::Valset* temp = _impl_.valset_;
  _impl_.valset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::Valset* QueryCurrentValsetResponse::unsafe_arena_release_valset() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryCurrentValsetResponse.valset)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::Valset* temp = _impl_.valset_;
  _impl_.valset_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::Valset* QueryCurrentValsetResponse::_internal_mutable_valset() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.valset_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::Valset>(GetArenaForAllocation());
    _impl_.valset_ = p;
  }
  return _impl_.valset_;
}
inline ::injective::peggy::v1::Valset* QueryCurrentValsetResponse::mutable_valset() {
  ::injective::peggy::v1::Valset* _msg = _internal_mutable_valset();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryCurrentValsetResponse.valset)
  return _msg;
}
inline void QueryCurrentValsetResponse::set_allocated_valset(::injective::peggy::v1::Valset* valset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valset_);
  }
  if (valset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valset));
    if (message_arena != submessage_arena) {
      valset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valset, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.valset_ = valset;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryCurrentValsetResponse.valset)
}

// -------------------------------------------------------------------

// QueryValsetRequestRequest

// uint64 nonce = 1 [json_name = "nonce"];
inline void QueryValsetRequestRequest::clear_nonce() {
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t QueryValsetRequestRequest::nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryValsetRequestRequest.nonce)
  return _internal_nonce();
}
inline void QueryValsetRequestRequest::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryValsetRequestRequest.nonce)
}
inline ::uint64_t QueryValsetRequestRequest::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void QueryValsetRequestRequest::_internal_set_nonce(::uint64_t value) {
  ;
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// QueryValsetRequestResponse

// .injective.peggy.v1.Valset valset = 1 [json_name = "valset"];
inline bool QueryValsetRequestResponse::has_valset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.valset_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::Valset& QueryValsetRequestResponse::_internal_valset() const {
  const ::injective::peggy::v1::Valset* p = _impl_.valset_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::Valset&>(
      ::injective::peggy::v1::_Valset_default_instance_);
}
inline const ::injective::peggy::v1::Valset& QueryValsetRequestResponse::valset() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryValsetRequestResponse.valset)
  return _internal_valset();
}
inline void QueryValsetRequestResponse::unsafe_arena_set_allocated_valset(
    ::injective::peggy::v1::Valset* valset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valset_);
  }
  _impl_.valset_ = valset;
  if (valset) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryValsetRequestResponse.valset)
}
inline ::injective::peggy::v1::Valset* QueryValsetRequestResponse::release_valset() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::Valset* temp = _impl_.valset_;
  _impl_.valset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::Valset* QueryValsetRequestResponse::unsafe_arena_release_valset() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryValsetRequestResponse.valset)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::Valset* temp = _impl_.valset_;
  _impl_.valset_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::Valset* QueryValsetRequestResponse::_internal_mutable_valset() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.valset_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::Valset>(GetArenaForAllocation());
    _impl_.valset_ = p;
  }
  return _impl_.valset_;
}
inline ::injective::peggy::v1::Valset* QueryValsetRequestResponse::mutable_valset() {
  ::injective::peggy::v1::Valset* _msg = _internal_mutable_valset();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryValsetRequestResponse.valset)
  return _msg;
}
inline void QueryValsetRequestResponse::set_allocated_valset(::injective::peggy::v1::Valset* valset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valset_);
  }
  if (valset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valset));
    if (message_arena != submessage_arena) {
      valset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valset, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.valset_ = valset;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryValsetRequestResponse.valset)
}

// -------------------------------------------------------------------

// QueryValsetConfirmRequest

// uint64 nonce = 1 [json_name = "nonce"];
inline void QueryValsetConfirmRequest::clear_nonce() {
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t QueryValsetConfirmRequest::nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryValsetConfirmRequest.nonce)
  return _internal_nonce();
}
inline void QueryValsetConfirmRequest::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryValsetConfirmRequest.nonce)
}
inline ::uint64_t QueryValsetConfirmRequest::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void QueryValsetConfirmRequest::_internal_set_nonce(::uint64_t value) {
  ;
  _impl_.nonce_ = value;
}

// string address = 2 [json_name = "address"];
inline void QueryValsetConfirmRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& QueryValsetConfirmRequest::address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryValsetConfirmRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryValsetConfirmRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryValsetConfirmRequest.address)
}
inline std::string* QueryValsetConfirmRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryValsetConfirmRequest.address)
  return _s;
}
inline const std::string& QueryValsetConfirmRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void QueryValsetConfirmRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryValsetConfirmRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryValsetConfirmRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryValsetConfirmRequest.address)
  return _impl_.address_.Release();
}
inline void QueryValsetConfirmRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryValsetConfirmRequest.address)
}

// -------------------------------------------------------------------

// QueryValsetConfirmResponse

// .injective.peggy.v1.MsgValsetConfirm confirm = 1 [json_name = "confirm"];
inline bool QueryValsetConfirmResponse::has_confirm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confirm_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::MsgValsetConfirm& QueryValsetConfirmResponse::_internal_confirm() const {
  const ::injective::peggy::v1::MsgValsetConfirm* p = _impl_.confirm_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::MsgValsetConfirm&>(
      ::injective::peggy::v1::_MsgValsetConfirm_default_instance_);
}
inline const ::injective::peggy::v1::MsgValsetConfirm& QueryValsetConfirmResponse::confirm() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryValsetConfirmResponse.confirm)
  return _internal_confirm();
}
inline void QueryValsetConfirmResponse::unsafe_arena_set_allocated_confirm(
    ::injective::peggy::v1::MsgValsetConfirm* confirm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.confirm_);
  }
  _impl_.confirm_ = confirm;
  if (confirm) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryValsetConfirmResponse.confirm)
}
inline ::injective::peggy::v1::MsgValsetConfirm* QueryValsetConfirmResponse::release_confirm() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::MsgValsetConfirm* temp = _impl_.confirm_;
  _impl_.confirm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::MsgValsetConfirm* QueryValsetConfirmResponse::unsafe_arena_release_confirm() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryValsetConfirmResponse.confirm)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::MsgValsetConfirm* temp = _impl_.confirm_;
  _impl_.confirm_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::MsgValsetConfirm* QueryValsetConfirmResponse::_internal_mutable_confirm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confirm_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::MsgValsetConfirm>(GetArenaForAllocation());
    _impl_.confirm_ = p;
  }
  return _impl_.confirm_;
}
inline ::injective::peggy::v1::MsgValsetConfirm* QueryValsetConfirmResponse::mutable_confirm() {
  ::injective::peggy::v1::MsgValsetConfirm* _msg = _internal_mutable_confirm();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryValsetConfirmResponse.confirm)
  return _msg;
}
inline void QueryValsetConfirmResponse::set_allocated_confirm(::injective::peggy::v1::MsgValsetConfirm* confirm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.confirm_);
  }
  if (confirm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(confirm));
    if (message_arena != submessage_arena) {
      confirm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, confirm, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.confirm_ = confirm;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryValsetConfirmResponse.confirm)
}

// -------------------------------------------------------------------

// QueryValsetConfirmsByNonceRequest

// uint64 nonce = 1 [json_name = "nonce"];
inline void QueryValsetConfirmsByNonceRequest::clear_nonce() {
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t QueryValsetConfirmsByNonceRequest::nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryValsetConfirmsByNonceRequest.nonce)
  return _internal_nonce();
}
inline void QueryValsetConfirmsByNonceRequest::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryValsetConfirmsByNonceRequest.nonce)
}
inline ::uint64_t QueryValsetConfirmsByNonceRequest::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void QueryValsetConfirmsByNonceRequest::_internal_set_nonce(::uint64_t value) {
  ;
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// QueryValsetConfirmsByNonceResponse

// repeated .injective.peggy.v1.MsgValsetConfirm confirms = 1 [json_name = "confirms"];
inline int QueryValsetConfirmsByNonceResponse::_internal_confirms_size() const {
  return _impl_.confirms_.size();
}
inline int QueryValsetConfirmsByNonceResponse::confirms_size() const {
  return _internal_confirms_size();
}
inline ::injective::peggy::v1::MsgValsetConfirm* QueryValsetConfirmsByNonceResponse::mutable_confirms(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryValsetConfirmsByNonceResponse.confirms)
  return _internal_mutable_confirms()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgValsetConfirm >*
QueryValsetConfirmsByNonceResponse::mutable_confirms() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryValsetConfirmsByNonceResponse.confirms)
  return _internal_mutable_confirms();
}
inline const ::injective::peggy::v1::MsgValsetConfirm& QueryValsetConfirmsByNonceResponse::_internal_confirms(int index) const {
  return _internal_confirms().Get(index);
}
inline const ::injective::peggy::v1::MsgValsetConfirm& QueryValsetConfirmsByNonceResponse::confirms(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryValsetConfirmsByNonceResponse.confirms)
  return _internal_confirms(index);
}
inline ::injective::peggy::v1::MsgValsetConfirm* QueryValsetConfirmsByNonceResponse::_internal_add_confirms() {
  return _internal_mutable_confirms()->Add();
}
inline ::injective::peggy::v1::MsgValsetConfirm* QueryValsetConfirmsByNonceResponse::add_confirms() {
  ::injective::peggy::v1::MsgValsetConfirm* _add = _internal_add_confirms();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryValsetConfirmsByNonceResponse.confirms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgValsetConfirm >&
QueryValsetConfirmsByNonceResponse::confirms() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryValsetConfirmsByNonceResponse.confirms)
  return _internal_confirms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgValsetConfirm>&
QueryValsetConfirmsByNonceResponse::_internal_confirms() const {
  return _impl_.confirms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgValsetConfirm>*
QueryValsetConfirmsByNonceResponse::_internal_mutable_confirms() {
  return &_impl_.confirms_;
}

// -------------------------------------------------------------------

// QueryLastValsetRequestsRequest

// -------------------------------------------------------------------

// QueryLastValsetRequestsResponse

// repeated .injective.peggy.v1.Valset valsets = 1 [json_name = "valsets"];
inline int QueryLastValsetRequestsResponse::_internal_valsets_size() const {
  return _impl_.valsets_.size();
}
inline int QueryLastValsetRequestsResponse::valsets_size() const {
  return _internal_valsets_size();
}
inline ::injective::peggy::v1::Valset* QueryLastValsetRequestsResponse::mutable_valsets(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryLastValsetRequestsResponse.valsets)
  return _internal_mutable_valsets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >*
QueryLastValsetRequestsResponse::mutable_valsets() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryLastValsetRequestsResponse.valsets)
  return _internal_mutable_valsets();
}
inline const ::injective::peggy::v1::Valset& QueryLastValsetRequestsResponse::_internal_valsets(int index) const {
  return _internal_valsets().Get(index);
}
inline const ::injective::peggy::v1::Valset& QueryLastValsetRequestsResponse::valsets(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryLastValsetRequestsResponse.valsets)
  return _internal_valsets(index);
}
inline ::injective::peggy::v1::Valset* QueryLastValsetRequestsResponse::_internal_add_valsets() {
  return _internal_mutable_valsets()->Add();
}
inline ::injective::peggy::v1::Valset* QueryLastValsetRequestsResponse::add_valsets() {
  ::injective::peggy::v1::Valset* _add = _internal_add_valsets();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryLastValsetRequestsResponse.valsets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >&
QueryLastValsetRequestsResponse::valsets() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryLastValsetRequestsResponse.valsets)
  return _internal_valsets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>&
QueryLastValsetRequestsResponse::_internal_valsets() const {
  return _impl_.valsets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>*
QueryLastValsetRequestsResponse::_internal_mutable_valsets() {
  return &_impl_.valsets_;
}

// -------------------------------------------------------------------

// QueryLastPendingValsetRequestByAddrRequest

// string address = 1 [json_name = "address"];
inline void QueryLastPendingValsetRequestByAddrRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& QueryLastPendingValsetRequestByAddrRequest::address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryLastPendingValsetRequestByAddrRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest.address)
}
inline std::string* QueryLastPendingValsetRequestByAddrRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest.address)
  return _s;
}
inline const std::string& QueryLastPendingValsetRequestByAddrRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void QueryLastPendingValsetRequestByAddrRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryLastPendingValsetRequestByAddrRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryLastPendingValsetRequestByAddrRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest.address)
  return _impl_.address_.Release();
}
inline void QueryLastPendingValsetRequestByAddrRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryLastPendingValsetRequestByAddrRequest.address)
}

// -------------------------------------------------------------------

// QueryLastPendingValsetRequestByAddrResponse

// repeated .injective.peggy.v1.Valset valsets = 1 [json_name = "valsets"];
inline int QueryLastPendingValsetRequestByAddrResponse::_internal_valsets_size() const {
  return _impl_.valsets_.size();
}
inline int QueryLastPendingValsetRequestByAddrResponse::valsets_size() const {
  return _internal_valsets_size();
}
inline ::injective::peggy::v1::Valset* QueryLastPendingValsetRequestByAddrResponse::mutable_valsets(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse.valsets)
  return _internal_mutable_valsets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >*
QueryLastPendingValsetRequestByAddrResponse::mutable_valsets() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse.valsets)
  return _internal_mutable_valsets();
}
inline const ::injective::peggy::v1::Valset& QueryLastPendingValsetRequestByAddrResponse::_internal_valsets(int index) const {
  return _internal_valsets().Get(index);
}
inline const ::injective::peggy::v1::Valset& QueryLastPendingValsetRequestByAddrResponse::valsets(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse.valsets)
  return _internal_valsets(index);
}
inline ::injective::peggy::v1::Valset* QueryLastPendingValsetRequestByAddrResponse::_internal_add_valsets() {
  return _internal_mutable_valsets()->Add();
}
inline ::injective::peggy::v1::Valset* QueryLastPendingValsetRequestByAddrResponse::add_valsets() {
  ::injective::peggy::v1::Valset* _add = _internal_add_valsets();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse.valsets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::Valset >&
QueryLastPendingValsetRequestByAddrResponse::valsets() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryLastPendingValsetRequestByAddrResponse.valsets)
  return _internal_valsets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>&
QueryLastPendingValsetRequestByAddrResponse::_internal_valsets() const {
  return _impl_.valsets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::Valset>*
QueryLastPendingValsetRequestByAddrResponse::_internal_mutable_valsets() {
  return &_impl_.valsets_;
}

// -------------------------------------------------------------------

// QueryBatchFeeRequest

// -------------------------------------------------------------------

// QueryBatchFeeResponse

// repeated .injective.peggy.v1.BatchFees batchFees = 1 [json_name = "batchFees"];
inline int QueryBatchFeeResponse::_internal_batchfees_size() const {
  return _impl_.batchfees_.size();
}
inline int QueryBatchFeeResponse::batchfees_size() const {
  return _internal_batchfees_size();
}
inline ::injective::peggy::v1::BatchFees* QueryBatchFeeResponse::mutable_batchfees(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryBatchFeeResponse.batchFees)
  return _internal_mutable_batchfees()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BatchFees >*
QueryBatchFeeResponse::mutable_batchfees() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryBatchFeeResponse.batchFees)
  return _internal_mutable_batchfees();
}
inline const ::injective::peggy::v1::BatchFees& QueryBatchFeeResponse::_internal_batchfees(int index) const {
  return _internal_batchfees().Get(index);
}
inline const ::injective::peggy::v1::BatchFees& QueryBatchFeeResponse::batchfees(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryBatchFeeResponse.batchFees)
  return _internal_batchfees(index);
}
inline ::injective::peggy::v1::BatchFees* QueryBatchFeeResponse::_internal_add_batchfees() {
  return _internal_mutable_batchfees()->Add();
}
inline ::injective::peggy::v1::BatchFees* QueryBatchFeeResponse::add_batchfees() {
  ::injective::peggy::v1::BatchFees* _add = _internal_add_batchfees();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryBatchFeeResponse.batchFees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BatchFees >&
QueryBatchFeeResponse::batchfees() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryBatchFeeResponse.batchFees)
  return _internal_batchfees();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BatchFees>&
QueryBatchFeeResponse::_internal_batchfees() const {
  return _impl_.batchfees_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BatchFees>*
QueryBatchFeeResponse::_internal_mutable_batchfees() {
  return &_impl_.batchfees_;
}

// -------------------------------------------------------------------

// QueryLastPendingBatchRequestByAddrRequest

// string address = 1 [json_name = "address"];
inline void QueryLastPendingBatchRequestByAddrRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& QueryLastPendingBatchRequestByAddrRequest::address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryLastPendingBatchRequestByAddrRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest.address)
}
inline std::string* QueryLastPendingBatchRequestByAddrRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest.address)
  return _s;
}
inline const std::string& QueryLastPendingBatchRequestByAddrRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void QueryLastPendingBatchRequestByAddrRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryLastPendingBatchRequestByAddrRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryLastPendingBatchRequestByAddrRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest.address)
  return _impl_.address_.Release();
}
inline void QueryLastPendingBatchRequestByAddrRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryLastPendingBatchRequestByAddrRequest.address)
}

// -------------------------------------------------------------------

// QueryLastPendingBatchRequestByAddrResponse

// .injective.peggy.v1.OutgoingTxBatch batch = 1 [json_name = "batch"];
inline bool QueryLastPendingBatchRequestByAddrResponse::has_batch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.batch_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::OutgoingTxBatch& QueryLastPendingBatchRequestByAddrResponse::_internal_batch() const {
  const ::injective::peggy::v1::OutgoingTxBatch* p = _impl_.batch_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::OutgoingTxBatch&>(
      ::injective::peggy::v1::_OutgoingTxBatch_default_instance_);
}
inline const ::injective::peggy::v1::OutgoingTxBatch& QueryLastPendingBatchRequestByAddrResponse::batch() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse.batch)
  return _internal_batch();
}
inline void QueryLastPendingBatchRequestByAddrResponse::unsafe_arena_set_allocated_batch(
    ::injective::peggy::v1::OutgoingTxBatch* batch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_);
  }
  _impl_.batch_ = batch;
  if (batch) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse.batch)
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryLastPendingBatchRequestByAddrResponse::release_batch() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::OutgoingTxBatch* temp = _impl_.batch_;
  _impl_.batch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryLastPendingBatchRequestByAddrResponse::unsafe_arena_release_batch() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse.batch)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::OutgoingTxBatch* temp = _impl_.batch_;
  _impl_.batch_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryLastPendingBatchRequestByAddrResponse::_internal_mutable_batch() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.batch_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::OutgoingTxBatch>(GetArenaForAllocation());
    _impl_.batch_ = p;
  }
  return _impl_.batch_;
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryLastPendingBatchRequestByAddrResponse::mutable_batch() {
  ::injective::peggy::v1::OutgoingTxBatch* _msg = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse.batch)
  return _msg;
}
inline void QueryLastPendingBatchRequestByAddrResponse::set_allocated_batch(::injective::peggy::v1::OutgoingTxBatch* batch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_);
  }
  if (batch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch));
    if (message_arena != submessage_arena) {
      batch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.batch_ = batch;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryLastPendingBatchRequestByAddrResponse.batch)
}

// -------------------------------------------------------------------

// QueryOutgoingTxBatchesRequest

// -------------------------------------------------------------------

// QueryOutgoingTxBatchesResponse

// repeated .injective.peggy.v1.OutgoingTxBatch batches = 1 [json_name = "batches"];
inline int QueryOutgoingTxBatchesResponse::_internal_batches_size() const {
  return _impl_.batches_.size();
}
inline int QueryOutgoingTxBatchesResponse::batches_size() const {
  return _internal_batches_size();
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryOutgoingTxBatchesResponse::mutable_batches(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryOutgoingTxBatchesResponse.batches)
  return _internal_mutable_batches()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTxBatch >*
QueryOutgoingTxBatchesResponse::mutable_batches() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryOutgoingTxBatchesResponse.batches)
  return _internal_mutable_batches();
}
inline const ::injective::peggy::v1::OutgoingTxBatch& QueryOutgoingTxBatchesResponse::_internal_batches(int index) const {
  return _internal_batches().Get(index);
}
inline const ::injective::peggy::v1::OutgoingTxBatch& QueryOutgoingTxBatchesResponse::batches(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryOutgoingTxBatchesResponse.batches)
  return _internal_batches(index);
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryOutgoingTxBatchesResponse::_internal_add_batches() {
  return _internal_mutable_batches()->Add();
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryOutgoingTxBatchesResponse::add_batches() {
  ::injective::peggy::v1::OutgoingTxBatch* _add = _internal_add_batches();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryOutgoingTxBatchesResponse.batches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTxBatch >&
QueryOutgoingTxBatchesResponse::batches() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryOutgoingTxBatchesResponse.batches)
  return _internal_batches();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTxBatch>&
QueryOutgoingTxBatchesResponse::_internal_batches() const {
  return _impl_.batches_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTxBatch>*
QueryOutgoingTxBatchesResponse::_internal_mutable_batches() {
  return &_impl_.batches_;
}

// -------------------------------------------------------------------

// QueryBatchRequestByNonceRequest

// uint64 nonce = 1 [json_name = "nonce"];
inline void QueryBatchRequestByNonceRequest::clear_nonce() {
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t QueryBatchRequestByNonceRequest::nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryBatchRequestByNonceRequest.nonce)
  return _internal_nonce();
}
inline void QueryBatchRequestByNonceRequest::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryBatchRequestByNonceRequest.nonce)
}
inline ::uint64_t QueryBatchRequestByNonceRequest::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void QueryBatchRequestByNonceRequest::_internal_set_nonce(::uint64_t value) {
  ;
  _impl_.nonce_ = value;
}

// string contract_address = 2 [json_name = "contractAddress"];
inline void QueryBatchRequestByNonceRequest::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& QueryBatchRequestByNonceRequest::contract_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryBatchRequestByNonceRequest.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryBatchRequestByNonceRequest::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryBatchRequestByNonceRequest.contract_address)
}
inline std::string* QueryBatchRequestByNonceRequest::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryBatchRequestByNonceRequest.contract_address)
  return _s;
}
inline const std::string& QueryBatchRequestByNonceRequest::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void QueryBatchRequestByNonceRequest::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryBatchRequestByNonceRequest::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryBatchRequestByNonceRequest::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryBatchRequestByNonceRequest.contract_address)
  return _impl_.contract_address_.Release();
}
inline void QueryBatchRequestByNonceRequest::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryBatchRequestByNonceRequest.contract_address)
}

// -------------------------------------------------------------------

// QueryBatchRequestByNonceResponse

// .injective.peggy.v1.OutgoingTxBatch batch = 1 [json_name = "batch"];
inline bool QueryBatchRequestByNonceResponse::has_batch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.batch_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::OutgoingTxBatch& QueryBatchRequestByNonceResponse::_internal_batch() const {
  const ::injective::peggy::v1::OutgoingTxBatch* p = _impl_.batch_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::OutgoingTxBatch&>(
      ::injective::peggy::v1::_OutgoingTxBatch_default_instance_);
}
inline const ::injective::peggy::v1::OutgoingTxBatch& QueryBatchRequestByNonceResponse::batch() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryBatchRequestByNonceResponse.batch)
  return _internal_batch();
}
inline void QueryBatchRequestByNonceResponse::unsafe_arena_set_allocated_batch(
    ::injective::peggy::v1::OutgoingTxBatch* batch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_);
  }
  _impl_.batch_ = batch;
  if (batch) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryBatchRequestByNonceResponse.batch)
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryBatchRequestByNonceResponse::release_batch() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::OutgoingTxBatch* temp = _impl_.batch_;
  _impl_.batch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryBatchRequestByNonceResponse::unsafe_arena_release_batch() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryBatchRequestByNonceResponse.batch)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::OutgoingTxBatch* temp = _impl_.batch_;
  _impl_.batch_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryBatchRequestByNonceResponse::_internal_mutable_batch() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.batch_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::OutgoingTxBatch>(GetArenaForAllocation());
    _impl_.batch_ = p;
  }
  return _impl_.batch_;
}
inline ::injective::peggy::v1::OutgoingTxBatch* QueryBatchRequestByNonceResponse::mutable_batch() {
  ::injective::peggy::v1::OutgoingTxBatch* _msg = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryBatchRequestByNonceResponse.batch)
  return _msg;
}
inline void QueryBatchRequestByNonceResponse::set_allocated_batch(::injective::peggy::v1::OutgoingTxBatch* batch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_);
  }
  if (batch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch));
    if (message_arena != submessage_arena) {
      batch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.batch_ = batch;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryBatchRequestByNonceResponse.batch)
}

// -------------------------------------------------------------------

// QueryBatchConfirmsRequest

// uint64 nonce = 1 [json_name = "nonce"];
inline void QueryBatchConfirmsRequest::clear_nonce() {
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t QueryBatchConfirmsRequest::nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryBatchConfirmsRequest.nonce)
  return _internal_nonce();
}
inline void QueryBatchConfirmsRequest::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryBatchConfirmsRequest.nonce)
}
inline ::uint64_t QueryBatchConfirmsRequest::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void QueryBatchConfirmsRequest::_internal_set_nonce(::uint64_t value) {
  ;
  _impl_.nonce_ = value;
}

// string contract_address = 2 [json_name = "contractAddress"];
inline void QueryBatchConfirmsRequest::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& QueryBatchConfirmsRequest::contract_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryBatchConfirmsRequest.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryBatchConfirmsRequest::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryBatchConfirmsRequest.contract_address)
}
inline std::string* QueryBatchConfirmsRequest::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryBatchConfirmsRequest.contract_address)
  return _s;
}
inline const std::string& QueryBatchConfirmsRequest::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void QueryBatchConfirmsRequest::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryBatchConfirmsRequest::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryBatchConfirmsRequest::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryBatchConfirmsRequest.contract_address)
  return _impl_.contract_address_.Release();
}
inline void QueryBatchConfirmsRequest::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryBatchConfirmsRequest.contract_address)
}

// -------------------------------------------------------------------

// QueryBatchConfirmsResponse

// repeated .injective.peggy.v1.MsgConfirmBatch confirms = 1 [json_name = "confirms"];
inline int QueryBatchConfirmsResponse::_internal_confirms_size() const {
  return _impl_.confirms_.size();
}
inline int QueryBatchConfirmsResponse::confirms_size() const {
  return _internal_confirms_size();
}
inline ::injective::peggy::v1::MsgConfirmBatch* QueryBatchConfirmsResponse::mutable_confirms(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryBatchConfirmsResponse.confirms)
  return _internal_mutable_confirms()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgConfirmBatch >*
QueryBatchConfirmsResponse::mutable_confirms() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryBatchConfirmsResponse.confirms)
  return _internal_mutable_confirms();
}
inline const ::injective::peggy::v1::MsgConfirmBatch& QueryBatchConfirmsResponse::_internal_confirms(int index) const {
  return _internal_confirms().Get(index);
}
inline const ::injective::peggy::v1::MsgConfirmBatch& QueryBatchConfirmsResponse::confirms(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryBatchConfirmsResponse.confirms)
  return _internal_confirms(index);
}
inline ::injective::peggy::v1::MsgConfirmBatch* QueryBatchConfirmsResponse::_internal_add_confirms() {
  return _internal_mutable_confirms()->Add();
}
inline ::injective::peggy::v1::MsgConfirmBatch* QueryBatchConfirmsResponse::add_confirms() {
  ::injective::peggy::v1::MsgConfirmBatch* _add = _internal_add_confirms();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryBatchConfirmsResponse.confirms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::MsgConfirmBatch >&
QueryBatchConfirmsResponse::confirms() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryBatchConfirmsResponse.confirms)
  return _internal_confirms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgConfirmBatch>&
QueryBatchConfirmsResponse::_internal_confirms() const {
  return _impl_.confirms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::MsgConfirmBatch>*
QueryBatchConfirmsResponse::_internal_mutable_confirms() {
  return &_impl_.confirms_;
}

// -------------------------------------------------------------------

// QueryLastEventByAddrRequest

// string address = 1 [json_name = "address"];
inline void QueryLastEventByAddrRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& QueryLastEventByAddrRequest::address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryLastEventByAddrRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryLastEventByAddrRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryLastEventByAddrRequest.address)
}
inline std::string* QueryLastEventByAddrRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryLastEventByAddrRequest.address)
  return _s;
}
inline const std::string& QueryLastEventByAddrRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void QueryLastEventByAddrRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryLastEventByAddrRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryLastEventByAddrRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryLastEventByAddrRequest.address)
  return _impl_.address_.Release();
}
inline void QueryLastEventByAddrRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryLastEventByAddrRequest.address)
}

// -------------------------------------------------------------------

// QueryLastEventByAddrResponse

// .injective.peggy.v1.LastClaimEvent last_claim_event = 1 [json_name = "lastClaimEvent"];
inline bool QueryLastEventByAddrResponse::has_last_claim_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_claim_event_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::LastClaimEvent& QueryLastEventByAddrResponse::_internal_last_claim_event() const {
  const ::injective::peggy::v1::LastClaimEvent* p = _impl_.last_claim_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::LastClaimEvent&>(
      ::injective::peggy::v1::_LastClaimEvent_default_instance_);
}
inline const ::injective::peggy::v1::LastClaimEvent& QueryLastEventByAddrResponse::last_claim_event() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryLastEventByAddrResponse.last_claim_event)
  return _internal_last_claim_event();
}
inline void QueryLastEventByAddrResponse::unsafe_arena_set_allocated_last_claim_event(
    ::injective::peggy::v1::LastClaimEvent* last_claim_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_claim_event_);
  }
  _impl_.last_claim_event_ = last_claim_event;
  if (last_claim_event) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryLastEventByAddrResponse.last_claim_event)
}
inline ::injective::peggy::v1::LastClaimEvent* QueryLastEventByAddrResponse::release_last_claim_event() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::LastClaimEvent* temp = _impl_.last_claim_event_;
  _impl_.last_claim_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::LastClaimEvent* QueryLastEventByAddrResponse::unsafe_arena_release_last_claim_event() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryLastEventByAddrResponse.last_claim_event)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::LastClaimEvent* temp = _impl_.last_claim_event_;
  _impl_.last_claim_event_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::LastClaimEvent* QueryLastEventByAddrResponse::_internal_mutable_last_claim_event() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.last_claim_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::LastClaimEvent>(GetArenaForAllocation());
    _impl_.last_claim_event_ = p;
  }
  return _impl_.last_claim_event_;
}
inline ::injective::peggy::v1::LastClaimEvent* QueryLastEventByAddrResponse::mutable_last_claim_event() {
  ::injective::peggy::v1::LastClaimEvent* _msg = _internal_mutable_last_claim_event();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryLastEventByAddrResponse.last_claim_event)
  return _msg;
}
inline void QueryLastEventByAddrResponse::set_allocated_last_claim_event(::injective::peggy::v1::LastClaimEvent* last_claim_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_claim_event_);
  }
  if (last_claim_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_claim_event));
    if (message_arena != submessage_arena) {
      last_claim_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_claim_event, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.last_claim_event_ = last_claim_event;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryLastEventByAddrResponse.last_claim_event)
}

// -------------------------------------------------------------------

// QueryERC20ToDenomRequest

// string erc20 = 1 [json_name = "erc20"];
inline void QueryERC20ToDenomRequest::clear_erc20() {
  _impl_.erc20_.ClearToEmpty();
}
inline const std::string& QueryERC20ToDenomRequest::erc20() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryERC20ToDenomRequest.erc20)
  return _internal_erc20();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryERC20ToDenomRequest::set_erc20(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.erc20_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryERC20ToDenomRequest.erc20)
}
inline std::string* QueryERC20ToDenomRequest::mutable_erc20() {
  std::string* _s = _internal_mutable_erc20();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryERC20ToDenomRequest.erc20)
  return _s;
}
inline const std::string& QueryERC20ToDenomRequest::_internal_erc20() const {
  return _impl_.erc20_.Get();
}
inline void QueryERC20ToDenomRequest::_internal_set_erc20(const std::string& value) {
  ;


  _impl_.erc20_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryERC20ToDenomRequest::_internal_mutable_erc20() {
  ;
  return _impl_.erc20_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryERC20ToDenomRequest::release_erc20() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryERC20ToDenomRequest.erc20)
  return _impl_.erc20_.Release();
}
inline void QueryERC20ToDenomRequest::set_allocated_erc20(std::string* value) {
  _impl_.erc20_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.erc20_.IsDefault()) {
          _impl_.erc20_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryERC20ToDenomRequest.erc20)
}

// -------------------------------------------------------------------

// QueryERC20ToDenomResponse

// string denom = 1 [json_name = "denom"];
inline void QueryERC20ToDenomResponse::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& QueryERC20ToDenomResponse::denom() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryERC20ToDenomResponse.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryERC20ToDenomResponse::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryERC20ToDenomResponse.denom)
}
inline std::string* QueryERC20ToDenomResponse::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryERC20ToDenomResponse.denom)
  return _s;
}
inline const std::string& QueryERC20ToDenomResponse::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void QueryERC20ToDenomResponse::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryERC20ToDenomResponse::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryERC20ToDenomResponse::release_denom() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryERC20ToDenomResponse.denom)
  return _impl_.denom_.Release();
}
inline void QueryERC20ToDenomResponse::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryERC20ToDenomResponse.denom)
}

// bool cosmos_originated = 2 [json_name = "cosmosOriginated"];
inline void QueryERC20ToDenomResponse::clear_cosmos_originated() {
  _impl_.cosmos_originated_ = false;
}
inline bool QueryERC20ToDenomResponse::cosmos_originated() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryERC20ToDenomResponse.cosmos_originated)
  return _internal_cosmos_originated();
}
inline void QueryERC20ToDenomResponse::set_cosmos_originated(bool value) {
  _internal_set_cosmos_originated(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryERC20ToDenomResponse.cosmos_originated)
}
inline bool QueryERC20ToDenomResponse::_internal_cosmos_originated() const {
  return _impl_.cosmos_originated_;
}
inline void QueryERC20ToDenomResponse::_internal_set_cosmos_originated(bool value) {
  ;
  _impl_.cosmos_originated_ = value;
}

// -------------------------------------------------------------------

// QueryDenomToERC20Request

// string denom = 1 [json_name = "denom"];
inline void QueryDenomToERC20Request::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& QueryDenomToERC20Request::denom() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDenomToERC20Request.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDenomToERC20Request::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDenomToERC20Request.denom)
}
inline std::string* QueryDenomToERC20Request::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDenomToERC20Request.denom)
  return _s;
}
inline const std::string& QueryDenomToERC20Request::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void QueryDenomToERC20Request::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDenomToERC20Request::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDenomToERC20Request::release_denom() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDenomToERC20Request.denom)
  return _impl_.denom_.Release();
}
inline void QueryDenomToERC20Request::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDenomToERC20Request.denom)
}

// -------------------------------------------------------------------

// QueryDenomToERC20Response

// string erc20 = 1 [json_name = "erc20"];
inline void QueryDenomToERC20Response::clear_erc20() {
  _impl_.erc20_.ClearToEmpty();
}
inline const std::string& QueryDenomToERC20Response::erc20() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDenomToERC20Response.erc20)
  return _internal_erc20();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDenomToERC20Response::set_erc20(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.erc20_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDenomToERC20Response.erc20)
}
inline std::string* QueryDenomToERC20Response::mutable_erc20() {
  std::string* _s = _internal_mutable_erc20();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDenomToERC20Response.erc20)
  return _s;
}
inline const std::string& QueryDenomToERC20Response::_internal_erc20() const {
  return _impl_.erc20_.Get();
}
inline void QueryDenomToERC20Response::_internal_set_erc20(const std::string& value) {
  ;


  _impl_.erc20_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDenomToERC20Response::_internal_mutable_erc20() {
  ;
  return _impl_.erc20_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDenomToERC20Response::release_erc20() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDenomToERC20Response.erc20)
  return _impl_.erc20_.Release();
}
inline void QueryDenomToERC20Response::set_allocated_erc20(std::string* value) {
  _impl_.erc20_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.erc20_.IsDefault()) {
          _impl_.erc20_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDenomToERC20Response.erc20)
}

// bool cosmos_originated = 2 [json_name = "cosmosOriginated"];
inline void QueryDenomToERC20Response::clear_cosmos_originated() {
  _impl_.cosmos_originated_ = false;
}
inline bool QueryDenomToERC20Response::cosmos_originated() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDenomToERC20Response.cosmos_originated)
  return _internal_cosmos_originated();
}
inline void QueryDenomToERC20Response::set_cosmos_originated(bool value) {
  _internal_set_cosmos_originated(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDenomToERC20Response.cosmos_originated)
}
inline bool QueryDenomToERC20Response::_internal_cosmos_originated() const {
  return _impl_.cosmos_originated_;
}
inline void QueryDenomToERC20Response::_internal_set_cosmos_originated(bool value) {
  ;
  _impl_.cosmos_originated_ = value;
}

// -------------------------------------------------------------------

// QueryDelegateKeysByValidatorAddress

// string validator_address = 1 [json_name = "validatorAddress"];
inline void QueryDelegateKeysByValidatorAddress::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByValidatorAddress::validator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByValidatorAddress.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByValidatorAddress::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByValidatorAddress.validator_address)
}
inline std::string* QueryDelegateKeysByValidatorAddress::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByValidatorAddress.validator_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByValidatorAddress::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void QueryDelegateKeysByValidatorAddress::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByValidatorAddress::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByValidatorAddress::release_validator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByValidatorAddress.validator_address)
  return _impl_.validator_address_.Release();
}
inline void QueryDelegateKeysByValidatorAddress::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByValidatorAddress.validator_address)
}

// -------------------------------------------------------------------

// QueryDelegateKeysByValidatorAddressResponse

// string eth_address = 1 [json_name = "ethAddress"];
inline void QueryDelegateKeysByValidatorAddressResponse::clear_eth_address() {
  _impl_.eth_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByValidatorAddressResponse::eth_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.eth_address)
  return _internal_eth_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByValidatorAddressResponse::set_eth_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.eth_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.eth_address)
}
inline std::string* QueryDelegateKeysByValidatorAddressResponse::mutable_eth_address() {
  std::string* _s = _internal_mutable_eth_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.eth_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByValidatorAddressResponse::_internal_eth_address() const {
  return _impl_.eth_address_.Get();
}
inline void QueryDelegateKeysByValidatorAddressResponse::_internal_set_eth_address(const std::string& value) {
  ;


  _impl_.eth_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByValidatorAddressResponse::_internal_mutable_eth_address() {
  ;
  return _impl_.eth_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByValidatorAddressResponse::release_eth_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.eth_address)
  return _impl_.eth_address_.Release();
}
inline void QueryDelegateKeysByValidatorAddressResponse::set_allocated_eth_address(std::string* value) {
  _impl_.eth_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.eth_address_.IsDefault()) {
          _impl_.eth_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.eth_address)
}

// string orchestrator_address = 2 [json_name = "orchestratorAddress"];
inline void QueryDelegateKeysByValidatorAddressResponse::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByValidatorAddressResponse::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByValidatorAddressResponse::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.orchestrator_address)
}
inline std::string* QueryDelegateKeysByValidatorAddressResponse::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.orchestrator_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByValidatorAddressResponse::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void QueryDelegateKeysByValidatorAddressResponse::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByValidatorAddressResponse::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByValidatorAddressResponse::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void QueryDelegateKeysByValidatorAddressResponse::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByValidatorAddressResponse.orchestrator_address)
}

// -------------------------------------------------------------------

// QueryDelegateKeysByEthAddress

// string eth_address = 1 [json_name = "ethAddress"];
inline void QueryDelegateKeysByEthAddress::clear_eth_address() {
  _impl_.eth_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByEthAddress::eth_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByEthAddress.eth_address)
  return _internal_eth_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByEthAddress::set_eth_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.eth_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByEthAddress.eth_address)
}
inline std::string* QueryDelegateKeysByEthAddress::mutable_eth_address() {
  std::string* _s = _internal_mutable_eth_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByEthAddress.eth_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByEthAddress::_internal_eth_address() const {
  return _impl_.eth_address_.Get();
}
inline void QueryDelegateKeysByEthAddress::_internal_set_eth_address(const std::string& value) {
  ;


  _impl_.eth_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByEthAddress::_internal_mutable_eth_address() {
  ;
  return _impl_.eth_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByEthAddress::release_eth_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByEthAddress.eth_address)
  return _impl_.eth_address_.Release();
}
inline void QueryDelegateKeysByEthAddress::set_allocated_eth_address(std::string* value) {
  _impl_.eth_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.eth_address_.IsDefault()) {
          _impl_.eth_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByEthAddress.eth_address)
}

// -------------------------------------------------------------------

// QueryDelegateKeysByEthAddressResponse

// string validator_address = 1 [json_name = "validatorAddress"];
inline void QueryDelegateKeysByEthAddressResponse::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByEthAddressResponse::validator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByEthAddressResponse::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.validator_address)
}
inline std::string* QueryDelegateKeysByEthAddressResponse::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.validator_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByEthAddressResponse::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void QueryDelegateKeysByEthAddressResponse::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByEthAddressResponse::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByEthAddressResponse::release_validator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.validator_address)
  return _impl_.validator_address_.Release();
}
inline void QueryDelegateKeysByEthAddressResponse::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.validator_address)
}

// string orchestrator_address = 2 [json_name = "orchestratorAddress"];
inline void QueryDelegateKeysByEthAddressResponse::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByEthAddressResponse::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByEthAddressResponse::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.orchestrator_address)
}
inline std::string* QueryDelegateKeysByEthAddressResponse::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.orchestrator_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByEthAddressResponse::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void QueryDelegateKeysByEthAddressResponse::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByEthAddressResponse::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByEthAddressResponse::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void QueryDelegateKeysByEthAddressResponse::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByEthAddressResponse.orchestrator_address)
}

// -------------------------------------------------------------------

// QueryDelegateKeysByOrchestratorAddress

// string orchestrator_address = 1 [json_name = "orchestratorAddress"];
inline void QueryDelegateKeysByOrchestratorAddress::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByOrchestratorAddress::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByOrchestratorAddress::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress.orchestrator_address)
}
inline std::string* QueryDelegateKeysByOrchestratorAddress::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress.orchestrator_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByOrchestratorAddress::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void QueryDelegateKeysByOrchestratorAddress::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByOrchestratorAddress::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByOrchestratorAddress::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void QueryDelegateKeysByOrchestratorAddress::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddress.orchestrator_address)
}

// -------------------------------------------------------------------

// QueryDelegateKeysByOrchestratorAddressResponse

// string validator_address = 1 [json_name = "validatorAddress"];
inline void QueryDelegateKeysByOrchestratorAddressResponse::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByOrchestratorAddressResponse::validator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByOrchestratorAddressResponse::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.validator_address)
}
inline std::string* QueryDelegateKeysByOrchestratorAddressResponse::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.validator_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByOrchestratorAddressResponse::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void QueryDelegateKeysByOrchestratorAddressResponse::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByOrchestratorAddressResponse::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByOrchestratorAddressResponse::release_validator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.validator_address)
  return _impl_.validator_address_.Release();
}
inline void QueryDelegateKeysByOrchestratorAddressResponse::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.validator_address)
}

// string eth_address = 2 [json_name = "ethAddress"];
inline void QueryDelegateKeysByOrchestratorAddressResponse::clear_eth_address() {
  _impl_.eth_address_.ClearToEmpty();
}
inline const std::string& QueryDelegateKeysByOrchestratorAddressResponse::eth_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.eth_address)
  return _internal_eth_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDelegateKeysByOrchestratorAddressResponse::set_eth_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.eth_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.eth_address)
}
inline std::string* QueryDelegateKeysByOrchestratorAddressResponse::mutable_eth_address() {
  std::string* _s = _internal_mutable_eth_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.eth_address)
  return _s;
}
inline const std::string& QueryDelegateKeysByOrchestratorAddressResponse::_internal_eth_address() const {
  return _impl_.eth_address_.Get();
}
inline void QueryDelegateKeysByOrchestratorAddressResponse::_internal_set_eth_address(const std::string& value) {
  ;


  _impl_.eth_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByOrchestratorAddressResponse::_internal_mutable_eth_address() {
  ;
  return _impl_.eth_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDelegateKeysByOrchestratorAddressResponse::release_eth_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.eth_address)
  return _impl_.eth_address_.Release();
}
inline void QueryDelegateKeysByOrchestratorAddressResponse::set_allocated_eth_address(std::string* value) {
  _impl_.eth_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.eth_address_.IsDefault()) {
          _impl_.eth_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryDelegateKeysByOrchestratorAddressResponse.eth_address)
}

// -------------------------------------------------------------------

// QueryPendingSendToEth

// string sender_address = 1 [json_name = "senderAddress"];
inline void QueryPendingSendToEth::clear_sender_address() {
  _impl_.sender_address_.ClearToEmpty();
}
inline const std::string& QueryPendingSendToEth::sender_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryPendingSendToEth.sender_address)
  return _internal_sender_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryPendingSendToEth::set_sender_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.QueryPendingSendToEth.sender_address)
}
inline std::string* QueryPendingSendToEth::mutable_sender_address() {
  std::string* _s = _internal_mutable_sender_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryPendingSendToEth.sender_address)
  return _s;
}
inline const std::string& QueryPendingSendToEth::_internal_sender_address() const {
  return _impl_.sender_address_.Get();
}
inline void QueryPendingSendToEth::_internal_set_sender_address(const std::string& value) {
  ;


  _impl_.sender_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryPendingSendToEth::_internal_mutable_sender_address() {
  ;
  return _impl_.sender_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryPendingSendToEth::release_sender_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryPendingSendToEth.sender_address)
  return _impl_.sender_address_.Release();
}
inline void QueryPendingSendToEth::set_allocated_sender_address(std::string* value) {
  _impl_.sender_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_address_.IsDefault()) {
          _impl_.sender_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryPendingSendToEth.sender_address)
}

// -------------------------------------------------------------------

// QueryPendingSendToEthResponse

// repeated .injective.peggy.v1.OutgoingTransferTx transfers_in_batches = 1 [json_name = "transfersInBatches"];
inline int QueryPendingSendToEthResponse::_internal_transfers_in_batches_size() const {
  return _impl_.transfers_in_batches_.size();
}
inline int QueryPendingSendToEthResponse::transfers_in_batches_size() const {
  return _internal_transfers_in_batches_size();
}
inline ::injective::peggy::v1::OutgoingTransferTx* QueryPendingSendToEthResponse::mutable_transfers_in_batches(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryPendingSendToEthResponse.transfers_in_batches)
  return _internal_mutable_transfers_in_batches()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >*
QueryPendingSendToEthResponse::mutable_transfers_in_batches() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryPendingSendToEthResponse.transfers_in_batches)
  return _internal_mutable_transfers_in_batches();
}
inline const ::injective::peggy::v1::OutgoingTransferTx& QueryPendingSendToEthResponse::_internal_transfers_in_batches(int index) const {
  return _internal_transfers_in_batches().Get(index);
}
inline const ::injective::peggy::v1::OutgoingTransferTx& QueryPendingSendToEthResponse::transfers_in_batches(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryPendingSendToEthResponse.transfers_in_batches)
  return _internal_transfers_in_batches(index);
}
inline ::injective::peggy::v1::OutgoingTransferTx* QueryPendingSendToEthResponse::_internal_add_transfers_in_batches() {
  return _internal_mutable_transfers_in_batches()->Add();
}
inline ::injective::peggy::v1::OutgoingTransferTx* QueryPendingSendToEthResponse::add_transfers_in_batches() {
  ::injective::peggy::v1::OutgoingTransferTx* _add = _internal_add_transfers_in_batches();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryPendingSendToEthResponse.transfers_in_batches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >&
QueryPendingSendToEthResponse::transfers_in_batches() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryPendingSendToEthResponse.transfers_in_batches)
  return _internal_transfers_in_batches();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>&
QueryPendingSendToEthResponse::_internal_transfers_in_batches() const {
  return _impl_.transfers_in_batches_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>*
QueryPendingSendToEthResponse::_internal_mutable_transfers_in_batches() {
  return &_impl_.transfers_in_batches_;
}

// repeated .injective.peggy.v1.OutgoingTransferTx unbatched_transfers = 2 [json_name = "unbatchedTransfers"];
inline int QueryPendingSendToEthResponse::_internal_unbatched_transfers_size() const {
  return _impl_.unbatched_transfers_.size();
}
inline int QueryPendingSendToEthResponse::unbatched_transfers_size() const {
  return _internal_unbatched_transfers_size();
}
inline ::injective::peggy::v1::OutgoingTransferTx* QueryPendingSendToEthResponse::mutable_unbatched_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryPendingSendToEthResponse.unbatched_transfers)
  return _internal_mutable_unbatched_transfers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >*
QueryPendingSendToEthResponse::mutable_unbatched_transfers() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.QueryPendingSendToEthResponse.unbatched_transfers)
  return _internal_mutable_unbatched_transfers();
}
inline const ::injective::peggy::v1::OutgoingTransferTx& QueryPendingSendToEthResponse::_internal_unbatched_transfers(int index) const {
  return _internal_unbatched_transfers().Get(index);
}
inline const ::injective::peggy::v1::OutgoingTransferTx& QueryPendingSendToEthResponse::unbatched_transfers(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryPendingSendToEthResponse.unbatched_transfers)
  return _internal_unbatched_transfers(index);
}
inline ::injective::peggy::v1::OutgoingTransferTx* QueryPendingSendToEthResponse::_internal_add_unbatched_transfers() {
  return _internal_mutable_unbatched_transfers()->Add();
}
inline ::injective::peggy::v1::OutgoingTransferTx* QueryPendingSendToEthResponse::add_unbatched_transfers() {
  ::injective::peggy::v1::OutgoingTransferTx* _add = _internal_add_unbatched_transfers();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.QueryPendingSendToEthResponse.unbatched_transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::OutgoingTransferTx >&
QueryPendingSendToEthResponse::unbatched_transfers() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.QueryPendingSendToEthResponse.unbatched_transfers)
  return _internal_unbatched_transfers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>&
QueryPendingSendToEthResponse::_internal_unbatched_transfers() const {
  return _impl_.unbatched_transfers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::OutgoingTransferTx>*
QueryPendingSendToEthResponse::_internal_mutable_unbatched_transfers() {
  return &_impl_.unbatched_transfers_;
}

// -------------------------------------------------------------------

// QueryModuleStateRequest

// -------------------------------------------------------------------

// QueryModuleStateResponse

// .injective.peggy.v1.GenesisState state = 1 [json_name = "state"];
inline bool QueryModuleStateResponse::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::injective::peggy::v1::GenesisState& QueryModuleStateResponse::_internal_state() const {
  const ::injective::peggy::v1::GenesisState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::peggy::v1::GenesisState&>(
      ::injective::peggy::v1::_GenesisState_default_instance_);
}
inline const ::injective::peggy::v1::GenesisState& QueryModuleStateResponse::state() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.QueryModuleStateResponse.state)
  return _internal_state();
}
inline void QueryModuleStateResponse::unsafe_arena_set_allocated_state(
    ::injective::peggy::v1::GenesisState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.peggy.v1.QueryModuleStateResponse.state)
}
inline ::injective::peggy::v1::GenesisState* QueryModuleStateResponse::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::GenesisState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::peggy::v1::GenesisState* QueryModuleStateResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.QueryModuleStateResponse.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::peggy::v1::GenesisState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::injective::peggy::v1::GenesisState* QueryModuleStateResponse::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::peggy::v1::GenesisState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::injective::peggy::v1::GenesisState* QueryModuleStateResponse::mutable_state() {
  ::injective::peggy::v1::GenesisState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.QueryModuleStateResponse.state)
  return _msg;
}
inline void QueryModuleStateResponse::set_allocated_state(::injective::peggy::v1::GenesisState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.QueryModuleStateResponse.state)
}

// -------------------------------------------------------------------

// MissingNoncesRequest

// -------------------------------------------------------------------

// MissingNoncesResponse

// repeated string operator_addresses = 1 [json_name = "operatorAddresses"];
inline int MissingNoncesResponse::_internal_operator_addresses_size() const {
  return _impl_.operator_addresses_.size();
}
inline int MissingNoncesResponse::operator_addresses_size() const {
  return _internal_operator_addresses_size();
}
inline void MissingNoncesResponse::clear_operator_addresses() {
  _internal_mutable_operator_addresses()->Clear();
}
inline std::string* MissingNoncesResponse::add_operator_addresses() {
  std::string* _s = _internal_add_operator_addresses();
  // @@protoc_insertion_point(field_add_mutable:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
  return _s;
}
inline const std::string& MissingNoncesResponse::operator_addresses(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
  return _internal_operator_addresses(index);
}
inline std::string* MissingNoncesResponse::mutable_operator_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
  return _internal_mutable_operator_addresses()->Mutable(index);
}
inline void MissingNoncesResponse::set_operator_addresses(int index, const std::string& value) {
  _internal_mutable_operator_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::set_operator_addresses(int index, std::string&& value) {
  _internal_mutable_operator_addresses()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::set_operator_addresses(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_operator_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::set_operator_addresses(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_operator_addresses()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::set_operator_addresses(int index, absl::string_view value) {
  _internal_mutable_operator_addresses()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::add_operator_addresses(const std::string& value) {
  _internal_mutable_operator_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::add_operator_addresses(std::string&& value) {
  _internal_mutable_operator_addresses()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::add_operator_addresses(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_operator_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::add_operator_addresses(const char* value, std::size_t size) {
  _internal_mutable_operator_addresses()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline void MissingNoncesResponse::add_operator_addresses(absl::string_view value) {
  _internal_mutable_operator_addresses()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MissingNoncesResponse::operator_addresses() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
  return _internal_operator_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MissingNoncesResponse::mutable_operator_addresses() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.MissingNoncesResponse.operator_addresses)
  return _internal_mutable_operator_addresses();
}
inline const std::string& MissingNoncesResponse::_internal_operator_addresses(int index) const {
  return _internal_operator_addresses().Get(index);
}
inline std::string* MissingNoncesResponse::_internal_add_operator_addresses() {
  return _internal_mutable_operator_addresses()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MissingNoncesResponse::_internal_operator_addresses() const {
  return _impl_.operator_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MissingNoncesResponse::_internal_mutable_operator_addresses() {
  return &_impl_.operator_addresses_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace peggy
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2fpeggy_2fv1_2fquery_2eproto_2epb_2eh
