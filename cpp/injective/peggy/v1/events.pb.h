// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/peggy/v1/events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2fpeggy_2fv1_2fevents_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2fpeggy_2fv1_2fevents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "injective/peggy/v1/attestation.pb.h"
#include "injective/peggy/v1/types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2fpeggy_2fv1_2fevents_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2fpeggy_2fv1_2fevents_2eproto;
namespace injective {
namespace peggy {
namespace v1 {
class EventAttestationObserved;
struct EventAttestationObservedDefaultTypeInternal;
extern EventAttestationObservedDefaultTypeInternal _EventAttestationObserved_default_instance_;
class EventAttestationVote;
struct EventAttestationVoteDefaultTypeInternal;
extern EventAttestationVoteDefaultTypeInternal _EventAttestationVote_default_instance_;
class EventBridgeWithdrawCanceled;
struct EventBridgeWithdrawCanceledDefaultTypeInternal;
extern EventBridgeWithdrawCanceledDefaultTypeInternal _EventBridgeWithdrawCanceled_default_instance_;
class EventCancelSendToEth;
struct EventCancelSendToEthDefaultTypeInternal;
extern EventCancelSendToEthDefaultTypeInternal _EventCancelSendToEth_default_instance_;
class EventConfirmBatch;
struct EventConfirmBatchDefaultTypeInternal;
extern EventConfirmBatchDefaultTypeInternal _EventConfirmBatch_default_instance_;
class EventDepositClaim;
struct EventDepositClaimDefaultTypeInternal;
extern EventDepositClaimDefaultTypeInternal _EventDepositClaim_default_instance_;
class EventERC20DeployedClaim;
struct EventERC20DeployedClaimDefaultTypeInternal;
extern EventERC20DeployedClaimDefaultTypeInternal _EventERC20DeployedClaim_default_instance_;
class EventOutgoingBatch;
struct EventOutgoingBatchDefaultTypeInternal;
extern EventOutgoingBatchDefaultTypeInternal _EventOutgoingBatch_default_instance_;
class EventOutgoingBatchCanceled;
struct EventOutgoingBatchCanceledDefaultTypeInternal;
extern EventOutgoingBatchCanceledDefaultTypeInternal _EventOutgoingBatchCanceled_default_instance_;
class EventSendToEth;
struct EventSendToEthDefaultTypeInternal;
extern EventSendToEthDefaultTypeInternal _EventSendToEth_default_instance_;
class EventSetOrchestratorAddresses;
struct EventSetOrchestratorAddressesDefaultTypeInternal;
extern EventSetOrchestratorAddressesDefaultTypeInternal _EventSetOrchestratorAddresses_default_instance_;
class EventSubmitBadSignatureEvidence;
struct EventSubmitBadSignatureEvidenceDefaultTypeInternal;
extern EventSubmitBadSignatureEvidenceDefaultTypeInternal _EventSubmitBadSignatureEvidence_default_instance_;
class EventValidatorSlash;
struct EventValidatorSlashDefaultTypeInternal;
extern EventValidatorSlashDefaultTypeInternal _EventValidatorSlash_default_instance_;
class EventValsetConfirm;
struct EventValsetConfirmDefaultTypeInternal;
extern EventValsetConfirmDefaultTypeInternal _EventValsetConfirm_default_instance_;
class EventValsetUpdateClaim;
struct EventValsetUpdateClaimDefaultTypeInternal;
extern EventValsetUpdateClaimDefaultTypeInternal _EventValsetUpdateClaim_default_instance_;
class EventValsetUpdateRequest;
struct EventValsetUpdateRequestDefaultTypeInternal;
extern EventValsetUpdateRequestDefaultTypeInternal _EventValsetUpdateRequest_default_instance_;
class EventWithdrawClaim;
struct EventWithdrawClaimDefaultTypeInternal;
extern EventWithdrawClaimDefaultTypeInternal _EventWithdrawClaim_default_instance_;
}  // namespace v1
}  // namespace peggy
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::peggy::v1::EventAttestationObserved* Arena::CreateMaybeMessage<::injective::peggy::v1::EventAttestationObserved>(Arena*);
template <>
::injective::peggy::v1::EventAttestationVote* Arena::CreateMaybeMessage<::injective::peggy::v1::EventAttestationVote>(Arena*);
template <>
::injective::peggy::v1::EventBridgeWithdrawCanceled* Arena::CreateMaybeMessage<::injective::peggy::v1::EventBridgeWithdrawCanceled>(Arena*);
template <>
::injective::peggy::v1::EventCancelSendToEth* Arena::CreateMaybeMessage<::injective::peggy::v1::EventCancelSendToEth>(Arena*);
template <>
::injective::peggy::v1::EventConfirmBatch* Arena::CreateMaybeMessage<::injective::peggy::v1::EventConfirmBatch>(Arena*);
template <>
::injective::peggy::v1::EventDepositClaim* Arena::CreateMaybeMessage<::injective::peggy::v1::EventDepositClaim>(Arena*);
template <>
::injective::peggy::v1::EventERC20DeployedClaim* Arena::CreateMaybeMessage<::injective::peggy::v1::EventERC20DeployedClaim>(Arena*);
template <>
::injective::peggy::v1::EventOutgoingBatch* Arena::CreateMaybeMessage<::injective::peggy::v1::EventOutgoingBatch>(Arena*);
template <>
::injective::peggy::v1::EventOutgoingBatchCanceled* Arena::CreateMaybeMessage<::injective::peggy::v1::EventOutgoingBatchCanceled>(Arena*);
template <>
::injective::peggy::v1::EventSendToEth* Arena::CreateMaybeMessage<::injective::peggy::v1::EventSendToEth>(Arena*);
template <>
::injective::peggy::v1::EventSetOrchestratorAddresses* Arena::CreateMaybeMessage<::injective::peggy::v1::EventSetOrchestratorAddresses>(Arena*);
template <>
::injective::peggy::v1::EventSubmitBadSignatureEvidence* Arena::CreateMaybeMessage<::injective::peggy::v1::EventSubmitBadSignatureEvidence>(Arena*);
template <>
::injective::peggy::v1::EventValidatorSlash* Arena::CreateMaybeMessage<::injective::peggy::v1::EventValidatorSlash>(Arena*);
template <>
::injective::peggy::v1::EventValsetConfirm* Arena::CreateMaybeMessage<::injective::peggy::v1::EventValsetConfirm>(Arena*);
template <>
::injective::peggy::v1::EventValsetUpdateClaim* Arena::CreateMaybeMessage<::injective::peggy::v1::EventValsetUpdateClaim>(Arena*);
template <>
::injective::peggy::v1::EventValsetUpdateRequest* Arena::CreateMaybeMessage<::injective::peggy::v1::EventValsetUpdateRequest>(Arena*);
template <>
::injective::peggy::v1::EventWithdrawClaim* Arena::CreateMaybeMessage<::injective::peggy::v1::EventWithdrawClaim>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace peggy {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class EventAttestationObserved final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventAttestationObserved) */ {
 public:
  inline EventAttestationObserved() : EventAttestationObserved(nullptr) {}
  ~EventAttestationObserved() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventAttestationObserved(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAttestationObserved(const EventAttestationObserved& from);
  EventAttestationObserved(EventAttestationObserved&& from) noexcept
    : EventAttestationObserved() {
    *this = ::std::move(from);
  }

  inline EventAttestationObserved& operator=(const EventAttestationObserved& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAttestationObserved& operator=(EventAttestationObserved&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAttestationObserved& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAttestationObserved* internal_default_instance() {
    return reinterpret_cast<const EventAttestationObserved*>(
               &_EventAttestationObserved_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EventAttestationObserved& a, EventAttestationObserved& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAttestationObserved* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAttestationObserved* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAttestationObserved* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAttestationObserved>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAttestationObserved& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventAttestationObserved& from) {
    EventAttestationObserved::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAttestationObserved* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventAttestationObserved";
  }
  protected:
  explicit EventAttestationObserved(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBridgeContractFieldNumber = 2,
    kAttestationIdFieldNumber = 4,
    kBridgeChainIdFieldNumber = 3,
    kNonceFieldNumber = 5,
    kAttestationTypeFieldNumber = 1,
  };
  // string bridge_contract = 2 [json_name = "bridgeContract"];
  void clear_bridge_contract() ;
  const std::string& bridge_contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bridge_contract(Arg_&& arg, Args_... args);
  std::string* mutable_bridge_contract();
  PROTOBUF_NODISCARD std::string* release_bridge_contract();
  void set_allocated_bridge_contract(std::string* ptr);

  private:
  const std::string& _internal_bridge_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bridge_contract(
      const std::string& value);
  std::string* _internal_mutable_bridge_contract();

  public:
  // bytes attestation_id = 4 [json_name = "attestationId"];
  void clear_attestation_id() ;
  const std::string& attestation_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attestation_id(Arg_&& arg, Args_... args);
  std::string* mutable_attestation_id();
  PROTOBUF_NODISCARD std::string* release_attestation_id();
  void set_allocated_attestation_id(std::string* ptr);

  private:
  const std::string& _internal_attestation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attestation_id(
      const std::string& value);
  std::string* _internal_mutable_attestation_id();

  public:
  // uint64 bridge_chain_id = 3 [json_name = "bridgeChainId"];
  void clear_bridge_chain_id() ;
  ::uint64_t bridge_chain_id() const;
  void set_bridge_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_bridge_chain_id() const;
  void _internal_set_bridge_chain_id(::uint64_t value);

  public:
  // uint64 nonce = 5 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // .injective.peggy.v1.ClaimType attestation_type = 1 [json_name = "attestationType"];
  void clear_attestation_type() ;
  ::injective::peggy::v1::ClaimType attestation_type() const;
  void set_attestation_type(::injective::peggy::v1::ClaimType value);

  private:
  ::injective::peggy::v1::ClaimType _internal_attestation_type() const;
  void _internal_set_attestation_type(::injective::peggy::v1::ClaimType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventAttestationObserved)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bridge_contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attestation_id_;
    ::uint64_t bridge_chain_id_;
    ::uint64_t nonce_;
    int attestation_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventBridgeWithdrawCanceled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventBridgeWithdrawCanceled) */ {
 public:
  inline EventBridgeWithdrawCanceled() : EventBridgeWithdrawCanceled(nullptr) {}
  ~EventBridgeWithdrawCanceled() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventBridgeWithdrawCanceled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventBridgeWithdrawCanceled(const EventBridgeWithdrawCanceled& from);
  EventBridgeWithdrawCanceled(EventBridgeWithdrawCanceled&& from) noexcept
    : EventBridgeWithdrawCanceled() {
    *this = ::std::move(from);
  }

  inline EventBridgeWithdrawCanceled& operator=(const EventBridgeWithdrawCanceled& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventBridgeWithdrawCanceled& operator=(EventBridgeWithdrawCanceled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventBridgeWithdrawCanceled& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventBridgeWithdrawCanceled* internal_default_instance() {
    return reinterpret_cast<const EventBridgeWithdrawCanceled*>(
               &_EventBridgeWithdrawCanceled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EventBridgeWithdrawCanceled& a, EventBridgeWithdrawCanceled& b) {
    a.Swap(&b);
  }
  inline void Swap(EventBridgeWithdrawCanceled* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventBridgeWithdrawCanceled* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventBridgeWithdrawCanceled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventBridgeWithdrawCanceled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventBridgeWithdrawCanceled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventBridgeWithdrawCanceled& from) {
    EventBridgeWithdrawCanceled::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBridgeWithdrawCanceled* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventBridgeWithdrawCanceled";
  }
  protected:
  explicit EventBridgeWithdrawCanceled(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBridgeContractFieldNumber = 1,
    kBridgeChainIdFieldNumber = 2,
  };
  // string bridge_contract = 1 [json_name = "bridgeContract"];
  void clear_bridge_contract() ;
  const std::string& bridge_contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bridge_contract(Arg_&& arg, Args_... args);
  std::string* mutable_bridge_contract();
  PROTOBUF_NODISCARD std::string* release_bridge_contract();
  void set_allocated_bridge_contract(std::string* ptr);

  private:
  const std::string& _internal_bridge_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bridge_contract(
      const std::string& value);
  std::string* _internal_mutable_bridge_contract();

  public:
  // uint64 bridge_chain_id = 2 [json_name = "bridgeChainId"];
  void clear_bridge_chain_id() ;
  ::uint64_t bridge_chain_id() const;
  void set_bridge_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_bridge_chain_id() const;
  void _internal_set_bridge_chain_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventBridgeWithdrawCanceled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bridge_contract_;
    ::uint64_t bridge_chain_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventOutgoingBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventOutgoingBatch) */ {
 public:
  inline EventOutgoingBatch() : EventOutgoingBatch(nullptr) {}
  ~EventOutgoingBatch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventOutgoingBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventOutgoingBatch(const EventOutgoingBatch& from);
  EventOutgoingBatch(EventOutgoingBatch&& from) noexcept
    : EventOutgoingBatch() {
    *this = ::std::move(from);
  }

  inline EventOutgoingBatch& operator=(const EventOutgoingBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventOutgoingBatch& operator=(EventOutgoingBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventOutgoingBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventOutgoingBatch* internal_default_instance() {
    return reinterpret_cast<const EventOutgoingBatch*>(
               &_EventOutgoingBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EventOutgoingBatch& a, EventOutgoingBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(EventOutgoingBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventOutgoingBatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventOutgoingBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventOutgoingBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventOutgoingBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventOutgoingBatch& from) {
    EventOutgoingBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventOutgoingBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventOutgoingBatch";
  }
  protected:
  explicit EventOutgoingBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchTxIdsFieldNumber = 5,
    kDenomFieldNumber = 1,
    kOrchestratorAddressFieldNumber = 2,
    kBatchNonceFieldNumber = 3,
    kBatchTimeoutFieldNumber = 4,
  };
  // repeated uint64 batch_tx_ids = 5 [json_name = "batchTxIds"];
  int batch_tx_ids_size() const;
  private:
  int _internal_batch_tx_ids_size() const;

  public:
  void clear_batch_tx_ids() ;
  ::uint64_t batch_tx_ids(int index) const;
  void set_batch_tx_ids(int index, ::uint64_t value);
  void add_batch_tx_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& batch_tx_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_batch_tx_ids();

  private:
  ::uint64_t _internal_batch_tx_ids(int index) const;
  void _internal_add_batch_tx_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_batch_tx_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_batch_tx_ids();

  public:
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string orchestrator_address = 2 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // uint64 batch_nonce = 3 [json_name = "batchNonce"];
  void clear_batch_nonce() ;
  ::uint64_t batch_nonce() const;
  void set_batch_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_batch_nonce() const;
  void _internal_set_batch_nonce(::uint64_t value);

  public:
  // uint64 batch_timeout = 4 [json_name = "batchTimeout"];
  void clear_batch_timeout() ;
  ::uint64_t batch_timeout() const;
  void set_batch_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_batch_timeout() const;
  void _internal_set_batch_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventOutgoingBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> batch_tx_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _batch_tx_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::uint64_t batch_nonce_;
    ::uint64_t batch_timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventOutgoingBatchCanceled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventOutgoingBatchCanceled) */ {
 public:
  inline EventOutgoingBatchCanceled() : EventOutgoingBatchCanceled(nullptr) {}
  ~EventOutgoingBatchCanceled() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventOutgoingBatchCanceled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventOutgoingBatchCanceled(const EventOutgoingBatchCanceled& from);
  EventOutgoingBatchCanceled(EventOutgoingBatchCanceled&& from) noexcept
    : EventOutgoingBatchCanceled() {
    *this = ::std::move(from);
  }

  inline EventOutgoingBatchCanceled& operator=(const EventOutgoingBatchCanceled& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventOutgoingBatchCanceled& operator=(EventOutgoingBatchCanceled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventOutgoingBatchCanceled& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventOutgoingBatchCanceled* internal_default_instance() {
    return reinterpret_cast<const EventOutgoingBatchCanceled*>(
               &_EventOutgoingBatchCanceled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EventOutgoingBatchCanceled& a, EventOutgoingBatchCanceled& b) {
    a.Swap(&b);
  }
  inline void Swap(EventOutgoingBatchCanceled* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventOutgoingBatchCanceled* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventOutgoingBatchCanceled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventOutgoingBatchCanceled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventOutgoingBatchCanceled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventOutgoingBatchCanceled& from) {
    EventOutgoingBatchCanceled::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventOutgoingBatchCanceled* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventOutgoingBatchCanceled";
  }
  protected:
  explicit EventOutgoingBatchCanceled(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBridgeContractFieldNumber = 1,
    kBridgeChainIdFieldNumber = 2,
    kBatchIdFieldNumber = 3,
    kNonceFieldNumber = 4,
  };
  // string bridge_contract = 1 [json_name = "bridgeContract"];
  void clear_bridge_contract() ;
  const std::string& bridge_contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bridge_contract(Arg_&& arg, Args_... args);
  std::string* mutable_bridge_contract();
  PROTOBUF_NODISCARD std::string* release_bridge_contract();
  void set_allocated_bridge_contract(std::string* ptr);

  private:
  const std::string& _internal_bridge_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bridge_contract(
      const std::string& value);
  std::string* _internal_mutable_bridge_contract();

  public:
  // uint64 bridge_chain_id = 2 [json_name = "bridgeChainId"];
  void clear_bridge_chain_id() ;
  ::uint64_t bridge_chain_id() const;
  void set_bridge_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_bridge_chain_id() const;
  void _internal_set_bridge_chain_id(::uint64_t value);

  public:
  // uint64 batch_id = 3 [json_name = "batchId"];
  void clear_batch_id() ;
  ::uint64_t batch_id() const;
  void set_batch_id(::uint64_t value);

  private:
  ::uint64_t _internal_batch_id() const;
  void _internal_set_batch_id(::uint64_t value);

  public:
  // uint64 nonce = 4 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventOutgoingBatchCanceled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bridge_contract_;
    ::uint64_t bridge_chain_id_;
    ::uint64_t batch_id_;
    ::uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventValsetUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventValsetUpdateRequest) */ {
 public:
  inline EventValsetUpdateRequest() : EventValsetUpdateRequest(nullptr) {}
  ~EventValsetUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventValsetUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventValsetUpdateRequest(const EventValsetUpdateRequest& from);
  EventValsetUpdateRequest(EventValsetUpdateRequest&& from) noexcept
    : EventValsetUpdateRequest() {
    *this = ::std::move(from);
  }

  inline EventValsetUpdateRequest& operator=(const EventValsetUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventValsetUpdateRequest& operator=(EventValsetUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventValsetUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventValsetUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const EventValsetUpdateRequest*>(
               &_EventValsetUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EventValsetUpdateRequest& a, EventValsetUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EventValsetUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventValsetUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventValsetUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventValsetUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventValsetUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventValsetUpdateRequest& from) {
    EventValsetUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventValsetUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventValsetUpdateRequest";
  }
  protected:
  explicit EventValsetUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsetMembersFieldNumber = 3,
    kRewardAmountFieldNumber = 4,
    kRewardTokenFieldNumber = 5,
    kValsetNonceFieldNumber = 1,
    kValsetHeightFieldNumber = 2,
  };
  // repeated .injective.peggy.v1.BridgeValidator valset_members = 3 [json_name = "valsetMembers"];
  int valset_members_size() const;
  private:
  int _internal_valset_members_size() const;

  public:
  void clear_valset_members() ;
  ::injective::peggy::v1::BridgeValidator* mutable_valset_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >*
      mutable_valset_members();
  private:
  const ::injective::peggy::v1::BridgeValidator& _internal_valset_members(int index) const;
  ::injective::peggy::v1::BridgeValidator* _internal_add_valset_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>& _internal_valset_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>* _internal_mutable_valset_members();
  public:
  const ::injective::peggy::v1::BridgeValidator& valset_members(int index) const;
  ::injective::peggy::v1::BridgeValidator* add_valset_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >&
      valset_members() const;
  // string reward_amount = 4 [json_name = "rewardAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_reward_amount() ;
  const std::string& reward_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reward_amount(Arg_&& arg, Args_... args);
  std::string* mutable_reward_amount();
  PROTOBUF_NODISCARD std::string* release_reward_amount();
  void set_allocated_reward_amount(std::string* ptr);

  private:
  const std::string& _internal_reward_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_amount(
      const std::string& value);
  std::string* _internal_mutable_reward_amount();

  public:
  // string reward_token = 5 [json_name = "rewardToken"];
  void clear_reward_token() ;
  const std::string& reward_token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reward_token(Arg_&& arg, Args_... args);
  std::string* mutable_reward_token();
  PROTOBUF_NODISCARD std::string* release_reward_token();
  void set_allocated_reward_token(std::string* ptr);

  private:
  const std::string& _internal_reward_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_token(
      const std::string& value);
  std::string* _internal_mutable_reward_token();

  public:
  // uint64 valset_nonce = 1 [json_name = "valsetNonce"];
  void clear_valset_nonce() ;
  ::uint64_t valset_nonce() const;
  void set_valset_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_valset_nonce() const;
  void _internal_set_valset_nonce(::uint64_t value);

  public:
  // uint64 valset_height = 2 [json_name = "valsetHeight"];
  void clear_valset_height() ;
  ::uint64_t valset_height() const;
  void set_valset_height(::uint64_t value);

  private:
  ::uint64_t _internal_valset_height() const;
  void _internal_set_valset_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventValsetUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator > valset_members_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_token_;
    ::uint64_t valset_nonce_;
    ::uint64_t valset_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventSetOrchestratorAddresses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventSetOrchestratorAddresses) */ {
 public:
  inline EventSetOrchestratorAddresses() : EventSetOrchestratorAddresses(nullptr) {}
  ~EventSetOrchestratorAddresses() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventSetOrchestratorAddresses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSetOrchestratorAddresses(const EventSetOrchestratorAddresses& from);
  EventSetOrchestratorAddresses(EventSetOrchestratorAddresses&& from) noexcept
    : EventSetOrchestratorAddresses() {
    *this = ::std::move(from);
  }

  inline EventSetOrchestratorAddresses& operator=(const EventSetOrchestratorAddresses& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSetOrchestratorAddresses& operator=(EventSetOrchestratorAddresses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSetOrchestratorAddresses& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSetOrchestratorAddresses* internal_default_instance() {
    return reinterpret_cast<const EventSetOrchestratorAddresses*>(
               &_EventSetOrchestratorAddresses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EventSetOrchestratorAddresses& a, EventSetOrchestratorAddresses& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSetOrchestratorAddresses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSetOrchestratorAddresses* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSetOrchestratorAddresses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSetOrchestratorAddresses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSetOrchestratorAddresses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSetOrchestratorAddresses& from) {
    EventSetOrchestratorAddresses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSetOrchestratorAddresses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventSetOrchestratorAddresses";
  }
  protected:
  explicit EventSetOrchestratorAddresses(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorAddressFieldNumber = 1,
    kOrchestratorAddressFieldNumber = 2,
    kOperatorEthAddressFieldNumber = 3,
  };
  // string validator_address = 1 [json_name = "validatorAddress"];
  void clear_validator_address() ;
  const std::string& validator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* ptr);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // string orchestrator_address = 2 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // string operator_eth_address = 3 [json_name = "operatorEthAddress"];
  void clear_operator_eth_address() ;
  const std::string& operator_eth_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_eth_address(Arg_&& arg, Args_... args);
  std::string* mutable_operator_eth_address();
  PROTOBUF_NODISCARD std::string* release_operator_eth_address();
  void set_allocated_operator_eth_address(std::string* ptr);

  private:
  const std::string& _internal_operator_eth_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_eth_address(
      const std::string& value);
  std::string* _internal_mutable_operator_eth_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventSetOrchestratorAddresses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_eth_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventValsetConfirm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventValsetConfirm) */ {
 public:
  inline EventValsetConfirm() : EventValsetConfirm(nullptr) {}
  ~EventValsetConfirm() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventValsetConfirm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventValsetConfirm(const EventValsetConfirm& from);
  EventValsetConfirm(EventValsetConfirm&& from) noexcept
    : EventValsetConfirm() {
    *this = ::std::move(from);
  }

  inline EventValsetConfirm& operator=(const EventValsetConfirm& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventValsetConfirm& operator=(EventValsetConfirm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventValsetConfirm& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventValsetConfirm* internal_default_instance() {
    return reinterpret_cast<const EventValsetConfirm*>(
               &_EventValsetConfirm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EventValsetConfirm& a, EventValsetConfirm& b) {
    a.Swap(&b);
  }
  inline void Swap(EventValsetConfirm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventValsetConfirm* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventValsetConfirm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventValsetConfirm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventValsetConfirm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventValsetConfirm& from) {
    EventValsetConfirm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventValsetConfirm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventValsetConfirm";
  }
  protected:
  explicit EventValsetConfirm(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrchestratorAddressFieldNumber = 2,
    kValsetNonceFieldNumber = 1,
  };
  // string orchestrator_address = 2 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // uint64 valset_nonce = 1 [json_name = "valsetNonce"];
  void clear_valset_nonce() ;
  ::uint64_t valset_nonce() const;
  void set_valset_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_valset_nonce() const;
  void _internal_set_valset_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventValsetConfirm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::uint64_t valset_nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventSendToEth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventSendToEth) */ {
 public:
  inline EventSendToEth() : EventSendToEth(nullptr) {}
  ~EventSendToEth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventSendToEth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSendToEth(const EventSendToEth& from);
  EventSendToEth(EventSendToEth&& from) noexcept
    : EventSendToEth() {
    *this = ::std::move(from);
  }

  inline EventSendToEth& operator=(const EventSendToEth& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSendToEth& operator=(EventSendToEth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSendToEth& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSendToEth* internal_default_instance() {
    return reinterpret_cast<const EventSendToEth*>(
               &_EventSendToEth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EventSendToEth& a, EventSendToEth& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSendToEth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSendToEth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSendToEth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSendToEth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSendToEth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSendToEth& from) {
    EventSendToEth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSendToEth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventSendToEth";
  }
  protected:
  explicit EventSendToEth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 2,
    kReceiverFieldNumber = 3,
    kAmountFieldNumber = 4,
    kBridgeFeeFieldNumber = 5,
    kOutgoingTxIdFieldNumber = 1,
  };
  // string sender = 2 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string receiver = 3 [json_name = "receiver"];
  void clear_receiver() ;
  const std::string& receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* ptr);

  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(
      const std::string& value);
  std::string* _internal_mutable_receiver();

  public:
  // string amount = 4 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Coin"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // string bridge_fee = 5 [json_name = "bridgeFee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Coin"];
  void clear_bridge_fee() ;
  const std::string& bridge_fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bridge_fee(Arg_&& arg, Args_... args);
  std::string* mutable_bridge_fee();
  PROTOBUF_NODISCARD std::string* release_bridge_fee();
  void set_allocated_bridge_fee(std::string* ptr);

  private:
  const std::string& _internal_bridge_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bridge_fee(
      const std::string& value);
  std::string* _internal_mutable_bridge_fee();

  public:
  // uint64 outgoing_tx_id = 1 [json_name = "outgoingTxId"];
  void clear_outgoing_tx_id() ;
  ::uint64_t outgoing_tx_id() const;
  void set_outgoing_tx_id(::uint64_t value);

  private:
  ::uint64_t _internal_outgoing_tx_id() const;
  void _internal_set_outgoing_tx_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventSendToEth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bridge_fee_;
    ::uint64_t outgoing_tx_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventConfirmBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventConfirmBatch) */ {
 public:
  inline EventConfirmBatch() : EventConfirmBatch(nullptr) {}
  ~EventConfirmBatch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventConfirmBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventConfirmBatch(const EventConfirmBatch& from);
  EventConfirmBatch(EventConfirmBatch&& from) noexcept
    : EventConfirmBatch() {
    *this = ::std::move(from);
  }

  inline EventConfirmBatch& operator=(const EventConfirmBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventConfirmBatch& operator=(EventConfirmBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventConfirmBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventConfirmBatch* internal_default_instance() {
    return reinterpret_cast<const EventConfirmBatch*>(
               &_EventConfirmBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EventConfirmBatch& a, EventConfirmBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(EventConfirmBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventConfirmBatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventConfirmBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventConfirmBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventConfirmBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventConfirmBatch& from) {
    EventConfirmBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventConfirmBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventConfirmBatch";
  }
  protected:
  explicit EventConfirmBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrchestratorAddressFieldNumber = 2,
    kBatchNonceFieldNumber = 1,
  };
  // string orchestrator_address = 2 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // uint64 batch_nonce = 1 [json_name = "batchNonce"];
  void clear_batch_nonce() ;
  ::uint64_t batch_nonce() const;
  void set_batch_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_batch_nonce() const;
  void _internal_set_batch_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventConfirmBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::uint64_t batch_nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventAttestationVote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventAttestationVote) */ {
 public:
  inline EventAttestationVote() : EventAttestationVote(nullptr) {}
  ~EventAttestationVote() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventAttestationVote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAttestationVote(const EventAttestationVote& from);
  EventAttestationVote(EventAttestationVote&& from) noexcept
    : EventAttestationVote() {
    *this = ::std::move(from);
  }

  inline EventAttestationVote& operator=(const EventAttestationVote& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAttestationVote& operator=(EventAttestationVote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAttestationVote& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAttestationVote* internal_default_instance() {
    return reinterpret_cast<const EventAttestationVote*>(
               &_EventAttestationVote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EventAttestationVote& a, EventAttestationVote& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAttestationVote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAttestationVote* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAttestationVote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAttestationVote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAttestationVote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventAttestationVote& from) {
    EventAttestationVote::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAttestationVote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventAttestationVote";
  }
  protected:
  explicit EventAttestationVote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttestationIdFieldNumber = 2,
    kVoterFieldNumber = 3,
    kEventNonceFieldNumber = 1,
  };
  // bytes attestation_id = 2 [json_name = "attestationId"];
  void clear_attestation_id() ;
  const std::string& attestation_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attestation_id(Arg_&& arg, Args_... args);
  std::string* mutable_attestation_id();
  PROTOBUF_NODISCARD std::string* release_attestation_id();
  void set_allocated_attestation_id(std::string* ptr);

  private:
  const std::string& _internal_attestation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attestation_id(
      const std::string& value);
  std::string* _internal_mutable_attestation_id();

  public:
  // string voter = 3 [json_name = "voter"];
  void clear_voter() ;
  const std::string& voter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_voter(Arg_&& arg, Args_... args);
  std::string* mutable_voter();
  PROTOBUF_NODISCARD std::string* release_voter();
  void set_allocated_voter(std::string* ptr);

  private:
  const std::string& _internal_voter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voter(
      const std::string& value);
  std::string* _internal_mutable_voter();

  public:
  // uint64 event_nonce = 1 [json_name = "eventNonce"];
  void clear_event_nonce() ;
  ::uint64_t event_nonce() const;
  void set_event_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_event_nonce() const;
  void _internal_set_event_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventAttestationVote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attestation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voter_;
    ::uint64_t event_nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventDepositClaim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventDepositClaim) */ {
 public:
  inline EventDepositClaim() : EventDepositClaim(nullptr) {}
  ~EventDepositClaim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventDepositClaim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventDepositClaim(const EventDepositClaim& from);
  EventDepositClaim(EventDepositClaim&& from) noexcept
    : EventDepositClaim() {
    *this = ::std::move(from);
  }

  inline EventDepositClaim& operator=(const EventDepositClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventDepositClaim& operator=(EventDepositClaim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventDepositClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventDepositClaim* internal_default_instance() {
    return reinterpret_cast<const EventDepositClaim*>(
               &_EventDepositClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EventDepositClaim& a, EventDepositClaim& b) {
    a.Swap(&b);
  }
  inline void Swap(EventDepositClaim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventDepositClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventDepositClaim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventDepositClaim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventDepositClaim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventDepositClaim& from) {
    EventDepositClaim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventDepositClaim* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventDepositClaim";
  }
  protected:
  explicit EventDepositClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttestationIdFieldNumber = 3,
    kEthereumSenderFieldNumber = 4,
    kCosmosReceiverFieldNumber = 5,
    kTokenContractFieldNumber = 6,
    kAmountFieldNumber = 7,
    kOrchestratorAddressFieldNumber = 8,
    kDataFieldNumber = 9,
    kEventNonceFieldNumber = 1,
    kEventHeightFieldNumber = 2,
  };
  // bytes attestation_id = 3 [json_name = "attestationId"];
  void clear_attestation_id() ;
  const std::string& attestation_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attestation_id(Arg_&& arg, Args_... args);
  std::string* mutable_attestation_id();
  PROTOBUF_NODISCARD std::string* release_attestation_id();
  void set_allocated_attestation_id(std::string* ptr);

  private:
  const std::string& _internal_attestation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attestation_id(
      const std::string& value);
  std::string* _internal_mutable_attestation_id();

  public:
  // string ethereum_sender = 4 [json_name = "ethereumSender"];
  void clear_ethereum_sender() ;
  const std::string& ethereum_sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ethereum_sender(Arg_&& arg, Args_... args);
  std::string* mutable_ethereum_sender();
  PROTOBUF_NODISCARD std::string* release_ethereum_sender();
  void set_allocated_ethereum_sender(std::string* ptr);

  private:
  const std::string& _internal_ethereum_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ethereum_sender(
      const std::string& value);
  std::string* _internal_mutable_ethereum_sender();

  public:
  // string cosmos_receiver = 5 [json_name = "cosmosReceiver"];
  void clear_cosmos_receiver() ;
  const std::string& cosmos_receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cosmos_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_cosmos_receiver();
  PROTOBUF_NODISCARD std::string* release_cosmos_receiver();
  void set_allocated_cosmos_receiver(std::string* ptr);

  private:
  const std::string& _internal_cosmos_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cosmos_receiver(
      const std::string& value);
  std::string* _internal_mutable_cosmos_receiver();

  public:
  // string token_contract = 6 [json_name = "tokenContract"];
  void clear_token_contract() ;
  const std::string& token_contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token_contract(Arg_&& arg, Args_... args);
  std::string* mutable_token_contract();
  PROTOBUF_NODISCARD std::string* release_token_contract();
  void set_allocated_token_contract(std::string* ptr);

  private:
  const std::string& _internal_token_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_contract(
      const std::string& value);
  std::string* _internal_mutable_token_contract();

  public:
  // string amount = 7 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // string orchestrator_address = 8 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // string data = 9 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // uint64 event_nonce = 1 [json_name = "eventNonce"];
  void clear_event_nonce() ;
  ::uint64_t event_nonce() const;
  void set_event_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_event_nonce() const;
  void _internal_set_event_nonce(::uint64_t value);

  public:
  // uint64 event_height = 2 [json_name = "eventHeight"];
  void clear_event_height() ;
  ::uint64_t event_height() const;
  void set_event_height(::uint64_t value);

  private:
  ::uint64_t _internal_event_height() const;
  void _internal_set_event_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventDepositClaim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attestation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ethereum_sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cosmos_receiver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::uint64_t event_nonce_;
    ::uint64_t event_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventWithdrawClaim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventWithdrawClaim) */ {
 public:
  inline EventWithdrawClaim() : EventWithdrawClaim(nullptr) {}
  ~EventWithdrawClaim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventWithdrawClaim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventWithdrawClaim(const EventWithdrawClaim& from);
  EventWithdrawClaim(EventWithdrawClaim&& from) noexcept
    : EventWithdrawClaim() {
    *this = ::std::move(from);
  }

  inline EventWithdrawClaim& operator=(const EventWithdrawClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventWithdrawClaim& operator=(EventWithdrawClaim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventWithdrawClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventWithdrawClaim* internal_default_instance() {
    return reinterpret_cast<const EventWithdrawClaim*>(
               &_EventWithdrawClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EventWithdrawClaim& a, EventWithdrawClaim& b) {
    a.Swap(&b);
  }
  inline void Swap(EventWithdrawClaim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventWithdrawClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventWithdrawClaim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventWithdrawClaim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventWithdrawClaim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventWithdrawClaim& from) {
    EventWithdrawClaim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventWithdrawClaim* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventWithdrawClaim";
  }
  protected:
  explicit EventWithdrawClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttestationIdFieldNumber = 3,
    kTokenContractFieldNumber = 5,
    kOrchestratorAddressFieldNumber = 6,
    kEventNonceFieldNumber = 1,
    kEventHeightFieldNumber = 2,
    kBatchNonceFieldNumber = 4,
  };
  // bytes attestation_id = 3 [json_name = "attestationId"];
  void clear_attestation_id() ;
  const std::string& attestation_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attestation_id(Arg_&& arg, Args_... args);
  std::string* mutable_attestation_id();
  PROTOBUF_NODISCARD std::string* release_attestation_id();
  void set_allocated_attestation_id(std::string* ptr);

  private:
  const std::string& _internal_attestation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attestation_id(
      const std::string& value);
  std::string* _internal_mutable_attestation_id();

  public:
  // string token_contract = 5 [json_name = "tokenContract"];
  void clear_token_contract() ;
  const std::string& token_contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token_contract(Arg_&& arg, Args_... args);
  std::string* mutable_token_contract();
  PROTOBUF_NODISCARD std::string* release_token_contract();
  void set_allocated_token_contract(std::string* ptr);

  private:
  const std::string& _internal_token_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_contract(
      const std::string& value);
  std::string* _internal_mutable_token_contract();

  public:
  // string orchestrator_address = 6 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // uint64 event_nonce = 1 [json_name = "eventNonce"];
  void clear_event_nonce() ;
  ::uint64_t event_nonce() const;
  void set_event_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_event_nonce() const;
  void _internal_set_event_nonce(::uint64_t value);

  public:
  // uint64 event_height = 2 [json_name = "eventHeight"];
  void clear_event_height() ;
  ::uint64_t event_height() const;
  void set_event_height(::uint64_t value);

  private:
  ::uint64_t _internal_event_height() const;
  void _internal_set_event_height(::uint64_t value);

  public:
  // uint64 batch_nonce = 4 [json_name = "batchNonce"];
  void clear_batch_nonce() ;
  ::uint64_t batch_nonce() const;
  void set_batch_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_batch_nonce() const;
  void _internal_set_batch_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventWithdrawClaim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attestation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::uint64_t event_nonce_;
    ::uint64_t event_height_;
    ::uint64_t batch_nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventERC20DeployedClaim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventERC20DeployedClaim) */ {
 public:
  inline EventERC20DeployedClaim() : EventERC20DeployedClaim(nullptr) {}
  ~EventERC20DeployedClaim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventERC20DeployedClaim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventERC20DeployedClaim(const EventERC20DeployedClaim& from);
  EventERC20DeployedClaim(EventERC20DeployedClaim&& from) noexcept
    : EventERC20DeployedClaim() {
    *this = ::std::move(from);
  }

  inline EventERC20DeployedClaim& operator=(const EventERC20DeployedClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventERC20DeployedClaim& operator=(EventERC20DeployedClaim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventERC20DeployedClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventERC20DeployedClaim* internal_default_instance() {
    return reinterpret_cast<const EventERC20DeployedClaim*>(
               &_EventERC20DeployedClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EventERC20DeployedClaim& a, EventERC20DeployedClaim& b) {
    a.Swap(&b);
  }
  inline void Swap(EventERC20DeployedClaim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventERC20DeployedClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventERC20DeployedClaim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventERC20DeployedClaim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventERC20DeployedClaim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventERC20DeployedClaim& from) {
    EventERC20DeployedClaim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventERC20DeployedClaim* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventERC20DeployedClaim";
  }
  protected:
  explicit EventERC20DeployedClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttestationIdFieldNumber = 3,
    kCosmosDenomFieldNumber = 4,
    kTokenContractFieldNumber = 5,
    kNameFieldNumber = 6,
    kSymbolFieldNumber = 7,
    kOrchestratorAddressFieldNumber = 9,
    kEventNonceFieldNumber = 1,
    kEventHeightFieldNumber = 2,
    kDecimalsFieldNumber = 8,
  };
  // bytes attestation_id = 3 [json_name = "attestationId"];
  void clear_attestation_id() ;
  const std::string& attestation_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attestation_id(Arg_&& arg, Args_... args);
  std::string* mutable_attestation_id();
  PROTOBUF_NODISCARD std::string* release_attestation_id();
  void set_allocated_attestation_id(std::string* ptr);

  private:
  const std::string& _internal_attestation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attestation_id(
      const std::string& value);
  std::string* _internal_mutable_attestation_id();

  public:
  // string cosmos_denom = 4 [json_name = "cosmosDenom"];
  void clear_cosmos_denom() ;
  const std::string& cosmos_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cosmos_denom(Arg_&& arg, Args_... args);
  std::string* mutable_cosmos_denom();
  PROTOBUF_NODISCARD std::string* release_cosmos_denom();
  void set_allocated_cosmos_denom(std::string* ptr);

  private:
  const std::string& _internal_cosmos_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cosmos_denom(
      const std::string& value);
  std::string* _internal_mutable_cosmos_denom();

  public:
  // string token_contract = 5 [json_name = "tokenContract"];
  void clear_token_contract() ;
  const std::string& token_contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token_contract(Arg_&& arg, Args_... args);
  std::string* mutable_token_contract();
  PROTOBUF_NODISCARD std::string* release_token_contract();
  void set_allocated_token_contract(std::string* ptr);

  private:
  const std::string& _internal_token_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_contract(
      const std::string& value);
  std::string* _internal_mutable_token_contract();

  public:
  // string name = 6 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string symbol = 7 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string orchestrator_address = 9 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // uint64 event_nonce = 1 [json_name = "eventNonce"];
  void clear_event_nonce() ;
  ::uint64_t event_nonce() const;
  void set_event_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_event_nonce() const;
  void _internal_set_event_nonce(::uint64_t value);

  public:
  // uint64 event_height = 2 [json_name = "eventHeight"];
  void clear_event_height() ;
  ::uint64_t event_height() const;
  void set_event_height(::uint64_t value);

  private:
  ::uint64_t _internal_event_height() const;
  void _internal_set_event_height(::uint64_t value);

  public:
  // uint64 decimals = 8 [json_name = "decimals"];
  void clear_decimals() ;
  ::uint64_t decimals() const;
  void set_decimals(::uint64_t value);

  private:
  ::uint64_t _internal_decimals() const;
  void _internal_set_decimals(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventERC20DeployedClaim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attestation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cosmos_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::uint64_t event_nonce_;
    ::uint64_t event_height_;
    ::uint64_t decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventValsetUpdateClaim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventValsetUpdateClaim) */ {
 public:
  inline EventValsetUpdateClaim() : EventValsetUpdateClaim(nullptr) {}
  ~EventValsetUpdateClaim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventValsetUpdateClaim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventValsetUpdateClaim(const EventValsetUpdateClaim& from);
  EventValsetUpdateClaim(EventValsetUpdateClaim&& from) noexcept
    : EventValsetUpdateClaim() {
    *this = ::std::move(from);
  }

  inline EventValsetUpdateClaim& operator=(const EventValsetUpdateClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventValsetUpdateClaim& operator=(EventValsetUpdateClaim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventValsetUpdateClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventValsetUpdateClaim* internal_default_instance() {
    return reinterpret_cast<const EventValsetUpdateClaim*>(
               &_EventValsetUpdateClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EventValsetUpdateClaim& a, EventValsetUpdateClaim& b) {
    a.Swap(&b);
  }
  inline void Swap(EventValsetUpdateClaim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventValsetUpdateClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventValsetUpdateClaim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventValsetUpdateClaim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventValsetUpdateClaim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventValsetUpdateClaim& from) {
    EventValsetUpdateClaim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventValsetUpdateClaim* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventValsetUpdateClaim";
  }
  protected:
  explicit EventValsetUpdateClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsetMembersFieldNumber = 5,
    kAttestationIdFieldNumber = 3,
    kRewardAmountFieldNumber = 6,
    kRewardTokenFieldNumber = 7,
    kOrchestratorAddressFieldNumber = 8,
    kEventNonceFieldNumber = 1,
    kEventHeightFieldNumber = 2,
    kValsetNonceFieldNumber = 4,
  };
  // repeated .injective.peggy.v1.BridgeValidator valset_members = 5 [json_name = "valsetMembers"];
  int valset_members_size() const;
  private:
  int _internal_valset_members_size() const;

  public:
  void clear_valset_members() ;
  ::injective::peggy::v1::BridgeValidator* mutable_valset_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >*
      mutable_valset_members();
  private:
  const ::injective::peggy::v1::BridgeValidator& _internal_valset_members(int index) const;
  ::injective::peggy::v1::BridgeValidator* _internal_add_valset_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>& _internal_valset_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>* _internal_mutable_valset_members();
  public:
  const ::injective::peggy::v1::BridgeValidator& valset_members(int index) const;
  ::injective::peggy::v1::BridgeValidator* add_valset_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >&
      valset_members() const;
  // bytes attestation_id = 3 [json_name = "attestationId"];
  void clear_attestation_id() ;
  const std::string& attestation_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attestation_id(Arg_&& arg, Args_... args);
  std::string* mutable_attestation_id();
  PROTOBUF_NODISCARD std::string* release_attestation_id();
  void set_allocated_attestation_id(std::string* ptr);

  private:
  const std::string& _internal_attestation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attestation_id(
      const std::string& value);
  std::string* _internal_mutable_attestation_id();

  public:
  // string reward_amount = 6 [json_name = "rewardAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  void clear_reward_amount() ;
  const std::string& reward_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reward_amount(Arg_&& arg, Args_... args);
  std::string* mutable_reward_amount();
  PROTOBUF_NODISCARD std::string* release_reward_amount();
  void set_allocated_reward_amount(std::string* ptr);

  private:
  const std::string& _internal_reward_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_amount(
      const std::string& value);
  std::string* _internal_mutable_reward_amount();

  public:
  // string reward_token = 7 [json_name = "rewardToken"];
  void clear_reward_token() ;
  const std::string& reward_token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reward_token(Arg_&& arg, Args_... args);
  std::string* mutable_reward_token();
  PROTOBUF_NODISCARD std::string* release_reward_token();
  void set_allocated_reward_token(std::string* ptr);

  private:
  const std::string& _internal_reward_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_token(
      const std::string& value);
  std::string* _internal_mutable_reward_token();

  public:
  // string orchestrator_address = 8 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // uint64 event_nonce = 1 [json_name = "eventNonce"];
  void clear_event_nonce() ;
  ::uint64_t event_nonce() const;
  void set_event_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_event_nonce() const;
  void _internal_set_event_nonce(::uint64_t value);

  public:
  // uint64 event_height = 2 [json_name = "eventHeight"];
  void clear_event_height() ;
  ::uint64_t event_height() const;
  void set_event_height(::uint64_t value);

  private:
  ::uint64_t _internal_event_height() const;
  void _internal_set_event_height(::uint64_t value);

  public:
  // uint64 valset_nonce = 4 [json_name = "valsetNonce"];
  void clear_valset_nonce() ;
  ::uint64_t valset_nonce() const;
  void set_valset_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_valset_nonce() const;
  void _internal_set_valset_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventValsetUpdateClaim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator > valset_members_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attestation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::uint64_t event_nonce_;
    ::uint64_t event_height_;
    ::uint64_t valset_nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventCancelSendToEth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventCancelSendToEth) */ {
 public:
  inline EventCancelSendToEth() : EventCancelSendToEth(nullptr) {}
  ~EventCancelSendToEth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventCancelSendToEth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventCancelSendToEth(const EventCancelSendToEth& from);
  EventCancelSendToEth(EventCancelSendToEth&& from) noexcept
    : EventCancelSendToEth() {
    *this = ::std::move(from);
  }

  inline EventCancelSendToEth& operator=(const EventCancelSendToEth& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventCancelSendToEth& operator=(EventCancelSendToEth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventCancelSendToEth& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventCancelSendToEth* internal_default_instance() {
    return reinterpret_cast<const EventCancelSendToEth*>(
               &_EventCancelSendToEth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EventCancelSendToEth& a, EventCancelSendToEth& b) {
    a.Swap(&b);
  }
  inline void Swap(EventCancelSendToEth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventCancelSendToEth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventCancelSendToEth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventCancelSendToEth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventCancelSendToEth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventCancelSendToEth& from) {
    EventCancelSendToEth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventCancelSendToEth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventCancelSendToEth";
  }
  protected:
  explicit EventCancelSendToEth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutgoingTxIdFieldNumber = 1,
  };
  // uint64 outgoing_tx_id = 1 [json_name = "outgoingTxId"];
  void clear_outgoing_tx_id() ;
  ::uint64_t outgoing_tx_id() const;
  void set_outgoing_tx_id(::uint64_t value);

  private:
  ::uint64_t _internal_outgoing_tx_id() const;
  void _internal_set_outgoing_tx_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventCancelSendToEth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t outgoing_tx_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventSubmitBadSignatureEvidence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventSubmitBadSignatureEvidence) */ {
 public:
  inline EventSubmitBadSignatureEvidence() : EventSubmitBadSignatureEvidence(nullptr) {}
  ~EventSubmitBadSignatureEvidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventSubmitBadSignatureEvidence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSubmitBadSignatureEvidence(const EventSubmitBadSignatureEvidence& from);
  EventSubmitBadSignatureEvidence(EventSubmitBadSignatureEvidence&& from) noexcept
    : EventSubmitBadSignatureEvidence() {
    *this = ::std::move(from);
  }

  inline EventSubmitBadSignatureEvidence& operator=(const EventSubmitBadSignatureEvidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSubmitBadSignatureEvidence& operator=(EventSubmitBadSignatureEvidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSubmitBadSignatureEvidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSubmitBadSignatureEvidence* internal_default_instance() {
    return reinterpret_cast<const EventSubmitBadSignatureEvidence*>(
               &_EventSubmitBadSignatureEvidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EventSubmitBadSignatureEvidence& a, EventSubmitBadSignatureEvidence& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSubmitBadSignatureEvidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSubmitBadSignatureEvidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSubmitBadSignatureEvidence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSubmitBadSignatureEvidence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSubmitBadSignatureEvidence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSubmitBadSignatureEvidence& from) {
    EventSubmitBadSignatureEvidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSubmitBadSignatureEvidence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventSubmitBadSignatureEvidence";
  }
  protected:
  explicit EventSubmitBadSignatureEvidence(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBadEthSignatureFieldNumber = 1,
    kBadEthSignatureSubjectFieldNumber = 2,
  };
  // string bad_eth_signature = 1 [json_name = "badEthSignature"];
  void clear_bad_eth_signature() ;
  const std::string& bad_eth_signature() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bad_eth_signature(Arg_&& arg, Args_... args);
  std::string* mutable_bad_eth_signature();
  PROTOBUF_NODISCARD std::string* release_bad_eth_signature();
  void set_allocated_bad_eth_signature(std::string* ptr);

  private:
  const std::string& _internal_bad_eth_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bad_eth_signature(
      const std::string& value);
  std::string* _internal_mutable_bad_eth_signature();

  public:
  // string bad_eth_signature_subject = 2 [json_name = "badEthSignatureSubject"];
  void clear_bad_eth_signature_subject() ;
  const std::string& bad_eth_signature_subject() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bad_eth_signature_subject(Arg_&& arg, Args_... args);
  std::string* mutable_bad_eth_signature_subject();
  PROTOBUF_NODISCARD std::string* release_bad_eth_signature_subject();
  void set_allocated_bad_eth_signature_subject(std::string* ptr);

  private:
  const std::string& _internal_bad_eth_signature_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bad_eth_signature_subject(
      const std::string& value);
  std::string* _internal_mutable_bad_eth_signature_subject();

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventSubmitBadSignatureEvidence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bad_eth_signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bad_eth_signature_subject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventValidatorSlash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.peggy.v1.EventValidatorSlash) */ {
 public:
  inline EventValidatorSlash() : EventValidatorSlash(nullptr) {}
  ~EventValidatorSlash() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventValidatorSlash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventValidatorSlash(const EventValidatorSlash& from);
  EventValidatorSlash(EventValidatorSlash&& from) noexcept
    : EventValidatorSlash() {
    *this = ::std::move(from);
  }

  inline EventValidatorSlash& operator=(const EventValidatorSlash& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventValidatorSlash& operator=(EventValidatorSlash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventValidatorSlash& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventValidatorSlash* internal_default_instance() {
    return reinterpret_cast<const EventValidatorSlash*>(
               &_EventValidatorSlash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EventValidatorSlash& a, EventValidatorSlash& b) {
    a.Swap(&b);
  }
  inline void Swap(EventValidatorSlash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventValidatorSlash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventValidatorSlash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventValidatorSlash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventValidatorSlash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventValidatorSlash& from) {
    EventValidatorSlash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventValidatorSlash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.peggy.v1.EventValidatorSlash";
  }
  protected:
  explicit EventValidatorSlash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kConsensusAddressFieldNumber = 3,
    kOperatorAddressFieldNumber = 4,
    kMonikerFieldNumber = 5,
    kPowerFieldNumber = 1,
  };
  // string reason = 2 [json_name = "reason"];
  void clear_reason() ;
  const std::string& reason() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* ptr);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // string consensus_address = 3 [json_name = "consensusAddress"];
  void clear_consensus_address() ;
  const std::string& consensus_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_consensus_address(Arg_&& arg, Args_... args);
  std::string* mutable_consensus_address();
  PROTOBUF_NODISCARD std::string* release_consensus_address();
  void set_allocated_consensus_address(std::string* ptr);

  private:
  const std::string& _internal_consensus_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consensus_address(
      const std::string& value);
  std::string* _internal_mutable_consensus_address();

  public:
  // string operator_address = 4 [json_name = "operatorAddress"];
  void clear_operator_address() ;
  const std::string& operator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_address(Arg_&& arg, Args_... args);
  std::string* mutable_operator_address();
  PROTOBUF_NODISCARD std::string* release_operator_address();
  void set_allocated_operator_address(std::string* ptr);

  private:
  const std::string& _internal_operator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_address(
      const std::string& value);
  std::string* _internal_mutable_operator_address();

  public:
  // string moniker = 5 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* ptr);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // int64 power = 1 [json_name = "power"];
  void clear_power() ;
  ::int64_t power() const;
  void set_power(::int64_t value);

  private:
  ::int64_t _internal_power() const;
  void _internal_set_power(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.peggy.v1.EventValidatorSlash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consensus_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr moniker_;
    ::int64_t power_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fpeggy_2fv1_2fevents_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EventAttestationObserved

// .injective.peggy.v1.ClaimType attestation_type = 1 [json_name = "attestationType"];
inline void EventAttestationObserved::clear_attestation_type() {
  _impl_.attestation_type_ = 0;
}
inline ::injective::peggy::v1::ClaimType EventAttestationObserved::attestation_type() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationObserved.attestation_type)
  return _internal_attestation_type();
}
inline void EventAttestationObserved::set_attestation_type(::injective::peggy::v1::ClaimType value) {
   _internal_set_attestation_type(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationObserved.attestation_type)
}
inline ::injective::peggy::v1::ClaimType EventAttestationObserved::_internal_attestation_type() const {
  return static_cast<::injective::peggy::v1::ClaimType>(_impl_.attestation_type_);
}
inline void EventAttestationObserved::_internal_set_attestation_type(::injective::peggy::v1::ClaimType value) {
  ;
  _impl_.attestation_type_ = value;
}

// string bridge_contract = 2 [json_name = "bridgeContract"];
inline void EventAttestationObserved::clear_bridge_contract() {
  _impl_.bridge_contract_.ClearToEmpty();
}
inline const std::string& EventAttestationObserved::bridge_contract() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationObserved.bridge_contract)
  return _internal_bridge_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAttestationObserved::set_bridge_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bridge_contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationObserved.bridge_contract)
}
inline std::string* EventAttestationObserved::mutable_bridge_contract() {
  std::string* _s = _internal_mutable_bridge_contract();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventAttestationObserved.bridge_contract)
  return _s;
}
inline const std::string& EventAttestationObserved::_internal_bridge_contract() const {
  return _impl_.bridge_contract_.Get();
}
inline void EventAttestationObserved::_internal_set_bridge_contract(const std::string& value) {
  ;


  _impl_.bridge_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAttestationObserved::_internal_mutable_bridge_contract() {
  ;
  return _impl_.bridge_contract_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAttestationObserved::release_bridge_contract() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventAttestationObserved.bridge_contract)
  return _impl_.bridge_contract_.Release();
}
inline void EventAttestationObserved::set_allocated_bridge_contract(std::string* value) {
  _impl_.bridge_contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bridge_contract_.IsDefault()) {
          _impl_.bridge_contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventAttestationObserved.bridge_contract)
}

// uint64 bridge_chain_id = 3 [json_name = "bridgeChainId"];
inline void EventAttestationObserved::clear_bridge_chain_id() {
  _impl_.bridge_chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t EventAttestationObserved::bridge_chain_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationObserved.bridge_chain_id)
  return _internal_bridge_chain_id();
}
inline void EventAttestationObserved::set_bridge_chain_id(::uint64_t value) {
  _internal_set_bridge_chain_id(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationObserved.bridge_chain_id)
}
inline ::uint64_t EventAttestationObserved::_internal_bridge_chain_id() const {
  return _impl_.bridge_chain_id_;
}
inline void EventAttestationObserved::_internal_set_bridge_chain_id(::uint64_t value) {
  ;
  _impl_.bridge_chain_id_ = value;
}

// bytes attestation_id = 4 [json_name = "attestationId"];
inline void EventAttestationObserved::clear_attestation_id() {
  _impl_.attestation_id_.ClearToEmpty();
}
inline const std::string& EventAttestationObserved::attestation_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationObserved.attestation_id)
  return _internal_attestation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAttestationObserved::set_attestation_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.attestation_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationObserved.attestation_id)
}
inline std::string* EventAttestationObserved::mutable_attestation_id() {
  std::string* _s = _internal_mutable_attestation_id();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventAttestationObserved.attestation_id)
  return _s;
}
inline const std::string& EventAttestationObserved::_internal_attestation_id() const {
  return _impl_.attestation_id_.Get();
}
inline void EventAttestationObserved::_internal_set_attestation_id(const std::string& value) {
  ;


  _impl_.attestation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAttestationObserved::_internal_mutable_attestation_id() {
  ;
  return _impl_.attestation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAttestationObserved::release_attestation_id() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventAttestationObserved.attestation_id)
  return _impl_.attestation_id_.Release();
}
inline void EventAttestationObserved::set_allocated_attestation_id(std::string* value) {
  _impl_.attestation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attestation_id_.IsDefault()) {
          _impl_.attestation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventAttestationObserved.attestation_id)
}

// uint64 nonce = 5 [json_name = "nonce"];
inline void EventAttestationObserved::clear_nonce() {
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventAttestationObserved::nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationObserved.nonce)
  return _internal_nonce();
}
inline void EventAttestationObserved::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationObserved.nonce)
}
inline ::uint64_t EventAttestationObserved::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void EventAttestationObserved::_internal_set_nonce(::uint64_t value) {
  ;
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// EventBridgeWithdrawCanceled

// string bridge_contract = 1 [json_name = "bridgeContract"];
inline void EventBridgeWithdrawCanceled::clear_bridge_contract() {
  _impl_.bridge_contract_.ClearToEmpty();
}
inline const std::string& EventBridgeWithdrawCanceled::bridge_contract() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventBridgeWithdrawCanceled.bridge_contract)
  return _internal_bridge_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventBridgeWithdrawCanceled::set_bridge_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bridge_contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventBridgeWithdrawCanceled.bridge_contract)
}
inline std::string* EventBridgeWithdrawCanceled::mutable_bridge_contract() {
  std::string* _s = _internal_mutable_bridge_contract();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventBridgeWithdrawCanceled.bridge_contract)
  return _s;
}
inline const std::string& EventBridgeWithdrawCanceled::_internal_bridge_contract() const {
  return _impl_.bridge_contract_.Get();
}
inline void EventBridgeWithdrawCanceled::_internal_set_bridge_contract(const std::string& value) {
  ;


  _impl_.bridge_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* EventBridgeWithdrawCanceled::_internal_mutable_bridge_contract() {
  ;
  return _impl_.bridge_contract_.Mutable( GetArenaForAllocation());
}
inline std::string* EventBridgeWithdrawCanceled::release_bridge_contract() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventBridgeWithdrawCanceled.bridge_contract)
  return _impl_.bridge_contract_.Release();
}
inline void EventBridgeWithdrawCanceled::set_allocated_bridge_contract(std::string* value) {
  _impl_.bridge_contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bridge_contract_.IsDefault()) {
          _impl_.bridge_contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventBridgeWithdrawCanceled.bridge_contract)
}

// uint64 bridge_chain_id = 2 [json_name = "bridgeChainId"];
inline void EventBridgeWithdrawCanceled::clear_bridge_chain_id() {
  _impl_.bridge_chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t EventBridgeWithdrawCanceled::bridge_chain_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventBridgeWithdrawCanceled.bridge_chain_id)
  return _internal_bridge_chain_id();
}
inline void EventBridgeWithdrawCanceled::set_bridge_chain_id(::uint64_t value) {
  _internal_set_bridge_chain_id(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventBridgeWithdrawCanceled.bridge_chain_id)
}
inline ::uint64_t EventBridgeWithdrawCanceled::_internal_bridge_chain_id() const {
  return _impl_.bridge_chain_id_;
}
inline void EventBridgeWithdrawCanceled::_internal_set_bridge_chain_id(::uint64_t value) {
  ;
  _impl_.bridge_chain_id_ = value;
}

// -------------------------------------------------------------------

// EventOutgoingBatch

// string denom = 1 [json_name = "denom"];
inline void EventOutgoingBatch::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& EventOutgoingBatch::denom() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatch.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventOutgoingBatch::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatch.denom)
}
inline std::string* EventOutgoingBatch::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventOutgoingBatch.denom)
  return _s;
}
inline const std::string& EventOutgoingBatch::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void EventOutgoingBatch::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* EventOutgoingBatch::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* EventOutgoingBatch::release_denom() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventOutgoingBatch.denom)
  return _impl_.denom_.Release();
}
inline void EventOutgoingBatch::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventOutgoingBatch.denom)
}

// string orchestrator_address = 2 [json_name = "orchestratorAddress"];
inline void EventOutgoingBatch::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventOutgoingBatch::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatch.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventOutgoingBatch::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatch.orchestrator_address)
}
inline std::string* EventOutgoingBatch::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventOutgoingBatch.orchestrator_address)
  return _s;
}
inline const std::string& EventOutgoingBatch::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventOutgoingBatch::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventOutgoingBatch::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventOutgoingBatch::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventOutgoingBatch.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventOutgoingBatch::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventOutgoingBatch.orchestrator_address)
}

// uint64 batch_nonce = 3 [json_name = "batchNonce"];
inline void EventOutgoingBatch::clear_batch_nonce() {
  _impl_.batch_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventOutgoingBatch::batch_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatch.batch_nonce)
  return _internal_batch_nonce();
}
inline void EventOutgoingBatch::set_batch_nonce(::uint64_t value) {
  _internal_set_batch_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatch.batch_nonce)
}
inline ::uint64_t EventOutgoingBatch::_internal_batch_nonce() const {
  return _impl_.batch_nonce_;
}
inline void EventOutgoingBatch::_internal_set_batch_nonce(::uint64_t value) {
  ;
  _impl_.batch_nonce_ = value;
}

// uint64 batch_timeout = 4 [json_name = "batchTimeout"];
inline void EventOutgoingBatch::clear_batch_timeout() {
  _impl_.batch_timeout_ = ::uint64_t{0u};
}
inline ::uint64_t EventOutgoingBatch::batch_timeout() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatch.batch_timeout)
  return _internal_batch_timeout();
}
inline void EventOutgoingBatch::set_batch_timeout(::uint64_t value) {
  _internal_set_batch_timeout(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatch.batch_timeout)
}
inline ::uint64_t EventOutgoingBatch::_internal_batch_timeout() const {
  return _impl_.batch_timeout_;
}
inline void EventOutgoingBatch::_internal_set_batch_timeout(::uint64_t value) {
  ;
  _impl_.batch_timeout_ = value;
}

// repeated uint64 batch_tx_ids = 5 [json_name = "batchTxIds"];
inline int EventOutgoingBatch::_internal_batch_tx_ids_size() const {
  return _impl_.batch_tx_ids_.size();
}
inline int EventOutgoingBatch::batch_tx_ids_size() const {
  return _internal_batch_tx_ids_size();
}
inline void EventOutgoingBatch::clear_batch_tx_ids() {
  _internal_mutable_batch_tx_ids()->Clear();
}
inline ::uint64_t EventOutgoingBatch::batch_tx_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatch.batch_tx_ids)
  return _internal_batch_tx_ids(index);
}
inline void EventOutgoingBatch::set_batch_tx_ids(int index, ::uint64_t value) {
  _internal_mutable_batch_tx_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatch.batch_tx_ids)
}
inline void EventOutgoingBatch::add_batch_tx_ids(::uint64_t value) {
  _internal_add_batch_tx_ids(value);
  // @@protoc_insertion_point(field_add:injective.peggy.v1.EventOutgoingBatch.batch_tx_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& EventOutgoingBatch::batch_tx_ids() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.EventOutgoingBatch.batch_tx_ids)
  return _internal_batch_tx_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* EventOutgoingBatch::mutable_batch_tx_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.EventOutgoingBatch.batch_tx_ids)
  return _internal_mutable_batch_tx_ids();
}

inline ::uint64_t EventOutgoingBatch::_internal_batch_tx_ids(int index) const {
  return _internal_batch_tx_ids().Get(index);
}
inline void EventOutgoingBatch::_internal_add_batch_tx_ids(::uint64_t value) {
  _internal_mutable_batch_tx_ids()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& EventOutgoingBatch::_internal_batch_tx_ids() const {
  return _impl_.batch_tx_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* EventOutgoingBatch::_internal_mutable_batch_tx_ids() {
  return &_impl_.batch_tx_ids_;
}

// -------------------------------------------------------------------

// EventOutgoingBatchCanceled

// string bridge_contract = 1 [json_name = "bridgeContract"];
inline void EventOutgoingBatchCanceled::clear_bridge_contract() {
  _impl_.bridge_contract_.ClearToEmpty();
}
inline const std::string& EventOutgoingBatchCanceled::bridge_contract() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatchCanceled.bridge_contract)
  return _internal_bridge_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventOutgoingBatchCanceled::set_bridge_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bridge_contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatchCanceled.bridge_contract)
}
inline std::string* EventOutgoingBatchCanceled::mutable_bridge_contract() {
  std::string* _s = _internal_mutable_bridge_contract();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventOutgoingBatchCanceled.bridge_contract)
  return _s;
}
inline const std::string& EventOutgoingBatchCanceled::_internal_bridge_contract() const {
  return _impl_.bridge_contract_.Get();
}
inline void EventOutgoingBatchCanceled::_internal_set_bridge_contract(const std::string& value) {
  ;


  _impl_.bridge_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* EventOutgoingBatchCanceled::_internal_mutable_bridge_contract() {
  ;
  return _impl_.bridge_contract_.Mutable( GetArenaForAllocation());
}
inline std::string* EventOutgoingBatchCanceled::release_bridge_contract() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventOutgoingBatchCanceled.bridge_contract)
  return _impl_.bridge_contract_.Release();
}
inline void EventOutgoingBatchCanceled::set_allocated_bridge_contract(std::string* value) {
  _impl_.bridge_contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bridge_contract_.IsDefault()) {
          _impl_.bridge_contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventOutgoingBatchCanceled.bridge_contract)
}

// uint64 bridge_chain_id = 2 [json_name = "bridgeChainId"];
inline void EventOutgoingBatchCanceled::clear_bridge_chain_id() {
  _impl_.bridge_chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t EventOutgoingBatchCanceled::bridge_chain_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatchCanceled.bridge_chain_id)
  return _internal_bridge_chain_id();
}
inline void EventOutgoingBatchCanceled::set_bridge_chain_id(::uint64_t value) {
  _internal_set_bridge_chain_id(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatchCanceled.bridge_chain_id)
}
inline ::uint64_t EventOutgoingBatchCanceled::_internal_bridge_chain_id() const {
  return _impl_.bridge_chain_id_;
}
inline void EventOutgoingBatchCanceled::_internal_set_bridge_chain_id(::uint64_t value) {
  ;
  _impl_.bridge_chain_id_ = value;
}

// uint64 batch_id = 3 [json_name = "batchId"];
inline void EventOutgoingBatchCanceled::clear_batch_id() {
  _impl_.batch_id_ = ::uint64_t{0u};
}
inline ::uint64_t EventOutgoingBatchCanceled::batch_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatchCanceled.batch_id)
  return _internal_batch_id();
}
inline void EventOutgoingBatchCanceled::set_batch_id(::uint64_t value) {
  _internal_set_batch_id(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatchCanceled.batch_id)
}
inline ::uint64_t EventOutgoingBatchCanceled::_internal_batch_id() const {
  return _impl_.batch_id_;
}
inline void EventOutgoingBatchCanceled::_internal_set_batch_id(::uint64_t value) {
  ;
  _impl_.batch_id_ = value;
}

// uint64 nonce = 4 [json_name = "nonce"];
inline void EventOutgoingBatchCanceled::clear_nonce() {
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventOutgoingBatchCanceled::nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventOutgoingBatchCanceled.nonce)
  return _internal_nonce();
}
inline void EventOutgoingBatchCanceled::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventOutgoingBatchCanceled.nonce)
}
inline ::uint64_t EventOutgoingBatchCanceled::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void EventOutgoingBatchCanceled::_internal_set_nonce(::uint64_t value) {
  ;
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// EventValsetUpdateRequest

// uint64 valset_nonce = 1 [json_name = "valsetNonce"];
inline void EventValsetUpdateRequest::clear_valset_nonce() {
  _impl_.valset_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventValsetUpdateRequest::valset_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateRequest.valset_nonce)
  return _internal_valset_nonce();
}
inline void EventValsetUpdateRequest::set_valset_nonce(::uint64_t value) {
  _internal_set_valset_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateRequest.valset_nonce)
}
inline ::uint64_t EventValsetUpdateRequest::_internal_valset_nonce() const {
  return _impl_.valset_nonce_;
}
inline void EventValsetUpdateRequest::_internal_set_valset_nonce(::uint64_t value) {
  ;
  _impl_.valset_nonce_ = value;
}

// uint64 valset_height = 2 [json_name = "valsetHeight"];
inline void EventValsetUpdateRequest::clear_valset_height() {
  _impl_.valset_height_ = ::uint64_t{0u};
}
inline ::uint64_t EventValsetUpdateRequest::valset_height() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateRequest.valset_height)
  return _internal_valset_height();
}
inline void EventValsetUpdateRequest::set_valset_height(::uint64_t value) {
  _internal_set_valset_height(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateRequest.valset_height)
}
inline ::uint64_t EventValsetUpdateRequest::_internal_valset_height() const {
  return _impl_.valset_height_;
}
inline void EventValsetUpdateRequest::_internal_set_valset_height(::uint64_t value) {
  ;
  _impl_.valset_height_ = value;
}

// repeated .injective.peggy.v1.BridgeValidator valset_members = 3 [json_name = "valsetMembers"];
inline int EventValsetUpdateRequest::_internal_valset_members_size() const {
  return _impl_.valset_members_.size();
}
inline int EventValsetUpdateRequest::valset_members_size() const {
  return _internal_valset_members_size();
}
inline ::injective::peggy::v1::BridgeValidator* EventValsetUpdateRequest::mutable_valset_members(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateRequest.valset_members)
  return _internal_mutable_valset_members()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >*
EventValsetUpdateRequest::mutable_valset_members() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.EventValsetUpdateRequest.valset_members)
  return _internal_mutable_valset_members();
}
inline const ::injective::peggy::v1::BridgeValidator& EventValsetUpdateRequest::_internal_valset_members(int index) const {
  return _internal_valset_members().Get(index);
}
inline const ::injective::peggy::v1::BridgeValidator& EventValsetUpdateRequest::valset_members(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateRequest.valset_members)
  return _internal_valset_members(index);
}
inline ::injective::peggy::v1::BridgeValidator* EventValsetUpdateRequest::_internal_add_valset_members() {
  return _internal_mutable_valset_members()->Add();
}
inline ::injective::peggy::v1::BridgeValidator* EventValsetUpdateRequest::add_valset_members() {
  ::injective::peggy::v1::BridgeValidator* _add = _internal_add_valset_members();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.EventValsetUpdateRequest.valset_members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >&
EventValsetUpdateRequest::valset_members() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.EventValsetUpdateRequest.valset_members)
  return _internal_valset_members();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>&
EventValsetUpdateRequest::_internal_valset_members() const {
  return _impl_.valset_members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>*
EventValsetUpdateRequest::_internal_mutable_valset_members() {
  return &_impl_.valset_members_;
}

// string reward_amount = 4 [json_name = "rewardAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void EventValsetUpdateRequest::clear_reward_amount() {
  _impl_.reward_amount_.ClearToEmpty();
}
inline const std::string& EventValsetUpdateRequest::reward_amount() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateRequest.reward_amount)
  return _internal_reward_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValsetUpdateRequest::set_reward_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reward_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateRequest.reward_amount)
}
inline std::string* EventValsetUpdateRequest::mutable_reward_amount() {
  std::string* _s = _internal_mutable_reward_amount();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateRequest.reward_amount)
  return _s;
}
inline const std::string& EventValsetUpdateRequest::_internal_reward_amount() const {
  return _impl_.reward_amount_.Get();
}
inline void EventValsetUpdateRequest::_internal_set_reward_amount(const std::string& value) {
  ;


  _impl_.reward_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValsetUpdateRequest::_internal_mutable_reward_amount() {
  ;
  return _impl_.reward_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValsetUpdateRequest::release_reward_amount() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValsetUpdateRequest.reward_amount)
  return _impl_.reward_amount_.Release();
}
inline void EventValsetUpdateRequest::set_allocated_reward_amount(std::string* value) {
  _impl_.reward_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reward_amount_.IsDefault()) {
          _impl_.reward_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValsetUpdateRequest.reward_amount)
}

// string reward_token = 5 [json_name = "rewardToken"];
inline void EventValsetUpdateRequest::clear_reward_token() {
  _impl_.reward_token_.ClearToEmpty();
}
inline const std::string& EventValsetUpdateRequest::reward_token() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateRequest.reward_token)
  return _internal_reward_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValsetUpdateRequest::set_reward_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reward_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateRequest.reward_token)
}
inline std::string* EventValsetUpdateRequest::mutable_reward_token() {
  std::string* _s = _internal_mutable_reward_token();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateRequest.reward_token)
  return _s;
}
inline const std::string& EventValsetUpdateRequest::_internal_reward_token() const {
  return _impl_.reward_token_.Get();
}
inline void EventValsetUpdateRequest::_internal_set_reward_token(const std::string& value) {
  ;


  _impl_.reward_token_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValsetUpdateRequest::_internal_mutable_reward_token() {
  ;
  return _impl_.reward_token_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValsetUpdateRequest::release_reward_token() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValsetUpdateRequest.reward_token)
  return _impl_.reward_token_.Release();
}
inline void EventValsetUpdateRequest::set_allocated_reward_token(std::string* value) {
  _impl_.reward_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reward_token_.IsDefault()) {
          _impl_.reward_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValsetUpdateRequest.reward_token)
}

// -------------------------------------------------------------------

// EventSetOrchestratorAddresses

// string validator_address = 1 [json_name = "validatorAddress"];
inline void EventSetOrchestratorAddresses::clear_validator_address() {
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& EventSetOrchestratorAddresses::validator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSetOrchestratorAddresses.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSetOrchestratorAddresses::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSetOrchestratorAddresses.validator_address)
}
inline std::string* EventSetOrchestratorAddresses::mutable_validator_address() {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSetOrchestratorAddresses.validator_address)
  return _s;
}
inline const std::string& EventSetOrchestratorAddresses::_internal_validator_address() const {
  return _impl_.validator_address_.Get();
}
inline void EventSetOrchestratorAddresses::_internal_set_validator_address(const std::string& value) {
  ;


  _impl_.validator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSetOrchestratorAddresses::_internal_mutable_validator_address() {
  ;
  return _impl_.validator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSetOrchestratorAddresses::release_validator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSetOrchestratorAddresses.validator_address)
  return _impl_.validator_address_.Release();
}
inline void EventSetOrchestratorAddresses::set_allocated_validator_address(std::string* value) {
  _impl_.validator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.validator_address_.IsDefault()) {
          _impl_.validator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSetOrchestratorAddresses.validator_address)
}

// string orchestrator_address = 2 [json_name = "orchestratorAddress"];
inline void EventSetOrchestratorAddresses::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventSetOrchestratorAddresses::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSetOrchestratorAddresses.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSetOrchestratorAddresses::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSetOrchestratorAddresses.orchestrator_address)
}
inline std::string* EventSetOrchestratorAddresses::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSetOrchestratorAddresses.orchestrator_address)
  return _s;
}
inline const std::string& EventSetOrchestratorAddresses::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventSetOrchestratorAddresses::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSetOrchestratorAddresses::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSetOrchestratorAddresses::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSetOrchestratorAddresses.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventSetOrchestratorAddresses::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSetOrchestratorAddresses.orchestrator_address)
}

// string operator_eth_address = 3 [json_name = "operatorEthAddress"];
inline void EventSetOrchestratorAddresses::clear_operator_eth_address() {
  _impl_.operator_eth_address_.ClearToEmpty();
}
inline const std::string& EventSetOrchestratorAddresses::operator_eth_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSetOrchestratorAddresses.operator_eth_address)
  return _internal_operator_eth_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSetOrchestratorAddresses::set_operator_eth_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operator_eth_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSetOrchestratorAddresses.operator_eth_address)
}
inline std::string* EventSetOrchestratorAddresses::mutable_operator_eth_address() {
  std::string* _s = _internal_mutable_operator_eth_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSetOrchestratorAddresses.operator_eth_address)
  return _s;
}
inline const std::string& EventSetOrchestratorAddresses::_internal_operator_eth_address() const {
  return _impl_.operator_eth_address_.Get();
}
inline void EventSetOrchestratorAddresses::_internal_set_operator_eth_address(const std::string& value) {
  ;


  _impl_.operator_eth_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSetOrchestratorAddresses::_internal_mutable_operator_eth_address() {
  ;
  return _impl_.operator_eth_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSetOrchestratorAddresses::release_operator_eth_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSetOrchestratorAddresses.operator_eth_address)
  return _impl_.operator_eth_address_.Release();
}
inline void EventSetOrchestratorAddresses::set_allocated_operator_eth_address(std::string* value) {
  _impl_.operator_eth_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_eth_address_.IsDefault()) {
          _impl_.operator_eth_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSetOrchestratorAddresses.operator_eth_address)
}

// -------------------------------------------------------------------

// EventValsetConfirm

// uint64 valset_nonce = 1 [json_name = "valsetNonce"];
inline void EventValsetConfirm::clear_valset_nonce() {
  _impl_.valset_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventValsetConfirm::valset_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetConfirm.valset_nonce)
  return _internal_valset_nonce();
}
inline void EventValsetConfirm::set_valset_nonce(::uint64_t value) {
  _internal_set_valset_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetConfirm.valset_nonce)
}
inline ::uint64_t EventValsetConfirm::_internal_valset_nonce() const {
  return _impl_.valset_nonce_;
}
inline void EventValsetConfirm::_internal_set_valset_nonce(::uint64_t value) {
  ;
  _impl_.valset_nonce_ = value;
}

// string orchestrator_address = 2 [json_name = "orchestratorAddress"];
inline void EventValsetConfirm::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventValsetConfirm::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetConfirm.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValsetConfirm::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetConfirm.orchestrator_address)
}
inline std::string* EventValsetConfirm::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetConfirm.orchestrator_address)
  return _s;
}
inline const std::string& EventValsetConfirm::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventValsetConfirm::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValsetConfirm::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValsetConfirm::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValsetConfirm.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventValsetConfirm::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValsetConfirm.orchestrator_address)
}

// -------------------------------------------------------------------

// EventSendToEth

// uint64 outgoing_tx_id = 1 [json_name = "outgoingTxId"];
inline void EventSendToEth::clear_outgoing_tx_id() {
  _impl_.outgoing_tx_id_ = ::uint64_t{0u};
}
inline ::uint64_t EventSendToEth::outgoing_tx_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSendToEth.outgoing_tx_id)
  return _internal_outgoing_tx_id();
}
inline void EventSendToEth::set_outgoing_tx_id(::uint64_t value) {
  _internal_set_outgoing_tx_id(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSendToEth.outgoing_tx_id)
}
inline ::uint64_t EventSendToEth::_internal_outgoing_tx_id() const {
  return _impl_.outgoing_tx_id_;
}
inline void EventSendToEth::_internal_set_outgoing_tx_id(::uint64_t value) {
  ;
  _impl_.outgoing_tx_id_ = value;
}

// string sender = 2 [json_name = "sender"];
inline void EventSendToEth::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& EventSendToEth::sender() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSendToEth.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSendToEth::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSendToEth.sender)
}
inline std::string* EventSendToEth::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSendToEth.sender)
  return _s;
}
inline const std::string& EventSendToEth::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void EventSendToEth::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSendToEth::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSendToEth::release_sender() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSendToEth.sender)
  return _impl_.sender_.Release();
}
inline void EventSendToEth::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSendToEth.sender)
}

// string receiver = 3 [json_name = "receiver"];
inline void EventSendToEth::clear_receiver() {
  _impl_.receiver_.ClearToEmpty();
}
inline const std::string& EventSendToEth::receiver() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSendToEth.receiver)
  return _internal_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSendToEth::set_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSendToEth.receiver)
}
inline std::string* EventSendToEth::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSendToEth.receiver)
  return _s;
}
inline const std::string& EventSendToEth::_internal_receiver() const {
  return _impl_.receiver_.Get();
}
inline void EventSendToEth::_internal_set_receiver(const std::string& value) {
  ;


  _impl_.receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSendToEth::_internal_mutable_receiver() {
  ;
  return _impl_.receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSendToEth::release_receiver() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSendToEth.receiver)
  return _impl_.receiver_.Release();
}
inline void EventSendToEth::set_allocated_receiver(std::string* value) {
  _impl_.receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_.IsDefault()) {
          _impl_.receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSendToEth.receiver)
}

// string amount = 4 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Coin"];
inline void EventSendToEth::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& EventSendToEth::amount() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSendToEth.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSendToEth::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSendToEth.amount)
}
inline std::string* EventSendToEth::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSendToEth.amount)
  return _s;
}
inline const std::string& EventSendToEth::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void EventSendToEth::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSendToEth::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSendToEth::release_amount() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSendToEth.amount)
  return _impl_.amount_.Release();
}
inline void EventSendToEth::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSendToEth.amount)
}

// string bridge_fee = 5 [json_name = "bridgeFee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Coin"];
inline void EventSendToEth::clear_bridge_fee() {
  _impl_.bridge_fee_.ClearToEmpty();
}
inline const std::string& EventSendToEth::bridge_fee() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSendToEth.bridge_fee)
  return _internal_bridge_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSendToEth::set_bridge_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bridge_fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSendToEth.bridge_fee)
}
inline std::string* EventSendToEth::mutable_bridge_fee() {
  std::string* _s = _internal_mutable_bridge_fee();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSendToEth.bridge_fee)
  return _s;
}
inline const std::string& EventSendToEth::_internal_bridge_fee() const {
  return _impl_.bridge_fee_.Get();
}
inline void EventSendToEth::_internal_set_bridge_fee(const std::string& value) {
  ;


  _impl_.bridge_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSendToEth::_internal_mutable_bridge_fee() {
  ;
  return _impl_.bridge_fee_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSendToEth::release_bridge_fee() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSendToEth.bridge_fee)
  return _impl_.bridge_fee_.Release();
}
inline void EventSendToEth::set_allocated_bridge_fee(std::string* value) {
  _impl_.bridge_fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bridge_fee_.IsDefault()) {
          _impl_.bridge_fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSendToEth.bridge_fee)
}

// -------------------------------------------------------------------

// EventConfirmBatch

// uint64 batch_nonce = 1 [json_name = "batchNonce"];
inline void EventConfirmBatch::clear_batch_nonce() {
  _impl_.batch_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventConfirmBatch::batch_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventConfirmBatch.batch_nonce)
  return _internal_batch_nonce();
}
inline void EventConfirmBatch::set_batch_nonce(::uint64_t value) {
  _internal_set_batch_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventConfirmBatch.batch_nonce)
}
inline ::uint64_t EventConfirmBatch::_internal_batch_nonce() const {
  return _impl_.batch_nonce_;
}
inline void EventConfirmBatch::_internal_set_batch_nonce(::uint64_t value) {
  ;
  _impl_.batch_nonce_ = value;
}

// string orchestrator_address = 2 [json_name = "orchestratorAddress"];
inline void EventConfirmBatch::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventConfirmBatch::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventConfirmBatch.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventConfirmBatch::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventConfirmBatch.orchestrator_address)
}
inline std::string* EventConfirmBatch::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventConfirmBatch.orchestrator_address)
  return _s;
}
inline const std::string& EventConfirmBatch::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventConfirmBatch::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventConfirmBatch::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventConfirmBatch::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventConfirmBatch.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventConfirmBatch::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventConfirmBatch.orchestrator_address)
}

// -------------------------------------------------------------------

// EventAttestationVote

// uint64 event_nonce = 1 [json_name = "eventNonce"];
inline void EventAttestationVote::clear_event_nonce() {
  _impl_.event_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventAttestationVote::event_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationVote.event_nonce)
  return _internal_event_nonce();
}
inline void EventAttestationVote::set_event_nonce(::uint64_t value) {
  _internal_set_event_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationVote.event_nonce)
}
inline ::uint64_t EventAttestationVote::_internal_event_nonce() const {
  return _impl_.event_nonce_;
}
inline void EventAttestationVote::_internal_set_event_nonce(::uint64_t value) {
  ;
  _impl_.event_nonce_ = value;
}

// bytes attestation_id = 2 [json_name = "attestationId"];
inline void EventAttestationVote::clear_attestation_id() {
  _impl_.attestation_id_.ClearToEmpty();
}
inline const std::string& EventAttestationVote::attestation_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationVote.attestation_id)
  return _internal_attestation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAttestationVote::set_attestation_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.attestation_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationVote.attestation_id)
}
inline std::string* EventAttestationVote::mutable_attestation_id() {
  std::string* _s = _internal_mutable_attestation_id();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventAttestationVote.attestation_id)
  return _s;
}
inline const std::string& EventAttestationVote::_internal_attestation_id() const {
  return _impl_.attestation_id_.Get();
}
inline void EventAttestationVote::_internal_set_attestation_id(const std::string& value) {
  ;


  _impl_.attestation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAttestationVote::_internal_mutable_attestation_id() {
  ;
  return _impl_.attestation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAttestationVote::release_attestation_id() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventAttestationVote.attestation_id)
  return _impl_.attestation_id_.Release();
}
inline void EventAttestationVote::set_allocated_attestation_id(std::string* value) {
  _impl_.attestation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attestation_id_.IsDefault()) {
          _impl_.attestation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventAttestationVote.attestation_id)
}

// string voter = 3 [json_name = "voter"];
inline void EventAttestationVote::clear_voter() {
  _impl_.voter_.ClearToEmpty();
}
inline const std::string& EventAttestationVote::voter() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventAttestationVote.voter)
  return _internal_voter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAttestationVote::set_voter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.voter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventAttestationVote.voter)
}
inline std::string* EventAttestationVote::mutable_voter() {
  std::string* _s = _internal_mutable_voter();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventAttestationVote.voter)
  return _s;
}
inline const std::string& EventAttestationVote::_internal_voter() const {
  return _impl_.voter_.Get();
}
inline void EventAttestationVote::_internal_set_voter(const std::string& value) {
  ;


  _impl_.voter_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAttestationVote::_internal_mutable_voter() {
  ;
  return _impl_.voter_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAttestationVote::release_voter() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventAttestationVote.voter)
  return _impl_.voter_.Release();
}
inline void EventAttestationVote::set_allocated_voter(std::string* value) {
  _impl_.voter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.voter_.IsDefault()) {
          _impl_.voter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventAttestationVote.voter)
}

// -------------------------------------------------------------------

// EventDepositClaim

// uint64 event_nonce = 1 [json_name = "eventNonce"];
inline void EventDepositClaim::clear_event_nonce() {
  _impl_.event_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventDepositClaim::event_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.event_nonce)
  return _internal_event_nonce();
}
inline void EventDepositClaim::set_event_nonce(::uint64_t value) {
  _internal_set_event_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.event_nonce)
}
inline ::uint64_t EventDepositClaim::_internal_event_nonce() const {
  return _impl_.event_nonce_;
}
inline void EventDepositClaim::_internal_set_event_nonce(::uint64_t value) {
  ;
  _impl_.event_nonce_ = value;
}

// uint64 event_height = 2 [json_name = "eventHeight"];
inline void EventDepositClaim::clear_event_height() {
  _impl_.event_height_ = ::uint64_t{0u};
}
inline ::uint64_t EventDepositClaim::event_height() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.event_height)
  return _internal_event_height();
}
inline void EventDepositClaim::set_event_height(::uint64_t value) {
  _internal_set_event_height(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.event_height)
}
inline ::uint64_t EventDepositClaim::_internal_event_height() const {
  return _impl_.event_height_;
}
inline void EventDepositClaim::_internal_set_event_height(::uint64_t value) {
  ;
  _impl_.event_height_ = value;
}

// bytes attestation_id = 3 [json_name = "attestationId"];
inline void EventDepositClaim::clear_attestation_id() {
  _impl_.attestation_id_.ClearToEmpty();
}
inline const std::string& EventDepositClaim::attestation_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.attestation_id)
  return _internal_attestation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDepositClaim::set_attestation_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.attestation_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.attestation_id)
}
inline std::string* EventDepositClaim::mutable_attestation_id() {
  std::string* _s = _internal_mutable_attestation_id();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventDepositClaim.attestation_id)
  return _s;
}
inline const std::string& EventDepositClaim::_internal_attestation_id() const {
  return _impl_.attestation_id_.Get();
}
inline void EventDepositClaim::_internal_set_attestation_id(const std::string& value) {
  ;


  _impl_.attestation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDepositClaim::_internal_mutable_attestation_id() {
  ;
  return _impl_.attestation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDepositClaim::release_attestation_id() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventDepositClaim.attestation_id)
  return _impl_.attestation_id_.Release();
}
inline void EventDepositClaim::set_allocated_attestation_id(std::string* value) {
  _impl_.attestation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attestation_id_.IsDefault()) {
          _impl_.attestation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventDepositClaim.attestation_id)
}

// string ethereum_sender = 4 [json_name = "ethereumSender"];
inline void EventDepositClaim::clear_ethereum_sender() {
  _impl_.ethereum_sender_.ClearToEmpty();
}
inline const std::string& EventDepositClaim::ethereum_sender() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.ethereum_sender)
  return _internal_ethereum_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDepositClaim::set_ethereum_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ethereum_sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.ethereum_sender)
}
inline std::string* EventDepositClaim::mutable_ethereum_sender() {
  std::string* _s = _internal_mutable_ethereum_sender();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventDepositClaim.ethereum_sender)
  return _s;
}
inline const std::string& EventDepositClaim::_internal_ethereum_sender() const {
  return _impl_.ethereum_sender_.Get();
}
inline void EventDepositClaim::_internal_set_ethereum_sender(const std::string& value) {
  ;


  _impl_.ethereum_sender_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDepositClaim::_internal_mutable_ethereum_sender() {
  ;
  return _impl_.ethereum_sender_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDepositClaim::release_ethereum_sender() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventDepositClaim.ethereum_sender)
  return _impl_.ethereum_sender_.Release();
}
inline void EventDepositClaim::set_allocated_ethereum_sender(std::string* value) {
  _impl_.ethereum_sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ethereum_sender_.IsDefault()) {
          _impl_.ethereum_sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventDepositClaim.ethereum_sender)
}

// string cosmos_receiver = 5 [json_name = "cosmosReceiver"];
inline void EventDepositClaim::clear_cosmos_receiver() {
  _impl_.cosmos_receiver_.ClearToEmpty();
}
inline const std::string& EventDepositClaim::cosmos_receiver() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.cosmos_receiver)
  return _internal_cosmos_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDepositClaim::set_cosmos_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cosmos_receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.cosmos_receiver)
}
inline std::string* EventDepositClaim::mutable_cosmos_receiver() {
  std::string* _s = _internal_mutable_cosmos_receiver();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventDepositClaim.cosmos_receiver)
  return _s;
}
inline const std::string& EventDepositClaim::_internal_cosmos_receiver() const {
  return _impl_.cosmos_receiver_.Get();
}
inline void EventDepositClaim::_internal_set_cosmos_receiver(const std::string& value) {
  ;


  _impl_.cosmos_receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDepositClaim::_internal_mutable_cosmos_receiver() {
  ;
  return _impl_.cosmos_receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDepositClaim::release_cosmos_receiver() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventDepositClaim.cosmos_receiver)
  return _impl_.cosmos_receiver_.Release();
}
inline void EventDepositClaim::set_allocated_cosmos_receiver(std::string* value) {
  _impl_.cosmos_receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cosmos_receiver_.IsDefault()) {
          _impl_.cosmos_receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventDepositClaim.cosmos_receiver)
}

// string token_contract = 6 [json_name = "tokenContract"];
inline void EventDepositClaim::clear_token_contract() {
  _impl_.token_contract_.ClearToEmpty();
}
inline const std::string& EventDepositClaim::token_contract() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.token_contract)
  return _internal_token_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDepositClaim::set_token_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.token_contract)
}
inline std::string* EventDepositClaim::mutable_token_contract() {
  std::string* _s = _internal_mutable_token_contract();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventDepositClaim.token_contract)
  return _s;
}
inline const std::string& EventDepositClaim::_internal_token_contract() const {
  return _impl_.token_contract_.Get();
}
inline void EventDepositClaim::_internal_set_token_contract(const std::string& value) {
  ;


  _impl_.token_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDepositClaim::_internal_mutable_token_contract() {
  ;
  return _impl_.token_contract_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDepositClaim::release_token_contract() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventDepositClaim.token_contract)
  return _impl_.token_contract_.Release();
}
inline void EventDepositClaim::set_allocated_token_contract(std::string* value) {
  _impl_.token_contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_contract_.IsDefault()) {
          _impl_.token_contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventDepositClaim.token_contract)
}

// string amount = 7 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void EventDepositClaim::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& EventDepositClaim::amount() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDepositClaim::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.amount)
}
inline std::string* EventDepositClaim::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventDepositClaim.amount)
  return _s;
}
inline const std::string& EventDepositClaim::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void EventDepositClaim::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDepositClaim::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDepositClaim::release_amount() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventDepositClaim.amount)
  return _impl_.amount_.Release();
}
inline void EventDepositClaim::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventDepositClaim.amount)
}

// string orchestrator_address = 8 [json_name = "orchestratorAddress"];
inline void EventDepositClaim::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventDepositClaim::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDepositClaim::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.orchestrator_address)
}
inline std::string* EventDepositClaim::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventDepositClaim.orchestrator_address)
  return _s;
}
inline const std::string& EventDepositClaim::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventDepositClaim::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDepositClaim::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDepositClaim::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventDepositClaim.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventDepositClaim::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventDepositClaim.orchestrator_address)
}

// string data = 9 [json_name = "data"];
inline void EventDepositClaim::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& EventDepositClaim::data() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventDepositClaim.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDepositClaim::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventDepositClaim.data)
}
inline std::string* EventDepositClaim::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventDepositClaim.data)
  return _s;
}
inline const std::string& EventDepositClaim::_internal_data() const {
  return _impl_.data_.Get();
}
inline void EventDepositClaim::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDepositClaim::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDepositClaim::release_data() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventDepositClaim.data)
  return _impl_.data_.Release();
}
inline void EventDepositClaim::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventDepositClaim.data)
}

// -------------------------------------------------------------------

// EventWithdrawClaim

// uint64 event_nonce = 1 [json_name = "eventNonce"];
inline void EventWithdrawClaim::clear_event_nonce() {
  _impl_.event_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventWithdrawClaim::event_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventWithdrawClaim.event_nonce)
  return _internal_event_nonce();
}
inline void EventWithdrawClaim::set_event_nonce(::uint64_t value) {
  _internal_set_event_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventWithdrawClaim.event_nonce)
}
inline ::uint64_t EventWithdrawClaim::_internal_event_nonce() const {
  return _impl_.event_nonce_;
}
inline void EventWithdrawClaim::_internal_set_event_nonce(::uint64_t value) {
  ;
  _impl_.event_nonce_ = value;
}

// uint64 event_height = 2 [json_name = "eventHeight"];
inline void EventWithdrawClaim::clear_event_height() {
  _impl_.event_height_ = ::uint64_t{0u};
}
inline ::uint64_t EventWithdrawClaim::event_height() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventWithdrawClaim.event_height)
  return _internal_event_height();
}
inline void EventWithdrawClaim::set_event_height(::uint64_t value) {
  _internal_set_event_height(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventWithdrawClaim.event_height)
}
inline ::uint64_t EventWithdrawClaim::_internal_event_height() const {
  return _impl_.event_height_;
}
inline void EventWithdrawClaim::_internal_set_event_height(::uint64_t value) {
  ;
  _impl_.event_height_ = value;
}

// bytes attestation_id = 3 [json_name = "attestationId"];
inline void EventWithdrawClaim::clear_attestation_id() {
  _impl_.attestation_id_.ClearToEmpty();
}
inline const std::string& EventWithdrawClaim::attestation_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventWithdrawClaim.attestation_id)
  return _internal_attestation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventWithdrawClaim::set_attestation_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.attestation_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventWithdrawClaim.attestation_id)
}
inline std::string* EventWithdrawClaim::mutable_attestation_id() {
  std::string* _s = _internal_mutable_attestation_id();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventWithdrawClaim.attestation_id)
  return _s;
}
inline const std::string& EventWithdrawClaim::_internal_attestation_id() const {
  return _impl_.attestation_id_.Get();
}
inline void EventWithdrawClaim::_internal_set_attestation_id(const std::string& value) {
  ;


  _impl_.attestation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventWithdrawClaim::_internal_mutable_attestation_id() {
  ;
  return _impl_.attestation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventWithdrawClaim::release_attestation_id() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventWithdrawClaim.attestation_id)
  return _impl_.attestation_id_.Release();
}
inline void EventWithdrawClaim::set_allocated_attestation_id(std::string* value) {
  _impl_.attestation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attestation_id_.IsDefault()) {
          _impl_.attestation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventWithdrawClaim.attestation_id)
}

// uint64 batch_nonce = 4 [json_name = "batchNonce"];
inline void EventWithdrawClaim::clear_batch_nonce() {
  _impl_.batch_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventWithdrawClaim::batch_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventWithdrawClaim.batch_nonce)
  return _internal_batch_nonce();
}
inline void EventWithdrawClaim::set_batch_nonce(::uint64_t value) {
  _internal_set_batch_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventWithdrawClaim.batch_nonce)
}
inline ::uint64_t EventWithdrawClaim::_internal_batch_nonce() const {
  return _impl_.batch_nonce_;
}
inline void EventWithdrawClaim::_internal_set_batch_nonce(::uint64_t value) {
  ;
  _impl_.batch_nonce_ = value;
}

// string token_contract = 5 [json_name = "tokenContract"];
inline void EventWithdrawClaim::clear_token_contract() {
  _impl_.token_contract_.ClearToEmpty();
}
inline const std::string& EventWithdrawClaim::token_contract() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventWithdrawClaim.token_contract)
  return _internal_token_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventWithdrawClaim::set_token_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventWithdrawClaim.token_contract)
}
inline std::string* EventWithdrawClaim::mutable_token_contract() {
  std::string* _s = _internal_mutable_token_contract();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventWithdrawClaim.token_contract)
  return _s;
}
inline const std::string& EventWithdrawClaim::_internal_token_contract() const {
  return _impl_.token_contract_.Get();
}
inline void EventWithdrawClaim::_internal_set_token_contract(const std::string& value) {
  ;


  _impl_.token_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* EventWithdrawClaim::_internal_mutable_token_contract() {
  ;
  return _impl_.token_contract_.Mutable( GetArenaForAllocation());
}
inline std::string* EventWithdrawClaim::release_token_contract() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventWithdrawClaim.token_contract)
  return _impl_.token_contract_.Release();
}
inline void EventWithdrawClaim::set_allocated_token_contract(std::string* value) {
  _impl_.token_contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_contract_.IsDefault()) {
          _impl_.token_contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventWithdrawClaim.token_contract)
}

// string orchestrator_address = 6 [json_name = "orchestratorAddress"];
inline void EventWithdrawClaim::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventWithdrawClaim::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventWithdrawClaim.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventWithdrawClaim::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventWithdrawClaim.orchestrator_address)
}
inline std::string* EventWithdrawClaim::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventWithdrawClaim.orchestrator_address)
  return _s;
}
inline const std::string& EventWithdrawClaim::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventWithdrawClaim::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventWithdrawClaim::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventWithdrawClaim::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventWithdrawClaim.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventWithdrawClaim::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventWithdrawClaim.orchestrator_address)
}

// -------------------------------------------------------------------

// EventERC20DeployedClaim

// uint64 event_nonce = 1 [json_name = "eventNonce"];
inline void EventERC20DeployedClaim::clear_event_nonce() {
  _impl_.event_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventERC20DeployedClaim::event_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.event_nonce)
  return _internal_event_nonce();
}
inline void EventERC20DeployedClaim::set_event_nonce(::uint64_t value) {
  _internal_set_event_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.event_nonce)
}
inline ::uint64_t EventERC20DeployedClaim::_internal_event_nonce() const {
  return _impl_.event_nonce_;
}
inline void EventERC20DeployedClaim::_internal_set_event_nonce(::uint64_t value) {
  ;
  _impl_.event_nonce_ = value;
}

// uint64 event_height = 2 [json_name = "eventHeight"];
inline void EventERC20DeployedClaim::clear_event_height() {
  _impl_.event_height_ = ::uint64_t{0u};
}
inline ::uint64_t EventERC20DeployedClaim::event_height() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.event_height)
  return _internal_event_height();
}
inline void EventERC20DeployedClaim::set_event_height(::uint64_t value) {
  _internal_set_event_height(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.event_height)
}
inline ::uint64_t EventERC20DeployedClaim::_internal_event_height() const {
  return _impl_.event_height_;
}
inline void EventERC20DeployedClaim::_internal_set_event_height(::uint64_t value) {
  ;
  _impl_.event_height_ = value;
}

// bytes attestation_id = 3 [json_name = "attestationId"];
inline void EventERC20DeployedClaim::clear_attestation_id() {
  _impl_.attestation_id_.ClearToEmpty();
}
inline const std::string& EventERC20DeployedClaim::attestation_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.attestation_id)
  return _internal_attestation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventERC20DeployedClaim::set_attestation_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.attestation_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.attestation_id)
}
inline std::string* EventERC20DeployedClaim::mutable_attestation_id() {
  std::string* _s = _internal_mutable_attestation_id();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventERC20DeployedClaim.attestation_id)
  return _s;
}
inline const std::string& EventERC20DeployedClaim::_internal_attestation_id() const {
  return _impl_.attestation_id_.Get();
}
inline void EventERC20DeployedClaim::_internal_set_attestation_id(const std::string& value) {
  ;


  _impl_.attestation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::_internal_mutable_attestation_id() {
  ;
  return _impl_.attestation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::release_attestation_id() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventERC20DeployedClaim.attestation_id)
  return _impl_.attestation_id_.Release();
}
inline void EventERC20DeployedClaim::set_allocated_attestation_id(std::string* value) {
  _impl_.attestation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attestation_id_.IsDefault()) {
          _impl_.attestation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventERC20DeployedClaim.attestation_id)
}

// string cosmos_denom = 4 [json_name = "cosmosDenom"];
inline void EventERC20DeployedClaim::clear_cosmos_denom() {
  _impl_.cosmos_denom_.ClearToEmpty();
}
inline const std::string& EventERC20DeployedClaim::cosmos_denom() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.cosmos_denom)
  return _internal_cosmos_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventERC20DeployedClaim::set_cosmos_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cosmos_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.cosmos_denom)
}
inline std::string* EventERC20DeployedClaim::mutable_cosmos_denom() {
  std::string* _s = _internal_mutable_cosmos_denom();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventERC20DeployedClaim.cosmos_denom)
  return _s;
}
inline const std::string& EventERC20DeployedClaim::_internal_cosmos_denom() const {
  return _impl_.cosmos_denom_.Get();
}
inline void EventERC20DeployedClaim::_internal_set_cosmos_denom(const std::string& value) {
  ;


  _impl_.cosmos_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::_internal_mutable_cosmos_denom() {
  ;
  return _impl_.cosmos_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::release_cosmos_denom() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventERC20DeployedClaim.cosmos_denom)
  return _impl_.cosmos_denom_.Release();
}
inline void EventERC20DeployedClaim::set_allocated_cosmos_denom(std::string* value) {
  _impl_.cosmos_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cosmos_denom_.IsDefault()) {
          _impl_.cosmos_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventERC20DeployedClaim.cosmos_denom)
}

// string token_contract = 5 [json_name = "tokenContract"];
inline void EventERC20DeployedClaim::clear_token_contract() {
  _impl_.token_contract_.ClearToEmpty();
}
inline const std::string& EventERC20DeployedClaim::token_contract() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.token_contract)
  return _internal_token_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventERC20DeployedClaim::set_token_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.token_contract)
}
inline std::string* EventERC20DeployedClaim::mutable_token_contract() {
  std::string* _s = _internal_mutable_token_contract();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventERC20DeployedClaim.token_contract)
  return _s;
}
inline const std::string& EventERC20DeployedClaim::_internal_token_contract() const {
  return _impl_.token_contract_.Get();
}
inline void EventERC20DeployedClaim::_internal_set_token_contract(const std::string& value) {
  ;


  _impl_.token_contract_.Set(value, GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::_internal_mutable_token_contract() {
  ;
  return _impl_.token_contract_.Mutable( GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::release_token_contract() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventERC20DeployedClaim.token_contract)
  return _impl_.token_contract_.Release();
}
inline void EventERC20DeployedClaim::set_allocated_token_contract(std::string* value) {
  _impl_.token_contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_contract_.IsDefault()) {
          _impl_.token_contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventERC20DeployedClaim.token_contract)
}

// string name = 6 [json_name = "name"];
inline void EventERC20DeployedClaim::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EventERC20DeployedClaim::name() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventERC20DeployedClaim::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.name)
}
inline std::string* EventERC20DeployedClaim::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventERC20DeployedClaim.name)
  return _s;
}
inline const std::string& EventERC20DeployedClaim::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EventERC20DeployedClaim::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::release_name() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventERC20DeployedClaim.name)
  return _impl_.name_.Release();
}
inline void EventERC20DeployedClaim::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventERC20DeployedClaim.name)
}

// string symbol = 7 [json_name = "symbol"];
inline void EventERC20DeployedClaim::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& EventERC20DeployedClaim::symbol() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventERC20DeployedClaim::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.symbol)
}
inline std::string* EventERC20DeployedClaim::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventERC20DeployedClaim.symbol)
  return _s;
}
inline const std::string& EventERC20DeployedClaim::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void EventERC20DeployedClaim::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::release_symbol() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventERC20DeployedClaim.symbol)
  return _impl_.symbol_.Release();
}
inline void EventERC20DeployedClaim::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventERC20DeployedClaim.symbol)
}

// uint64 decimals = 8 [json_name = "decimals"];
inline void EventERC20DeployedClaim::clear_decimals() {
  _impl_.decimals_ = ::uint64_t{0u};
}
inline ::uint64_t EventERC20DeployedClaim::decimals() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.decimals)
  return _internal_decimals();
}
inline void EventERC20DeployedClaim::set_decimals(::uint64_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.decimals)
}
inline ::uint64_t EventERC20DeployedClaim::_internal_decimals() const {
  return _impl_.decimals_;
}
inline void EventERC20DeployedClaim::_internal_set_decimals(::uint64_t value) {
  ;
  _impl_.decimals_ = value;
}

// string orchestrator_address = 9 [json_name = "orchestratorAddress"];
inline void EventERC20DeployedClaim::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventERC20DeployedClaim::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventERC20DeployedClaim.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventERC20DeployedClaim::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventERC20DeployedClaim.orchestrator_address)
}
inline std::string* EventERC20DeployedClaim::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventERC20DeployedClaim.orchestrator_address)
  return _s;
}
inline const std::string& EventERC20DeployedClaim::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventERC20DeployedClaim::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventERC20DeployedClaim::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventERC20DeployedClaim.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventERC20DeployedClaim::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventERC20DeployedClaim.orchestrator_address)
}

// -------------------------------------------------------------------

// EventValsetUpdateClaim

// uint64 event_nonce = 1 [json_name = "eventNonce"];
inline void EventValsetUpdateClaim::clear_event_nonce() {
  _impl_.event_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventValsetUpdateClaim::event_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.event_nonce)
  return _internal_event_nonce();
}
inline void EventValsetUpdateClaim::set_event_nonce(::uint64_t value) {
  _internal_set_event_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateClaim.event_nonce)
}
inline ::uint64_t EventValsetUpdateClaim::_internal_event_nonce() const {
  return _impl_.event_nonce_;
}
inline void EventValsetUpdateClaim::_internal_set_event_nonce(::uint64_t value) {
  ;
  _impl_.event_nonce_ = value;
}

// uint64 event_height = 2 [json_name = "eventHeight"];
inline void EventValsetUpdateClaim::clear_event_height() {
  _impl_.event_height_ = ::uint64_t{0u};
}
inline ::uint64_t EventValsetUpdateClaim::event_height() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.event_height)
  return _internal_event_height();
}
inline void EventValsetUpdateClaim::set_event_height(::uint64_t value) {
  _internal_set_event_height(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateClaim.event_height)
}
inline ::uint64_t EventValsetUpdateClaim::_internal_event_height() const {
  return _impl_.event_height_;
}
inline void EventValsetUpdateClaim::_internal_set_event_height(::uint64_t value) {
  ;
  _impl_.event_height_ = value;
}

// bytes attestation_id = 3 [json_name = "attestationId"];
inline void EventValsetUpdateClaim::clear_attestation_id() {
  _impl_.attestation_id_.ClearToEmpty();
}
inline const std::string& EventValsetUpdateClaim::attestation_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.attestation_id)
  return _internal_attestation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValsetUpdateClaim::set_attestation_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.attestation_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateClaim.attestation_id)
}
inline std::string* EventValsetUpdateClaim::mutable_attestation_id() {
  std::string* _s = _internal_mutable_attestation_id();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateClaim.attestation_id)
  return _s;
}
inline const std::string& EventValsetUpdateClaim::_internal_attestation_id() const {
  return _impl_.attestation_id_.Get();
}
inline void EventValsetUpdateClaim::_internal_set_attestation_id(const std::string& value) {
  ;


  _impl_.attestation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::_internal_mutable_attestation_id() {
  ;
  return _impl_.attestation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::release_attestation_id() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValsetUpdateClaim.attestation_id)
  return _impl_.attestation_id_.Release();
}
inline void EventValsetUpdateClaim::set_allocated_attestation_id(std::string* value) {
  _impl_.attestation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attestation_id_.IsDefault()) {
          _impl_.attestation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValsetUpdateClaim.attestation_id)
}

// uint64 valset_nonce = 4 [json_name = "valsetNonce"];
inline void EventValsetUpdateClaim::clear_valset_nonce() {
  _impl_.valset_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t EventValsetUpdateClaim::valset_nonce() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.valset_nonce)
  return _internal_valset_nonce();
}
inline void EventValsetUpdateClaim::set_valset_nonce(::uint64_t value) {
  _internal_set_valset_nonce(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateClaim.valset_nonce)
}
inline ::uint64_t EventValsetUpdateClaim::_internal_valset_nonce() const {
  return _impl_.valset_nonce_;
}
inline void EventValsetUpdateClaim::_internal_set_valset_nonce(::uint64_t value) {
  ;
  _impl_.valset_nonce_ = value;
}

// repeated .injective.peggy.v1.BridgeValidator valset_members = 5 [json_name = "valsetMembers"];
inline int EventValsetUpdateClaim::_internal_valset_members_size() const {
  return _impl_.valset_members_.size();
}
inline int EventValsetUpdateClaim::valset_members_size() const {
  return _internal_valset_members_size();
}
inline ::injective::peggy::v1::BridgeValidator* EventValsetUpdateClaim::mutable_valset_members(int index) {
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateClaim.valset_members)
  return _internal_mutable_valset_members()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >*
EventValsetUpdateClaim::mutable_valset_members() {
  // @@protoc_insertion_point(field_mutable_list:injective.peggy.v1.EventValsetUpdateClaim.valset_members)
  return _internal_mutable_valset_members();
}
inline const ::injective::peggy::v1::BridgeValidator& EventValsetUpdateClaim::_internal_valset_members(int index) const {
  return _internal_valset_members().Get(index);
}
inline const ::injective::peggy::v1::BridgeValidator& EventValsetUpdateClaim::valset_members(int index) const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.valset_members)
  return _internal_valset_members(index);
}
inline ::injective::peggy::v1::BridgeValidator* EventValsetUpdateClaim::_internal_add_valset_members() {
  return _internal_mutable_valset_members()->Add();
}
inline ::injective::peggy::v1::BridgeValidator* EventValsetUpdateClaim::add_valset_members() {
  ::injective::peggy::v1::BridgeValidator* _add = _internal_add_valset_members();
  // @@protoc_insertion_point(field_add:injective.peggy.v1.EventValsetUpdateClaim.valset_members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::peggy::v1::BridgeValidator >&
EventValsetUpdateClaim::valset_members() const {
  // @@protoc_insertion_point(field_list:injective.peggy.v1.EventValsetUpdateClaim.valset_members)
  return _internal_valset_members();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>&
EventValsetUpdateClaim::_internal_valset_members() const {
  return _impl_.valset_members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::peggy::v1::BridgeValidator>*
EventValsetUpdateClaim::_internal_mutable_valset_members() {
  return &_impl_.valset_members_;
}

// string reward_amount = 6 [json_name = "rewardAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
inline void EventValsetUpdateClaim::clear_reward_amount() {
  _impl_.reward_amount_.ClearToEmpty();
}
inline const std::string& EventValsetUpdateClaim::reward_amount() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.reward_amount)
  return _internal_reward_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValsetUpdateClaim::set_reward_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reward_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateClaim.reward_amount)
}
inline std::string* EventValsetUpdateClaim::mutable_reward_amount() {
  std::string* _s = _internal_mutable_reward_amount();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateClaim.reward_amount)
  return _s;
}
inline const std::string& EventValsetUpdateClaim::_internal_reward_amount() const {
  return _impl_.reward_amount_.Get();
}
inline void EventValsetUpdateClaim::_internal_set_reward_amount(const std::string& value) {
  ;


  _impl_.reward_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::_internal_mutable_reward_amount() {
  ;
  return _impl_.reward_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::release_reward_amount() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValsetUpdateClaim.reward_amount)
  return _impl_.reward_amount_.Release();
}
inline void EventValsetUpdateClaim::set_allocated_reward_amount(std::string* value) {
  _impl_.reward_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reward_amount_.IsDefault()) {
          _impl_.reward_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValsetUpdateClaim.reward_amount)
}

// string reward_token = 7 [json_name = "rewardToken"];
inline void EventValsetUpdateClaim::clear_reward_token() {
  _impl_.reward_token_.ClearToEmpty();
}
inline const std::string& EventValsetUpdateClaim::reward_token() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.reward_token)
  return _internal_reward_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValsetUpdateClaim::set_reward_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reward_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateClaim.reward_token)
}
inline std::string* EventValsetUpdateClaim::mutable_reward_token() {
  std::string* _s = _internal_mutable_reward_token();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateClaim.reward_token)
  return _s;
}
inline const std::string& EventValsetUpdateClaim::_internal_reward_token() const {
  return _impl_.reward_token_.Get();
}
inline void EventValsetUpdateClaim::_internal_set_reward_token(const std::string& value) {
  ;


  _impl_.reward_token_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::_internal_mutable_reward_token() {
  ;
  return _impl_.reward_token_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::release_reward_token() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValsetUpdateClaim.reward_token)
  return _impl_.reward_token_.Release();
}
inline void EventValsetUpdateClaim::set_allocated_reward_token(std::string* value) {
  _impl_.reward_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reward_token_.IsDefault()) {
          _impl_.reward_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValsetUpdateClaim.reward_token)
}

// string orchestrator_address = 8 [json_name = "orchestratorAddress"];
inline void EventValsetUpdateClaim::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& EventValsetUpdateClaim::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValsetUpdateClaim.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValsetUpdateClaim::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValsetUpdateClaim.orchestrator_address)
}
inline std::string* EventValsetUpdateClaim::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValsetUpdateClaim.orchestrator_address)
  return _s;
}
inline const std::string& EventValsetUpdateClaim::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void EventValsetUpdateClaim::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValsetUpdateClaim::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValsetUpdateClaim.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void EventValsetUpdateClaim::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValsetUpdateClaim.orchestrator_address)
}

// -------------------------------------------------------------------

// EventCancelSendToEth

// uint64 outgoing_tx_id = 1 [json_name = "outgoingTxId"];
inline void EventCancelSendToEth::clear_outgoing_tx_id() {
  _impl_.outgoing_tx_id_ = ::uint64_t{0u};
}
inline ::uint64_t EventCancelSendToEth::outgoing_tx_id() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventCancelSendToEth.outgoing_tx_id)
  return _internal_outgoing_tx_id();
}
inline void EventCancelSendToEth::set_outgoing_tx_id(::uint64_t value) {
  _internal_set_outgoing_tx_id(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventCancelSendToEth.outgoing_tx_id)
}
inline ::uint64_t EventCancelSendToEth::_internal_outgoing_tx_id() const {
  return _impl_.outgoing_tx_id_;
}
inline void EventCancelSendToEth::_internal_set_outgoing_tx_id(::uint64_t value) {
  ;
  _impl_.outgoing_tx_id_ = value;
}

// -------------------------------------------------------------------

// EventSubmitBadSignatureEvidence

// string bad_eth_signature = 1 [json_name = "badEthSignature"];
inline void EventSubmitBadSignatureEvidence::clear_bad_eth_signature() {
  _impl_.bad_eth_signature_.ClearToEmpty();
}
inline const std::string& EventSubmitBadSignatureEvidence::bad_eth_signature() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature)
  return _internal_bad_eth_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubmitBadSignatureEvidence::set_bad_eth_signature(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bad_eth_signature_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature)
}
inline std::string* EventSubmitBadSignatureEvidence::mutable_bad_eth_signature() {
  std::string* _s = _internal_mutable_bad_eth_signature();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature)
  return _s;
}
inline const std::string& EventSubmitBadSignatureEvidence::_internal_bad_eth_signature() const {
  return _impl_.bad_eth_signature_.Get();
}
inline void EventSubmitBadSignatureEvidence::_internal_set_bad_eth_signature(const std::string& value) {
  ;


  _impl_.bad_eth_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubmitBadSignatureEvidence::_internal_mutable_bad_eth_signature() {
  ;
  return _impl_.bad_eth_signature_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubmitBadSignatureEvidence::release_bad_eth_signature() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature)
  return _impl_.bad_eth_signature_.Release();
}
inline void EventSubmitBadSignatureEvidence::set_allocated_bad_eth_signature(std::string* value) {
  _impl_.bad_eth_signature_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bad_eth_signature_.IsDefault()) {
          _impl_.bad_eth_signature_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature)
}

// string bad_eth_signature_subject = 2 [json_name = "badEthSignatureSubject"];
inline void EventSubmitBadSignatureEvidence::clear_bad_eth_signature_subject() {
  _impl_.bad_eth_signature_subject_.ClearToEmpty();
}
inline const std::string& EventSubmitBadSignatureEvidence::bad_eth_signature_subject() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature_subject)
  return _internal_bad_eth_signature_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubmitBadSignatureEvidence::set_bad_eth_signature_subject(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bad_eth_signature_subject_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature_subject)
}
inline std::string* EventSubmitBadSignatureEvidence::mutable_bad_eth_signature_subject() {
  std::string* _s = _internal_mutable_bad_eth_signature_subject();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature_subject)
  return _s;
}
inline const std::string& EventSubmitBadSignatureEvidence::_internal_bad_eth_signature_subject() const {
  return _impl_.bad_eth_signature_subject_.Get();
}
inline void EventSubmitBadSignatureEvidence::_internal_set_bad_eth_signature_subject(const std::string& value) {
  ;


  _impl_.bad_eth_signature_subject_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubmitBadSignatureEvidence::_internal_mutable_bad_eth_signature_subject() {
  ;
  return _impl_.bad_eth_signature_subject_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubmitBadSignatureEvidence::release_bad_eth_signature_subject() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature_subject)
  return _impl_.bad_eth_signature_subject_.Release();
}
inline void EventSubmitBadSignatureEvidence::set_allocated_bad_eth_signature_subject(std::string* value) {
  _impl_.bad_eth_signature_subject_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bad_eth_signature_subject_.IsDefault()) {
          _impl_.bad_eth_signature_subject_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventSubmitBadSignatureEvidence.bad_eth_signature_subject)
}

// -------------------------------------------------------------------

// EventValidatorSlash

// int64 power = 1 [json_name = "power"];
inline void EventValidatorSlash::clear_power() {
  _impl_.power_ = ::int64_t{0};
}
inline ::int64_t EventValidatorSlash::power() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValidatorSlash.power)
  return _internal_power();
}
inline void EventValidatorSlash::set_power(::int64_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValidatorSlash.power)
}
inline ::int64_t EventValidatorSlash::_internal_power() const {
  return _impl_.power_;
}
inline void EventValidatorSlash::_internal_set_power(::int64_t value) {
  ;
  _impl_.power_ = value;
}

// string reason = 2 [json_name = "reason"];
inline void EventValidatorSlash::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& EventValidatorSlash::reason() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValidatorSlash.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValidatorSlash::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValidatorSlash.reason)
}
inline std::string* EventValidatorSlash::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValidatorSlash.reason)
  return _s;
}
inline const std::string& EventValidatorSlash::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void EventValidatorSlash::_internal_set_reason(const std::string& value) {
  ;


  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::_internal_mutable_reason() {
  ;
  return _impl_.reason_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::release_reason() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValidatorSlash.reason)
  return _impl_.reason_.Release();
}
inline void EventValidatorSlash::set_allocated_reason(std::string* value) {
  _impl_.reason_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValidatorSlash.reason)
}

// string consensus_address = 3 [json_name = "consensusAddress"];
inline void EventValidatorSlash::clear_consensus_address() {
  _impl_.consensus_address_.ClearToEmpty();
}
inline const std::string& EventValidatorSlash::consensus_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValidatorSlash.consensus_address)
  return _internal_consensus_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValidatorSlash::set_consensus_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.consensus_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValidatorSlash.consensus_address)
}
inline std::string* EventValidatorSlash::mutable_consensus_address() {
  std::string* _s = _internal_mutable_consensus_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValidatorSlash.consensus_address)
  return _s;
}
inline const std::string& EventValidatorSlash::_internal_consensus_address() const {
  return _impl_.consensus_address_.Get();
}
inline void EventValidatorSlash::_internal_set_consensus_address(const std::string& value) {
  ;


  _impl_.consensus_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::_internal_mutable_consensus_address() {
  ;
  return _impl_.consensus_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::release_consensus_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValidatorSlash.consensus_address)
  return _impl_.consensus_address_.Release();
}
inline void EventValidatorSlash::set_allocated_consensus_address(std::string* value) {
  _impl_.consensus_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.consensus_address_.IsDefault()) {
          _impl_.consensus_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValidatorSlash.consensus_address)
}

// string operator_address = 4 [json_name = "operatorAddress"];
inline void EventValidatorSlash::clear_operator_address() {
  _impl_.operator_address_.ClearToEmpty();
}
inline const std::string& EventValidatorSlash::operator_address() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValidatorSlash.operator_address)
  return _internal_operator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValidatorSlash::set_operator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValidatorSlash.operator_address)
}
inline std::string* EventValidatorSlash::mutable_operator_address() {
  std::string* _s = _internal_mutable_operator_address();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValidatorSlash.operator_address)
  return _s;
}
inline const std::string& EventValidatorSlash::_internal_operator_address() const {
  return _impl_.operator_address_.Get();
}
inline void EventValidatorSlash::_internal_set_operator_address(const std::string& value) {
  ;


  _impl_.operator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::_internal_mutable_operator_address() {
  ;
  return _impl_.operator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::release_operator_address() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValidatorSlash.operator_address)
  return _impl_.operator_address_.Release();
}
inline void EventValidatorSlash::set_allocated_operator_address(std::string* value) {
  _impl_.operator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_address_.IsDefault()) {
          _impl_.operator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValidatorSlash.operator_address)
}

// string moniker = 5 [json_name = "moniker"];
inline void EventValidatorSlash::clear_moniker() {
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& EventValidatorSlash::moniker() const {
  // @@protoc_insertion_point(field_get:injective.peggy.v1.EventValidatorSlash.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventValidatorSlash::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.peggy.v1.EventValidatorSlash.moniker)
}
inline std::string* EventValidatorSlash::mutable_moniker() {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:injective.peggy.v1.EventValidatorSlash.moniker)
  return _s;
}
inline const std::string& EventValidatorSlash::_internal_moniker() const {
  return _impl_.moniker_.Get();
}
inline void EventValidatorSlash::_internal_set_moniker(const std::string& value) {
  ;


  _impl_.moniker_.Set(value, GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::_internal_mutable_moniker() {
  ;
  return _impl_.moniker_.Mutable( GetArenaForAllocation());
}
inline std::string* EventValidatorSlash::release_moniker() {
  // @@protoc_insertion_point(field_release:injective.peggy.v1.EventValidatorSlash.moniker)
  return _impl_.moniker_.Release();
}
inline void EventValidatorSlash::set_allocated_moniker(std::string* value) {
  _impl_.moniker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.moniker_.IsDefault()) {
          _impl_.moniker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.peggy.v1.EventValidatorSlash.moniker)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace peggy
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2fpeggy_2fv1_2fevents_2eproto_2epb_2eh
