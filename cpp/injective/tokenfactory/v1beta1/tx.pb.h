// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/tokenfactory/v1beta1/tx.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmos/bank/v1beta1/bank.pb.h"
#include "cosmos/msg/v1/msg.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "injective/tokenfactory/v1beta1/params.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
namespace injective {
namespace tokenfactory {
namespace v1beta1 {
class MsgBurn;
struct MsgBurnDefaultTypeInternal;
extern MsgBurnDefaultTypeInternal _MsgBurn_default_instance_;
class MsgBurnResponse;
struct MsgBurnResponseDefaultTypeInternal;
extern MsgBurnResponseDefaultTypeInternal _MsgBurnResponse_default_instance_;
class MsgChangeAdmin;
struct MsgChangeAdminDefaultTypeInternal;
extern MsgChangeAdminDefaultTypeInternal _MsgChangeAdmin_default_instance_;
class MsgChangeAdminResponse;
struct MsgChangeAdminResponseDefaultTypeInternal;
extern MsgChangeAdminResponseDefaultTypeInternal _MsgChangeAdminResponse_default_instance_;
class MsgCreateDenom;
struct MsgCreateDenomDefaultTypeInternal;
extern MsgCreateDenomDefaultTypeInternal _MsgCreateDenom_default_instance_;
class MsgCreateDenomResponse;
struct MsgCreateDenomResponseDefaultTypeInternal;
extern MsgCreateDenomResponseDefaultTypeInternal _MsgCreateDenomResponse_default_instance_;
class MsgMint;
struct MsgMintDefaultTypeInternal;
extern MsgMintDefaultTypeInternal _MsgMint_default_instance_;
class MsgMintResponse;
struct MsgMintResponseDefaultTypeInternal;
extern MsgMintResponseDefaultTypeInternal _MsgMintResponse_default_instance_;
class MsgSetDenomMetadata;
struct MsgSetDenomMetadataDefaultTypeInternal;
extern MsgSetDenomMetadataDefaultTypeInternal _MsgSetDenomMetadata_default_instance_;
class MsgSetDenomMetadataResponse;
struct MsgSetDenomMetadataResponseDefaultTypeInternal;
extern MsgSetDenomMetadataResponseDefaultTypeInternal _MsgSetDenomMetadataResponse_default_instance_;
class MsgUpdateParams;
struct MsgUpdateParamsDefaultTypeInternal;
extern MsgUpdateParamsDefaultTypeInternal _MsgUpdateParams_default_instance_;
class MsgUpdateParamsResponse;
struct MsgUpdateParamsResponseDefaultTypeInternal;
extern MsgUpdateParamsResponseDefaultTypeInternal _MsgUpdateParamsResponse_default_instance_;
}  // namespace v1beta1
}  // namespace tokenfactory
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::tokenfactory::v1beta1::MsgBurn* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgBurn>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgBurnResponse* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgBurnResponse>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgChangeAdmin* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgChangeAdmin>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgChangeAdminResponse* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgChangeAdminResponse>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgCreateDenom* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgCreateDenom>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgCreateDenomResponse* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgCreateDenomResponse>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgMint* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgMint>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgMintResponse* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgMintResponse>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgSetDenomMetadata* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgSetDenomMetadata>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgSetDenomMetadataResponse* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgSetDenomMetadataResponse>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgUpdateParams* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgUpdateParams>(Arena*);
template <>
::injective::tokenfactory::v1beta1::MsgUpdateParamsResponse* Arena::CreateMaybeMessage<::injective::tokenfactory::v1beta1::MsgUpdateParamsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace tokenfactory {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class MsgCreateDenom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgCreateDenom) */ {
 public:
  inline MsgCreateDenom() : MsgCreateDenom(nullptr) {}
  ~MsgCreateDenom() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateDenom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateDenom(const MsgCreateDenom& from);
  MsgCreateDenom(MsgCreateDenom&& from) noexcept
    : MsgCreateDenom() {
    *this = ::std::move(from);
  }

  inline MsgCreateDenom& operator=(const MsgCreateDenom& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateDenom& operator=(MsgCreateDenom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateDenom& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateDenom* internal_default_instance() {
    return reinterpret_cast<const MsgCreateDenom*>(
               &_MsgCreateDenom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgCreateDenom& a, MsgCreateDenom& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateDenom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateDenom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateDenom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateDenom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateDenom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateDenom& from) {
    MsgCreateDenom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateDenom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgCreateDenom";
  }
  protected:
  explicit MsgCreateDenom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kSubdenomFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string subdenom = 2 [json_name = "subdenom", (.gogoproto.moretags) = "yaml:\"subdenom\""];
  void clear_subdenom() ;
  const std::string& subdenom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subdenom(Arg_&& arg, Args_... args);
  std::string* mutable_subdenom();
  PROTOBUF_NODISCARD std::string* release_subdenom();
  void set_allocated_subdenom(std::string* ptr);

  private:
  const std::string& _internal_subdenom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subdenom(
      const std::string& value);
  std::string* _internal_mutable_subdenom();

  public:
  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgCreateDenom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subdenom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateDenomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgCreateDenomResponse) */ {
 public:
  inline MsgCreateDenomResponse() : MsgCreateDenomResponse(nullptr) {}
  ~MsgCreateDenomResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateDenomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateDenomResponse(const MsgCreateDenomResponse& from);
  MsgCreateDenomResponse(MsgCreateDenomResponse&& from) noexcept
    : MsgCreateDenomResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateDenomResponse& operator=(const MsgCreateDenomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateDenomResponse& operator=(MsgCreateDenomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateDenomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateDenomResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateDenomResponse*>(
               &_MsgCreateDenomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgCreateDenomResponse& a, MsgCreateDenomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateDenomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateDenomResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateDenomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateDenomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateDenomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateDenomResponse& from) {
    MsgCreateDenomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateDenomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgCreateDenomResponse";
  }
  protected:
  explicit MsgCreateDenomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewTokenDenomFieldNumber = 1,
  };
  // string new_token_denom = 1 [json_name = "newTokenDenom", (.gogoproto.moretags) = "yaml:\"new_token_denom\""];
  void clear_new_token_denom() ;
  const std::string& new_token_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_token_denom(Arg_&& arg, Args_... args);
  std::string* mutable_new_token_denom();
  PROTOBUF_NODISCARD std::string* release_new_token_denom();
  void set_allocated_new_token_denom(std::string* ptr);

  private:
  const std::string& _internal_new_token_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_token_denom(
      const std::string& value);
  std::string* _internal_mutable_new_token_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgCreateDenomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_token_denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgMint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgMint) */ {
 public:
  inline MsgMint() : MsgMint(nullptr) {}
  ~MsgMint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgMint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgMint(const MsgMint& from);
  MsgMint(MsgMint&& from) noexcept
    : MsgMint() {
    *this = ::std::move(from);
  }

  inline MsgMint& operator=(const MsgMint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgMint& operator=(MsgMint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgMint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgMint* internal_default_instance() {
    return reinterpret_cast<const MsgMint*>(
               &_MsgMint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgMint& a, MsgMint& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgMint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgMint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgMint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgMint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgMint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgMint& from) {
    MsgMint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgMint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgMint";
  }
  protected:
  explicit MsgMint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .cosmos.base.v1beta1.Coin amount = 2 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"amount\""];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgMint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgMintResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgMintResponse) */ {
 public:
  inline MsgMintResponse() : MsgMintResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgMintResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgMintResponse(const MsgMintResponse& from);
  MsgMintResponse(MsgMintResponse&& from) noexcept
    : MsgMintResponse() {
    *this = ::std::move(from);
  }

  inline MsgMintResponse& operator=(const MsgMintResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgMintResponse& operator=(MsgMintResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgMintResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgMintResponse* internal_default_instance() {
    return reinterpret_cast<const MsgMintResponse*>(
               &_MsgMintResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgMintResponse& a, MsgMintResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgMintResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgMintResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgMintResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgMintResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgMintResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgMintResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgMintResponse";
  }
  protected:
  explicit MsgMintResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgMintResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBurn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgBurn) */ {
 public:
  inline MsgBurn() : MsgBurn(nullptr) {}
  ~MsgBurn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBurn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBurn(const MsgBurn& from);
  MsgBurn(MsgBurn&& from) noexcept
    : MsgBurn() {
    *this = ::std::move(from);
  }

  inline MsgBurn& operator=(const MsgBurn& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBurn& operator=(MsgBurn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBurn& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBurn* internal_default_instance() {
    return reinterpret_cast<const MsgBurn*>(
               &_MsgBurn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgBurn& a, MsgBurn& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBurn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBurn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBurn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBurn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBurn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBurn& from) {
    MsgBurn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBurn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgBurn";
  }
  protected:
  explicit MsgBurn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .cosmos.base.v1beta1.Coin amount = 2 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"amount\""];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgBurn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBurnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgBurnResponse) */ {
 public:
  inline MsgBurnResponse() : MsgBurnResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBurnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBurnResponse(const MsgBurnResponse& from);
  MsgBurnResponse(MsgBurnResponse&& from) noexcept
    : MsgBurnResponse() {
    *this = ::std::move(from);
  }

  inline MsgBurnResponse& operator=(const MsgBurnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBurnResponse& operator=(MsgBurnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBurnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBurnResponse* internal_default_instance() {
    return reinterpret_cast<const MsgBurnResponse*>(
               &_MsgBurnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgBurnResponse& a, MsgBurnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBurnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBurnResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBurnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBurnResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgBurnResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgBurnResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgBurnResponse";
  }
  protected:
  explicit MsgBurnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgBurnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChangeAdmin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgChangeAdmin) */ {
 public:
  inline MsgChangeAdmin() : MsgChangeAdmin(nullptr) {}
  ~MsgChangeAdmin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChangeAdmin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChangeAdmin(const MsgChangeAdmin& from);
  MsgChangeAdmin(MsgChangeAdmin&& from) noexcept
    : MsgChangeAdmin() {
    *this = ::std::move(from);
  }

  inline MsgChangeAdmin& operator=(const MsgChangeAdmin& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChangeAdmin& operator=(MsgChangeAdmin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChangeAdmin& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChangeAdmin* internal_default_instance() {
    return reinterpret_cast<const MsgChangeAdmin*>(
               &_MsgChangeAdmin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgChangeAdmin& a, MsgChangeAdmin& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChangeAdmin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChangeAdmin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChangeAdmin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChangeAdmin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChangeAdmin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChangeAdmin& from) {
    MsgChangeAdmin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChangeAdmin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgChangeAdmin";
  }
  protected:
  explicit MsgChangeAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kDenomFieldNumber = 2,
    kNewAdminFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string denom = 2 [json_name = "denom", (.gogoproto.moretags) = "yaml:\"denom\""];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string new_admin = 3 [json_name = "newAdmin", (.gogoproto.moretags) = "yaml:\"new_admin\""];
  void clear_new_admin() ;
  const std::string& new_admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_admin(Arg_&& arg, Args_... args);
  std::string* mutable_new_admin();
  PROTOBUF_NODISCARD std::string* release_new_admin();
  void set_allocated_new_admin(std::string* ptr);

  private:
  const std::string& _internal_new_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_admin(
      const std::string& value);
  std::string* _internal_mutable_new_admin();

  public:
  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgChangeAdmin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_admin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChangeAdminResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgChangeAdminResponse) */ {
 public:
  inline MsgChangeAdminResponse() : MsgChangeAdminResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChangeAdminResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChangeAdminResponse(const MsgChangeAdminResponse& from);
  MsgChangeAdminResponse(MsgChangeAdminResponse&& from) noexcept
    : MsgChangeAdminResponse() {
    *this = ::std::move(from);
  }

  inline MsgChangeAdminResponse& operator=(const MsgChangeAdminResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChangeAdminResponse& operator=(MsgChangeAdminResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChangeAdminResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChangeAdminResponse* internal_default_instance() {
    return reinterpret_cast<const MsgChangeAdminResponse*>(
               &_MsgChangeAdminResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgChangeAdminResponse& a, MsgChangeAdminResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChangeAdminResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChangeAdminResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChangeAdminResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChangeAdminResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgChangeAdminResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgChangeAdminResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgChangeAdminResponse";
  }
  protected:
  explicit MsgChangeAdminResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgChangeAdminResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSetDenomMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgSetDenomMetadata) */ {
 public:
  inline MsgSetDenomMetadata() : MsgSetDenomMetadata(nullptr) {}
  ~MsgSetDenomMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSetDenomMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSetDenomMetadata(const MsgSetDenomMetadata& from);
  MsgSetDenomMetadata(MsgSetDenomMetadata&& from) noexcept
    : MsgSetDenomMetadata() {
    *this = ::std::move(from);
  }

  inline MsgSetDenomMetadata& operator=(const MsgSetDenomMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSetDenomMetadata& operator=(MsgSetDenomMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSetDenomMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSetDenomMetadata* internal_default_instance() {
    return reinterpret_cast<const MsgSetDenomMetadata*>(
               &_MsgSetDenomMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MsgSetDenomMetadata& a, MsgSetDenomMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSetDenomMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSetDenomMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSetDenomMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSetDenomMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgSetDenomMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgSetDenomMetadata& from) {
    MsgSetDenomMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgSetDenomMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgSetDenomMetadata";
  }
  protected:
  explicit MsgSetDenomMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .cosmos.bank.v1beta1.Metadata metadata = 2 [json_name = "metadata", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"metadata\""];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::cosmos::bank::v1beta1::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::cosmos::bank::v1beta1::Metadata* release_metadata();
  ::cosmos::bank::v1beta1::Metadata* mutable_metadata();
  void set_allocated_metadata(::cosmos::bank::v1beta1::Metadata* metadata);
  private:
  const ::cosmos::bank::v1beta1::Metadata& _internal_metadata() const;
  ::cosmos::bank::v1beta1::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::cosmos::bank::v1beta1::Metadata* metadata);
  ::cosmos::bank::v1beta1::Metadata* unsafe_arena_release_metadata();
  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgSetDenomMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::cosmos::bank::v1beta1::Metadata* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSetDenomMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgSetDenomMetadataResponse) */ {
 public:
  inline MsgSetDenomMetadataResponse() : MsgSetDenomMetadataResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSetDenomMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSetDenomMetadataResponse(const MsgSetDenomMetadataResponse& from);
  MsgSetDenomMetadataResponse(MsgSetDenomMetadataResponse&& from) noexcept
    : MsgSetDenomMetadataResponse() {
    *this = ::std::move(from);
  }

  inline MsgSetDenomMetadataResponse& operator=(const MsgSetDenomMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSetDenomMetadataResponse& operator=(MsgSetDenomMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSetDenomMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSetDenomMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const MsgSetDenomMetadataResponse*>(
               &_MsgSetDenomMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MsgSetDenomMetadataResponse& a, MsgSetDenomMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSetDenomMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSetDenomMetadataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSetDenomMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSetDenomMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgSetDenomMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgSetDenomMetadataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgSetDenomMetadataResponse";
  }
  protected:
  explicit MsgSetDenomMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgSetDenomMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgUpdateParams) */ {
 public:
  inline MsgUpdateParams() : MsgUpdateParams(nullptr) {}
  ~MsgUpdateParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParams(const MsgUpdateParams& from);
  MsgUpdateParams(MsgUpdateParams&& from) noexcept
    : MsgUpdateParams() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParams& operator=(const MsgUpdateParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParams& operator=(MsgUpdateParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParams* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParams*>(
               &_MsgUpdateParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MsgUpdateParams& a, MsgUpdateParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgUpdateParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgUpdateParams& from) {
    MsgUpdateParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgUpdateParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgUpdateParams";
  }
  protected:
  explicit MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorityFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_authority() ;
  const std::string& authority() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_authority(Arg_&& arg, Args_... args);
  std::string* mutable_authority();
  PROTOBUF_NODISCARD std::string* release_authority();
  void set_allocated_authority(std::string* ptr);

  private:
  const std::string& _internal_authority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authority(
      const std::string& value);
  std::string* _internal_mutable_authority();

  public:
  // .injective.tokenfactory.v1beta1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
  bool has_params() const;
  void clear_params() ;
  const ::injective::tokenfactory::v1beta1::Params& params() const;
  PROTOBUF_NODISCARD ::injective::tokenfactory::v1beta1::Params* release_params();
  ::injective::tokenfactory::v1beta1::Params* mutable_params();
  void set_allocated_params(::injective::tokenfactory::v1beta1::Params* params);
  private:
  const ::injective::tokenfactory::v1beta1::Params& _internal_params() const;
  ::injective::tokenfactory::v1beta1::Params* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::injective::tokenfactory::v1beta1::Params* params);
  ::injective::tokenfactory::v1beta1::Params* unsafe_arena_release_params();
  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgUpdateParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authority_;
    ::injective::tokenfactory::v1beta1::Params* params_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateParamsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.tokenfactory.v1beta1.MsgUpdateParamsResponse) */ {
 public:
  inline MsgUpdateParamsResponse() : MsgUpdateParamsResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParamsResponse(const MsgUpdateParamsResponse& from);
  MsgUpdateParamsResponse(MsgUpdateParamsResponse&& from) noexcept
    : MsgUpdateParamsResponse() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParamsResponse& operator=(const MsgUpdateParamsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParamsResponse& operator=(MsgUpdateParamsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParamsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParamsResponse* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParamsResponse*>(
               &_MsgUpdateParamsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MsgUpdateParamsResponse& a, MsgUpdateParamsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParamsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParamsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.tokenfactory.v1beta1.MsgUpdateParamsResponse";
  }
  protected:
  explicit MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.tokenfactory.v1beta1.MsgUpdateParamsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MsgCreateDenom

// string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
inline void MsgCreateDenom::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateDenom::sender() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgCreateDenom.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateDenom::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgCreateDenom.sender)
}
inline std::string* MsgCreateDenom::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgCreateDenom.sender)
  return _s;
}
inline const std::string& MsgCreateDenom::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateDenom::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateDenom::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateDenom::release_sender() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgCreateDenom.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateDenom::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgCreateDenom.sender)
}

// string subdenom = 2 [json_name = "subdenom", (.gogoproto.moretags) = "yaml:\"subdenom\""];
inline void MsgCreateDenom::clear_subdenom() {
  _impl_.subdenom_.ClearToEmpty();
}
inline const std::string& MsgCreateDenom::subdenom() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgCreateDenom.subdenom)
  return _internal_subdenom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateDenom::set_subdenom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subdenom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgCreateDenom.subdenom)
}
inline std::string* MsgCreateDenom::mutable_subdenom() {
  std::string* _s = _internal_mutable_subdenom();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgCreateDenom.subdenom)
  return _s;
}
inline const std::string& MsgCreateDenom::_internal_subdenom() const {
  return _impl_.subdenom_.Get();
}
inline void MsgCreateDenom::_internal_set_subdenom(const std::string& value) {
  ;


  _impl_.subdenom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateDenom::_internal_mutable_subdenom() {
  ;
  return _impl_.subdenom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateDenom::release_subdenom() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgCreateDenom.subdenom)
  return _impl_.subdenom_.Release();
}
inline void MsgCreateDenom::set_allocated_subdenom(std::string* value) {
  _impl_.subdenom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subdenom_.IsDefault()) {
          _impl_.subdenom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgCreateDenom.subdenom)
}

// -------------------------------------------------------------------

// MsgCreateDenomResponse

// string new_token_denom = 1 [json_name = "newTokenDenom", (.gogoproto.moretags) = "yaml:\"new_token_denom\""];
inline void MsgCreateDenomResponse::clear_new_token_denom() {
  _impl_.new_token_denom_.ClearToEmpty();
}
inline const std::string& MsgCreateDenomResponse::new_token_denom() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgCreateDenomResponse.new_token_denom)
  return _internal_new_token_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateDenomResponse::set_new_token_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.new_token_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgCreateDenomResponse.new_token_denom)
}
inline std::string* MsgCreateDenomResponse::mutable_new_token_denom() {
  std::string* _s = _internal_mutable_new_token_denom();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgCreateDenomResponse.new_token_denom)
  return _s;
}
inline const std::string& MsgCreateDenomResponse::_internal_new_token_denom() const {
  return _impl_.new_token_denom_.Get();
}
inline void MsgCreateDenomResponse::_internal_set_new_token_denom(const std::string& value) {
  ;


  _impl_.new_token_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateDenomResponse::_internal_mutable_new_token_denom() {
  ;
  return _impl_.new_token_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateDenomResponse::release_new_token_denom() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgCreateDenomResponse.new_token_denom)
  return _impl_.new_token_denom_.Release();
}
inline void MsgCreateDenomResponse::set_allocated_new_token_denom(std::string* value) {
  _impl_.new_token_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_token_denom_.IsDefault()) {
          _impl_.new_token_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgCreateDenomResponse.new_token_denom)
}

// -------------------------------------------------------------------

// MsgMint

// string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
inline void MsgMint::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgMint::sender() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgMint.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgMint::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgMint.sender)
}
inline std::string* MsgMint::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgMint.sender)
  return _s;
}
inline const std::string& MsgMint::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgMint::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgMint::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgMint::release_sender() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgMint.sender)
  return _impl_.sender_.Release();
}
inline void MsgMint::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgMint.sender)
}

// .cosmos.base.v1beta1.Coin amount = 2 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"amount\""];
inline bool MsgMint::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgMint::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgMint::amount() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgMint.amount)
  return _internal_amount();
}
inline void MsgMint::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.tokenfactory.v1beta1.MsgMint.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgMint::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgMint::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgMint.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgMint::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgMint::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgMint.amount)
  return _msg;
}
inline void MsgMint::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgMint.amount)
}

// -------------------------------------------------------------------

// MsgMintResponse

// -------------------------------------------------------------------

// MsgBurn

// string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
inline void MsgBurn::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgBurn::sender() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgBurn.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBurn::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgBurn.sender)
}
inline std::string* MsgBurn::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgBurn.sender)
  return _s;
}
inline const std::string& MsgBurn::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgBurn::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBurn::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBurn::release_sender() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgBurn.sender)
  return _impl_.sender_.Release();
}
inline void MsgBurn::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgBurn.sender)
}

// .cosmos.base.v1beta1.Coin amount = 2 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"amount\""];
inline bool MsgBurn::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgBurn::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgBurn::amount() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgBurn.amount)
  return _internal_amount();
}
inline void MsgBurn::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.tokenfactory.v1beta1.MsgBurn.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgBurn::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgBurn::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgBurn.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgBurn::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgBurn::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgBurn.amount)
  return _msg;
}
inline void MsgBurn::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgBurn.amount)
}

// -------------------------------------------------------------------

// MsgBurnResponse

// -------------------------------------------------------------------

// MsgChangeAdmin

// string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
inline void MsgChangeAdmin::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgChangeAdmin::sender() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgChangeAdmin.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChangeAdmin::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgChangeAdmin.sender)
}
inline std::string* MsgChangeAdmin::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgChangeAdmin.sender)
  return _s;
}
inline const std::string& MsgChangeAdmin::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgChangeAdmin::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChangeAdmin::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChangeAdmin::release_sender() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgChangeAdmin.sender)
  return _impl_.sender_.Release();
}
inline void MsgChangeAdmin::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgChangeAdmin.sender)
}

// string denom = 2 [json_name = "denom", (.gogoproto.moretags) = "yaml:\"denom\""];
inline void MsgChangeAdmin::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& MsgChangeAdmin::denom() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgChangeAdmin.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChangeAdmin::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgChangeAdmin.denom)
}
inline std::string* MsgChangeAdmin::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgChangeAdmin.denom)
  return _s;
}
inline const std::string& MsgChangeAdmin::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void MsgChangeAdmin::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChangeAdmin::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChangeAdmin::release_denom() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgChangeAdmin.denom)
  return _impl_.denom_.Release();
}
inline void MsgChangeAdmin::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgChangeAdmin.denom)
}

// string new_admin = 3 [json_name = "newAdmin", (.gogoproto.moretags) = "yaml:\"new_admin\""];
inline void MsgChangeAdmin::clear_new_admin() {
  _impl_.new_admin_.ClearToEmpty();
}
inline const std::string& MsgChangeAdmin::new_admin() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgChangeAdmin.new_admin)
  return _internal_new_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChangeAdmin::set_new_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.new_admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgChangeAdmin.new_admin)
}
inline std::string* MsgChangeAdmin::mutable_new_admin() {
  std::string* _s = _internal_mutable_new_admin();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgChangeAdmin.new_admin)
  return _s;
}
inline const std::string& MsgChangeAdmin::_internal_new_admin() const {
  return _impl_.new_admin_.Get();
}
inline void MsgChangeAdmin::_internal_set_new_admin(const std::string& value) {
  ;


  _impl_.new_admin_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChangeAdmin::_internal_mutable_new_admin() {
  ;
  return _impl_.new_admin_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChangeAdmin::release_new_admin() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgChangeAdmin.new_admin)
  return _impl_.new_admin_.Release();
}
inline void MsgChangeAdmin::set_allocated_new_admin(std::string* value) {
  _impl_.new_admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_admin_.IsDefault()) {
          _impl_.new_admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgChangeAdmin.new_admin)
}

// -------------------------------------------------------------------

// MsgChangeAdminResponse

// -------------------------------------------------------------------

// MsgSetDenomMetadata

// string sender = 1 [json_name = "sender", (.gogoproto.moretags) = "yaml:\"sender\""];
inline void MsgSetDenomMetadata::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgSetDenomMetadata::sender() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSetDenomMetadata::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.sender)
}
inline std::string* MsgSetDenomMetadata::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.sender)
  return _s;
}
inline const std::string& MsgSetDenomMetadata::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgSetDenomMetadata::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSetDenomMetadata::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSetDenomMetadata::release_sender() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.sender)
  return _impl_.sender_.Release();
}
inline void MsgSetDenomMetadata::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.sender)
}

// .cosmos.bank.v1beta1.Metadata metadata = 2 [json_name = "metadata", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"metadata\""];
inline bool MsgSetDenomMetadata::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::cosmos::bank::v1beta1::Metadata& MsgSetDenomMetadata::_internal_metadata() const {
  const ::cosmos::bank::v1beta1::Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::bank::v1beta1::Metadata&>(
      ::cosmos::bank::v1beta1::_Metadata_default_instance_);
}
inline const ::cosmos::bank::v1beta1::Metadata& MsgSetDenomMetadata::metadata() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.metadata)
  return _internal_metadata();
}
inline void MsgSetDenomMetadata::unsafe_arena_set_allocated_metadata(
    ::cosmos::bank::v1beta1::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.metadata)
}
inline ::cosmos::bank::v1beta1::Metadata* MsgSetDenomMetadata::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::bank::v1beta1::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::bank::v1beta1::Metadata* MsgSetDenomMetadata::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::bank::v1beta1::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::cosmos::bank::v1beta1::Metadata* MsgSetDenomMetadata::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::bank::v1beta1::Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::cosmos::bank::v1beta1::Metadata* MsgSetDenomMetadata::mutable_metadata() {
  ::cosmos::bank::v1beta1::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.metadata)
  return _msg;
}
inline void MsgSetDenomMetadata::set_allocated_metadata(::cosmos::bank::v1beta1::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgSetDenomMetadata.metadata)
}

// -------------------------------------------------------------------

// MsgSetDenomMetadataResponse

// -------------------------------------------------------------------

// MsgUpdateParams

// string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void MsgUpdateParams::clear_authority() {
  _impl_.authority_.ClearToEmpty();
}
inline const std::string& MsgUpdateParams::authority() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgUpdateParams.authority)
  return _internal_authority();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateParams::set_authority(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.authority_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.tokenfactory.v1beta1.MsgUpdateParams.authority)
}
inline std::string* MsgUpdateParams::mutable_authority() {
  std::string* _s = _internal_mutable_authority();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgUpdateParams.authority)
  return _s;
}
inline const std::string& MsgUpdateParams::_internal_authority() const {
  return _impl_.authority_.Get();
}
inline void MsgUpdateParams::_internal_set_authority(const std::string& value) {
  ;


  _impl_.authority_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::_internal_mutable_authority() {
  ;
  return _impl_.authority_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::release_authority() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgUpdateParams.authority)
  return _impl_.authority_.Release();
}
inline void MsgUpdateParams::set_allocated_authority(std::string* value) {
  _impl_.authority_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.authority_.IsDefault()) {
          _impl_.authority_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgUpdateParams.authority)
}

// .injective.tokenfactory.v1beta1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
inline bool MsgUpdateParams::has_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline const ::injective::tokenfactory::v1beta1::Params& MsgUpdateParams::_internal_params() const {
  const ::injective::tokenfactory::v1beta1::Params* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::tokenfactory::v1beta1::Params&>(
      ::injective::tokenfactory::v1beta1::_Params_default_instance_);
}
inline const ::injective::tokenfactory::v1beta1::Params& MsgUpdateParams::params() const {
  // @@protoc_insertion_point(field_get:injective.tokenfactory.v1beta1.MsgUpdateParams.params)
  return _internal_params();
}
inline void MsgUpdateParams::unsafe_arena_set_allocated_params(
    ::injective::tokenfactory::v1beta1::Params* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.tokenfactory.v1beta1.MsgUpdateParams.params)
}
inline ::injective::tokenfactory::v1beta1::Params* MsgUpdateParams::release_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::tokenfactory::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::tokenfactory::v1beta1::Params* MsgUpdateParams::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:injective.tokenfactory.v1beta1.MsgUpdateParams.params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::tokenfactory::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::injective::tokenfactory::v1beta1::Params* MsgUpdateParams::_internal_mutable_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::tokenfactory::v1beta1::Params>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::injective::tokenfactory::v1beta1::Params* MsgUpdateParams::mutable_params() {
  ::injective::tokenfactory::v1beta1::Params* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:injective.tokenfactory.v1beta1.MsgUpdateParams.params)
  return _msg;
}
inline void MsgUpdateParams::set_allocated_params(::injective::tokenfactory::v1beta1::Params* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:injective.tokenfactory.v1beta1.MsgUpdateParams.params)
}

// -------------------------------------------------------------------

// MsgUpdateParamsResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace tokenfactory
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2ftokenfactory_2fv1beta1_2ftx_2eproto_2epb_2eh
