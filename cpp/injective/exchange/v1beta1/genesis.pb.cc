// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/exchange/v1beta1/genesis.proto

#include "injective/exchange/v1beta1/genesis.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace injective {
namespace exchange {
namespace v1beta1 {
template <typename>
PROTOBUF_CONSTEXPR GenesisState::GenesisState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.spot_markets_)*/{}
  , /*decltype(_impl_.derivative_markets_)*/{}
  , /*decltype(_impl_.spot_orderbook_)*/{}
  , /*decltype(_impl_.derivative_orderbook_)*/{}
  , /*decltype(_impl_.balances_)*/{}
  , /*decltype(_impl_.positions_)*/{}
  , /*decltype(_impl_.subaccount_trade_nonces_)*/{}
  , /*decltype(_impl_.expiry_futures_market_info_state_)*/{}
  , /*decltype(_impl_.perpetual_market_info_)*/{}
  , /*decltype(_impl_.perpetual_market_funding_state_)*/{}
  , /*decltype(_impl_.derivative_market_settlement_scheduled_)*/{}
  , /*decltype(_impl_.trading_reward_pool_campaign_schedule_)*/{}
  , /*decltype(_impl_.trading_reward_campaign_account_points_)*/{}
  , /*decltype(_impl_.fee_discount_account_tier_ttl_)*/{}
  , /*decltype(_impl_.fee_discount_bucket_volume_accounts_)*/{}
  , /*decltype(_impl_.pending_trading_reward_pool_campaign_schedule_)*/{}
  , /*decltype(_impl_.pending_trading_reward_campaign_account_points_)*/{}
  , /*decltype(_impl_.rewards_opt_out_addresses_)*/{}
  , /*decltype(_impl_.historical_trade_records_)*/{}
  , /*decltype(_impl_.binary_options_markets_)*/{}
  , /*decltype(_impl_.binary_options_market_ids_scheduled_for_settlement_)*/{}
  , /*decltype(_impl_.spot_market_ids_scheduled_to_force_close_)*/{}
  , /*decltype(_impl_.denom_decimals_)*/{}
  , /*decltype(_impl_.conditional_derivative_orderbooks_)*/{}
  , /*decltype(_impl_.market_fee_multipliers_)*/{}
  , /*decltype(_impl_.orderbook_sequences_)*/{}
  , /*decltype(_impl_.subaccount_volumes_)*/{}
  , /*decltype(_impl_.market_volumes_)*/{}
  , /*decltype(_impl_.params_)*/nullptr
  , /*decltype(_impl_.trading_reward_campaign_info_)*/nullptr
  , /*decltype(_impl_.fee_discount_schedule_)*/nullptr
  , /*decltype(_impl_.is_spot_exchange_enabled_)*/ false

  , /*decltype(_impl_.is_derivatives_exchange_enabled_)*/ false

  , /*decltype(_impl_.is_first_fee_cycle_finished_)*/ false
} {}
struct GenesisStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenesisStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenesisStateDefaultTypeInternal() {}
  union {
    GenesisState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenesisStateDefaultTypeInternal _GenesisState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbookSequence::OrderbookSequence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.sequence_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbookSequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookSequenceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookSequenceDefaultTypeInternal() {}
  union {
    OrderbookSequence _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookSequenceDefaultTypeInternal _OrderbookSequence_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeeDiscountAccountTierTTL::FeeDiscountAccountTierTTL(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.tier_ttl_)*/nullptr} {}
struct FeeDiscountAccountTierTTLDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeDiscountAccountTierTTLDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeDiscountAccountTierTTLDefaultTypeInternal() {}
  union {
    FeeDiscountAccountTierTTL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeDiscountAccountTierTTLDefaultTypeInternal _FeeDiscountAccountTierTTL_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeeDiscountBucketVolumeAccounts::FeeDiscountBucketVolumeAccounts(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_volume_)*/{}
  , /*decltype(_impl_.bucket_start_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeDiscountBucketVolumeAccountsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeDiscountBucketVolumeAccountsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeDiscountBucketVolumeAccountsDefaultTypeInternal() {}
  union {
    FeeDiscountBucketVolumeAccounts _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeDiscountBucketVolumeAccountsDefaultTypeInternal _FeeDiscountBucketVolumeAccounts_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AccountVolume::AccountVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.volume_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountVolumeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountVolumeDefaultTypeInternal() {}
  union {
    AccountVolume _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountVolumeDefaultTypeInternal _AccountVolume_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradingRewardCampaignAccountPoints::TradingRewardCampaignAccountPoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.points_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TradingRewardCampaignAccountPointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradingRewardCampaignAccountPointsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradingRewardCampaignAccountPointsDefaultTypeInternal() {}
  union {
    TradingRewardCampaignAccountPoints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradingRewardCampaignAccountPointsDefaultTypeInternal _TradingRewardCampaignAccountPoints_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradingRewardCampaignAccountPendingPoints::TradingRewardCampaignAccountPendingPoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_points_)*/{}
  , /*decltype(_impl_.reward_pool_start_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TradingRewardCampaignAccountPendingPointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradingRewardCampaignAccountPendingPointsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradingRewardCampaignAccountPendingPointsDefaultTypeInternal() {}
  union {
    TradingRewardCampaignAccountPendingPoints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradingRewardCampaignAccountPendingPointsDefaultTypeInternal _TradingRewardCampaignAccountPendingPoints_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotOrderBook::SpotOrderBook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.isbuyside_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpotOrderBookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotOrderBookDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotOrderBookDefaultTypeInternal() {}
  union {
    SpotOrderBook _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotOrderBookDefaultTypeInternal _SpotOrderBook_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeOrderBook::DerivativeOrderBook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.isbuyside_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DerivativeOrderBookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeOrderBookDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeOrderBookDefaultTypeInternal() {}
  union {
    DerivativeOrderBook _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeOrderBookDefaultTypeInternal _DerivativeOrderBook_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ConditionalDerivativeOrderBook::ConditionalDerivativeOrderBook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.limit_buy_orders_)*/{}
  , /*decltype(_impl_.market_buy_orders_)*/{}
  , /*decltype(_impl_.limit_sell_orders_)*/{}
  , /*decltype(_impl_.market_sell_orders_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConditionalDerivativeOrderBookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConditionalDerivativeOrderBookDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConditionalDerivativeOrderBookDefaultTypeInternal() {}
  union {
    ConditionalDerivativeOrderBook _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConditionalDerivativeOrderBookDefaultTypeInternal _ConditionalDerivativeOrderBook_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Balance::Balance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deposits_)*/nullptr} {}
struct BalanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BalanceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BalanceDefaultTypeInternal() {}
  union {
    Balance _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BalanceDefaultTypeInternal _Balance_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativePosition::DerivativePosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.position_)*/nullptr} {}
struct DerivativePositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativePositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativePositionDefaultTypeInternal() {}
  union {
    DerivativePosition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativePositionDefaultTypeInternal _DerivativePosition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountNonce::SubaccountNonce(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_trade_nonce_)*/nullptr} {}
struct SubaccountNonceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountNonceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountNonceDefaultTypeInternal() {}
  union {
    SubaccountNonce _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountNonceDefaultTypeInternal _SubaccountNonce_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ExpiryFuturesMarketInfoState::ExpiryFuturesMarketInfoState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_info_)*/nullptr} {}
struct ExpiryFuturesMarketInfoStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpiryFuturesMarketInfoStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpiryFuturesMarketInfoStateDefaultTypeInternal() {}
  union {
    ExpiryFuturesMarketInfoState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpiryFuturesMarketInfoStateDefaultTypeInternal _ExpiryFuturesMarketInfoState_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PerpetualMarketFundingState::PerpetualMarketFundingState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.funding_)*/nullptr} {}
struct PerpetualMarketFundingStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PerpetualMarketFundingStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PerpetualMarketFundingStateDefaultTypeInternal() {}
  union {
    PerpetualMarketFundingState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PerpetualMarketFundingStateDefaultTypeInternal _PerpetualMarketFundingState_default_instance_;
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
static ::_pb::Metadata file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[15];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fgenesis_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_injective_2fexchange_2fv1beta1_2fgenesis_2eproto = nullptr;
const ::uint32_t TableStruct_injective_2fexchange_2fv1beta1_2fgenesis_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.params_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.spot_markets_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.derivative_markets_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.spot_orderbook_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.derivative_orderbook_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.balances_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.positions_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.subaccount_trade_nonces_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.expiry_futures_market_info_state_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.perpetual_market_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.perpetual_market_funding_state_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.derivative_market_settlement_scheduled_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.is_spot_exchange_enabled_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.is_derivatives_exchange_enabled_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.trading_reward_campaign_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.trading_reward_pool_campaign_schedule_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.trading_reward_campaign_account_points_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.fee_discount_schedule_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.fee_discount_account_tier_ttl_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.fee_discount_bucket_volume_accounts_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.is_first_fee_cycle_finished_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.pending_trading_reward_pool_campaign_schedule_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.pending_trading_reward_campaign_account_points_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.rewards_opt_out_addresses_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.historical_trade_records_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.binary_options_markets_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.binary_options_market_ids_scheduled_for_settlement_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.spot_market_ids_scheduled_to_force_close_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.denom_decimals_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.conditional_derivative_orderbooks_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.market_fee_multipliers_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.orderbook_sequences_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.subaccount_volumes_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::GenesisState, _impl_.market_volumes_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
    ~0u,
    ~0u,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderbookSequence, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderbookSequence, _impl_.sequence_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderbookSequence, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountAccountTierTTL, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountAccountTierTTL, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountAccountTierTTL, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountAccountTierTTL, _impl_.tier_ttl_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountBucketVolumeAccounts, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountBucketVolumeAccounts, _impl_.bucket_start_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountBucketVolumeAccounts, _impl_.account_volume_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AccountVolume, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AccountVolume, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AccountVolume, _impl_.volume_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignAccountPoints, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignAccountPoints, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignAccountPoints, _impl_.points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignAccountPendingPoints, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignAccountPendingPoints, _impl_.reward_pool_start_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignAccountPendingPoints, _impl_.account_points_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrderBook, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrderBook, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrderBook, _impl_.isbuyside_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrderBook, _impl_.orders_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrderBook, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrderBook, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrderBook, _impl_.isbuyside_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrderBook, _impl_.orders_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ConditionalDerivativeOrderBook, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ConditionalDerivativeOrderBook, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ConditionalDerivativeOrderBook, _impl_.limit_buy_orders_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ConditionalDerivativeOrderBook, _impl_.market_buy_orders_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ConditionalDerivativeOrderBook, _impl_.limit_sell_orders_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ConditionalDerivativeOrderBook, _impl_.market_sell_orders_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Balance, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Balance, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Balance, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Balance, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Balance, _impl_.deposits_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativePosition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativePosition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativePosition, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativePosition, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativePosition, _impl_.position_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountNonce, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountNonce, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountNonce, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountNonce, _impl_.subaccount_trade_nonce_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState, _impl_.market_info_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFundingState, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFundingState, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFundingState, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFundingState, _impl_.funding_),
    ~0u,
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 42, -1, sizeof(::injective::exchange::v1beta1::GenesisState)},
        { 76, -1, -1, sizeof(::injective::exchange::v1beta1::OrderbookSequence)},
        { 86, 96, -1, sizeof(::injective::exchange::v1beta1::FeeDiscountAccountTierTTL)},
        { 98, -1, -1, sizeof(::injective::exchange::v1beta1::FeeDiscountBucketVolumeAccounts)},
        { 108, -1, -1, sizeof(::injective::exchange::v1beta1::AccountVolume)},
        { 118, -1, -1, sizeof(::injective::exchange::v1beta1::TradingRewardCampaignAccountPoints)},
        { 128, -1, -1, sizeof(::injective::exchange::v1beta1::TradingRewardCampaignAccountPendingPoints)},
        { 138, -1, -1, sizeof(::injective::exchange::v1beta1::SpotOrderBook)},
        { 149, -1, -1, sizeof(::injective::exchange::v1beta1::DerivativeOrderBook)},
        { 160, -1, -1, sizeof(::injective::exchange::v1beta1::ConditionalDerivativeOrderBook)},
        { 173, 184, -1, sizeof(::injective::exchange::v1beta1::Balance)},
        { 187, 198, -1, sizeof(::injective::exchange::v1beta1::DerivativePosition)},
        { 201, 211, -1, sizeof(::injective::exchange::v1beta1::SubaccountNonce)},
        { 213, 223, -1, sizeof(::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState)},
        { 225, 235, -1, sizeof(::injective::exchange::v1beta1::PerpetualMarketFundingState)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::injective::exchange::v1beta1::_GenesisState_default_instance_._instance,
    &::injective::exchange::v1beta1::_OrderbookSequence_default_instance_._instance,
    &::injective::exchange::v1beta1::_FeeDiscountAccountTierTTL_default_instance_._instance,
    &::injective::exchange::v1beta1::_FeeDiscountBucketVolumeAccounts_default_instance_._instance,
    &::injective::exchange::v1beta1::_AccountVolume_default_instance_._instance,
    &::injective::exchange::v1beta1::_TradingRewardCampaignAccountPoints_default_instance_._instance,
    &::injective::exchange::v1beta1::_TradingRewardCampaignAccountPendingPoints_default_instance_._instance,
    &::injective::exchange::v1beta1::_SpotOrderBook_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeOrderBook_default_instance_._instance,
    &::injective::exchange::v1beta1::_ConditionalDerivativeOrderBook_default_instance_._instance,
    &::injective::exchange::v1beta1::_Balance_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativePosition_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountNonce_default_instance_._instance,
    &::injective::exchange::v1beta1::_ExpiryFuturesMarketInfoState_default_instance_._instance,
    &::injective::exchange::v1beta1::_PerpetualMarketFundingState_default_instance_._instance,
};
const char descriptor_table_protodef_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n(injective/exchange/v1beta1/genesis.pro"
    "to\022\032injective.exchange.v1beta1\032)injectiv"
    "e/exchange/v1beta1/exchange.proto\032#injec"
    "tive/exchange/v1beta1/tx.proto\032\024gogoprot"
    "o/gogo.proto\"\361\033\n\014GenesisState\022@\n\006params\030"
    "\001 \001(\0132\".injective.exchange.v1beta1.Param"
    "sB\004\310\336\037\000R\006params\022I\n\014spot_markets\030\002 \003(\0132&."
    "injective.exchange.v1beta1.SpotMarketR\013s"
    "potMarkets\022[\n\022derivative_markets\030\003 \003(\0132,"
    ".injective.exchange.v1beta1.DerivativeMa"
    "rketR\021derivativeMarkets\022V\n\016spot_orderboo"
    "k\030\004 \003(\0132).injective.exchange.v1beta1.Spo"
    "tOrderBookB\004\310\336\037\000R\rspotOrderbook\022h\n\024deriv"
    "ative_orderbook\030\005 \003(\0132/.injective.exchan"
    "ge.v1beta1.DerivativeOrderBookB\004\310\336\037\000R\023de"
    "rivativeOrderbook\022E\n\010balances\030\006 \003(\0132#.in"
    "jective.exchange.v1beta1.BalanceB\004\310\336\037\000R\010"
    "balances\022R\n\tpositions\030\007 \003(\0132..injective."
    "exchange.v1beta1.DerivativePositionB\004\310\336\037"
    "\000R\tpositions\022i\n\027subaccount_trade_nonces\030"
    "\010 \003(\0132+.injective.exchange.v1beta1.Subac"
    "countNonceB\004\310\336\037\000R\025subaccountTradeNonces\022"
    "\206\001\n expiry_futures_market_info_state\030\t \003"
    "(\01328.injective.exchange.v1beta1.ExpiryFu"
    "turesMarketInfoStateB\004\310\336\037\000R\034expiryFuture"
    "sMarketInfoState\022i\n\025perpetual_market_inf"
    "o\030\n \003(\0132/.injective.exchange.v1beta1.Per"
    "petualMarketInfoB\004\310\336\037\000R\023perpetualMarketI"
    "nfo\022\202\001\n\036perpetual_market_funding_state\030\013"
    " \003(\01327.injective.exchange.v1beta1.Perpet"
    "ualMarketFundingStateB\004\310\336\037\000R\033perpetualMa"
    "rketFundingState\022\225\001\n&derivative_market_s"
    "ettlement_scheduled\030\014 \003(\0132:.injective.ex"
    "change.v1beta1.DerivativeMarketSettlemen"
    "tInfoB\004\310\336\037\000R#derivativeMarketSettlementS"
    "cheduled\0227\n\030is_spot_exchange_enabled\030\r \001"
    "(\010R\025isSpotExchangeEnabled\022E\n\037is_derivati"
    "ves_exchange_enabled\030\016 \001(\010R\034isDerivative"
    "sExchangeEnabled\022v\n\034trading_reward_campa"
    "ign_info\030\017 \001(\01325.injective.exchange.v1be"
    "ta1.TradingRewardCampaignInfoR\031tradingRe"
    "wardCampaignInfo\022\200\001\n%trading_reward_pool"
    "_campaign_schedule\030\020 \003(\0132..injective.exc"
    "hange.v1beta1.CampaignRewardPoolR!tradin"
    "gRewardPoolCampaignSchedule\022\222\001\n&trading_"
    "reward_campaign_account_points\030\021 \003(\0132>.i"
    "njective.exchange.v1beta1.TradingRewardC"
    "ampaignAccountPointsR\"tradingRewardCampa"
    "ignAccountPoints\022c\n\025fee_discount_schedul"
    "e\030\022 \001(\0132/.injective.exchange.v1beta1.Fee"
    "DiscountScheduleR\023feeDiscountSchedule\022w\n"
    "\035fee_discount_account_tier_ttl\030\023 \003(\01325.i"
    "njective.exchange.v1beta1.FeeDiscountAcc"
    "ountTierTTLR\031feeDiscountAccountTierTtl\022\211"
    "\001\n#fee_discount_bucket_volume_accounts\030\024"
    " \003(\0132;.injective.exchange.v1beta1.FeeDis"
    "countBucketVolumeAccountsR\037feeDiscountBu"
    "cketVolumeAccounts\022<\n\033is_first_fee_cycle"
    "_finished\030\025 \001(\010R\027isFirstFeeCycleFinished"
    "\022\217\001\n-pending_trading_reward_pool_campaig"
    "n_schedule\030\026 \003(\0132..injective.exchange.v1"
    "beta1.CampaignRewardPoolR(pendingTrading"
    "RewardPoolCampaignSchedule\022\250\001\n.pending_t"
    "rading_reward_campaign_account_points\030\027 "
    "\003(\0132E.injective.exchange.v1beta1.Trading"
    "RewardCampaignAccountPendingPointsR)pend"
    "ingTradingRewardCampaignAccountPoints\0229\n"
    "\031rewards_opt_out_addresses\030\030 \003(\tR\026reward"
    "sOptOutAddresses\022b\n\030historical_trade_rec"
    "ords\030\031 \003(\0132(.injective.exchange.v1beta1."
    "TradeRecordsR\026historicalTradeRecords\022e\n\026"
    "binary_options_markets\030\032 \003(\0132/.injective"
    ".exchange.v1beta1.BinaryOptionsMarketR\024b"
    "inaryOptionsMarkets\022h\n2binary_options_ma"
    "rket_ids_scheduled_for_settlement\030\033 \003(\tR"
    ",binaryOptionsMarketIdsScheduledForSettl"
    "ement\022T\n(spot_market_ids_scheduled_to_fo"
    "rce_close\030\034 \003(\tR\"spotMarketIdsScheduledT"
    "oForceClose\022V\n\016denom_decimals\030\035 \003(\0132).in"
    "jective.exchange.v1beta1.DenomDecimalsB\004"
    "\310\336\037\000R\rdenomDecimals\022\206\001\n!conditional_deri"
    "vative_orderbooks\030\036 \003(\0132:.injective.exch"
    "ange.v1beta1.ConditionalDerivativeOrderB"
    "ookR\037conditionalDerivativeOrderbooks\022e\n\026"
    "market_fee_multipliers\030\037 \003(\0132/.injective"
    ".exchange.v1beta1.MarketFeeMultiplierR\024m"
    "arketFeeMultipliers\022^\n\023orderbook_sequenc"
    "es\030  \003(\0132-.injective.exchange.v1beta1.Or"
    "derbookSequenceR\022orderbookSequences\022j\n\022s"
    "ubaccount_volumes\030! \003(\0132;.injective.exch"
    "ange.v1beta1.AggregateSubaccountVolumeRe"
    "cordR\021subaccountVolumes\022O\n\016market_volume"
    "s\030\" \003(\0132(.injective.exchange.v1beta1.Mar"
    "ketVolumeR\rmarketVolumes\"L\n\021OrderbookSeq"
    "uence\022\032\n\010sequence\030\001 \001(\004R\010sequence\022\033\n\tmar"
    "ket_id\030\002 \001(\tR\010marketId\"\200\001\n\031FeeDiscountAc"
    "countTierTTL\022\030\n\007account\030\001 \001(\tR\007account\022I"
    "\n\010tier_ttl\030\002 \001(\0132..injective.exchange.v1"
    "beta1.FeeDiscountTierTTLR\007tierTtl\"\251\001\n\037Fe"
    "eDiscountBucketVolumeAccounts\0224\n\026bucket_"
    "start_timestamp\030\001 \001(\003R\024bucketStartTimest"
    "amp\022P\n\016account_volume\030\002 \003(\0132).injective."
    "exchange.v1beta1.AccountVolumeR\raccountV"
    "olume\"q\n\rAccountVolume\022\030\n\007account\030\001 \001(\tR"
    "\007account\022F\n\006volume\030\002 \001(\tB.\310\336\037\000\332\336\037&github"
    ".com/cosmos/cosmos-sdk/types.DecR\006volume"
    "\"\206\001\n\"TradingRewardCampaignAccountPoints\022"
    "\030\n\007account\030\001 \001(\tR\007account\022F\n\006points\030\002 \001("
    "\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/"
    "types.DecR\006points\"\321\001\n)TradingRewardCampa"
    "ignAccountPendingPoints\022=\n\033reward_pool_s"
    "tart_timestamp\030\001 \001(\003R\030rewardPoolStartTim"
    "estamp\022e\n\016account_points\030\002 \003(\0132>.injecti"
    "ve.exchange.v1beta1.TradingRewardCampaig"
    "nAccountPointsR\raccountPoints\"\230\001\n\rSpotOr"
    "derBook\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\022\034\n\t"
    "isBuySide\030\002 \001(\010R\tisBuySide\022B\n\006orders\030\003 \003"
    "(\0132*.injective.exchange.v1beta1.SpotLimi"
    "tOrderR\006orders:\010\210\240\037\000\350\240\037\000\"\244\001\n\023DerivativeO"
    "rderBook\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\022\034\n"
    "\tisBuySide\030\002 \001(\010R\tisBuySide\022H\n\006orders\030\003 "
    "\003(\01320.injective.exchange.v1beta1.Derivat"
    "iveLimitOrderR\006orders:\010\210\240\037\000\350\240\037\000\"\301\003\n\036Cond"
    "itionalDerivativeOrderBook\022\033\n\tmarket_id\030"
    "\001 \001(\tR\010marketId\022Z\n\020limit_buy_orders\030\002 \003("
    "\01320.injective.exchange.v1beta1.Derivativ"
    "eLimitOrderR\016limitBuyOrders\022]\n\021market_bu"
    "y_orders\030\003 \003(\01321.injective.exchange.v1be"
    "ta1.DerivativeMarketOrderR\017marketBuyOrde"
    "rs\022\\\n\021limit_sell_orders\030\004 \003(\01320.injectiv"
    "e.exchange.v1beta1.DerivativeLimitOrderR"
    "\017limitSellOrders\022_\n\022market_sell_orders\030\005"
    " \003(\01321.injective.exchange.v1beta1.Deriva"
    "tiveMarketOrderR\020marketSellOrders:\010\210\240\037\000\350"
    "\240\037\000\"\217\001\n\007Balance\022#\n\rsubaccount_id\030\001 \001(\tR\014"
    "subaccountId\022\024\n\005denom\030\002 \001(\tR\005denom\022\?\n\010de"
    "posits\030\003 \001(\0132#.injective.exchange.v1beta"
    "1.DepositR\010deposits:\010\210\240\037\000\350\240\037\000\"\242\001\n\022Deriva"
    "tivePosition\022#\n\rsubaccount_id\030\001 \001(\tR\014sub"
    "accountId\022\033\n\tmarket_id\030\002 \001(\tR\010marketId\022@"
    "\n\010position\030\003 \001(\0132$.injective.exchange.v1"
    "beta1.PositionR\010position:\010\210\240\037\000\350\240\037\000\"\256\001\n\017S"
    "ubaccountNonce\022#\n\rsubaccount_id\030\001 \001(\tR\014s"
    "ubaccountId\022l\n\026subaccount_trade_nonce\030\002 "
    "\001(\01320.injective.exchange.v1beta1.Subacco"
    "untTradeNonceB\004\310\336\037\000R\024subaccountTradeNonc"
    "e:\010\210\240\037\000\350\240\037\000\"\221\001\n\034ExpiryFuturesMarketInfoS"
    "tate\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\022T\n\013mar"
    "ket_info\030\002 \001(\01323.injective.exchange.v1be"
    "ta1.ExpiryFuturesMarketInfoR\nmarketInfo\""
    "\210\001\n\033PerpetualMarketFundingState\022\033\n\tmarke"
    "t_id\030\001 \001(\tR\010marketId\022L\n\007funding\030\002 \001(\01322."
    "injective.exchange.v1beta1.PerpetualMark"
    "etFundingR\007fundingB\210\002\n\036com.injective.exc"
    "hange.v1beta1B\014GenesisProtoP\001ZNgithub.co"
    "m/InjectiveLabs/injective-core/injective"
    "-chain/modules/exchange/types\242\002\003IEX\252\002\032In"
    "jective.Exchange.V1beta1\312\002\032Injective\\Exc"
    "hange\\V1beta1\342\002&Injective\\Exchange\\V1bet"
    "a1\\GPBMetadata\352\002\034Injective::Exchange::V1"
    "beta1b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_deps[3] =
    {
        &::descriptor_table_gogoproto_2fgogo_2eproto,
        &::descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto,
        &::descriptor_table_injective_2fexchange_2fv1beta1_2ftx_2eproto,
};
static ::absl::once_flag descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto = {
    false,
    false,
    6413,
    descriptor_table_protodef_injective_2fexchange_2fv1beta1_2fgenesis_2eproto,
    "injective/exchange/v1beta1/genesis.proto",
    &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
    descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_deps,
    3,
    15,
    schemas,
    file_default_instances,
    TableStruct_injective_2fexchange_2fv1beta1_2fgenesis_2eproto::offsets,
    file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto,
    file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fgenesis_2eproto,
    file_level_service_descriptors_injective_2fexchange_2fv1beta1_2fgenesis_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter() {
  return &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_injective_2fexchange_2fv1beta1_2fgenesis_2eproto(&descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto);
namespace injective {
namespace exchange {
namespace v1beta1 {
// ===================================================================

class GenesisState::_Internal {
 public:
  using HasBits = decltype(std::declval<GenesisState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GenesisState, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::Params& params(const GenesisState* msg);
  static void set_has_params(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& trading_reward_campaign_info(const GenesisState* msg);
  static void set_has_trading_reward_campaign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::injective::exchange::v1beta1::FeeDiscountSchedule& fee_discount_schedule(const GenesisState* msg);
  static void set_has_fee_discount_schedule(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::injective::exchange::v1beta1::Params&
GenesisState::_Internal::params(const GenesisState* msg) {
  return *msg->_impl_.params_;
}
const ::injective::exchange::v1beta1::TradingRewardCampaignInfo&
GenesisState::_Internal::trading_reward_campaign_info(const GenesisState* msg) {
  return *msg->_impl_.trading_reward_campaign_info_;
}
const ::injective::exchange::v1beta1::FeeDiscountSchedule&
GenesisState::_Internal::fee_discount_schedule(const GenesisState* msg) {
  return *msg->_impl_.fee_discount_schedule_;
}
void GenesisState::clear_params() {
  if (_impl_.params_ != nullptr) _impl_.params_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void GenesisState::clear_spot_markets() {
  _internal_mutable_spot_markets()->Clear();
}
void GenesisState::clear_derivative_markets() {
  _internal_mutable_derivative_markets()->Clear();
}
void GenesisState::clear_perpetual_market_info() {
  _internal_mutable_perpetual_market_info()->Clear();
}
void GenesisState::clear_derivative_market_settlement_scheduled() {
  _internal_mutable_derivative_market_settlement_scheduled()->Clear();
}
void GenesisState::clear_trading_reward_campaign_info() {
  if (_impl_.trading_reward_campaign_info_ != nullptr) _impl_.trading_reward_campaign_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void GenesisState::clear_trading_reward_pool_campaign_schedule() {
  _internal_mutable_trading_reward_pool_campaign_schedule()->Clear();
}
void GenesisState::clear_fee_discount_schedule() {
  if (_impl_.fee_discount_schedule_ != nullptr) _impl_.fee_discount_schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void GenesisState::clear_pending_trading_reward_pool_campaign_schedule() {
  _internal_mutable_pending_trading_reward_pool_campaign_schedule()->Clear();
}
void GenesisState::clear_historical_trade_records() {
  _internal_mutable_historical_trade_records()->Clear();
}
void GenesisState::clear_binary_options_markets() {
  _internal_mutable_binary_options_markets()->Clear();
}
void GenesisState::clear_denom_decimals() {
  _internal_mutable_denom_decimals()->Clear();
}
void GenesisState::clear_market_fee_multipliers() {
  _internal_mutable_market_fee_multipliers()->Clear();
}
void GenesisState::clear_subaccount_volumes() {
  _internal_mutable_subaccount_volumes()->Clear();
}
void GenesisState::clear_market_volumes() {
  _internal_mutable_market_volumes()->Clear();
}
GenesisState::GenesisState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.GenesisState)
}
GenesisState::GenesisState(const GenesisState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GenesisState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spot_markets_){from._impl_.spot_markets_}
    , decltype(_impl_.derivative_markets_){from._impl_.derivative_markets_}
    , decltype(_impl_.spot_orderbook_){from._impl_.spot_orderbook_}
    , decltype(_impl_.derivative_orderbook_){from._impl_.derivative_orderbook_}
    , decltype(_impl_.balances_){from._impl_.balances_}
    , decltype(_impl_.positions_){from._impl_.positions_}
    , decltype(_impl_.subaccount_trade_nonces_){from._impl_.subaccount_trade_nonces_}
    , decltype(_impl_.expiry_futures_market_info_state_){from._impl_.expiry_futures_market_info_state_}
    , decltype(_impl_.perpetual_market_info_){from._impl_.perpetual_market_info_}
    , decltype(_impl_.perpetual_market_funding_state_){from._impl_.perpetual_market_funding_state_}
    , decltype(_impl_.derivative_market_settlement_scheduled_){from._impl_.derivative_market_settlement_scheduled_}
    , decltype(_impl_.trading_reward_pool_campaign_schedule_){from._impl_.trading_reward_pool_campaign_schedule_}
    , decltype(_impl_.trading_reward_campaign_account_points_){from._impl_.trading_reward_campaign_account_points_}
    , decltype(_impl_.fee_discount_account_tier_ttl_){from._impl_.fee_discount_account_tier_ttl_}
    , decltype(_impl_.fee_discount_bucket_volume_accounts_){from._impl_.fee_discount_bucket_volume_accounts_}
    , decltype(_impl_.pending_trading_reward_pool_campaign_schedule_){from._impl_.pending_trading_reward_pool_campaign_schedule_}
    , decltype(_impl_.pending_trading_reward_campaign_account_points_){from._impl_.pending_trading_reward_campaign_account_points_}
    , decltype(_impl_.rewards_opt_out_addresses_){from._impl_.rewards_opt_out_addresses_}
    , decltype(_impl_.historical_trade_records_){from._impl_.historical_trade_records_}
    , decltype(_impl_.binary_options_markets_){from._impl_.binary_options_markets_}
    , decltype(_impl_.binary_options_market_ids_scheduled_for_settlement_){from._impl_.binary_options_market_ids_scheduled_for_settlement_}
    , decltype(_impl_.spot_market_ids_scheduled_to_force_close_){from._impl_.spot_market_ids_scheduled_to_force_close_}
    , decltype(_impl_.denom_decimals_){from._impl_.denom_decimals_}
    , decltype(_impl_.conditional_derivative_orderbooks_){from._impl_.conditional_derivative_orderbooks_}
    , decltype(_impl_.market_fee_multipliers_){from._impl_.market_fee_multipliers_}
    , decltype(_impl_.orderbook_sequences_){from._impl_.orderbook_sequences_}
    , decltype(_impl_.subaccount_volumes_){from._impl_.subaccount_volumes_}
    , decltype(_impl_.market_volumes_){from._impl_.market_volumes_}
    , decltype(_impl_.params_){nullptr}
    , decltype(_impl_.trading_reward_campaign_info_){nullptr}
    , decltype(_impl_.fee_discount_schedule_){nullptr}
    , decltype(_impl_.is_spot_exchange_enabled_) {}

    , decltype(_impl_.is_derivatives_exchange_enabled_) {}

    , decltype(_impl_.is_first_fee_cycle_finished_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.params_ = new ::injective::exchange::v1beta1::Params(*from._impl_.params_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.trading_reward_campaign_info_ = new ::injective::exchange::v1beta1::TradingRewardCampaignInfo(*from._impl_.trading_reward_campaign_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.fee_discount_schedule_ = new ::injective::exchange::v1beta1::FeeDiscountSchedule(*from._impl_.fee_discount_schedule_);
  }
  ::memcpy(&_impl_.is_spot_exchange_enabled_, &from._impl_.is_spot_exchange_enabled_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_first_fee_cycle_finished_) -
    reinterpret_cast<char*>(&_impl_.is_spot_exchange_enabled_)) + sizeof(_impl_.is_first_fee_cycle_finished_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.GenesisState)
}

inline void GenesisState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spot_markets_){arena}
    , decltype(_impl_.derivative_markets_){arena}
    , decltype(_impl_.spot_orderbook_){arena}
    , decltype(_impl_.derivative_orderbook_){arena}
    , decltype(_impl_.balances_){arena}
    , decltype(_impl_.positions_){arena}
    , decltype(_impl_.subaccount_trade_nonces_){arena}
    , decltype(_impl_.expiry_futures_market_info_state_){arena}
    , decltype(_impl_.perpetual_market_info_){arena}
    , decltype(_impl_.perpetual_market_funding_state_){arena}
    , decltype(_impl_.derivative_market_settlement_scheduled_){arena}
    , decltype(_impl_.trading_reward_pool_campaign_schedule_){arena}
    , decltype(_impl_.trading_reward_campaign_account_points_){arena}
    , decltype(_impl_.fee_discount_account_tier_ttl_){arena}
    , decltype(_impl_.fee_discount_bucket_volume_accounts_){arena}
    , decltype(_impl_.pending_trading_reward_pool_campaign_schedule_){arena}
    , decltype(_impl_.pending_trading_reward_campaign_account_points_){arena}
    , decltype(_impl_.rewards_opt_out_addresses_){arena}
    , decltype(_impl_.historical_trade_records_){arena}
    , decltype(_impl_.binary_options_markets_){arena}
    , decltype(_impl_.binary_options_market_ids_scheduled_for_settlement_){arena}
    , decltype(_impl_.spot_market_ids_scheduled_to_force_close_){arena}
    , decltype(_impl_.denom_decimals_){arena}
    , decltype(_impl_.conditional_derivative_orderbooks_){arena}
    , decltype(_impl_.market_fee_multipliers_){arena}
    , decltype(_impl_.orderbook_sequences_){arena}
    , decltype(_impl_.subaccount_volumes_){arena}
    , decltype(_impl_.market_volumes_){arena}
    , decltype(_impl_.params_){nullptr}
    , decltype(_impl_.trading_reward_campaign_info_){nullptr}
    , decltype(_impl_.fee_discount_schedule_){nullptr}
    , decltype(_impl_.is_spot_exchange_enabled_) { false }

    , decltype(_impl_.is_derivatives_exchange_enabled_) { false }

    , decltype(_impl_.is_first_fee_cycle_finished_) { false }

  };
}

GenesisState::~GenesisState() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.GenesisState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenesisState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_spot_markets()->~RepeatedPtrField();
  _internal_mutable_derivative_markets()->~RepeatedPtrField();
  _internal_mutable_spot_orderbook()->~RepeatedPtrField();
  _internal_mutable_derivative_orderbook()->~RepeatedPtrField();
  _internal_mutable_balances()->~RepeatedPtrField();
  _internal_mutable_positions()->~RepeatedPtrField();
  _internal_mutable_subaccount_trade_nonces()->~RepeatedPtrField();
  _internal_mutable_expiry_futures_market_info_state()->~RepeatedPtrField();
  _internal_mutable_perpetual_market_info()->~RepeatedPtrField();
  _internal_mutable_perpetual_market_funding_state()->~RepeatedPtrField();
  _internal_mutable_derivative_market_settlement_scheduled()->~RepeatedPtrField();
  _internal_mutable_trading_reward_pool_campaign_schedule()->~RepeatedPtrField();
  _internal_mutable_trading_reward_campaign_account_points()->~RepeatedPtrField();
  _internal_mutable_fee_discount_account_tier_ttl()->~RepeatedPtrField();
  _internal_mutable_fee_discount_bucket_volume_accounts()->~RepeatedPtrField();
  _internal_mutable_pending_trading_reward_pool_campaign_schedule()->~RepeatedPtrField();
  _internal_mutable_pending_trading_reward_campaign_account_points()->~RepeatedPtrField();
  _internal_mutable_rewards_opt_out_addresses()->~RepeatedPtrField();
  _internal_mutable_historical_trade_records()->~RepeatedPtrField();
  _internal_mutable_binary_options_markets()->~RepeatedPtrField();
  _internal_mutable_binary_options_market_ids_scheduled_for_settlement()->~RepeatedPtrField();
  _internal_mutable_spot_market_ids_scheduled_to_force_close()->~RepeatedPtrField();
  _internal_mutable_denom_decimals()->~RepeatedPtrField();
  _internal_mutable_conditional_derivative_orderbooks()->~RepeatedPtrField();
  _internal_mutable_market_fee_multipliers()->~RepeatedPtrField();
  _internal_mutable_orderbook_sequences()->~RepeatedPtrField();
  _internal_mutable_subaccount_volumes()->~RepeatedPtrField();
  _internal_mutable_market_volumes()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.params_;
  if (this != internal_default_instance()) delete _impl_.trading_reward_campaign_info_;
  if (this != internal_default_instance()) delete _impl_.fee_discount_schedule_;
}

void GenesisState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GenesisState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.GenesisState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_spot_markets()->Clear();
  _internal_mutable_derivative_markets()->Clear();
  _internal_mutable_spot_orderbook()->Clear();
  _internal_mutable_derivative_orderbook()->Clear();
  _internal_mutable_balances()->Clear();
  _internal_mutable_positions()->Clear();
  _internal_mutable_subaccount_trade_nonces()->Clear();
  _internal_mutable_expiry_futures_market_info_state()->Clear();
  _internal_mutable_perpetual_market_info()->Clear();
  _internal_mutable_perpetual_market_funding_state()->Clear();
  _internal_mutable_derivative_market_settlement_scheduled()->Clear();
  _internal_mutable_trading_reward_pool_campaign_schedule()->Clear();
  _internal_mutable_trading_reward_campaign_account_points()->Clear();
  _internal_mutable_fee_discount_account_tier_ttl()->Clear();
  _internal_mutable_fee_discount_bucket_volume_accounts()->Clear();
  _internal_mutable_pending_trading_reward_pool_campaign_schedule()->Clear();
  _internal_mutable_pending_trading_reward_campaign_account_points()->Clear();
  _internal_mutable_rewards_opt_out_addresses()->Clear();
  _internal_mutable_historical_trade_records()->Clear();
  _internal_mutable_binary_options_markets()->Clear();
  _internal_mutable_binary_options_market_ids_scheduled_for_settlement()->Clear();
  _internal_mutable_spot_market_ids_scheduled_to_force_close()->Clear();
  _internal_mutable_denom_decimals()->Clear();
  _internal_mutable_conditional_derivative_orderbooks()->Clear();
  _internal_mutable_market_fee_multipliers()->Clear();
  _internal_mutable_orderbook_sequences()->Clear();
  _internal_mutable_subaccount_volumes()->Clear();
  _internal_mutable_market_volumes()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.params_ != nullptr);
      _impl_.params_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.trading_reward_campaign_info_ != nullptr);
      _impl_.trading_reward_campaign_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.fee_discount_schedule_ != nullptr);
      _impl_.fee_discount_schedule_->Clear();
    }
  }
  ::memset(&_impl_.is_spot_exchange_enabled_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_first_fee_cycle_finished_) -
      reinterpret_cast<char*>(&_impl_.is_spot_exchange_enabled_)) + sizeof(_impl_.is_first_fee_cycle_finished_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenesisState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.Params params = 1 [json_name = "params", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_params(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SpotMarket spot_markets = 2 [json_name = "spotMarkets"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_spot_markets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeMarket derivative_markets = 3 [json_name = "derivativeMarkets"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_derivative_markets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SpotOrderBook spot_orderbook = 4 [json_name = "spotOrderbook", (.gogoproto.nullable) = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_spot_orderbook(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeOrderBook derivative_orderbook = 5 [json_name = "derivativeOrderbook", (.gogoproto.nullable) = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_derivative_orderbook(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.Balance balances = 6 [json_name = "balances", (.gogoproto.nullable) = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_balances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativePosition positions = 7 [json_name = "positions", (.gogoproto.nullable) = false];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_positions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SubaccountNonce subaccount_trade_nonces = 8 [json_name = "subaccountTradeNonces", (.gogoproto.nullable) = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subaccount_trade_nonces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9 [json_name = "expiryFuturesMarketInfoState", (.gogoproto.nullable) = false];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_expiry_futures_market_info_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 10 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = false];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_perpetual_market_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.PerpetualMarketFundingState perpetual_market_funding_state = 11 [json_name = "perpetualMarketFundingState", (.gogoproto.nullable) = false];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_perpetual_market_funding_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12 [json_name = "derivativeMarketSettlementScheduled", (.gogoproto.nullable) = false];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_derivative_market_settlement_scheduled(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_spot_exchange_enabled = 13 [json_name = "isSpotExchangeEnabled"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.is_spot_exchange_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_derivatives_exchange_enabled = 14 [json_name = "isDerivativesExchangeEnabled"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.is_derivatives_exchange_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 15 [json_name = "tradingRewardCampaignInfo"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_trading_reward_campaign_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 16 [json_name = "tradingRewardPoolCampaignSchedule"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_trading_reward_pool_campaign_schedule(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17 [json_name = "tradingRewardCampaignAccountPoints"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_trading_reward_campaign_account_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 18 [json_name = "feeDiscountSchedule"];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_fee_discount_schedule(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19 [json_name = "feeDiscountAccountTierTtl"];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_fee_discount_account_tier_ttl(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20 [json_name = "feeDiscountBucketVolumeAccounts"];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_fee_discount_bucket_volume_accounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_first_fee_cycle_finished = 21 [json_name = "isFirstFeeCycleFinished"];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          _impl_.is_first_fee_cycle_finished_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22 [json_name = "pendingTradingRewardPoolCampaignSchedule"];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_pending_trading_reward_pool_campaign_schedule(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23 [json_name = "pendingTradingRewardCampaignAccountPoints"];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_pending_trading_reward_campaign_account_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string rewards_opt_out_addresses = 24 [json_name = "rewardsOptOutAddresses"];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_rewards_opt_out_addresses();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.GenesisState.rewards_opt_out_addresses"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.TradeRecords historical_trade_records = 25 [json_name = "historicalTradeRecords"];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_historical_trade_records(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<202>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.BinaryOptionsMarket binary_options_markets = 26 [json_name = "binaryOptionsMarkets"];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 210)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_binary_options_markets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<210>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string binary_options_market_ids_scheduled_for_settlement = 27 [json_name = "binaryOptionsMarketIdsScheduledForSettlement"];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_binary_options_market_ids_scheduled_for_settlement();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.GenesisState.binary_options_market_ids_scheduled_for_settlement"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string spot_market_ids_scheduled_to_force_close = 28 [json_name = "spotMarketIdsScheduledToForceClose"];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_spot_market_ids_scheduled_to_force_close();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.GenesisState.spot_market_ids_scheduled_to_force_close"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 29 [json_name = "denomDecimals", (.gogoproto.nullable) = false];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 234)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_denom_decimals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<234>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30 [json_name = "conditionalDerivativeOrderbooks"];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_conditional_derivative_orderbooks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 31 [json_name = "marketFeeMultipliers"];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_market_fee_multipliers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<250>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.OrderbookSequence orderbook_sequences = 32 [json_name = "orderbookSequences"];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 2)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_orderbook_sequences(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<258>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.AggregateSubaccountVolumeRecord subaccount_volumes = 33 [json_name = "subaccountVolumes"];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_subaccount_volumes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<266>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 34 [json_name = "marketVolumes"];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_market_volumes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GenesisState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.GenesisState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.Params params = 1 [json_name = "params", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::params(this),
        _Internal::params(this).GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.SpotMarket spot_markets = 2 [json_name = "spotMarkets"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_spot_markets_size()); i < n; i++) {
    const auto& repfield = this->_internal_spot_markets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarket derivative_markets = 3 [json_name = "derivativeMarkets"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_derivative_markets_size()); i < n; i++) {
    const auto& repfield = this->_internal_derivative_markets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.SpotOrderBook spot_orderbook = 4 [json_name = "spotOrderbook", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_spot_orderbook_size()); i < n; i++) {
    const auto& repfield = this->_internal_spot_orderbook(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativeOrderBook derivative_orderbook = 5 [json_name = "derivativeOrderbook", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_derivative_orderbook_size()); i < n; i++) {
    const auto& repfield = this->_internal_derivative_orderbook(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.Balance balances = 6 [json_name = "balances", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_balances_size()); i < n; i++) {
    const auto& repfield = this->_internal_balances(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativePosition positions = 7 [json_name = "positions", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_positions_size()); i < n; i++) {
    const auto& repfield = this->_internal_positions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.SubaccountNonce subaccount_trade_nonces = 8 [json_name = "subaccountTradeNonces", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subaccount_trade_nonces_size()); i < n; i++) {
    const auto& repfield = this->_internal_subaccount_trade_nonces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9 [json_name = "expiryFuturesMarketInfoState", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_expiry_futures_market_info_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_expiry_futures_market_info_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 10 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_perpetual_market_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_perpetual_market_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.PerpetualMarketFundingState perpetual_market_funding_state = 11 [json_name = "perpetualMarketFundingState", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_perpetual_market_funding_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_perpetual_market_funding_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12 [json_name = "derivativeMarketSettlementScheduled", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_derivative_market_settlement_scheduled_size()); i < n; i++) {
    const auto& repfield = this->_internal_derivative_market_settlement_scheduled(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool is_spot_exchange_enabled = 13 [json_name = "isSpotExchangeEnabled"];
  if (this->_internal_is_spot_exchange_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        13, this->_internal_is_spot_exchange_enabled(), target);
  }

  // bool is_derivatives_exchange_enabled = 14 [json_name = "isDerivativesExchangeEnabled"];
  if (this->_internal_is_derivatives_exchange_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        14, this->_internal_is_derivatives_exchange_enabled(), target);
  }

  // .injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 15 [json_name = "tradingRewardCampaignInfo"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::trading_reward_campaign_info(this),
        _Internal::trading_reward_campaign_info(this).GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 16 [json_name = "tradingRewardPoolCampaignSchedule"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trading_reward_pool_campaign_schedule_size()); i < n; i++) {
    const auto& repfield = this->_internal_trading_reward_pool_campaign_schedule(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17 [json_name = "tradingRewardCampaignAccountPoints"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trading_reward_campaign_account_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_trading_reward_campaign_account_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 18 [json_name = "feeDiscountSchedule"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::fee_discount_schedule(this),
        _Internal::fee_discount_schedule(this).GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19 [json_name = "feeDiscountAccountTierTtl"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fee_discount_account_tier_ttl_size()); i < n; i++) {
    const auto& repfield = this->_internal_fee_discount_account_tier_ttl(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20 [json_name = "feeDiscountBucketVolumeAccounts"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fee_discount_bucket_volume_accounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_fee_discount_bucket_volume_accounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool is_first_fee_cycle_finished = 21 [json_name = "isFirstFeeCycleFinished"];
  if (this->_internal_is_first_fee_cycle_finished() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        21, this->_internal_is_first_fee_cycle_finished(), target);
  }

  // repeated .injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22 [json_name = "pendingTradingRewardPoolCampaignSchedule"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pending_trading_reward_pool_campaign_schedule_size()); i < n; i++) {
    const auto& repfield = this->_internal_pending_trading_reward_pool_campaign_schedule(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23 [json_name = "pendingTradingRewardCampaignAccountPoints"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pending_trading_reward_campaign_account_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_pending_trading_reward_campaign_account_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string rewards_opt_out_addresses = 24 [json_name = "rewardsOptOutAddresses"];
  for (int i = 0, n = this->_internal_rewards_opt_out_addresses_size(); i < n; ++i) {
    const auto& s = this->_internal_rewards_opt_out_addresses(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.GenesisState.rewards_opt_out_addresses");
    target = stream->WriteString(24, s, target);
  }

  // repeated .injective.exchange.v1beta1.TradeRecords historical_trade_records = 25 [json_name = "historicalTradeRecords"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_historical_trade_records_size()); i < n; i++) {
    const auto& repfield = this->_internal_historical_trade_records(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(25, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.BinaryOptionsMarket binary_options_markets = 26 [json_name = "binaryOptionsMarkets"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_binary_options_markets_size()); i < n; i++) {
    const auto& repfield = this->_internal_binary_options_markets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(26, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string binary_options_market_ids_scheduled_for_settlement = 27 [json_name = "binaryOptionsMarketIdsScheduledForSettlement"];
  for (int i = 0, n = this->_internal_binary_options_market_ids_scheduled_for_settlement_size(); i < n; ++i) {
    const auto& s = this->_internal_binary_options_market_ids_scheduled_for_settlement(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.GenesisState.binary_options_market_ids_scheduled_for_settlement");
    target = stream->WriteString(27, s, target);
  }

  // repeated string spot_market_ids_scheduled_to_force_close = 28 [json_name = "spotMarketIdsScheduledToForceClose"];
  for (int i = 0, n = this->_internal_spot_market_ids_scheduled_to_force_close_size(); i < n; ++i) {
    const auto& s = this->_internal_spot_market_ids_scheduled_to_force_close(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.GenesisState.spot_market_ids_scheduled_to_force_close");
    target = stream->WriteString(28, s, target);
  }

  // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 29 [json_name = "denomDecimals", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_denom_decimals_size()); i < n; i++) {
    const auto& repfield = this->_internal_denom_decimals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(29, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30 [json_name = "conditionalDerivativeOrderbooks"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditional_derivative_orderbooks_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditional_derivative_orderbooks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 31 [json_name = "marketFeeMultipliers"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_market_fee_multipliers_size()); i < n; i++) {
    const auto& repfield = this->_internal_market_fee_multipliers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(31, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.OrderbookSequence orderbook_sequences = 32 [json_name = "orderbookSequences"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orderbook_sequences_size()); i < n; i++) {
    const auto& repfield = this->_internal_orderbook_sequences(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(32, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.AggregateSubaccountVolumeRecord subaccount_volumes = 33 [json_name = "subaccountVolumes"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subaccount_volumes_size()); i < n; i++) {
    const auto& repfield = this->_internal_subaccount_volumes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(33, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 34 [json_name = "marketVolumes"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_market_volumes_size()); i < n; i++) {
    const auto& repfield = this->_internal_market_volumes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(34, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.GenesisState)
  return target;
}

::size_t GenesisState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.GenesisState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.SpotMarket spot_markets = 2 [json_name = "spotMarkets"];
  total_size += 1UL * this->_internal_spot_markets_size();
  for (const auto& msg : this->_internal_spot_markets()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarket derivative_markets = 3 [json_name = "derivativeMarkets"];
  total_size += 1UL * this->_internal_derivative_markets_size();
  for (const auto& msg : this->_internal_derivative_markets()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.SpotOrderBook spot_orderbook = 4 [json_name = "spotOrderbook", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_spot_orderbook_size();
  for (const auto& msg : this->_internal_spot_orderbook()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativeOrderBook derivative_orderbook = 5 [json_name = "derivativeOrderbook", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_derivative_orderbook_size();
  for (const auto& msg : this->_internal_derivative_orderbook()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.Balance balances = 6 [json_name = "balances", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_balances_size();
  for (const auto& msg : this->_internal_balances()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativePosition positions = 7 [json_name = "positions", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_positions_size();
  for (const auto& msg : this->_internal_positions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.SubaccountNonce subaccount_trade_nonces = 8 [json_name = "subaccountTradeNonces", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_subaccount_trade_nonces_size();
  for (const auto& msg : this->_internal_subaccount_trade_nonces()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9 [json_name = "expiryFuturesMarketInfoState", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_expiry_futures_market_info_state_size();
  for (const auto& msg : this->_internal_expiry_futures_market_info_state()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 10 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_perpetual_market_info_size();
  for (const auto& msg : this->_internal_perpetual_market_info()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.PerpetualMarketFundingState perpetual_market_funding_state = 11 [json_name = "perpetualMarketFundingState", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_perpetual_market_funding_state_size();
  for (const auto& msg : this->_internal_perpetual_market_funding_state()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12 [json_name = "derivativeMarketSettlementScheduled", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_derivative_market_settlement_scheduled_size();
  for (const auto& msg : this->_internal_derivative_market_settlement_scheduled()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 16 [json_name = "tradingRewardPoolCampaignSchedule"];
  total_size += 2UL * this->_internal_trading_reward_pool_campaign_schedule_size();
  for (const auto& msg : this->_internal_trading_reward_pool_campaign_schedule()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17 [json_name = "tradingRewardCampaignAccountPoints"];
  total_size += 2UL * this->_internal_trading_reward_campaign_account_points_size();
  for (const auto& msg : this->_internal_trading_reward_campaign_account_points()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19 [json_name = "feeDiscountAccountTierTtl"];
  total_size += 2UL * this->_internal_fee_discount_account_tier_ttl_size();
  for (const auto& msg : this->_internal_fee_discount_account_tier_ttl()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20 [json_name = "feeDiscountBucketVolumeAccounts"];
  total_size += 2UL * this->_internal_fee_discount_bucket_volume_accounts_size();
  for (const auto& msg : this->_internal_fee_discount_bucket_volume_accounts()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22 [json_name = "pendingTradingRewardPoolCampaignSchedule"];
  total_size += 2UL * this->_internal_pending_trading_reward_pool_campaign_schedule_size();
  for (const auto& msg : this->_internal_pending_trading_reward_pool_campaign_schedule()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23 [json_name = "pendingTradingRewardCampaignAccountPoints"];
  total_size += 2UL * this->_internal_pending_trading_reward_campaign_account_points_size();
  for (const auto& msg : this->_internal_pending_trading_reward_campaign_account_points()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string rewards_opt_out_addresses = 24 [json_name = "rewardsOptOutAddresses"];
  total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_rewards_opt_out_addresses().size());
  for (int i = 0, n = _internal_rewards_opt_out_addresses().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_rewards_opt_out_addresses().Get(i));
  }

  // repeated .injective.exchange.v1beta1.TradeRecords historical_trade_records = 25 [json_name = "historicalTradeRecords"];
  total_size += 2UL * this->_internal_historical_trade_records_size();
  for (const auto& msg : this->_internal_historical_trade_records()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.BinaryOptionsMarket binary_options_markets = 26 [json_name = "binaryOptionsMarkets"];
  total_size += 2UL * this->_internal_binary_options_markets_size();
  for (const auto& msg : this->_internal_binary_options_markets()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string binary_options_market_ids_scheduled_for_settlement = 27 [json_name = "binaryOptionsMarketIdsScheduledForSettlement"];
  total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_binary_options_market_ids_scheduled_for_settlement().size());
  for (int i = 0, n = _internal_binary_options_market_ids_scheduled_for_settlement().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_binary_options_market_ids_scheduled_for_settlement().Get(i));
  }

  // repeated string spot_market_ids_scheduled_to_force_close = 28 [json_name = "spotMarketIdsScheduledToForceClose"];
  total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_spot_market_ids_scheduled_to_force_close().size());
  for (int i = 0, n = _internal_spot_market_ids_scheduled_to_force_close().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_spot_market_ids_scheduled_to_force_close().Get(i));
  }

  // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 29 [json_name = "denomDecimals", (.gogoproto.nullable) = false];
  total_size += 2UL * this->_internal_denom_decimals_size();
  for (const auto& msg : this->_internal_denom_decimals()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30 [json_name = "conditionalDerivativeOrderbooks"];
  total_size += 2UL * this->_internal_conditional_derivative_orderbooks_size();
  for (const auto& msg : this->_internal_conditional_derivative_orderbooks()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 31 [json_name = "marketFeeMultipliers"];
  total_size += 2UL * this->_internal_market_fee_multipliers_size();
  for (const auto& msg : this->_internal_market_fee_multipliers()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.OrderbookSequence orderbook_sequences = 32 [json_name = "orderbookSequences"];
  total_size += 2UL * this->_internal_orderbook_sequences_size();
  for (const auto& msg : this->_internal_orderbook_sequences()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.AggregateSubaccountVolumeRecord subaccount_volumes = 33 [json_name = "subaccountVolumes"];
  total_size += 2UL * this->_internal_subaccount_volumes_size();
  for (const auto& msg : this->_internal_subaccount_volumes()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 34 [json_name = "marketVolumes"];
  total_size += 2UL * this->_internal_market_volumes_size();
  for (const auto& msg : this->_internal_market_volumes()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .injective.exchange.v1beta1.Params params = 1 [json_name = "params", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.params_);
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 15 [json_name = "tradingRewardCampaignInfo"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trading_reward_campaign_info_);
    }

    // .injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 18 [json_name = "feeDiscountSchedule"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fee_discount_schedule_);
    }

  }
  // bool is_spot_exchange_enabled = 13 [json_name = "isSpotExchangeEnabled"];
  if (this->_internal_is_spot_exchange_enabled() != 0) {
    total_size += 2;
  }

  // bool is_derivatives_exchange_enabled = 14 [json_name = "isDerivativesExchangeEnabled"];
  if (this->_internal_is_derivatives_exchange_enabled() != 0) {
    total_size += 2;
  }

  // bool is_first_fee_cycle_finished = 21 [json_name = "isFirstFeeCycleFinished"];
  if (this->_internal_is_first_fee_cycle_finished() != 0) {
    total_size += 3;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenesisState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GenesisState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenesisState::GetClassData() const { return &_class_data_; }


void GenesisState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GenesisState*>(&to_msg);
  auto& from = static_cast<const GenesisState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.GenesisState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_spot_markets()->MergeFrom(from._internal_spot_markets());
  _this->_internal_mutable_derivative_markets()->MergeFrom(from._internal_derivative_markets());
  _this->_internal_mutable_spot_orderbook()->MergeFrom(from._internal_spot_orderbook());
  _this->_internal_mutable_derivative_orderbook()->MergeFrom(from._internal_derivative_orderbook());
  _this->_internal_mutable_balances()->MergeFrom(from._internal_balances());
  _this->_internal_mutable_positions()->MergeFrom(from._internal_positions());
  _this->_internal_mutable_subaccount_trade_nonces()->MergeFrom(from._internal_subaccount_trade_nonces());
  _this->_internal_mutable_expiry_futures_market_info_state()->MergeFrom(from._internal_expiry_futures_market_info_state());
  _this->_internal_mutable_perpetual_market_info()->MergeFrom(from._internal_perpetual_market_info());
  _this->_internal_mutable_perpetual_market_funding_state()->MergeFrom(from._internal_perpetual_market_funding_state());
  _this->_internal_mutable_derivative_market_settlement_scheduled()->MergeFrom(from._internal_derivative_market_settlement_scheduled());
  _this->_internal_mutable_trading_reward_pool_campaign_schedule()->MergeFrom(from._internal_trading_reward_pool_campaign_schedule());
  _this->_internal_mutable_trading_reward_campaign_account_points()->MergeFrom(from._internal_trading_reward_campaign_account_points());
  _this->_internal_mutable_fee_discount_account_tier_ttl()->MergeFrom(from._internal_fee_discount_account_tier_ttl());
  _this->_internal_mutable_fee_discount_bucket_volume_accounts()->MergeFrom(from._internal_fee_discount_bucket_volume_accounts());
  _this->_internal_mutable_pending_trading_reward_pool_campaign_schedule()->MergeFrom(from._internal_pending_trading_reward_pool_campaign_schedule());
  _this->_internal_mutable_pending_trading_reward_campaign_account_points()->MergeFrom(from._internal_pending_trading_reward_campaign_account_points());
  _this->_internal_mutable_rewards_opt_out_addresses()->MergeFrom(from._internal_rewards_opt_out_addresses());
  _this->_internal_mutable_historical_trade_records()->MergeFrom(from._internal_historical_trade_records());
  _this->_internal_mutable_binary_options_markets()->MergeFrom(from._internal_binary_options_markets());
  _this->_internal_mutable_binary_options_market_ids_scheduled_for_settlement()->MergeFrom(from._internal_binary_options_market_ids_scheduled_for_settlement());
  _this->_internal_mutable_spot_market_ids_scheduled_to_force_close()->MergeFrom(from._internal_spot_market_ids_scheduled_to_force_close());
  _this->_internal_mutable_denom_decimals()->MergeFrom(from._internal_denom_decimals());
  _this->_internal_mutable_conditional_derivative_orderbooks()->MergeFrom(from._internal_conditional_derivative_orderbooks());
  _this->_internal_mutable_market_fee_multipliers()->MergeFrom(from._internal_market_fee_multipliers());
  _this->_internal_mutable_orderbook_sequences()->MergeFrom(from._internal_orderbook_sequences());
  _this->_internal_mutable_subaccount_volumes()->MergeFrom(from._internal_subaccount_volumes());
  _this->_internal_mutable_market_volumes()->MergeFrom(from._internal_market_volumes());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_params()->::injective::exchange::v1beta1::Params::MergeFrom(
          from._internal_params());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_trading_reward_campaign_info()->::injective::exchange::v1beta1::TradingRewardCampaignInfo::MergeFrom(
          from._internal_trading_reward_campaign_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_fee_discount_schedule()->::injective::exchange::v1beta1::FeeDiscountSchedule::MergeFrom(
          from._internal_fee_discount_schedule());
    }
  }
  if (from._internal_is_spot_exchange_enabled() != 0) {
    _this->_internal_set_is_spot_exchange_enabled(from._internal_is_spot_exchange_enabled());
  }
  if (from._internal_is_derivatives_exchange_enabled() != 0) {
    _this->_internal_set_is_derivatives_exchange_enabled(from._internal_is_derivatives_exchange_enabled());
  }
  if (from._internal_is_first_fee_cycle_finished() != 0) {
    _this->_internal_set_is_first_fee_cycle_finished(from._internal_is_first_fee_cycle_finished());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenesisState::CopyFrom(const GenesisState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.GenesisState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenesisState::IsInitialized() const {
  return true;
}

void GenesisState::InternalSwap(GenesisState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_spot_markets()->InternalSwap(other->_internal_mutable_spot_markets());
  _internal_mutable_derivative_markets()->InternalSwap(other->_internal_mutable_derivative_markets());
  _internal_mutable_spot_orderbook()->InternalSwap(other->_internal_mutable_spot_orderbook());
  _internal_mutable_derivative_orderbook()->InternalSwap(other->_internal_mutable_derivative_orderbook());
  _internal_mutable_balances()->InternalSwap(other->_internal_mutable_balances());
  _internal_mutable_positions()->InternalSwap(other->_internal_mutable_positions());
  _internal_mutable_subaccount_trade_nonces()->InternalSwap(other->_internal_mutable_subaccount_trade_nonces());
  _internal_mutable_expiry_futures_market_info_state()->InternalSwap(other->_internal_mutable_expiry_futures_market_info_state());
  _internal_mutable_perpetual_market_info()->InternalSwap(other->_internal_mutable_perpetual_market_info());
  _internal_mutable_perpetual_market_funding_state()->InternalSwap(other->_internal_mutable_perpetual_market_funding_state());
  _internal_mutable_derivative_market_settlement_scheduled()->InternalSwap(other->_internal_mutable_derivative_market_settlement_scheduled());
  _internal_mutable_trading_reward_pool_campaign_schedule()->InternalSwap(other->_internal_mutable_trading_reward_pool_campaign_schedule());
  _internal_mutable_trading_reward_campaign_account_points()->InternalSwap(other->_internal_mutable_trading_reward_campaign_account_points());
  _internal_mutable_fee_discount_account_tier_ttl()->InternalSwap(other->_internal_mutable_fee_discount_account_tier_ttl());
  _internal_mutable_fee_discount_bucket_volume_accounts()->InternalSwap(other->_internal_mutable_fee_discount_bucket_volume_accounts());
  _internal_mutable_pending_trading_reward_pool_campaign_schedule()->InternalSwap(other->_internal_mutable_pending_trading_reward_pool_campaign_schedule());
  _internal_mutable_pending_trading_reward_campaign_account_points()->InternalSwap(other->_internal_mutable_pending_trading_reward_campaign_account_points());
  _internal_mutable_rewards_opt_out_addresses()->InternalSwap(
      other->_internal_mutable_rewards_opt_out_addresses());
  _internal_mutable_historical_trade_records()->InternalSwap(other->_internal_mutable_historical_trade_records());
  _internal_mutable_binary_options_markets()->InternalSwap(other->_internal_mutable_binary_options_markets());
  _internal_mutable_binary_options_market_ids_scheduled_for_settlement()->InternalSwap(
      other->_internal_mutable_binary_options_market_ids_scheduled_for_settlement());
  _internal_mutable_spot_market_ids_scheduled_to_force_close()->InternalSwap(
      other->_internal_mutable_spot_market_ids_scheduled_to_force_close());
  _internal_mutable_denom_decimals()->InternalSwap(other->_internal_mutable_denom_decimals());
  _internal_mutable_conditional_derivative_orderbooks()->InternalSwap(other->_internal_mutable_conditional_derivative_orderbooks());
  _internal_mutable_market_fee_multipliers()->InternalSwap(other->_internal_mutable_market_fee_multipliers());
  _internal_mutable_orderbook_sequences()->InternalSwap(other->_internal_mutable_orderbook_sequences());
  _internal_mutable_subaccount_volumes()->InternalSwap(other->_internal_mutable_subaccount_volumes());
  _internal_mutable_market_volumes()->InternalSwap(other->_internal_mutable_market_volumes());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenesisState, _impl_.is_first_fee_cycle_finished_)
      + sizeof(GenesisState::_impl_.is_first_fee_cycle_finished_)
      - PROTOBUF_FIELD_OFFSET(GenesisState, _impl_.params_)>(
          reinterpret_cast<char*>(&_impl_.params_),
          reinterpret_cast<char*>(&other->_impl_.params_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GenesisState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[0]);
}
// ===================================================================

class OrderbookSequence::_Internal {
 public:
};

OrderbookSequence::OrderbookSequence(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.OrderbookSequence)
}
OrderbookSequence::OrderbookSequence(const OrderbookSequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbookSequence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.sequence_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.sequence_ = from._impl_.sequence_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.OrderbookSequence)
}

inline void OrderbookSequence::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.sequence_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrderbookSequence::~OrderbookSequence() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.OrderbookSequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbookSequence::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
}

void OrderbookSequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbookSequence::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.OrderbookSequence)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.sequence_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbookSequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 sequence = 1 [json_name = "sequence"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.OrderbookSequence.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbookSequence::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.OrderbookSequence)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 sequence = 1 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_sequence(), target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.OrderbookSequence.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.OrderbookSequence)
  return target;
}

::size_t OrderbookSequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.OrderbookSequence)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // uint64 sequence = 1 [json_name = "sequence"];
  if (this->_internal_sequence() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_sequence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbookSequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbookSequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbookSequence::GetClassData() const { return &_class_data_; }


void OrderbookSequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbookSequence*>(&to_msg);
  auto& from = static_cast<const OrderbookSequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.OrderbookSequence)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_sequence() != 0) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbookSequence::CopyFrom(const OrderbookSequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.OrderbookSequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbookSequence::IsInitialized() const {
  return true;
}

void OrderbookSequence::InternalSwap(OrderbookSequence* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);

  swap(_impl_.sequence_, other->_impl_.sequence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbookSequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[1]);
}
// ===================================================================

class FeeDiscountAccountTierTTL::_Internal {
 public:
  using HasBits = decltype(std::declval<FeeDiscountAccountTierTTL>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FeeDiscountAccountTierTTL, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::FeeDiscountTierTTL& tier_ttl(const FeeDiscountAccountTierTTL* msg);
  static void set_has_tier_ttl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::FeeDiscountTierTTL&
FeeDiscountAccountTierTTL::_Internal::tier_ttl(const FeeDiscountAccountTierTTL* msg) {
  return *msg->_impl_.tier_ttl_;
}
void FeeDiscountAccountTierTTL::clear_tier_ttl() {
  if (_impl_.tier_ttl_ != nullptr) _impl_.tier_ttl_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FeeDiscountAccountTierTTL::FeeDiscountAccountTierTTL(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
}
FeeDiscountAccountTierTTL::FeeDiscountAccountTierTTL(const FeeDiscountAccountTierTTL& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeeDiscountAccountTierTTL* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_) {}

    , decltype(_impl_.tier_ttl_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account().empty()) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.tier_ttl_ = new ::injective::exchange::v1beta1::FeeDiscountTierTTL(*from._impl_.tier_ttl_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
}

inline void FeeDiscountAccountTierTTL::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_) {}

    , decltype(_impl_.tier_ttl_){nullptr}
  };
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FeeDiscountAccountTierTTL::~FeeDiscountAccountTierTTL() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeDiscountAccountTierTTL::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tier_ttl_;
}

void FeeDiscountAccountTierTTL::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeDiscountAccountTierTTL::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.tier_ttl_ != nullptr);
    _impl_.tier_ttl_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeDiscountAccountTierTTL::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account = 1 [json_name = "account"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.FeeDiscountAccountTierTTL.account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.FeeDiscountTierTTL tier_ttl = 2 [json_name = "tierTtl"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tier_ttl(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeeDiscountAccountTierTTL::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    const std::string& _s = this->_internal_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.FeeDiscountAccountTierTTL.account");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.FeeDiscountTierTTL tier_ttl = 2 [json_name = "tierTtl"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tier_ttl(this),
        _Internal::tier_ttl(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
  return target;
}

::size_t FeeDiscountAccountTierTTL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account());
  }

  // .injective.exchange.v1beta1.FeeDiscountTierTTL tier_ttl = 2 [json_name = "tierTtl"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tier_ttl_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeDiscountAccountTierTTL::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeDiscountAccountTierTTL::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeDiscountAccountTierTTL::GetClassData() const { return &_class_data_; }


void FeeDiscountAccountTierTTL::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeDiscountAccountTierTTL*>(&to_msg);
  auto& from = static_cast<const FeeDiscountAccountTierTTL&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account().empty()) {
    _this->_internal_set_account(from._internal_account());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_tier_ttl()->::injective::exchange::v1beta1::FeeDiscountTierTTL::MergeFrom(
        from._internal_tier_ttl());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeDiscountAccountTierTTL::CopyFrom(const FeeDiscountAccountTierTTL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.FeeDiscountAccountTierTTL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeDiscountAccountTierTTL::IsInitialized() const {
  return true;
}

void FeeDiscountAccountTierTTL::InternalSwap(FeeDiscountAccountTierTTL* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
  swap(_impl_.tier_ttl_, other->_impl_.tier_ttl_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeDiscountAccountTierTTL::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[2]);
}
// ===================================================================

class FeeDiscountBucketVolumeAccounts::_Internal {
 public:
};

FeeDiscountBucketVolumeAccounts::FeeDiscountBucketVolumeAccounts(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
}
FeeDiscountBucketVolumeAccounts::FeeDiscountBucketVolumeAccounts(const FeeDiscountBucketVolumeAccounts& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeeDiscountBucketVolumeAccounts* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_volume_){from._impl_.account_volume_}
    , decltype(_impl_.bucket_start_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.bucket_start_timestamp_ = from._impl_.bucket_start_timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
}

inline void FeeDiscountBucketVolumeAccounts::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_volume_){arena}
    , decltype(_impl_.bucket_start_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeeDiscountBucketVolumeAccounts::~FeeDiscountBucketVolumeAccounts() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeDiscountBucketVolumeAccounts::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_account_volume()->~RepeatedPtrField();
}

void FeeDiscountBucketVolumeAccounts::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeDiscountBucketVolumeAccounts::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_account_volume()->Clear();
  _impl_.bucket_start_timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeDiscountBucketVolumeAccounts::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 bucket_start_timestamp = 1 [json_name = "bucketStartTimestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.bucket_start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.AccountVolume account_volume = 2 [json_name = "accountVolume"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_account_volume(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeeDiscountBucketVolumeAccounts::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 bucket_start_timestamp = 1 [json_name = "bucketStartTimestamp"];
  if (this->_internal_bucket_start_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_bucket_start_timestamp(), target);
  }

  // repeated .injective.exchange.v1beta1.AccountVolume account_volume = 2 [json_name = "accountVolume"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_account_volume_size()); i < n; i++) {
    const auto& repfield = this->_internal_account_volume(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
  return target;
}

::size_t FeeDiscountBucketVolumeAccounts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.AccountVolume account_volume = 2 [json_name = "accountVolume"];
  total_size += 1UL * this->_internal_account_volume_size();
  for (const auto& msg : this->_internal_account_volume()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 bucket_start_timestamp = 1 [json_name = "bucketStartTimestamp"];
  if (this->_internal_bucket_start_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_bucket_start_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeDiscountBucketVolumeAccounts::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeDiscountBucketVolumeAccounts::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeDiscountBucketVolumeAccounts::GetClassData() const { return &_class_data_; }


void FeeDiscountBucketVolumeAccounts::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeDiscountBucketVolumeAccounts*>(&to_msg);
  auto& from = static_cast<const FeeDiscountBucketVolumeAccounts&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_account_volume()->MergeFrom(from._internal_account_volume());
  if (from._internal_bucket_start_timestamp() != 0) {
    _this->_internal_set_bucket_start_timestamp(from._internal_bucket_start_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeDiscountBucketVolumeAccounts::CopyFrom(const FeeDiscountBucketVolumeAccounts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeDiscountBucketVolumeAccounts::IsInitialized() const {
  return true;
}

void FeeDiscountBucketVolumeAccounts::InternalSwap(FeeDiscountBucketVolumeAccounts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_account_volume()->InternalSwap(other->_internal_mutable_account_volume());

  swap(_impl_.bucket_start_timestamp_, other->_impl_.bucket_start_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeDiscountBucketVolumeAccounts::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[3]);
}
// ===================================================================

class AccountVolume::_Internal {
 public:
};

AccountVolume::AccountVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.AccountVolume)
}
AccountVolume::AccountVolume(const AccountVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_) {}

    , decltype(_impl_.volume_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account().empty()) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  _impl_.volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_volume().empty()) {
    _this->_impl_.volume_.Set(from._internal_volume(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.AccountVolume)
}

inline void AccountVolume::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_) {}

    , decltype(_impl_.volume_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountVolume::~AccountVolume() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.AccountVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountVolume::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_.Destroy();
  _impl_.volume_.Destroy();
}

void AccountVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.AccountVolume)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_.ClearToEmpty();
  _impl_.volume_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account = 1 [json_name = "account"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.AccountVolume.account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string volume = 2 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_volume();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.AccountVolume.volume"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountVolume::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.AccountVolume)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    const std::string& _s = this->_internal_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.AccountVolume.account");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string volume = 2 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_volume().empty()) {
    const std::string& _s = this->_internal_volume();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.AccountVolume.volume");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.AccountVolume)
  return target;
}

::size_t AccountVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.AccountVolume)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account());
  }

  // string volume = 2 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_volume().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_volume());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountVolume::GetClassData() const { return &_class_data_; }


void AccountVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountVolume*>(&to_msg);
  auto& from = static_cast<const AccountVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.AccountVolume)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account().empty()) {
    _this->_internal_set_account(from._internal_account());
  }
  if (!from._internal_volume().empty()) {
    _this->_internal_set_volume(from._internal_volume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountVolume::CopyFrom(const AccountVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.AccountVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountVolume::IsInitialized() const {
  return true;
}

void AccountVolume::InternalSwap(AccountVolume* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.volume_, lhs_arena,
                                       &other->_impl_.volume_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[4]);
}
// ===================================================================

class TradingRewardCampaignAccountPoints::_Internal {
 public:
};

TradingRewardCampaignAccountPoints::TradingRewardCampaignAccountPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
}
TradingRewardCampaignAccountPoints::TradingRewardCampaignAccountPoints(const TradingRewardCampaignAccountPoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradingRewardCampaignAccountPoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_) {}

    , decltype(_impl_.points_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account().empty()) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  _impl_.points_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.points_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_points().empty()) {
    _this->_impl_.points_.Set(from._internal_points(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
}

inline void TradingRewardCampaignAccountPoints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_) {}

    , decltype(_impl_.points_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.points_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.points_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradingRewardCampaignAccountPoints::~TradingRewardCampaignAccountPoints() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradingRewardCampaignAccountPoints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_.Destroy();
  _impl_.points_.Destroy();
}

void TradingRewardCampaignAccountPoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradingRewardCampaignAccountPoints::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_.ClearToEmpty();
  _impl_.points_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradingRewardCampaignAccountPoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account = 1 [json_name = "account"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradingRewardCampaignAccountPoints.account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string points = 2 [json_name = "points", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_points();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradingRewardCampaignAccountPoints.points"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradingRewardCampaignAccountPoints::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    const std::string& _s = this->_internal_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradingRewardCampaignAccountPoints.account");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string points = 2 [json_name = "points", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_points().empty()) {
    const std::string& _s = this->_internal_points();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradingRewardCampaignAccountPoints.points");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
  return target;
}

::size_t TradingRewardCampaignAccountPoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account());
  }

  // string points = 2 [json_name = "points", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_points().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_points());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradingRewardCampaignAccountPoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradingRewardCampaignAccountPoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradingRewardCampaignAccountPoints::GetClassData() const { return &_class_data_; }


void TradingRewardCampaignAccountPoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradingRewardCampaignAccountPoints*>(&to_msg);
  auto& from = static_cast<const TradingRewardCampaignAccountPoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account().empty()) {
    _this->_internal_set_account(from._internal_account());
  }
  if (!from._internal_points().empty()) {
    _this->_internal_set_points(from._internal_points());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradingRewardCampaignAccountPoints::CopyFrom(const TradingRewardCampaignAccountPoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradingRewardCampaignAccountPoints::IsInitialized() const {
  return true;
}

void TradingRewardCampaignAccountPoints::InternalSwap(TradingRewardCampaignAccountPoints* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.points_, lhs_arena,
                                       &other->_impl_.points_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TradingRewardCampaignAccountPoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[5]);
}
// ===================================================================

class TradingRewardCampaignAccountPendingPoints::_Internal {
 public:
};

TradingRewardCampaignAccountPendingPoints::TradingRewardCampaignAccountPendingPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
}
TradingRewardCampaignAccountPendingPoints::TradingRewardCampaignAccountPendingPoints(const TradingRewardCampaignAccountPendingPoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradingRewardCampaignAccountPendingPoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_points_){from._impl_.account_points_}
    , decltype(_impl_.reward_pool_start_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.reward_pool_start_timestamp_ = from._impl_.reward_pool_start_timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
}

inline void TradingRewardCampaignAccountPendingPoints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_points_){arena}
    , decltype(_impl_.reward_pool_start_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TradingRewardCampaignAccountPendingPoints::~TradingRewardCampaignAccountPendingPoints() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradingRewardCampaignAccountPendingPoints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_account_points()->~RepeatedPtrField();
}

void TradingRewardCampaignAccountPendingPoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradingRewardCampaignAccountPendingPoints::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_account_points()->Clear();
  _impl_.reward_pool_start_timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradingRewardCampaignAccountPendingPoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 reward_pool_start_timestamp = 1 [json_name = "rewardPoolStartTimestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.reward_pool_start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints account_points = 2 [json_name = "accountPoints"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_account_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradingRewardCampaignAccountPendingPoints::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 reward_pool_start_timestamp = 1 [json_name = "rewardPoolStartTimestamp"];
  if (this->_internal_reward_pool_start_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_reward_pool_start_timestamp(), target);
  }

  // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints account_points = 2 [json_name = "accountPoints"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_account_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_account_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
  return target;
}

::size_t TradingRewardCampaignAccountPendingPoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints account_points = 2 [json_name = "accountPoints"];
  total_size += 1UL * this->_internal_account_points_size();
  for (const auto& msg : this->_internal_account_points()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 reward_pool_start_timestamp = 1 [json_name = "rewardPoolStartTimestamp"];
  if (this->_internal_reward_pool_start_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_reward_pool_start_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradingRewardCampaignAccountPendingPoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradingRewardCampaignAccountPendingPoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradingRewardCampaignAccountPendingPoints::GetClassData() const { return &_class_data_; }


void TradingRewardCampaignAccountPendingPoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradingRewardCampaignAccountPendingPoints*>(&to_msg);
  auto& from = static_cast<const TradingRewardCampaignAccountPendingPoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_account_points()->MergeFrom(from._internal_account_points());
  if (from._internal_reward_pool_start_timestamp() != 0) {
    _this->_internal_set_reward_pool_start_timestamp(from._internal_reward_pool_start_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradingRewardCampaignAccountPendingPoints::CopyFrom(const TradingRewardCampaignAccountPendingPoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradingRewardCampaignAccountPendingPoints::IsInitialized() const {
  return true;
}

void TradingRewardCampaignAccountPendingPoints::InternalSwap(TradingRewardCampaignAccountPendingPoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_account_points()->InternalSwap(other->_internal_mutable_account_points());

  swap(_impl_.reward_pool_start_timestamp_, other->_impl_.reward_pool_start_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TradingRewardCampaignAccountPendingPoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[6]);
}
// ===================================================================

class SpotOrderBook::_Internal {
 public:
};

void SpotOrderBook::clear_orders() {
  _internal_mutable_orders()->Clear();
}
SpotOrderBook::SpotOrderBook(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SpotOrderBook)
}
SpotOrderBook::SpotOrderBook(const SpotOrderBook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotOrderBook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){from._impl_.orders_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.isbuyside_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.isbuyside_ = from._impl_.isbuyside_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SpotOrderBook)
}

inline void SpotOrderBook::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.isbuyside_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotOrderBook::~SpotOrderBook() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SpotOrderBook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotOrderBook::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_orders()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void SpotOrderBook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotOrderBook::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SpotOrderBook)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_orders()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _impl_.isbuyside_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotOrderBook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotOrderBook.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isBuySide = 2 [json_name = "isBuySide"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.isbuyside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SpotLimitOrder orders = 3 [json_name = "orders"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotOrderBook::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SpotOrderBook)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotOrderBook.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool isBuySide = 2 [json_name = "isBuySide"];
  if (this->_internal_isbuyside() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_isbuyside(), target);
  }

  // repeated .injective.exchange.v1beta1.SpotLimitOrder orders = 3 [json_name = "orders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SpotOrderBook)
  return target;
}

::size_t SpotOrderBook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SpotOrderBook)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.SpotLimitOrder orders = 3 [json_name = "orders"];
  total_size += 1UL * this->_internal_orders_size();
  for (const auto& msg : this->_internal_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // bool isBuySide = 2 [json_name = "isBuySide"];
  if (this->_internal_isbuyside() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotOrderBook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotOrderBook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotOrderBook::GetClassData() const { return &_class_data_; }


void SpotOrderBook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotOrderBook*>(&to_msg);
  auto& from = static_cast<const SpotOrderBook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SpotOrderBook)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_orders()->MergeFrom(from._internal_orders());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_isbuyside() != 0) {
    _this->_internal_set_isbuyside(from._internal_isbuyside());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotOrderBook::CopyFrom(const SpotOrderBook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SpotOrderBook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotOrderBook::IsInitialized() const {
  return true;
}

void SpotOrderBook::InternalSwap(SpotOrderBook* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_orders()->InternalSwap(other->_internal_mutable_orders());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);

  swap(_impl_.isbuyside_, other->_impl_.isbuyside_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotOrderBook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[7]);
}
// ===================================================================

class DerivativeOrderBook::_Internal {
 public:
};

void DerivativeOrderBook::clear_orders() {
  _internal_mutable_orders()->Clear();
}
DerivativeOrderBook::DerivativeOrderBook(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeOrderBook)
}
DerivativeOrderBook::DerivativeOrderBook(const DerivativeOrderBook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeOrderBook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){from._impl_.orders_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.isbuyside_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.isbuyside_ = from._impl_.isbuyside_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeOrderBook)
}

inline void DerivativeOrderBook::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.isbuyside_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeOrderBook::~DerivativeOrderBook() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeOrderBook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeOrderBook::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_orders()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void DerivativeOrderBook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeOrderBook::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeOrderBook)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_orders()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _impl_.isbuyside_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeOrderBook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeOrderBook.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isBuySide = 2 [json_name = "isBuySide"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.isbuyside_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeLimitOrder orders = 3 [json_name = "orders"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeOrderBook::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeOrderBook)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeOrderBook.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool isBuySide = 2 [json_name = "isBuySide"];
  if (this->_internal_isbuyside() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_isbuyside(), target);
  }

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder orders = 3 [json_name = "orders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeOrderBook)
  return target;
}

::size_t DerivativeOrderBook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeOrderBook)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder orders = 3 [json_name = "orders"];
  total_size += 1UL * this->_internal_orders_size();
  for (const auto& msg : this->_internal_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // bool isBuySide = 2 [json_name = "isBuySide"];
  if (this->_internal_isbuyside() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeOrderBook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeOrderBook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeOrderBook::GetClassData() const { return &_class_data_; }


void DerivativeOrderBook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeOrderBook*>(&to_msg);
  auto& from = static_cast<const DerivativeOrderBook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeOrderBook)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_orders()->MergeFrom(from._internal_orders());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_isbuyside() != 0) {
    _this->_internal_set_isbuyside(from._internal_isbuyside());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeOrderBook::CopyFrom(const DerivativeOrderBook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeOrderBook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeOrderBook::IsInitialized() const {
  return true;
}

void DerivativeOrderBook::InternalSwap(DerivativeOrderBook* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_orders()->InternalSwap(other->_internal_mutable_orders());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);

  swap(_impl_.isbuyside_, other->_impl_.isbuyside_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeOrderBook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[8]);
}
// ===================================================================

class ConditionalDerivativeOrderBook::_Internal {
 public:
};

void ConditionalDerivativeOrderBook::clear_limit_buy_orders() {
  _internal_mutable_limit_buy_orders()->Clear();
}
void ConditionalDerivativeOrderBook::clear_market_buy_orders() {
  _internal_mutable_market_buy_orders()->Clear();
}
void ConditionalDerivativeOrderBook::clear_limit_sell_orders() {
  _internal_mutable_limit_sell_orders()->Clear();
}
void ConditionalDerivativeOrderBook::clear_market_sell_orders() {
  _internal_mutable_market_sell_orders()->Clear();
}
ConditionalDerivativeOrderBook::ConditionalDerivativeOrderBook(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
}
ConditionalDerivativeOrderBook::ConditionalDerivativeOrderBook(const ConditionalDerivativeOrderBook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConditionalDerivativeOrderBook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.limit_buy_orders_){from._impl_.limit_buy_orders_}
    , decltype(_impl_.market_buy_orders_){from._impl_.market_buy_orders_}
    , decltype(_impl_.limit_sell_orders_){from._impl_.limit_sell_orders_}
    , decltype(_impl_.market_sell_orders_){from._impl_.market_sell_orders_}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
}

inline void ConditionalDerivativeOrderBook::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.limit_buy_orders_){arena}
    , decltype(_impl_.market_buy_orders_){arena}
    , decltype(_impl_.limit_sell_orders_){arena}
    , decltype(_impl_.market_sell_orders_){arena}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConditionalDerivativeOrderBook::~ConditionalDerivativeOrderBook() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConditionalDerivativeOrderBook::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_limit_buy_orders()->~RepeatedPtrField();
  _internal_mutable_market_buy_orders()->~RepeatedPtrField();
  _internal_mutable_limit_sell_orders()->~RepeatedPtrField();
  _internal_mutable_market_sell_orders()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void ConditionalDerivativeOrderBook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConditionalDerivativeOrderBook::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_limit_buy_orders()->Clear();
  _internal_mutable_market_buy_orders()->Clear();
  _internal_mutable_limit_sell_orders()->Clear();
  _internal_mutable_market_sell_orders()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConditionalDerivativeOrderBook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.ConditionalDerivativeOrderBook.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_buy_orders = 2 [json_name = "limitBuyOrders"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_limit_buy_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_buy_orders = 3 [json_name = "marketBuyOrders"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_market_buy_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_sell_orders = 4 [json_name = "limitSellOrders"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_limit_sell_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_sell_orders = 5 [json_name = "marketSellOrders"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_market_sell_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConditionalDerivativeOrderBook::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.ConditionalDerivativeOrderBook.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_buy_orders = 2 [json_name = "limitBuyOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_limit_buy_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_limit_buy_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_buy_orders = 3 [json_name = "marketBuyOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_market_buy_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_market_buy_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_sell_orders = 4 [json_name = "limitSellOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_limit_sell_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_limit_sell_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_sell_orders = 5 [json_name = "marketSellOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_market_sell_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_market_sell_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
  return target;
}

::size_t ConditionalDerivativeOrderBook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_buy_orders = 2 [json_name = "limitBuyOrders"];
  total_size += 1UL * this->_internal_limit_buy_orders_size();
  for (const auto& msg : this->_internal_limit_buy_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_buy_orders = 3 [json_name = "marketBuyOrders"];
  total_size += 1UL * this->_internal_market_buy_orders_size();
  for (const auto& msg : this->_internal_market_buy_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_sell_orders = 4 [json_name = "limitSellOrders"];
  total_size += 1UL * this->_internal_limit_sell_orders_size();
  for (const auto& msg : this->_internal_limit_sell_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_sell_orders = 5 [json_name = "marketSellOrders"];
  total_size += 1UL * this->_internal_market_sell_orders_size();
  for (const auto& msg : this->_internal_market_sell_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConditionalDerivativeOrderBook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConditionalDerivativeOrderBook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConditionalDerivativeOrderBook::GetClassData() const { return &_class_data_; }


void ConditionalDerivativeOrderBook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConditionalDerivativeOrderBook*>(&to_msg);
  auto& from = static_cast<const ConditionalDerivativeOrderBook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_limit_buy_orders()->MergeFrom(from._internal_limit_buy_orders());
  _this->_internal_mutable_market_buy_orders()->MergeFrom(from._internal_market_buy_orders());
  _this->_internal_mutable_limit_sell_orders()->MergeFrom(from._internal_limit_sell_orders());
  _this->_internal_mutable_market_sell_orders()->MergeFrom(from._internal_market_sell_orders());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConditionalDerivativeOrderBook::CopyFrom(const ConditionalDerivativeOrderBook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.ConditionalDerivativeOrderBook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalDerivativeOrderBook::IsInitialized() const {
  return true;
}

void ConditionalDerivativeOrderBook::InternalSwap(ConditionalDerivativeOrderBook* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_limit_buy_orders()->InternalSwap(other->_internal_mutable_limit_buy_orders());
  _internal_mutable_market_buy_orders()->InternalSwap(other->_internal_mutable_market_buy_orders());
  _internal_mutable_limit_sell_orders()->InternalSwap(other->_internal_mutable_limit_sell_orders());
  _internal_mutable_market_sell_orders()->InternalSwap(other->_internal_mutable_market_sell_orders());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConditionalDerivativeOrderBook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[9]);
}
// ===================================================================

class Balance::_Internal {
 public:
  using HasBits = decltype(std::declval<Balance>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Balance, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::Deposit& deposits(const Balance* msg);
  static void set_has_deposits(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::Deposit&
Balance::_Internal::deposits(const Balance* msg) {
  return *msg->_impl_.deposits_;
}
void Balance::clear_deposits() {
  if (_impl_.deposits_ != nullptr) _impl_.deposits_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Balance::Balance(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.Balance)
}
Balance::Balance(const Balance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Balance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.denom_) {}

    , decltype(_impl_.deposits_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.deposits_ = new ::injective::exchange::v1beta1::Deposit(*from._impl_.deposits_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.Balance)
}

inline void Balance::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.denom_) {}

    , decltype(_impl_.deposits_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Balance::~Balance() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.Balance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Balance::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.denom_.Destroy();
  if (this != internal_default_instance()) delete _impl_.deposits_;
}

void Balance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Balance::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.Balance)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.denom_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.deposits_ != nullptr);
    _impl_.deposits_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Balance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Balance.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string denom = 2 [json_name = "denom"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Balance.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.Deposit deposits = 3 [json_name = "deposits"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_deposits(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Balance::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.Balance)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Balance.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string denom = 2 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Balance.denom");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.Deposit deposits = 3 [json_name = "deposits"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::deposits(this),
        _Internal::deposits(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.Balance)
  return target;
}

::size_t Balance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.Balance)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string denom = 2 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  // .injective.exchange.v1beta1.Deposit deposits = 3 [json_name = "deposits"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.deposits_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Balance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Balance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Balance::GetClassData() const { return &_class_data_; }


void Balance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Balance*>(&to_msg);
  auto& from = static_cast<const Balance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.Balance)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_deposits()->::injective::exchange::v1beta1::Deposit::MergeFrom(
        from._internal_deposits());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Balance::CopyFrom(const Balance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.Balance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Balance::IsInitialized() const {
  return true;
}

void Balance::InternalSwap(Balance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);
  swap(_impl_.deposits_, other->_impl_.deposits_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Balance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[10]);
}
// ===================================================================

class DerivativePosition::_Internal {
 public:
  using HasBits = decltype(std::declval<DerivativePosition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DerivativePosition, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::Position& position(const DerivativePosition* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::Position&
DerivativePosition::_Internal::position(const DerivativePosition* msg) {
  return *msg->_impl_.position_;
}
void DerivativePosition::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
DerivativePosition::DerivativePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativePosition)
}
DerivativePosition::DerivativePosition(const DerivativePosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativePosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.position_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::injective::exchange::v1beta1::Position(*from._impl_.position_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativePosition)
}

inline void DerivativePosition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.position_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativePosition::~DerivativePosition() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativePosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativePosition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void DerivativePosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativePosition::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativePosition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativePosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativePosition.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativePosition.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.Position position = 3 [json_name = "position"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativePosition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativePosition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativePosition.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativePosition.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.Position position = 3 [json_name = "position"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativePosition)
  return target;
}

::size_t DerivativePosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativePosition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective.exchange.v1beta1.Position position = 3 [json_name = "position"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativePosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativePosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativePosition::GetClassData() const { return &_class_data_; }


void DerivativePosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativePosition*>(&to_msg);
  auto& from = static_cast<const DerivativePosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativePosition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::injective::exchange::v1beta1::Position::MergeFrom(
        from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativePosition::CopyFrom(const DerivativePosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativePosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativePosition::IsInitialized() const {
  return true;
}

void DerivativePosition::InternalSwap(DerivativePosition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativePosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[11]);
}
// ===================================================================

class SubaccountNonce::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountNonce>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountNonce, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::SubaccountTradeNonce& subaccount_trade_nonce(const SubaccountNonce* msg);
  static void set_has_subaccount_trade_nonce(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::SubaccountTradeNonce&
SubaccountNonce::_Internal::subaccount_trade_nonce(const SubaccountNonce* msg) {
  return *msg->_impl_.subaccount_trade_nonce_;
}
void SubaccountNonce::clear_subaccount_trade_nonce() {
  if (_impl_.subaccount_trade_nonce_ != nullptr) _impl_.subaccount_trade_nonce_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SubaccountNonce::SubaccountNonce(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountNonce)
}
SubaccountNonce::SubaccountNonce(const SubaccountNonce& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountNonce* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.subaccount_trade_nonce_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.subaccount_trade_nonce_ = new ::injective::exchange::v1beta1::SubaccountTradeNonce(*from._impl_.subaccount_trade_nonce_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountNonce)
}

inline void SubaccountNonce::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.subaccount_trade_nonce_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountNonce::~SubaccountNonce() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountNonce)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountNonce::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.subaccount_trade_nonce_;
}

void SubaccountNonce::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountNonce::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountNonce)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.subaccount_trade_nonce_ != nullptr);
    _impl_.subaccount_trade_nonce_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountNonce::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SubaccountNonce.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.SubaccountTradeNonce subaccount_trade_nonce = 2 [json_name = "subaccountTradeNonce", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_subaccount_trade_nonce(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountNonce::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountNonce)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SubaccountNonce.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.SubaccountTradeNonce subaccount_trade_nonce = 2 [json_name = "subaccountTradeNonce", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::subaccount_trade_nonce(this),
        _Internal::subaccount_trade_nonce(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountNonce)
  return target;
}

::size_t SubaccountNonce::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountNonce)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // .injective.exchange.v1beta1.SubaccountTradeNonce subaccount_trade_nonce = 2 [json_name = "subaccountTradeNonce", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.subaccount_trade_nonce_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountNonce::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountNonce::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountNonce::GetClassData() const { return &_class_data_; }


void SubaccountNonce::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountNonce*>(&to_msg);
  auto& from = static_cast<const SubaccountNonce&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountNonce)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_subaccount_trade_nonce()->::injective::exchange::v1beta1::SubaccountTradeNonce::MergeFrom(
        from._internal_subaccount_trade_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountNonce::CopyFrom(const SubaccountNonce& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountNonce)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountNonce::IsInitialized() const {
  return true;
}

void SubaccountNonce::InternalSwap(SubaccountNonce* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  swap(_impl_.subaccount_trade_nonce_, other->_impl_.subaccount_trade_nonce_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountNonce::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[12]);
}
// ===================================================================

class ExpiryFuturesMarketInfoState::_Internal {
 public:
  using HasBits = decltype(std::declval<ExpiryFuturesMarketInfoState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ExpiryFuturesMarketInfoState, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& market_info(const ExpiryFuturesMarketInfoState* msg);
  static void set_has_market_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo&
ExpiryFuturesMarketInfoState::_Internal::market_info(const ExpiryFuturesMarketInfoState* msg) {
  return *msg->_impl_.market_info_;
}
void ExpiryFuturesMarketInfoState::clear_market_info() {
  if (_impl_.market_info_ != nullptr) _impl_.market_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ExpiryFuturesMarketInfoState::ExpiryFuturesMarketInfoState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
}
ExpiryFuturesMarketInfoState::ExpiryFuturesMarketInfoState(const ExpiryFuturesMarketInfoState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpiryFuturesMarketInfoState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.market_info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_info_ = new ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo(*from._impl_.market_info_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
}

inline void ExpiryFuturesMarketInfoState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.market_info_){nullptr}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExpiryFuturesMarketInfoState::~ExpiryFuturesMarketInfoState() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpiryFuturesMarketInfoState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.market_info_;
}

void ExpiryFuturesMarketInfoState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpiryFuturesMarketInfoState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.market_info_ != nullptr);
    _impl_.market_info_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpiryFuturesMarketInfoState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.ExpiryFuturesMarketInfoState.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo market_info = 2 [json_name = "marketInfo"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ExpiryFuturesMarketInfoState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.ExpiryFuturesMarketInfoState.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo market_info = 2 [json_name = "marketInfo"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::market_info(this),
        _Internal::market_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
  return target;
}

::size_t ExpiryFuturesMarketInfoState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo market_info = 2 [json_name = "marketInfo"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.market_info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpiryFuturesMarketInfoState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpiryFuturesMarketInfoState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpiryFuturesMarketInfoState::GetClassData() const { return &_class_data_; }


void ExpiryFuturesMarketInfoState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpiryFuturesMarketInfoState*>(&to_msg);
  auto& from = static_cast<const ExpiryFuturesMarketInfoState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_market_info()->::injective::exchange::v1beta1::ExpiryFuturesMarketInfo::MergeFrom(
        from._internal_market_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpiryFuturesMarketInfoState::CopyFrom(const ExpiryFuturesMarketInfoState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfoState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpiryFuturesMarketInfoState::IsInitialized() const {
  return true;
}

void ExpiryFuturesMarketInfoState::InternalSwap(ExpiryFuturesMarketInfoState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  swap(_impl_.market_info_, other->_impl_.market_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpiryFuturesMarketInfoState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[13]);
}
// ===================================================================

class PerpetualMarketFundingState::_Internal {
 public:
  using HasBits = decltype(std::declval<PerpetualMarketFundingState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PerpetualMarketFundingState, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::PerpetualMarketFunding& funding(const PerpetualMarketFundingState* msg);
  static void set_has_funding(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::PerpetualMarketFunding&
PerpetualMarketFundingState::_Internal::funding(const PerpetualMarketFundingState* msg) {
  return *msg->_impl_.funding_;
}
void PerpetualMarketFundingState::clear_funding() {
  if (_impl_.funding_ != nullptr) _impl_.funding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PerpetualMarketFundingState::PerpetualMarketFundingState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.PerpetualMarketFundingState)
}
PerpetualMarketFundingState::PerpetualMarketFundingState(const PerpetualMarketFundingState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PerpetualMarketFundingState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.funding_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.funding_ = new ::injective::exchange::v1beta1::PerpetualMarketFunding(*from._impl_.funding_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.PerpetualMarketFundingState)
}

inline void PerpetualMarketFundingState::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.funding_){nullptr}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PerpetualMarketFundingState::~PerpetualMarketFundingState() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.PerpetualMarketFundingState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PerpetualMarketFundingState::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.funding_;
}

void PerpetualMarketFundingState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PerpetualMarketFundingState::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.PerpetualMarketFundingState)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.funding_ != nullptr);
    _impl_.funding_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PerpetualMarketFundingState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PerpetualMarketFundingState.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_funding(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PerpetualMarketFundingState::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.PerpetualMarketFundingState)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PerpetualMarketFundingState.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::funding(this),
        _Internal::funding(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.PerpetualMarketFundingState)
  return target;
}

::size_t PerpetualMarketFundingState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.PerpetualMarketFundingState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.funding_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PerpetualMarketFundingState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PerpetualMarketFundingState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PerpetualMarketFundingState::GetClassData() const { return &_class_data_; }


void PerpetualMarketFundingState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PerpetualMarketFundingState*>(&to_msg);
  auto& from = static_cast<const PerpetualMarketFundingState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.PerpetualMarketFundingState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_funding()->::injective::exchange::v1beta1::PerpetualMarketFunding::MergeFrom(
        from._internal_funding());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PerpetualMarketFundingState::CopyFrom(const PerpetualMarketFundingState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.PerpetualMarketFundingState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerpetualMarketFundingState::IsInitialized() const {
  return true;
}

void PerpetualMarketFundingState::InternalSwap(PerpetualMarketFundingState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  swap(_impl_.funding_, other->_impl_.funding_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PerpetualMarketFundingState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fgenesis_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fgenesis_2eproto[14]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::GenesisState*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::GenesisState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::GenesisState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::OrderbookSequence*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::OrderbookSequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::OrderbookSequence >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::FeeDiscountAccountTierTTL*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::FeeDiscountAccountTierTTL >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::FeeDiscountAccountTierTTL >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::FeeDiscountBucketVolumeAccounts*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::FeeDiscountBucketVolumeAccounts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::FeeDiscountBucketVolumeAccounts >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::AccountVolume*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::AccountVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::AccountVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::TradingRewardCampaignAccountPoints*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::TradingRewardCampaignAccountPoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::TradingRewardCampaignAccountPoints >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::TradingRewardCampaignAccountPendingPoints*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::TradingRewardCampaignAccountPendingPoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::TradingRewardCampaignAccountPendingPoints >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SpotOrderBook*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SpotOrderBook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SpotOrderBook >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeOrderBook*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeOrderBook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeOrderBook >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::ConditionalDerivativeOrderBook*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::ConditionalDerivativeOrderBook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::ConditionalDerivativeOrderBook >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::Balance*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::Balance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::Balance >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativePosition*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativePosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativePosition >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountNonce*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountNonce >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountNonce >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::ExpiryFuturesMarketInfoState >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::PerpetualMarketFundingState*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::PerpetualMarketFundingState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::PerpetualMarketFundingState >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
