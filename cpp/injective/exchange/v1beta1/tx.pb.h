// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/exchange/v1beta1/tx.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2ftx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2ftx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmos/distribution/v1beta1/distribution.pb.h"
#include "cosmos/msg/v1/msg.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "gogoproto/gogo.pb.h"
#include "injective/exchange/v1beta1/exchange.pb.h"
#include "injective/oracle/v1beta1/oracle.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2fexchange_2fv1beta1_2ftx_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2fexchange_2fv1beta1_2ftx_2eproto;
namespace injective {
namespace exchange {
namespace v1beta1 {
class AtomicMarketOrderFeeMultiplierScheduleProposal;
struct AtomicMarketOrderFeeMultiplierScheduleProposalDefaultTypeInternal;
extern AtomicMarketOrderFeeMultiplierScheduleProposalDefaultTypeInternal _AtomicMarketOrderFeeMultiplierScheduleProposal_default_instance_;
class BatchCommunityPoolSpendProposal;
struct BatchCommunityPoolSpendProposalDefaultTypeInternal;
extern BatchCommunityPoolSpendProposalDefaultTypeInternal _BatchCommunityPoolSpendProposal_default_instance_;
class BatchExchangeModificationProposal;
struct BatchExchangeModificationProposalDefaultTypeInternal;
extern BatchExchangeModificationProposalDefaultTypeInternal _BatchExchangeModificationProposal_default_instance_;
class BinaryOptionsMarketLaunchProposal;
struct BinaryOptionsMarketLaunchProposalDefaultTypeInternal;
extern BinaryOptionsMarketLaunchProposalDefaultTypeInternal _BinaryOptionsMarketLaunchProposal_default_instance_;
class BinaryOptionsMarketParamUpdateProposal;
struct BinaryOptionsMarketParamUpdateProposalDefaultTypeInternal;
extern BinaryOptionsMarketParamUpdateProposalDefaultTypeInternal _BinaryOptionsMarketParamUpdateProposal_default_instance_;
class DerivativeMarketOrderResults;
struct DerivativeMarketOrderResultsDefaultTypeInternal;
extern DerivativeMarketOrderResultsDefaultTypeInternal _DerivativeMarketOrderResults_default_instance_;
class DerivativeMarketParamUpdateProposal;
struct DerivativeMarketParamUpdateProposalDefaultTypeInternal;
extern DerivativeMarketParamUpdateProposalDefaultTypeInternal _DerivativeMarketParamUpdateProposal_default_instance_;
class ExchangeEnableProposal;
struct ExchangeEnableProposalDefaultTypeInternal;
extern ExchangeEnableProposalDefaultTypeInternal _ExchangeEnableProposal_default_instance_;
class ExpiryFuturesMarketLaunchProposal;
struct ExpiryFuturesMarketLaunchProposalDefaultTypeInternal;
extern ExpiryFuturesMarketLaunchProposalDefaultTypeInternal _ExpiryFuturesMarketLaunchProposal_default_instance_;
class FeeDiscountProposal;
struct FeeDiscountProposalDefaultTypeInternal;
extern FeeDiscountProposalDefaultTypeInternal _FeeDiscountProposal_default_instance_;
class MarketForcedSettlementProposal;
struct MarketForcedSettlementProposalDefaultTypeInternal;
extern MarketForcedSettlementProposalDefaultTypeInternal _MarketForcedSettlementProposal_default_instance_;
class MsgAdminUpdateBinaryOptionsMarket;
struct MsgAdminUpdateBinaryOptionsMarketDefaultTypeInternal;
extern MsgAdminUpdateBinaryOptionsMarketDefaultTypeInternal _MsgAdminUpdateBinaryOptionsMarket_default_instance_;
class MsgAdminUpdateBinaryOptionsMarketResponse;
struct MsgAdminUpdateBinaryOptionsMarketResponseDefaultTypeInternal;
extern MsgAdminUpdateBinaryOptionsMarketResponseDefaultTypeInternal _MsgAdminUpdateBinaryOptionsMarketResponse_default_instance_;
class MsgBatchCancelBinaryOptionsOrders;
struct MsgBatchCancelBinaryOptionsOrdersDefaultTypeInternal;
extern MsgBatchCancelBinaryOptionsOrdersDefaultTypeInternal _MsgBatchCancelBinaryOptionsOrders_default_instance_;
class MsgBatchCancelBinaryOptionsOrdersResponse;
struct MsgBatchCancelBinaryOptionsOrdersResponseDefaultTypeInternal;
extern MsgBatchCancelBinaryOptionsOrdersResponseDefaultTypeInternal _MsgBatchCancelBinaryOptionsOrdersResponse_default_instance_;
class MsgBatchCancelDerivativeOrders;
struct MsgBatchCancelDerivativeOrdersDefaultTypeInternal;
extern MsgBatchCancelDerivativeOrdersDefaultTypeInternal _MsgBatchCancelDerivativeOrders_default_instance_;
class MsgBatchCancelDerivativeOrdersResponse;
struct MsgBatchCancelDerivativeOrdersResponseDefaultTypeInternal;
extern MsgBatchCancelDerivativeOrdersResponseDefaultTypeInternal _MsgBatchCancelDerivativeOrdersResponse_default_instance_;
class MsgBatchCancelSpotOrders;
struct MsgBatchCancelSpotOrdersDefaultTypeInternal;
extern MsgBatchCancelSpotOrdersDefaultTypeInternal _MsgBatchCancelSpotOrders_default_instance_;
class MsgBatchCancelSpotOrdersResponse;
struct MsgBatchCancelSpotOrdersResponseDefaultTypeInternal;
extern MsgBatchCancelSpotOrdersResponseDefaultTypeInternal _MsgBatchCancelSpotOrdersResponse_default_instance_;
class MsgBatchCreateDerivativeLimitOrders;
struct MsgBatchCreateDerivativeLimitOrdersDefaultTypeInternal;
extern MsgBatchCreateDerivativeLimitOrdersDefaultTypeInternal _MsgBatchCreateDerivativeLimitOrders_default_instance_;
class MsgBatchCreateDerivativeLimitOrdersResponse;
struct MsgBatchCreateDerivativeLimitOrdersResponseDefaultTypeInternal;
extern MsgBatchCreateDerivativeLimitOrdersResponseDefaultTypeInternal _MsgBatchCreateDerivativeLimitOrdersResponse_default_instance_;
class MsgBatchCreateSpotLimitOrders;
struct MsgBatchCreateSpotLimitOrdersDefaultTypeInternal;
extern MsgBatchCreateSpotLimitOrdersDefaultTypeInternal _MsgBatchCreateSpotLimitOrders_default_instance_;
class MsgBatchCreateSpotLimitOrdersResponse;
struct MsgBatchCreateSpotLimitOrdersResponseDefaultTypeInternal;
extern MsgBatchCreateSpotLimitOrdersResponseDefaultTypeInternal _MsgBatchCreateSpotLimitOrdersResponse_default_instance_;
class MsgBatchUpdateOrders;
struct MsgBatchUpdateOrdersDefaultTypeInternal;
extern MsgBatchUpdateOrdersDefaultTypeInternal _MsgBatchUpdateOrders_default_instance_;
class MsgBatchUpdateOrdersResponse;
struct MsgBatchUpdateOrdersResponseDefaultTypeInternal;
extern MsgBatchUpdateOrdersResponseDefaultTypeInternal _MsgBatchUpdateOrdersResponse_default_instance_;
class MsgCancelBinaryOptionsOrder;
struct MsgCancelBinaryOptionsOrderDefaultTypeInternal;
extern MsgCancelBinaryOptionsOrderDefaultTypeInternal _MsgCancelBinaryOptionsOrder_default_instance_;
class MsgCancelBinaryOptionsOrderResponse;
struct MsgCancelBinaryOptionsOrderResponseDefaultTypeInternal;
extern MsgCancelBinaryOptionsOrderResponseDefaultTypeInternal _MsgCancelBinaryOptionsOrderResponse_default_instance_;
class MsgCancelDerivativeOrder;
struct MsgCancelDerivativeOrderDefaultTypeInternal;
extern MsgCancelDerivativeOrderDefaultTypeInternal _MsgCancelDerivativeOrder_default_instance_;
class MsgCancelDerivativeOrderResponse;
struct MsgCancelDerivativeOrderResponseDefaultTypeInternal;
extern MsgCancelDerivativeOrderResponseDefaultTypeInternal _MsgCancelDerivativeOrderResponse_default_instance_;
class MsgCancelSpotOrder;
struct MsgCancelSpotOrderDefaultTypeInternal;
extern MsgCancelSpotOrderDefaultTypeInternal _MsgCancelSpotOrder_default_instance_;
class MsgCancelSpotOrderResponse;
struct MsgCancelSpotOrderResponseDefaultTypeInternal;
extern MsgCancelSpotOrderResponseDefaultTypeInternal _MsgCancelSpotOrderResponse_default_instance_;
class MsgCreateBinaryOptionsLimitOrder;
struct MsgCreateBinaryOptionsLimitOrderDefaultTypeInternal;
extern MsgCreateBinaryOptionsLimitOrderDefaultTypeInternal _MsgCreateBinaryOptionsLimitOrder_default_instance_;
class MsgCreateBinaryOptionsLimitOrderResponse;
struct MsgCreateBinaryOptionsLimitOrderResponseDefaultTypeInternal;
extern MsgCreateBinaryOptionsLimitOrderResponseDefaultTypeInternal _MsgCreateBinaryOptionsLimitOrderResponse_default_instance_;
class MsgCreateBinaryOptionsMarketOrder;
struct MsgCreateBinaryOptionsMarketOrderDefaultTypeInternal;
extern MsgCreateBinaryOptionsMarketOrderDefaultTypeInternal _MsgCreateBinaryOptionsMarketOrder_default_instance_;
class MsgCreateBinaryOptionsMarketOrderResponse;
struct MsgCreateBinaryOptionsMarketOrderResponseDefaultTypeInternal;
extern MsgCreateBinaryOptionsMarketOrderResponseDefaultTypeInternal _MsgCreateBinaryOptionsMarketOrderResponse_default_instance_;
class MsgCreateDerivativeLimitOrder;
struct MsgCreateDerivativeLimitOrderDefaultTypeInternal;
extern MsgCreateDerivativeLimitOrderDefaultTypeInternal _MsgCreateDerivativeLimitOrder_default_instance_;
class MsgCreateDerivativeLimitOrderResponse;
struct MsgCreateDerivativeLimitOrderResponseDefaultTypeInternal;
extern MsgCreateDerivativeLimitOrderResponseDefaultTypeInternal _MsgCreateDerivativeLimitOrderResponse_default_instance_;
class MsgCreateDerivativeMarketOrder;
struct MsgCreateDerivativeMarketOrderDefaultTypeInternal;
extern MsgCreateDerivativeMarketOrderDefaultTypeInternal _MsgCreateDerivativeMarketOrder_default_instance_;
class MsgCreateDerivativeMarketOrderResponse;
struct MsgCreateDerivativeMarketOrderResponseDefaultTypeInternal;
extern MsgCreateDerivativeMarketOrderResponseDefaultTypeInternal _MsgCreateDerivativeMarketOrderResponse_default_instance_;
class MsgCreateSpotLimitOrder;
struct MsgCreateSpotLimitOrderDefaultTypeInternal;
extern MsgCreateSpotLimitOrderDefaultTypeInternal _MsgCreateSpotLimitOrder_default_instance_;
class MsgCreateSpotLimitOrderResponse;
struct MsgCreateSpotLimitOrderResponseDefaultTypeInternal;
extern MsgCreateSpotLimitOrderResponseDefaultTypeInternal _MsgCreateSpotLimitOrderResponse_default_instance_;
class MsgCreateSpotMarketOrder;
struct MsgCreateSpotMarketOrderDefaultTypeInternal;
extern MsgCreateSpotMarketOrderDefaultTypeInternal _MsgCreateSpotMarketOrder_default_instance_;
class MsgCreateSpotMarketOrderResponse;
struct MsgCreateSpotMarketOrderResponseDefaultTypeInternal;
extern MsgCreateSpotMarketOrderResponseDefaultTypeInternal _MsgCreateSpotMarketOrderResponse_default_instance_;
class MsgDeposit;
struct MsgDepositDefaultTypeInternal;
extern MsgDepositDefaultTypeInternal _MsgDeposit_default_instance_;
class MsgDepositResponse;
struct MsgDepositResponseDefaultTypeInternal;
extern MsgDepositResponseDefaultTypeInternal _MsgDepositResponse_default_instance_;
class MsgExternalTransfer;
struct MsgExternalTransferDefaultTypeInternal;
extern MsgExternalTransferDefaultTypeInternal _MsgExternalTransfer_default_instance_;
class MsgExternalTransferResponse;
struct MsgExternalTransferResponseDefaultTypeInternal;
extern MsgExternalTransferResponseDefaultTypeInternal _MsgExternalTransferResponse_default_instance_;
class MsgIncreasePositionMargin;
struct MsgIncreasePositionMarginDefaultTypeInternal;
extern MsgIncreasePositionMarginDefaultTypeInternal _MsgIncreasePositionMargin_default_instance_;
class MsgIncreasePositionMarginResponse;
struct MsgIncreasePositionMarginResponseDefaultTypeInternal;
extern MsgIncreasePositionMarginResponseDefaultTypeInternal _MsgIncreasePositionMarginResponse_default_instance_;
class MsgInstantBinaryOptionsMarketLaunch;
struct MsgInstantBinaryOptionsMarketLaunchDefaultTypeInternal;
extern MsgInstantBinaryOptionsMarketLaunchDefaultTypeInternal _MsgInstantBinaryOptionsMarketLaunch_default_instance_;
class MsgInstantBinaryOptionsMarketLaunchResponse;
struct MsgInstantBinaryOptionsMarketLaunchResponseDefaultTypeInternal;
extern MsgInstantBinaryOptionsMarketLaunchResponseDefaultTypeInternal _MsgInstantBinaryOptionsMarketLaunchResponse_default_instance_;
class MsgInstantExpiryFuturesMarketLaunch;
struct MsgInstantExpiryFuturesMarketLaunchDefaultTypeInternal;
extern MsgInstantExpiryFuturesMarketLaunchDefaultTypeInternal _MsgInstantExpiryFuturesMarketLaunch_default_instance_;
class MsgInstantExpiryFuturesMarketLaunchResponse;
struct MsgInstantExpiryFuturesMarketLaunchResponseDefaultTypeInternal;
extern MsgInstantExpiryFuturesMarketLaunchResponseDefaultTypeInternal _MsgInstantExpiryFuturesMarketLaunchResponse_default_instance_;
class MsgInstantPerpetualMarketLaunch;
struct MsgInstantPerpetualMarketLaunchDefaultTypeInternal;
extern MsgInstantPerpetualMarketLaunchDefaultTypeInternal _MsgInstantPerpetualMarketLaunch_default_instance_;
class MsgInstantPerpetualMarketLaunchResponse;
struct MsgInstantPerpetualMarketLaunchResponseDefaultTypeInternal;
extern MsgInstantPerpetualMarketLaunchResponseDefaultTypeInternal _MsgInstantPerpetualMarketLaunchResponse_default_instance_;
class MsgInstantSpotMarketLaunch;
struct MsgInstantSpotMarketLaunchDefaultTypeInternal;
extern MsgInstantSpotMarketLaunchDefaultTypeInternal _MsgInstantSpotMarketLaunch_default_instance_;
class MsgInstantSpotMarketLaunchResponse;
struct MsgInstantSpotMarketLaunchResponseDefaultTypeInternal;
extern MsgInstantSpotMarketLaunchResponseDefaultTypeInternal _MsgInstantSpotMarketLaunchResponse_default_instance_;
class MsgLiquidatePosition;
struct MsgLiquidatePositionDefaultTypeInternal;
extern MsgLiquidatePositionDefaultTypeInternal _MsgLiquidatePosition_default_instance_;
class MsgLiquidatePositionResponse;
struct MsgLiquidatePositionResponseDefaultTypeInternal;
extern MsgLiquidatePositionResponseDefaultTypeInternal _MsgLiquidatePositionResponse_default_instance_;
class MsgPrivilegedExecuteContract;
struct MsgPrivilegedExecuteContractDefaultTypeInternal;
extern MsgPrivilegedExecuteContractDefaultTypeInternal _MsgPrivilegedExecuteContract_default_instance_;
class MsgPrivilegedExecuteContractResponse;
struct MsgPrivilegedExecuteContractResponseDefaultTypeInternal;
extern MsgPrivilegedExecuteContractResponseDefaultTypeInternal _MsgPrivilegedExecuteContractResponse_default_instance_;
class MsgReclaimLockedFunds;
struct MsgReclaimLockedFundsDefaultTypeInternal;
extern MsgReclaimLockedFundsDefaultTypeInternal _MsgReclaimLockedFunds_default_instance_;
class MsgReclaimLockedFundsResponse;
struct MsgReclaimLockedFundsResponseDefaultTypeInternal;
extern MsgReclaimLockedFundsResponseDefaultTypeInternal _MsgReclaimLockedFundsResponse_default_instance_;
class MsgRewardsOptOut;
struct MsgRewardsOptOutDefaultTypeInternal;
extern MsgRewardsOptOutDefaultTypeInternal _MsgRewardsOptOut_default_instance_;
class MsgRewardsOptOutResponse;
struct MsgRewardsOptOutResponseDefaultTypeInternal;
extern MsgRewardsOptOutResponseDefaultTypeInternal _MsgRewardsOptOutResponse_default_instance_;
class MsgSignData;
struct MsgSignDataDefaultTypeInternal;
extern MsgSignDataDefaultTypeInternal _MsgSignData_default_instance_;
class MsgSignDoc;
struct MsgSignDocDefaultTypeInternal;
extern MsgSignDocDefaultTypeInternal _MsgSignDoc_default_instance_;
class MsgSubaccountTransfer;
struct MsgSubaccountTransferDefaultTypeInternal;
extern MsgSubaccountTransferDefaultTypeInternal _MsgSubaccountTransfer_default_instance_;
class MsgSubaccountTransferResponse;
struct MsgSubaccountTransferResponseDefaultTypeInternal;
extern MsgSubaccountTransferResponseDefaultTypeInternal _MsgSubaccountTransferResponse_default_instance_;
class MsgUpdateParams;
struct MsgUpdateParamsDefaultTypeInternal;
extern MsgUpdateParamsDefaultTypeInternal _MsgUpdateParams_default_instance_;
class MsgUpdateParamsResponse;
struct MsgUpdateParamsResponseDefaultTypeInternal;
extern MsgUpdateParamsResponseDefaultTypeInternal _MsgUpdateParamsResponse_default_instance_;
class MsgWithdraw;
struct MsgWithdrawDefaultTypeInternal;
extern MsgWithdrawDefaultTypeInternal _MsgWithdraw_default_instance_;
class MsgWithdrawResponse;
struct MsgWithdrawResponseDefaultTypeInternal;
extern MsgWithdrawResponseDefaultTypeInternal _MsgWithdrawResponse_default_instance_;
class OracleParams;
struct OracleParamsDefaultTypeInternal;
extern OracleParamsDefaultTypeInternal _OracleParams_default_instance_;
class OrderData;
struct OrderDataDefaultTypeInternal;
extern OrderDataDefaultTypeInternal _OrderData_default_instance_;
class PerpetualMarketLaunchProposal;
struct PerpetualMarketLaunchProposalDefaultTypeInternal;
extern PerpetualMarketLaunchProposalDefaultTypeInternal _PerpetualMarketLaunchProposal_default_instance_;
class ProviderOracleParams;
struct ProviderOracleParamsDefaultTypeInternal;
extern ProviderOracleParamsDefaultTypeInternal _ProviderOracleParams_default_instance_;
class RewardPointUpdate;
struct RewardPointUpdateDefaultTypeInternal;
extern RewardPointUpdateDefaultTypeInternal _RewardPointUpdate_default_instance_;
class SpotMarketLaunchProposal;
struct SpotMarketLaunchProposalDefaultTypeInternal;
extern SpotMarketLaunchProposalDefaultTypeInternal _SpotMarketLaunchProposal_default_instance_;
class SpotMarketOrderResults;
struct SpotMarketOrderResultsDefaultTypeInternal;
extern SpotMarketOrderResultsDefaultTypeInternal _SpotMarketOrderResults_default_instance_;
class SpotMarketParamUpdateProposal;
struct SpotMarketParamUpdateProposalDefaultTypeInternal;
extern SpotMarketParamUpdateProposalDefaultTypeInternal _SpotMarketParamUpdateProposal_default_instance_;
class TradingRewardCampaignLaunchProposal;
struct TradingRewardCampaignLaunchProposalDefaultTypeInternal;
extern TradingRewardCampaignLaunchProposalDefaultTypeInternal _TradingRewardCampaignLaunchProposal_default_instance_;
class TradingRewardCampaignUpdateProposal;
struct TradingRewardCampaignUpdateProposalDefaultTypeInternal;
extern TradingRewardCampaignUpdateProposalDefaultTypeInternal _TradingRewardCampaignUpdateProposal_default_instance_;
class TradingRewardPendingPointsUpdateProposal;
struct TradingRewardPendingPointsUpdateProposalDefaultTypeInternal;
extern TradingRewardPendingPointsUpdateProposalDefaultTypeInternal _TradingRewardPendingPointsUpdateProposal_default_instance_;
class UpdateDenomDecimalsProposal;
struct UpdateDenomDecimalsProposalDefaultTypeInternal;
extern UpdateDenomDecimalsProposalDefaultTypeInternal _UpdateDenomDecimalsProposal_default_instance_;
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::exchange::v1beta1::AtomicMarketOrderFeeMultiplierScheduleProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::AtomicMarketOrderFeeMultiplierScheduleProposal>(Arena*);
template <>
::injective::exchange::v1beta1::BatchCommunityPoolSpendProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::BatchCommunityPoolSpendProposal>(Arena*);
template <>
::injective::exchange::v1beta1::BatchExchangeModificationProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::BatchExchangeModificationProposal>(Arena*);
template <>
::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal>(Arena*);
template <>
::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeMarketOrderResults* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrderResults>(Arena*);
template <>
::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal>(Arena*);
template <>
::injective::exchange::v1beta1::ExchangeEnableProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::ExchangeEnableProposal>(Arena*);
template <>
::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal>(Arena*);
template <>
::injective::exchange::v1beta1::FeeDiscountProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountProposal>(Arena*);
template <>
::injective::exchange::v1beta1::MarketForcedSettlementProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MarketForcedSettlementProposal>(Arena*);
template <>
::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarket>(Arena*);
template <>
::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgAdminUpdateBinaryOptionsMarketResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrders>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCancelBinaryOptionsOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrders>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCancelDerivativeOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCancelSpotOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCancelSpotOrders>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCancelSpotOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrders>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCreateDerivativeLimitOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrders>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchCreateSpotLimitOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchUpdateOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchUpdateOrders>(Arena*);
template <>
::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgBatchUpdateOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCancelBinaryOptionsOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCancelDerivativeOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCancelDerivativeOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCancelDerivativeOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCancelSpotOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCancelSpotOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCancelSpotOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCancelSpotOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateBinaryOptionsLimitOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateBinaryOptionsMarketOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateDerivativeLimitOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateDerivativeMarketOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateSpotLimitOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateSpotLimitOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateSpotLimitOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateSpotMarketOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateSpotMarketOrder>(Arena*);
template <>
::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgCreateSpotMarketOrderResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgDeposit* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgDeposit>(Arena*);
template <>
::injective::exchange::v1beta1::MsgDepositResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgDepositResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgExternalTransfer* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgExternalTransfer>(Arena*);
template <>
::injective::exchange::v1beta1::MsgExternalTransferResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgExternalTransferResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgIncreasePositionMargin* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgIncreasePositionMargin>(Arena*);
template <>
::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgIncreasePositionMarginResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunch>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantBinaryOptionsMarketLaunchResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunch>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantExpiryFuturesMarketLaunchResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunch>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantPerpetualMarketLaunchResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantSpotMarketLaunch>(Arena*);
template <>
::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgInstantSpotMarketLaunchResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgLiquidatePosition* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgLiquidatePosition>(Arena*);
template <>
::injective::exchange::v1beta1::MsgLiquidatePositionResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgLiquidatePositionResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgPrivilegedExecuteContract* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgPrivilegedExecuteContract>(Arena*);
template <>
::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgPrivilegedExecuteContractResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgReclaimLockedFunds* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgReclaimLockedFunds>(Arena*);
template <>
::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgReclaimLockedFundsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgRewardsOptOut* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgRewardsOptOut>(Arena*);
template <>
::injective::exchange::v1beta1::MsgRewardsOptOutResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgRewardsOptOutResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgSignData* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgSignData>(Arena*);
template <>
::injective::exchange::v1beta1::MsgSignDoc* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgSignDoc>(Arena*);
template <>
::injective::exchange::v1beta1::MsgSubaccountTransfer* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgSubaccountTransfer>(Arena*);
template <>
::injective::exchange::v1beta1::MsgSubaccountTransferResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgSubaccountTransferResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgUpdateParams* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgUpdateParams>(Arena*);
template <>
::injective::exchange::v1beta1::MsgUpdateParamsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgUpdateParamsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::MsgWithdraw* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgWithdraw>(Arena*);
template <>
::injective::exchange::v1beta1::MsgWithdrawResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MsgWithdrawResponse>(Arena*);
template <>
::injective::exchange::v1beta1::OracleParams* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::OracleParams>(Arena*);
template <>
::injective::exchange::v1beta1::OrderData* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::OrderData>(Arena*);
template <>
::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketLaunchProposal>(Arena*);
template <>
::injective::exchange::v1beta1::ProviderOracleParams* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::ProviderOracleParams>(Arena*);
template <>
::injective::exchange::v1beta1::RewardPointUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::RewardPointUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::SpotMarketLaunchProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarketLaunchProposal>(Arena*);
template <>
::injective::exchange::v1beta1::SpotMarketOrderResults* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarketOrderResults>(Arena*);
template <>
::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarketParamUpdateProposal>(Arena*);
template <>
::injective::exchange::v1beta1::TradingRewardCampaignLaunchProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignLaunchProposal>(Arena*);
template <>
::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal>(Arena*);
template <>
::injective::exchange::v1beta1::TradingRewardPendingPointsUpdateProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardPendingPointsUpdateProposal>(Arena*);
template <>
::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::UpdateDenomDecimalsProposal>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace exchange {
namespace v1beta1 {
enum ExchangeType : int {
  EXCHANGE_UNSPECIFIED = 0,
  SPOT = 1,
  DERIVATIVES = 2,
  ExchangeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ExchangeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ExchangeType_IsValid(int value);
constexpr ExchangeType ExchangeType_MIN = static_cast<ExchangeType>(0);
constexpr ExchangeType ExchangeType_MAX = static_cast<ExchangeType>(2);
constexpr int ExchangeType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ExchangeType_descriptor();
template <typename T>
const std::string& ExchangeType_Name(T value) {
  static_assert(std::is_same<T, ExchangeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExchangeType_Name().");
  return ExchangeType_Name(static_cast<ExchangeType>(value));
}
template <>
inline const std::string& ExchangeType_Name(ExchangeType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ExchangeType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ExchangeType_Parse(absl::string_view name, ExchangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExchangeType>(
      ExchangeType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MsgUpdateParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgUpdateParams) */ {
 public:
  inline MsgUpdateParams() : MsgUpdateParams(nullptr) {}
  ~MsgUpdateParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParams(const MsgUpdateParams& from);
  MsgUpdateParams(MsgUpdateParams&& from) noexcept
    : MsgUpdateParams() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParams& operator=(const MsgUpdateParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParams& operator=(MsgUpdateParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParams* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParams*>(
               &_MsgUpdateParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgUpdateParams& a, MsgUpdateParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgUpdateParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgUpdateParams& from) {
    MsgUpdateParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgUpdateParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgUpdateParams";
  }
  protected:
  explicit MsgUpdateParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorityFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_authority() ;
  const std::string& authority() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_authority(Arg_&& arg, Args_... args);
  std::string* mutable_authority();
  PROTOBUF_NODISCARD std::string* release_authority();
  void set_allocated_authority(std::string* ptr);

  private:
  const std::string& _internal_authority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authority(
      const std::string& value);
  std::string* _internal_mutable_authority();

  public:
  // .injective.exchange.v1beta1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
  bool has_params() const;
  void clear_params() ;
  const ::injective::exchange::v1beta1::Params& params() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Params* release_params();
  ::injective::exchange::v1beta1::Params* mutable_params();
  void set_allocated_params(::injective::exchange::v1beta1::Params* params);
  private:
  const ::injective::exchange::v1beta1::Params& _internal_params() const;
  ::injective::exchange::v1beta1::Params* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::injective::exchange::v1beta1::Params* params);
  ::injective::exchange::v1beta1::Params* unsafe_arena_release_params();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgUpdateParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authority_;
    ::injective::exchange::v1beta1::Params* params_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgUpdateParamsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgUpdateParamsResponse) */ {
 public:
  inline MsgUpdateParamsResponse() : MsgUpdateParamsResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUpdateParamsResponse(const MsgUpdateParamsResponse& from);
  MsgUpdateParamsResponse(MsgUpdateParamsResponse&& from) noexcept
    : MsgUpdateParamsResponse() {
    *this = ::std::move(from);
  }

  inline MsgUpdateParamsResponse& operator=(const MsgUpdateParamsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUpdateParamsResponse& operator=(MsgUpdateParamsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgUpdateParamsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUpdateParamsResponse* internal_default_instance() {
    return reinterpret_cast<const MsgUpdateParamsResponse*>(
               &_MsgUpdateParamsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgUpdateParamsResponse& a, MsgUpdateParamsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUpdateParamsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUpdateParamsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUpdateParamsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgUpdateParamsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgUpdateParamsResponse";
  }
  protected:
  explicit MsgUpdateParamsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgUpdateParamsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgDeposit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgDeposit) */ {
 public:
  inline MsgDeposit() : MsgDeposit(nullptr) {}
  ~MsgDeposit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgDeposit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDeposit(const MsgDeposit& from);
  MsgDeposit(MsgDeposit&& from) noexcept
    : MsgDeposit() {
    *this = ::std::move(from);
  }

  inline MsgDeposit& operator=(const MsgDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDeposit& operator=(MsgDeposit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDeposit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDeposit* internal_default_instance() {
    return reinterpret_cast<const MsgDeposit*>(
               &_MsgDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgDeposit& a, MsgDeposit& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDeposit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDeposit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDeposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDeposit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgDeposit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgDeposit& from) {
    MsgDeposit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgDeposit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgDeposit";
  }
  protected:
  explicit MsgDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgDeposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgDepositResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgDepositResponse) */ {
 public:
  inline MsgDepositResponse() : MsgDepositResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgDepositResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDepositResponse(const MsgDepositResponse& from);
  MsgDepositResponse(MsgDepositResponse&& from) noexcept
    : MsgDepositResponse() {
    *this = ::std::move(from);
  }

  inline MsgDepositResponse& operator=(const MsgDepositResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDepositResponse& operator=(MsgDepositResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgDepositResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDepositResponse* internal_default_instance() {
    return reinterpret_cast<const MsgDepositResponse*>(
               &_MsgDepositResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgDepositResponse& a, MsgDepositResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDepositResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDepositResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDepositResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDepositResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgDepositResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgDepositResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgDepositResponse";
  }
  protected:
  explicit MsgDepositResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgDepositResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgWithdraw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgWithdraw) */ {
 public:
  inline MsgWithdraw() : MsgWithdraw(nullptr) {}
  ~MsgWithdraw() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgWithdraw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgWithdraw(const MsgWithdraw& from);
  MsgWithdraw(MsgWithdraw&& from) noexcept
    : MsgWithdraw() {
    *this = ::std::move(from);
  }

  inline MsgWithdraw& operator=(const MsgWithdraw& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgWithdraw& operator=(MsgWithdraw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgWithdraw& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgWithdraw* internal_default_instance() {
    return reinterpret_cast<const MsgWithdraw*>(
               &_MsgWithdraw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgWithdraw& a, MsgWithdraw& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgWithdraw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgWithdraw* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgWithdraw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgWithdraw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgWithdraw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgWithdraw& from) {
    MsgWithdraw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgWithdraw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgWithdraw";
  }
  protected:
  explicit MsgWithdraw(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgWithdraw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgWithdrawResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgWithdrawResponse) */ {
 public:
  inline MsgWithdrawResponse() : MsgWithdrawResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgWithdrawResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgWithdrawResponse(const MsgWithdrawResponse& from);
  MsgWithdrawResponse(MsgWithdrawResponse&& from) noexcept
    : MsgWithdrawResponse() {
    *this = ::std::move(from);
  }

  inline MsgWithdrawResponse& operator=(const MsgWithdrawResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgWithdrawResponse& operator=(MsgWithdrawResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgWithdrawResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgWithdrawResponse* internal_default_instance() {
    return reinterpret_cast<const MsgWithdrawResponse*>(
               &_MsgWithdrawResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgWithdrawResponse& a, MsgWithdrawResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgWithdrawResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgWithdrawResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgWithdrawResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgWithdrawResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgWithdrawResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgWithdrawResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgWithdrawResponse";
  }
  protected:
  explicit MsgWithdrawResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgWithdrawResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateSpotLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateSpotLimitOrder) */ {
 public:
  inline MsgCreateSpotLimitOrder() : MsgCreateSpotLimitOrder(nullptr) {}
  ~MsgCreateSpotLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateSpotLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateSpotLimitOrder(const MsgCreateSpotLimitOrder& from);
  MsgCreateSpotLimitOrder(MsgCreateSpotLimitOrder&& from) noexcept
    : MsgCreateSpotLimitOrder() {
    *this = ::std::move(from);
  }

  inline MsgCreateSpotLimitOrder& operator=(const MsgCreateSpotLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateSpotLimitOrder& operator=(MsgCreateSpotLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateSpotLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateSpotLimitOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCreateSpotLimitOrder*>(
               &_MsgCreateSpotLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgCreateSpotLimitOrder& a, MsgCreateSpotLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateSpotLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateSpotLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateSpotLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateSpotLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateSpotLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateSpotLimitOrder& from) {
    MsgCreateSpotLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateSpotLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateSpotLimitOrder";
  }
  protected:
  explicit MsgCreateSpotLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.exchange.v1beta1.SpotOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::SpotOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SpotOrder* release_order();
  ::injective::exchange::v1beta1::SpotOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::SpotOrder* order);
  private:
  const ::injective::exchange::v1beta1::SpotOrder& _internal_order() const;
  ::injective::exchange::v1beta1::SpotOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::SpotOrder* order);
  ::injective::exchange::v1beta1::SpotOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateSpotLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::exchange::v1beta1::SpotOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateSpotLimitOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse) */ {
 public:
  inline MsgCreateSpotLimitOrderResponse() : MsgCreateSpotLimitOrderResponse(nullptr) {}
  ~MsgCreateSpotLimitOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateSpotLimitOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateSpotLimitOrderResponse(const MsgCreateSpotLimitOrderResponse& from);
  MsgCreateSpotLimitOrderResponse(MsgCreateSpotLimitOrderResponse&& from) noexcept
    : MsgCreateSpotLimitOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateSpotLimitOrderResponse& operator=(const MsgCreateSpotLimitOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateSpotLimitOrderResponse& operator=(MsgCreateSpotLimitOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateSpotLimitOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateSpotLimitOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateSpotLimitOrderResponse*>(
               &_MsgCreateSpotLimitOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgCreateSpotLimitOrderResponse& a, MsgCreateSpotLimitOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateSpotLimitOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateSpotLimitOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateSpotLimitOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateSpotLimitOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateSpotLimitOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateSpotLimitOrderResponse& from) {
    MsgCreateSpotLimitOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateSpotLimitOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse";
  }
  protected:
  explicit MsgCreateSpotLimitOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCreateSpotLimitOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders) */ {
 public:
  inline MsgBatchCreateSpotLimitOrders() : MsgBatchCreateSpotLimitOrders(nullptr) {}
  ~MsgBatchCreateSpotLimitOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCreateSpotLimitOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCreateSpotLimitOrders(const MsgBatchCreateSpotLimitOrders& from);
  MsgBatchCreateSpotLimitOrders(MsgBatchCreateSpotLimitOrders&& from) noexcept
    : MsgBatchCreateSpotLimitOrders() {
    *this = ::std::move(from);
  }

  inline MsgBatchCreateSpotLimitOrders& operator=(const MsgBatchCreateSpotLimitOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCreateSpotLimitOrders& operator=(MsgBatchCreateSpotLimitOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCreateSpotLimitOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCreateSpotLimitOrders* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCreateSpotLimitOrders*>(
               &_MsgBatchCreateSpotLimitOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MsgBatchCreateSpotLimitOrders& a, MsgBatchCreateSpotLimitOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCreateSpotLimitOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCreateSpotLimitOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCreateSpotLimitOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCreateSpotLimitOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCreateSpotLimitOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCreateSpotLimitOrders& from) {
    MsgBatchCreateSpotLimitOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCreateSpotLimitOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders";
  }
  protected:
  explicit MsgBatchCreateSpotLimitOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 2,
    kSenderFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.SpotOrder orders = 2 [json_name = "orders", (.gogoproto.nullable) = false];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::SpotOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::SpotOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::SpotOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::SpotOrder& orders(int index) const;
  ::injective::exchange::v1beta1::SpotOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >&
      orders() const;
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder > orders_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCreateSpotLimitOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse) */ {
 public:
  inline MsgBatchCreateSpotLimitOrdersResponse() : MsgBatchCreateSpotLimitOrdersResponse(nullptr) {}
  ~MsgBatchCreateSpotLimitOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCreateSpotLimitOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCreateSpotLimitOrdersResponse(const MsgBatchCreateSpotLimitOrdersResponse& from);
  MsgBatchCreateSpotLimitOrdersResponse(MsgBatchCreateSpotLimitOrdersResponse&& from) noexcept
    : MsgBatchCreateSpotLimitOrdersResponse() {
    *this = ::std::move(from);
  }

  inline MsgBatchCreateSpotLimitOrdersResponse& operator=(const MsgBatchCreateSpotLimitOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCreateSpotLimitOrdersResponse& operator=(MsgBatchCreateSpotLimitOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCreateSpotLimitOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCreateSpotLimitOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCreateSpotLimitOrdersResponse*>(
               &_MsgBatchCreateSpotLimitOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MsgBatchCreateSpotLimitOrdersResponse& a, MsgBatchCreateSpotLimitOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCreateSpotLimitOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCreateSpotLimitOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCreateSpotLimitOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCreateSpotLimitOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCreateSpotLimitOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCreateSpotLimitOrdersResponse& from) {
    MsgBatchCreateSpotLimitOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCreateSpotLimitOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse";
  }
  protected:
  explicit MsgBatchCreateSpotLimitOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashesFieldNumber = 1,
  };
  // repeated string order_hashes = 1 [json_name = "orderHashes"];
  int order_hashes_size() const;
  private:
  int _internal_order_hashes_size() const;

  public:
  void clear_order_hashes() ;
  const std::string& order_hashes(int index) const;
  std::string* mutable_order_hashes(int index);
  void set_order_hashes(int index, const std::string& value);
  void set_order_hashes(int index, std::string&& value);
  void set_order_hashes(int index, const char* value);
  void set_order_hashes(int index, const char* value, std::size_t size);
  void set_order_hashes(int index, absl::string_view value);
  std::string* add_order_hashes();
  void add_order_hashes(const std::string& value);
  void add_order_hashes(std::string&& value);
  void add_order_hashes(const char* value);
  void add_order_hashes(const char* value, std::size_t size);
  void add_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_hashes();

  private:
  const std::string& _internal_order_hashes(int index) const;
  std::string* _internal_add_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_hashes();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantSpotMarketLaunch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch) */ {
 public:
  inline MsgInstantSpotMarketLaunch() : MsgInstantSpotMarketLaunch(nullptr) {}
  ~MsgInstantSpotMarketLaunch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantSpotMarketLaunch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantSpotMarketLaunch(const MsgInstantSpotMarketLaunch& from);
  MsgInstantSpotMarketLaunch(MsgInstantSpotMarketLaunch&& from) noexcept
    : MsgInstantSpotMarketLaunch() {
    *this = ::std::move(from);
  }

  inline MsgInstantSpotMarketLaunch& operator=(const MsgInstantSpotMarketLaunch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantSpotMarketLaunch& operator=(MsgInstantSpotMarketLaunch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantSpotMarketLaunch& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantSpotMarketLaunch* internal_default_instance() {
    return reinterpret_cast<const MsgInstantSpotMarketLaunch*>(
               &_MsgInstantSpotMarketLaunch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MsgInstantSpotMarketLaunch& a, MsgInstantSpotMarketLaunch& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantSpotMarketLaunch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantSpotMarketLaunch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantSpotMarketLaunch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantSpotMarketLaunch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgInstantSpotMarketLaunch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgInstantSpotMarketLaunch& from) {
    MsgInstantSpotMarketLaunch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgInstantSpotMarketLaunch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantSpotMarketLaunch";
  }
  protected:
  explicit MsgInstantSpotMarketLaunch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kTickerFieldNumber = 2,
    kBaseDenomFieldNumber = 3,
    kQuoteDenomFieldNumber = 4,
    kMinPriceTickSizeFieldNumber = 5,
    kMinQuantityTickSizeFieldNumber = 6,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string ticker = 2 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string base_denom = 3 [json_name = "baseDenom"];
  void clear_base_denom() ;
  const std::string& base_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_denom(Arg_&& arg, Args_... args);
  std::string* mutable_base_denom();
  PROTOBUF_NODISCARD std::string* release_base_denom();
  void set_allocated_base_denom(std::string* ptr);

  private:
  const std::string& _internal_base_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_denom(
      const std::string& value);
  std::string* _internal_mutable_base_denom();

  public:
  // string quote_denom = 4 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string min_price_tick_size = 5 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 6 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantSpotMarketLaunchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse) */ {
 public:
  inline MsgInstantSpotMarketLaunchResponse() : MsgInstantSpotMarketLaunchResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantSpotMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantSpotMarketLaunchResponse(const MsgInstantSpotMarketLaunchResponse& from);
  MsgInstantSpotMarketLaunchResponse(MsgInstantSpotMarketLaunchResponse&& from) noexcept
    : MsgInstantSpotMarketLaunchResponse() {
    *this = ::std::move(from);
  }

  inline MsgInstantSpotMarketLaunchResponse& operator=(const MsgInstantSpotMarketLaunchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantSpotMarketLaunchResponse& operator=(MsgInstantSpotMarketLaunchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantSpotMarketLaunchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantSpotMarketLaunchResponse* internal_default_instance() {
    return reinterpret_cast<const MsgInstantSpotMarketLaunchResponse*>(
               &_MsgInstantSpotMarketLaunchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MsgInstantSpotMarketLaunchResponse& a, MsgInstantSpotMarketLaunchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantSpotMarketLaunchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantSpotMarketLaunchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantSpotMarketLaunchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantSpotMarketLaunchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgInstantSpotMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgInstantSpotMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse";
  }
  protected:
  explicit MsgInstantSpotMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantPerpetualMarketLaunch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch) */ {
 public:
  inline MsgInstantPerpetualMarketLaunch() : MsgInstantPerpetualMarketLaunch(nullptr) {}
  ~MsgInstantPerpetualMarketLaunch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantPerpetualMarketLaunch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantPerpetualMarketLaunch(const MsgInstantPerpetualMarketLaunch& from);
  MsgInstantPerpetualMarketLaunch(MsgInstantPerpetualMarketLaunch&& from) noexcept
    : MsgInstantPerpetualMarketLaunch() {
    *this = ::std::move(from);
  }

  inline MsgInstantPerpetualMarketLaunch& operator=(const MsgInstantPerpetualMarketLaunch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantPerpetualMarketLaunch& operator=(MsgInstantPerpetualMarketLaunch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantPerpetualMarketLaunch& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantPerpetualMarketLaunch* internal_default_instance() {
    return reinterpret_cast<const MsgInstantPerpetualMarketLaunch*>(
               &_MsgInstantPerpetualMarketLaunch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MsgInstantPerpetualMarketLaunch& a, MsgInstantPerpetualMarketLaunch& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantPerpetualMarketLaunch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantPerpetualMarketLaunch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantPerpetualMarketLaunch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantPerpetualMarketLaunch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgInstantPerpetualMarketLaunch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgInstantPerpetualMarketLaunch& from) {
    MsgInstantPerpetualMarketLaunch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgInstantPerpetualMarketLaunch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch";
  }
  protected:
  explicit MsgInstantPerpetualMarketLaunch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kTickerFieldNumber = 2,
    kQuoteDenomFieldNumber = 3,
    kOracleBaseFieldNumber = 4,
    kOracleQuoteFieldNumber = 5,
    kMakerFeeRateFieldNumber = 8,
    kTakerFeeRateFieldNumber = 9,
    kInitialMarginRatioFieldNumber = 10,
    kMaintenanceMarginRatioFieldNumber = 11,
    kMinPriceTickSizeFieldNumber = 12,
    kMinQuantityTickSizeFieldNumber = 13,
    kOracleScaleFactorFieldNumber = 6,
    kOracleTypeFieldNumber = 7,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string ticker = 2 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string quote_denom = 3 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string oracle_base = 4 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 5 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // string maker_fee_rate = 8 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 9 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string initial_margin_ratio = 10 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_initial_margin_ratio() ;
  const std::string& initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_initial_margin_ratio();
  void set_allocated_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_initial_margin_ratio();

  public:
  // string maintenance_margin_ratio = 11 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maintenance_margin_ratio() ;
  const std::string& maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_maintenance_margin_ratio();
  void set_allocated_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_maintenance_margin_ratio();

  public:
  // string min_price_tick_size = 12 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 13 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // uint32 oracle_scale_factor = 6 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 7 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::uint32_t oracle_scale_factor_;
    int oracle_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantPerpetualMarketLaunchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse) */ {
 public:
  inline MsgInstantPerpetualMarketLaunchResponse() : MsgInstantPerpetualMarketLaunchResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantPerpetualMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantPerpetualMarketLaunchResponse(const MsgInstantPerpetualMarketLaunchResponse& from);
  MsgInstantPerpetualMarketLaunchResponse(MsgInstantPerpetualMarketLaunchResponse&& from) noexcept
    : MsgInstantPerpetualMarketLaunchResponse() {
    *this = ::std::move(from);
  }

  inline MsgInstantPerpetualMarketLaunchResponse& operator=(const MsgInstantPerpetualMarketLaunchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantPerpetualMarketLaunchResponse& operator=(MsgInstantPerpetualMarketLaunchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantPerpetualMarketLaunchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantPerpetualMarketLaunchResponse* internal_default_instance() {
    return reinterpret_cast<const MsgInstantPerpetualMarketLaunchResponse*>(
               &_MsgInstantPerpetualMarketLaunchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MsgInstantPerpetualMarketLaunchResponse& a, MsgInstantPerpetualMarketLaunchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantPerpetualMarketLaunchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantPerpetualMarketLaunchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantPerpetualMarketLaunchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantPerpetualMarketLaunchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgInstantPerpetualMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgInstantPerpetualMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse";
  }
  protected:
  explicit MsgInstantPerpetualMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantBinaryOptionsMarketLaunch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch) */ {
 public:
  inline MsgInstantBinaryOptionsMarketLaunch() : MsgInstantBinaryOptionsMarketLaunch(nullptr) {}
  ~MsgInstantBinaryOptionsMarketLaunch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantBinaryOptionsMarketLaunch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantBinaryOptionsMarketLaunch(const MsgInstantBinaryOptionsMarketLaunch& from);
  MsgInstantBinaryOptionsMarketLaunch(MsgInstantBinaryOptionsMarketLaunch&& from) noexcept
    : MsgInstantBinaryOptionsMarketLaunch() {
    *this = ::std::move(from);
  }

  inline MsgInstantBinaryOptionsMarketLaunch& operator=(const MsgInstantBinaryOptionsMarketLaunch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantBinaryOptionsMarketLaunch& operator=(MsgInstantBinaryOptionsMarketLaunch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantBinaryOptionsMarketLaunch& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantBinaryOptionsMarketLaunch* internal_default_instance() {
    return reinterpret_cast<const MsgInstantBinaryOptionsMarketLaunch*>(
               &_MsgInstantBinaryOptionsMarketLaunch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MsgInstantBinaryOptionsMarketLaunch& a, MsgInstantBinaryOptionsMarketLaunch& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantBinaryOptionsMarketLaunch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantBinaryOptionsMarketLaunch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantBinaryOptionsMarketLaunch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantBinaryOptionsMarketLaunch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgInstantBinaryOptionsMarketLaunch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgInstantBinaryOptionsMarketLaunch& from) {
    MsgInstantBinaryOptionsMarketLaunch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgInstantBinaryOptionsMarketLaunch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch";
  }
  protected:
  explicit MsgInstantBinaryOptionsMarketLaunch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kTickerFieldNumber = 2,
    kOracleSymbolFieldNumber = 3,
    kOracleProviderFieldNumber = 4,
    kMakerFeeRateFieldNumber = 7,
    kTakerFeeRateFieldNumber = 8,
    kAdminFieldNumber = 11,
    kQuoteDenomFieldNumber = 12,
    kMinPriceTickSizeFieldNumber = 13,
    kMinQuantityTickSizeFieldNumber = 14,
    kOracleTypeFieldNumber = 5,
    kOracleScaleFactorFieldNumber = 6,
    kExpirationTimestampFieldNumber = 9,
    kSettlementTimestampFieldNumber = 10,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string ticker = 2 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string oracle_symbol = 3 [json_name = "oracleSymbol"];
  void clear_oracle_symbol() ;
  const std::string& oracle_symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_symbol();
  PROTOBUF_NODISCARD std::string* release_oracle_symbol();
  void set_allocated_oracle_symbol(std::string* ptr);

  private:
  const std::string& _internal_oracle_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_symbol(
      const std::string& value);
  std::string* _internal_mutable_oracle_symbol();

  public:
  // string oracle_provider = 4 [json_name = "oracleProvider"];
  void clear_oracle_provider() ;
  const std::string& oracle_provider() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_provider(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_provider();
  PROTOBUF_NODISCARD std::string* release_oracle_provider();
  void set_allocated_oracle_provider(std::string* ptr);

  private:
  const std::string& _internal_oracle_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_provider(
      const std::string& value);
  std::string* _internal_mutable_oracle_provider();

  public:
  // string maker_fee_rate = 7 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 8 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string admin = 11 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string quote_denom = 12 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string min_price_tick_size = 13 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 14 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 5 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // uint32 oracle_scale_factor = 6 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // int64 expiration_timestamp = 9 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // int64 settlement_timestamp = 10 [json_name = "settlementTimestamp"];
  void clear_settlement_timestamp() ;
  ::int64_t settlement_timestamp() const;
  void set_settlement_timestamp(::int64_t value);

  private:
  ::int64_t _internal_settlement_timestamp() const;
  void _internal_set_settlement_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    int oracle_type_;
    ::uint32_t oracle_scale_factor_;
    ::int64_t expiration_timestamp_;
    ::int64_t settlement_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantBinaryOptionsMarketLaunchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse) */ {
 public:
  inline MsgInstantBinaryOptionsMarketLaunchResponse() : MsgInstantBinaryOptionsMarketLaunchResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantBinaryOptionsMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantBinaryOptionsMarketLaunchResponse(const MsgInstantBinaryOptionsMarketLaunchResponse& from);
  MsgInstantBinaryOptionsMarketLaunchResponse(MsgInstantBinaryOptionsMarketLaunchResponse&& from) noexcept
    : MsgInstantBinaryOptionsMarketLaunchResponse() {
    *this = ::std::move(from);
  }

  inline MsgInstantBinaryOptionsMarketLaunchResponse& operator=(const MsgInstantBinaryOptionsMarketLaunchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantBinaryOptionsMarketLaunchResponse& operator=(MsgInstantBinaryOptionsMarketLaunchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantBinaryOptionsMarketLaunchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantBinaryOptionsMarketLaunchResponse* internal_default_instance() {
    return reinterpret_cast<const MsgInstantBinaryOptionsMarketLaunchResponse*>(
               &_MsgInstantBinaryOptionsMarketLaunchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MsgInstantBinaryOptionsMarketLaunchResponse& a, MsgInstantBinaryOptionsMarketLaunchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantBinaryOptionsMarketLaunchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantBinaryOptionsMarketLaunchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantBinaryOptionsMarketLaunchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantBinaryOptionsMarketLaunchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgInstantBinaryOptionsMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgInstantBinaryOptionsMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse";
  }
  protected:
  explicit MsgInstantBinaryOptionsMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantExpiryFuturesMarketLaunch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch) */ {
 public:
  inline MsgInstantExpiryFuturesMarketLaunch() : MsgInstantExpiryFuturesMarketLaunch(nullptr) {}
  ~MsgInstantExpiryFuturesMarketLaunch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantExpiryFuturesMarketLaunch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantExpiryFuturesMarketLaunch(const MsgInstantExpiryFuturesMarketLaunch& from);
  MsgInstantExpiryFuturesMarketLaunch(MsgInstantExpiryFuturesMarketLaunch&& from) noexcept
    : MsgInstantExpiryFuturesMarketLaunch() {
    *this = ::std::move(from);
  }

  inline MsgInstantExpiryFuturesMarketLaunch& operator=(const MsgInstantExpiryFuturesMarketLaunch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantExpiryFuturesMarketLaunch& operator=(MsgInstantExpiryFuturesMarketLaunch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantExpiryFuturesMarketLaunch& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantExpiryFuturesMarketLaunch* internal_default_instance() {
    return reinterpret_cast<const MsgInstantExpiryFuturesMarketLaunch*>(
               &_MsgInstantExpiryFuturesMarketLaunch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MsgInstantExpiryFuturesMarketLaunch& a, MsgInstantExpiryFuturesMarketLaunch& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantExpiryFuturesMarketLaunch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantExpiryFuturesMarketLaunch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantExpiryFuturesMarketLaunch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantExpiryFuturesMarketLaunch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgInstantExpiryFuturesMarketLaunch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgInstantExpiryFuturesMarketLaunch& from) {
    MsgInstantExpiryFuturesMarketLaunch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgInstantExpiryFuturesMarketLaunch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch";
  }
  protected:
  explicit MsgInstantExpiryFuturesMarketLaunch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kTickerFieldNumber = 2,
    kQuoteDenomFieldNumber = 3,
    kOracleBaseFieldNumber = 4,
    kOracleQuoteFieldNumber = 5,
    kMakerFeeRateFieldNumber = 9,
    kTakerFeeRateFieldNumber = 10,
    kInitialMarginRatioFieldNumber = 11,
    kMaintenanceMarginRatioFieldNumber = 12,
    kMinPriceTickSizeFieldNumber = 13,
    kMinQuantityTickSizeFieldNumber = 14,
    kOracleTypeFieldNumber = 6,
    kOracleScaleFactorFieldNumber = 7,
    kExpiryFieldNumber = 8,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string ticker = 2 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string quote_denom = 3 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string oracle_base = 4 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 5 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // string maker_fee_rate = 9 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 10 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string initial_margin_ratio = 11 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_initial_margin_ratio() ;
  const std::string& initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_initial_margin_ratio();
  void set_allocated_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_initial_margin_ratio();

  public:
  // string maintenance_margin_ratio = 12 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maintenance_margin_ratio() ;
  const std::string& maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_maintenance_margin_ratio();
  void set_allocated_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_maintenance_margin_ratio();

  public:
  // string min_price_tick_size = 13 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 14 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 6 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // int64 expiry = 8 [json_name = "expiry"];
  void clear_expiry() ;
  ::int64_t expiry() const;
  void set_expiry(::int64_t value);

  private:
  ::int64_t _internal_expiry() const;
  void _internal_set_expiry(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    int oracle_type_;
    ::uint32_t oracle_scale_factor_;
    ::int64_t expiry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgInstantExpiryFuturesMarketLaunchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse) */ {
 public:
  inline MsgInstantExpiryFuturesMarketLaunchResponse() : MsgInstantExpiryFuturesMarketLaunchResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgInstantExpiryFuturesMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInstantExpiryFuturesMarketLaunchResponse(const MsgInstantExpiryFuturesMarketLaunchResponse& from);
  MsgInstantExpiryFuturesMarketLaunchResponse(MsgInstantExpiryFuturesMarketLaunchResponse&& from) noexcept
    : MsgInstantExpiryFuturesMarketLaunchResponse() {
    *this = ::std::move(from);
  }

  inline MsgInstantExpiryFuturesMarketLaunchResponse& operator=(const MsgInstantExpiryFuturesMarketLaunchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInstantExpiryFuturesMarketLaunchResponse& operator=(MsgInstantExpiryFuturesMarketLaunchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgInstantExpiryFuturesMarketLaunchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInstantExpiryFuturesMarketLaunchResponse* internal_default_instance() {
    return reinterpret_cast<const MsgInstantExpiryFuturesMarketLaunchResponse*>(
               &_MsgInstantExpiryFuturesMarketLaunchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MsgInstantExpiryFuturesMarketLaunchResponse& a, MsgInstantExpiryFuturesMarketLaunchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInstantExpiryFuturesMarketLaunchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInstantExpiryFuturesMarketLaunchResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInstantExpiryFuturesMarketLaunchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInstantExpiryFuturesMarketLaunchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgInstantExpiryFuturesMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgInstantExpiryFuturesMarketLaunchResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse";
  }
  protected:
  explicit MsgInstantExpiryFuturesMarketLaunchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateSpotMarketOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateSpotMarketOrder) */ {
 public:
  inline MsgCreateSpotMarketOrder() : MsgCreateSpotMarketOrder(nullptr) {}
  ~MsgCreateSpotMarketOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateSpotMarketOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateSpotMarketOrder(const MsgCreateSpotMarketOrder& from);
  MsgCreateSpotMarketOrder(MsgCreateSpotMarketOrder&& from) noexcept
    : MsgCreateSpotMarketOrder() {
    *this = ::std::move(from);
  }

  inline MsgCreateSpotMarketOrder& operator=(const MsgCreateSpotMarketOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateSpotMarketOrder& operator=(MsgCreateSpotMarketOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateSpotMarketOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateSpotMarketOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCreateSpotMarketOrder*>(
               &_MsgCreateSpotMarketOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MsgCreateSpotMarketOrder& a, MsgCreateSpotMarketOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateSpotMarketOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateSpotMarketOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateSpotMarketOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateSpotMarketOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateSpotMarketOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateSpotMarketOrder& from) {
    MsgCreateSpotMarketOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateSpotMarketOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateSpotMarketOrder";
  }
  protected:
  explicit MsgCreateSpotMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.exchange.v1beta1.SpotOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::SpotOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SpotOrder* release_order();
  ::injective::exchange::v1beta1::SpotOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::SpotOrder* order);
  private:
  const ::injective::exchange::v1beta1::SpotOrder& _internal_order() const;
  ::injective::exchange::v1beta1::SpotOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::SpotOrder* order);
  ::injective::exchange::v1beta1::SpotOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateSpotMarketOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::exchange::v1beta1::SpotOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateSpotMarketOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse) */ {
 public:
  inline MsgCreateSpotMarketOrderResponse() : MsgCreateSpotMarketOrderResponse(nullptr) {}
  ~MsgCreateSpotMarketOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateSpotMarketOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateSpotMarketOrderResponse(const MsgCreateSpotMarketOrderResponse& from);
  MsgCreateSpotMarketOrderResponse(MsgCreateSpotMarketOrderResponse&& from) noexcept
    : MsgCreateSpotMarketOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateSpotMarketOrderResponse& operator=(const MsgCreateSpotMarketOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateSpotMarketOrderResponse& operator=(MsgCreateSpotMarketOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateSpotMarketOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateSpotMarketOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateSpotMarketOrderResponse*>(
               &_MsgCreateSpotMarketOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MsgCreateSpotMarketOrderResponse& a, MsgCreateSpotMarketOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateSpotMarketOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateSpotMarketOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateSpotMarketOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateSpotMarketOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateSpotMarketOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateSpotMarketOrderResponse& from) {
    MsgCreateSpotMarketOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateSpotMarketOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse";
  }
  protected:
  explicit MsgCreateSpotMarketOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // .injective.exchange.v1beta1.SpotMarketOrderResults results = 2 [json_name = "results", (.gogoproto.nullable) = true];
  bool has_results() const;
  void clear_results() ;
  const ::injective::exchange::v1beta1::SpotMarketOrderResults& results() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SpotMarketOrderResults* release_results();
  ::injective::exchange::v1beta1::SpotMarketOrderResults* mutable_results();
  void set_allocated_results(::injective::exchange::v1beta1::SpotMarketOrderResults* results);
  private:
  const ::injective::exchange::v1beta1::SpotMarketOrderResults& _internal_results() const;
  ::injective::exchange::v1beta1::SpotMarketOrderResults* _internal_mutable_results();
  public:
  void unsafe_arena_set_allocated_results(
      ::injective::exchange::v1beta1::SpotMarketOrderResults* results);
  ::injective::exchange::v1beta1::SpotMarketOrderResults* unsafe_arena_release_results();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::injective::exchange::v1beta1::SpotMarketOrderResults* results_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class SpotMarketOrderResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SpotMarketOrderResults) */ {
 public:
  inline SpotMarketOrderResults() : SpotMarketOrderResults(nullptr) {}
  ~SpotMarketOrderResults() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotMarketOrderResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotMarketOrderResults(const SpotMarketOrderResults& from);
  SpotMarketOrderResults(SpotMarketOrderResults&& from) noexcept
    : SpotMarketOrderResults() {
    *this = ::std::move(from);
  }

  inline SpotMarketOrderResults& operator=(const SpotMarketOrderResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotMarketOrderResults& operator=(SpotMarketOrderResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotMarketOrderResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotMarketOrderResults* internal_default_instance() {
    return reinterpret_cast<const SpotMarketOrderResults*>(
               &_SpotMarketOrderResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SpotMarketOrderResults& a, SpotMarketOrderResults& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotMarketOrderResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotMarketOrderResults* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotMarketOrderResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotMarketOrderResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotMarketOrderResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotMarketOrderResults& from) {
    SpotMarketOrderResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotMarketOrderResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SpotMarketOrderResults";
  }
  protected:
  explicit SpotMarketOrderResults(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantityFieldNumber = 1,
    kPriceFieldNumber = 2,
    kFeeFieldNumber = 3,
  };
  // string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string fee = 3 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fee() ;
  const std::string& fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee(Arg_&& arg, Args_... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* ptr);

  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(
      const std::string& value);
  std::string* _internal_mutable_fee();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SpotMarketOrderResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateDerivativeLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder) */ {
 public:
  inline MsgCreateDerivativeLimitOrder() : MsgCreateDerivativeLimitOrder(nullptr) {}
  ~MsgCreateDerivativeLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateDerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateDerivativeLimitOrder(const MsgCreateDerivativeLimitOrder& from);
  MsgCreateDerivativeLimitOrder(MsgCreateDerivativeLimitOrder&& from) noexcept
    : MsgCreateDerivativeLimitOrder() {
    *this = ::std::move(from);
  }

  inline MsgCreateDerivativeLimitOrder& operator=(const MsgCreateDerivativeLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateDerivativeLimitOrder& operator=(MsgCreateDerivativeLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateDerivativeLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateDerivativeLimitOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCreateDerivativeLimitOrder*>(
               &_MsgCreateDerivativeLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MsgCreateDerivativeLimitOrder& a, MsgCreateDerivativeLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateDerivativeLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateDerivativeLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateDerivativeLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateDerivativeLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateDerivativeLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateDerivativeLimitOrder& from) {
    MsgCreateDerivativeLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateDerivativeLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder";
  }
  protected:
  explicit MsgCreateDerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::DerivativeOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeOrder* release_order();
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order);
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_order() const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::DerivativeOrder* order);
  ::injective::exchange::v1beta1::DerivativeOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::exchange::v1beta1::DerivativeOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateDerivativeLimitOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse) */ {
 public:
  inline MsgCreateDerivativeLimitOrderResponse() : MsgCreateDerivativeLimitOrderResponse(nullptr) {}
  ~MsgCreateDerivativeLimitOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateDerivativeLimitOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateDerivativeLimitOrderResponse(const MsgCreateDerivativeLimitOrderResponse& from);
  MsgCreateDerivativeLimitOrderResponse(MsgCreateDerivativeLimitOrderResponse&& from) noexcept
    : MsgCreateDerivativeLimitOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateDerivativeLimitOrderResponse& operator=(const MsgCreateDerivativeLimitOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateDerivativeLimitOrderResponse& operator=(MsgCreateDerivativeLimitOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateDerivativeLimitOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateDerivativeLimitOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateDerivativeLimitOrderResponse*>(
               &_MsgCreateDerivativeLimitOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MsgCreateDerivativeLimitOrderResponse& a, MsgCreateDerivativeLimitOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateDerivativeLimitOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateDerivativeLimitOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateDerivativeLimitOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateDerivativeLimitOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateDerivativeLimitOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateDerivativeLimitOrderResponse& from) {
    MsgCreateDerivativeLimitOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateDerivativeLimitOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse";
  }
  protected:
  explicit MsgCreateDerivativeLimitOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateBinaryOptionsLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder) */ {
 public:
  inline MsgCreateBinaryOptionsLimitOrder() : MsgCreateBinaryOptionsLimitOrder(nullptr) {}
  ~MsgCreateBinaryOptionsLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateBinaryOptionsLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateBinaryOptionsLimitOrder(const MsgCreateBinaryOptionsLimitOrder& from);
  MsgCreateBinaryOptionsLimitOrder(MsgCreateBinaryOptionsLimitOrder&& from) noexcept
    : MsgCreateBinaryOptionsLimitOrder() {
    *this = ::std::move(from);
  }

  inline MsgCreateBinaryOptionsLimitOrder& operator=(const MsgCreateBinaryOptionsLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateBinaryOptionsLimitOrder& operator=(MsgCreateBinaryOptionsLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateBinaryOptionsLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateBinaryOptionsLimitOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCreateBinaryOptionsLimitOrder*>(
               &_MsgCreateBinaryOptionsLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MsgCreateBinaryOptionsLimitOrder& a, MsgCreateBinaryOptionsLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateBinaryOptionsLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateBinaryOptionsLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateBinaryOptionsLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateBinaryOptionsLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateBinaryOptionsLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateBinaryOptionsLimitOrder& from) {
    MsgCreateBinaryOptionsLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateBinaryOptionsLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder";
  }
  protected:
  explicit MsgCreateBinaryOptionsLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::DerivativeOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeOrder* release_order();
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order);
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_order() const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::DerivativeOrder* order);
  ::injective::exchange::v1beta1::DerivativeOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::exchange::v1beta1::DerivativeOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateBinaryOptionsLimitOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse) */ {
 public:
  inline MsgCreateBinaryOptionsLimitOrderResponse() : MsgCreateBinaryOptionsLimitOrderResponse(nullptr) {}
  ~MsgCreateBinaryOptionsLimitOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateBinaryOptionsLimitOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateBinaryOptionsLimitOrderResponse(const MsgCreateBinaryOptionsLimitOrderResponse& from);
  MsgCreateBinaryOptionsLimitOrderResponse(MsgCreateBinaryOptionsLimitOrderResponse&& from) noexcept
    : MsgCreateBinaryOptionsLimitOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateBinaryOptionsLimitOrderResponse& operator=(const MsgCreateBinaryOptionsLimitOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateBinaryOptionsLimitOrderResponse& operator=(MsgCreateBinaryOptionsLimitOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateBinaryOptionsLimitOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateBinaryOptionsLimitOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateBinaryOptionsLimitOrderResponse*>(
               &_MsgCreateBinaryOptionsLimitOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MsgCreateBinaryOptionsLimitOrderResponse& a, MsgCreateBinaryOptionsLimitOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateBinaryOptionsLimitOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateBinaryOptionsLimitOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateBinaryOptionsLimitOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateBinaryOptionsLimitOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateBinaryOptionsLimitOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateBinaryOptionsLimitOrderResponse& from) {
    MsgCreateBinaryOptionsLimitOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateBinaryOptionsLimitOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse";
  }
  protected:
  explicit MsgCreateBinaryOptionsLimitOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCreateDerivativeLimitOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders) */ {
 public:
  inline MsgBatchCreateDerivativeLimitOrders() : MsgBatchCreateDerivativeLimitOrders(nullptr) {}
  ~MsgBatchCreateDerivativeLimitOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCreateDerivativeLimitOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCreateDerivativeLimitOrders(const MsgBatchCreateDerivativeLimitOrders& from);
  MsgBatchCreateDerivativeLimitOrders(MsgBatchCreateDerivativeLimitOrders&& from) noexcept
    : MsgBatchCreateDerivativeLimitOrders() {
    *this = ::std::move(from);
  }

  inline MsgBatchCreateDerivativeLimitOrders& operator=(const MsgBatchCreateDerivativeLimitOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCreateDerivativeLimitOrders& operator=(MsgBatchCreateDerivativeLimitOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCreateDerivativeLimitOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCreateDerivativeLimitOrders* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCreateDerivativeLimitOrders*>(
               &_MsgBatchCreateDerivativeLimitOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MsgBatchCreateDerivativeLimitOrders& a, MsgBatchCreateDerivativeLimitOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCreateDerivativeLimitOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCreateDerivativeLimitOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCreateDerivativeLimitOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCreateDerivativeLimitOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCreateDerivativeLimitOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCreateDerivativeLimitOrders& from) {
    MsgBatchCreateDerivativeLimitOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCreateDerivativeLimitOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders";
  }
  protected:
  explicit MsgBatchCreateDerivativeLimitOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 2,
    kSenderFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.DerivativeOrder orders = 2 [json_name = "orders", (.gogoproto.nullable) = false];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::DerivativeOrder& orders(int index) const;
  ::injective::exchange::v1beta1::DerivativeOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >&
      orders() const;
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder > orders_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCreateDerivativeLimitOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse) */ {
 public:
  inline MsgBatchCreateDerivativeLimitOrdersResponse() : MsgBatchCreateDerivativeLimitOrdersResponse(nullptr) {}
  ~MsgBatchCreateDerivativeLimitOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCreateDerivativeLimitOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCreateDerivativeLimitOrdersResponse(const MsgBatchCreateDerivativeLimitOrdersResponse& from);
  MsgBatchCreateDerivativeLimitOrdersResponse(MsgBatchCreateDerivativeLimitOrdersResponse&& from) noexcept
    : MsgBatchCreateDerivativeLimitOrdersResponse() {
    *this = ::std::move(from);
  }

  inline MsgBatchCreateDerivativeLimitOrdersResponse& operator=(const MsgBatchCreateDerivativeLimitOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCreateDerivativeLimitOrdersResponse& operator=(MsgBatchCreateDerivativeLimitOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCreateDerivativeLimitOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCreateDerivativeLimitOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCreateDerivativeLimitOrdersResponse*>(
               &_MsgBatchCreateDerivativeLimitOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MsgBatchCreateDerivativeLimitOrdersResponse& a, MsgBatchCreateDerivativeLimitOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCreateDerivativeLimitOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCreateDerivativeLimitOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCreateDerivativeLimitOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCreateDerivativeLimitOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCreateDerivativeLimitOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCreateDerivativeLimitOrdersResponse& from) {
    MsgBatchCreateDerivativeLimitOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCreateDerivativeLimitOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse";
  }
  protected:
  explicit MsgBatchCreateDerivativeLimitOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashesFieldNumber = 1,
  };
  // repeated string order_hashes = 1 [json_name = "orderHashes"];
  int order_hashes_size() const;
  private:
  int _internal_order_hashes_size() const;

  public:
  void clear_order_hashes() ;
  const std::string& order_hashes(int index) const;
  std::string* mutable_order_hashes(int index);
  void set_order_hashes(int index, const std::string& value);
  void set_order_hashes(int index, std::string&& value);
  void set_order_hashes(int index, const char* value);
  void set_order_hashes(int index, const char* value, std::size_t size);
  void set_order_hashes(int index, absl::string_view value);
  std::string* add_order_hashes();
  void add_order_hashes(const std::string& value);
  void add_order_hashes(std::string&& value);
  void add_order_hashes(const char* value);
  void add_order_hashes(const char* value, std::size_t size);
  void add_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_hashes();

  private:
  const std::string& _internal_order_hashes(int index) const;
  std::string* _internal_add_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_hashes();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCancelSpotOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCancelSpotOrder) */ {
 public:
  inline MsgCancelSpotOrder() : MsgCancelSpotOrder(nullptr) {}
  ~MsgCancelSpotOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCancelSpotOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCancelSpotOrder(const MsgCancelSpotOrder& from);
  MsgCancelSpotOrder(MsgCancelSpotOrder&& from) noexcept
    : MsgCancelSpotOrder() {
    *this = ::std::move(from);
  }

  inline MsgCancelSpotOrder& operator=(const MsgCancelSpotOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCancelSpotOrder& operator=(MsgCancelSpotOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCancelSpotOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCancelSpotOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCancelSpotOrder*>(
               &_MsgCancelSpotOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MsgCancelSpotOrder& a, MsgCancelSpotOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCancelSpotOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCancelSpotOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCancelSpotOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCancelSpotOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCancelSpotOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCancelSpotOrder& from) {
    MsgCancelSpotOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCancelSpotOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCancelSpotOrder";
  }
  protected:
  explicit MsgCancelSpotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kOrderHashFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string order_hash = 4 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCancelSpotOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCancelSpotOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCancelSpotOrderResponse) */ {
 public:
  inline MsgCancelSpotOrderResponse() : MsgCancelSpotOrderResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCancelSpotOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCancelSpotOrderResponse(const MsgCancelSpotOrderResponse& from);
  MsgCancelSpotOrderResponse(MsgCancelSpotOrderResponse&& from) noexcept
    : MsgCancelSpotOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCancelSpotOrderResponse& operator=(const MsgCancelSpotOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCancelSpotOrderResponse& operator=(MsgCancelSpotOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCancelSpotOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCancelSpotOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCancelSpotOrderResponse*>(
               &_MsgCancelSpotOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(MsgCancelSpotOrderResponse& a, MsgCancelSpotOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCancelSpotOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCancelSpotOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCancelSpotOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCancelSpotOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgCancelSpotOrderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgCancelSpotOrderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCancelSpotOrderResponse";
  }
  protected:
  explicit MsgCancelSpotOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCancelSpotOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCancelSpotOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCancelSpotOrders) */ {
 public:
  inline MsgBatchCancelSpotOrders() : MsgBatchCancelSpotOrders(nullptr) {}
  ~MsgBatchCancelSpotOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCancelSpotOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCancelSpotOrders(const MsgBatchCancelSpotOrders& from);
  MsgBatchCancelSpotOrders(MsgBatchCancelSpotOrders&& from) noexcept
    : MsgBatchCancelSpotOrders() {
    *this = ::std::move(from);
  }

  inline MsgBatchCancelSpotOrders& operator=(const MsgBatchCancelSpotOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCancelSpotOrders& operator=(MsgBatchCancelSpotOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCancelSpotOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCancelSpotOrders* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCancelSpotOrders*>(
               &_MsgBatchCancelSpotOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(MsgBatchCancelSpotOrders& a, MsgBatchCancelSpotOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCancelSpotOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCancelSpotOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCancelSpotOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCancelSpotOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCancelSpotOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCancelSpotOrders& from) {
    MsgBatchCancelSpotOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCancelSpotOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCancelSpotOrders";
  }
  protected:
  explicit MsgBatchCancelSpotOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kSenderFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.OrderData data = 2 [json_name = "data", (.gogoproto.nullable) = false];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective::exchange::v1beta1::OrderData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
      mutable_data();
  private:
  const ::injective::exchange::v1beta1::OrderData& _internal_data(int index) const;
  ::injective::exchange::v1beta1::OrderData* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>* _internal_mutable_data();
  public:
  const ::injective::exchange::v1beta1::OrderData& data(int index) const;
  ::injective::exchange::v1beta1::OrderData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
      data() const;
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCancelSpotOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCancelSpotOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse) */ {
 public:
  inline MsgBatchCancelSpotOrdersResponse() : MsgBatchCancelSpotOrdersResponse(nullptr) {}
  ~MsgBatchCancelSpotOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCancelSpotOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCancelSpotOrdersResponse(const MsgBatchCancelSpotOrdersResponse& from);
  MsgBatchCancelSpotOrdersResponse(MsgBatchCancelSpotOrdersResponse&& from) noexcept
    : MsgBatchCancelSpotOrdersResponse() {
    *this = ::std::move(from);
  }

  inline MsgBatchCancelSpotOrdersResponse& operator=(const MsgBatchCancelSpotOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCancelSpotOrdersResponse& operator=(MsgBatchCancelSpotOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCancelSpotOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCancelSpotOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCancelSpotOrdersResponse*>(
               &_MsgBatchCancelSpotOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MsgBatchCancelSpotOrdersResponse& a, MsgBatchCancelSpotOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCancelSpotOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCancelSpotOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCancelSpotOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCancelSpotOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCancelSpotOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCancelSpotOrdersResponse& from) {
    MsgBatchCancelSpotOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCancelSpotOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse";
  }
  protected:
  explicit MsgBatchCancelSpotOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // repeated bool success = 1 [json_name = "success"];
  int success_size() const;
  private:
  int _internal_success_size() const;

  public:
  void clear_success() ;
  bool success(int index) const;
  void set_success(int index, bool value);
  void add_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* mutable_success();

  private:
  bool _internal_success(int index) const;
  void _internal_add_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& _internal_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* _internal_mutable_success();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool> success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCancelBinaryOptionsOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders) */ {
 public:
  inline MsgBatchCancelBinaryOptionsOrders() : MsgBatchCancelBinaryOptionsOrders(nullptr) {}
  ~MsgBatchCancelBinaryOptionsOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCancelBinaryOptionsOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCancelBinaryOptionsOrders(const MsgBatchCancelBinaryOptionsOrders& from);
  MsgBatchCancelBinaryOptionsOrders(MsgBatchCancelBinaryOptionsOrders&& from) noexcept
    : MsgBatchCancelBinaryOptionsOrders() {
    *this = ::std::move(from);
  }

  inline MsgBatchCancelBinaryOptionsOrders& operator=(const MsgBatchCancelBinaryOptionsOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCancelBinaryOptionsOrders& operator=(MsgBatchCancelBinaryOptionsOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCancelBinaryOptionsOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCancelBinaryOptionsOrders* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCancelBinaryOptionsOrders*>(
               &_MsgBatchCancelBinaryOptionsOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MsgBatchCancelBinaryOptionsOrders& a, MsgBatchCancelBinaryOptionsOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCancelBinaryOptionsOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCancelBinaryOptionsOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCancelBinaryOptionsOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCancelBinaryOptionsOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCancelBinaryOptionsOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCancelBinaryOptionsOrders& from) {
    MsgBatchCancelBinaryOptionsOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCancelBinaryOptionsOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders";
  }
  protected:
  explicit MsgBatchCancelBinaryOptionsOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kSenderFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.OrderData data = 2 [json_name = "data", (.gogoproto.nullable) = false];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective::exchange::v1beta1::OrderData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
      mutable_data();
  private:
  const ::injective::exchange::v1beta1::OrderData& _internal_data(int index) const;
  ::injective::exchange::v1beta1::OrderData* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>* _internal_mutable_data();
  public:
  const ::injective::exchange::v1beta1::OrderData& data(int index) const;
  ::injective::exchange::v1beta1::OrderData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
      data() const;
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCancelBinaryOptionsOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse) */ {
 public:
  inline MsgBatchCancelBinaryOptionsOrdersResponse() : MsgBatchCancelBinaryOptionsOrdersResponse(nullptr) {}
  ~MsgBatchCancelBinaryOptionsOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCancelBinaryOptionsOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCancelBinaryOptionsOrdersResponse(const MsgBatchCancelBinaryOptionsOrdersResponse& from);
  MsgBatchCancelBinaryOptionsOrdersResponse(MsgBatchCancelBinaryOptionsOrdersResponse&& from) noexcept
    : MsgBatchCancelBinaryOptionsOrdersResponse() {
    *this = ::std::move(from);
  }

  inline MsgBatchCancelBinaryOptionsOrdersResponse& operator=(const MsgBatchCancelBinaryOptionsOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCancelBinaryOptionsOrdersResponse& operator=(MsgBatchCancelBinaryOptionsOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCancelBinaryOptionsOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCancelBinaryOptionsOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCancelBinaryOptionsOrdersResponse*>(
               &_MsgBatchCancelBinaryOptionsOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MsgBatchCancelBinaryOptionsOrdersResponse& a, MsgBatchCancelBinaryOptionsOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCancelBinaryOptionsOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCancelBinaryOptionsOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCancelBinaryOptionsOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCancelBinaryOptionsOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCancelBinaryOptionsOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCancelBinaryOptionsOrdersResponse& from) {
    MsgBatchCancelBinaryOptionsOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCancelBinaryOptionsOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse";
  }
  protected:
  explicit MsgBatchCancelBinaryOptionsOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // repeated bool success = 1 [json_name = "success"];
  int success_size() const;
  private:
  int _internal_success_size() const;

  public:
  void clear_success() ;
  bool success(int index) const;
  void set_success(int index, bool value);
  void add_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* mutable_success();

  private:
  bool _internal_success(int index) const;
  void _internal_add_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& _internal_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* _internal_mutable_success();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool> success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchUpdateOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchUpdateOrders) */ {
 public:
  inline MsgBatchUpdateOrders() : MsgBatchUpdateOrders(nullptr) {}
  ~MsgBatchUpdateOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchUpdateOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchUpdateOrders(const MsgBatchUpdateOrders& from);
  MsgBatchUpdateOrders(MsgBatchUpdateOrders&& from) noexcept
    : MsgBatchUpdateOrders() {
    *this = ::std::move(from);
  }

  inline MsgBatchUpdateOrders& operator=(const MsgBatchUpdateOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchUpdateOrders& operator=(MsgBatchUpdateOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchUpdateOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchUpdateOrders* internal_default_instance() {
    return reinterpret_cast<const MsgBatchUpdateOrders*>(
               &_MsgBatchUpdateOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MsgBatchUpdateOrders& a, MsgBatchUpdateOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchUpdateOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchUpdateOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchUpdateOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchUpdateOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchUpdateOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchUpdateOrders& from) {
    MsgBatchUpdateOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchUpdateOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchUpdateOrders";
  }
  protected:
  explicit MsgBatchUpdateOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpotMarketIdsToCancelAllFieldNumber = 3,
    kDerivativeMarketIdsToCancelAllFieldNumber = 4,
    kSpotOrdersToCancelFieldNumber = 5,
    kDerivativeOrdersToCancelFieldNumber = 6,
    kSpotOrdersToCreateFieldNumber = 7,
    kDerivativeOrdersToCreateFieldNumber = 8,
    kBinaryOptionsOrdersToCancelFieldNumber = 9,
    kBinaryOptionsMarketIdsToCancelAllFieldNumber = 10,
    kBinaryOptionsOrdersToCreateFieldNumber = 11,
    kSenderFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
  };
  // repeated string spot_market_ids_to_cancel_all = 3 [json_name = "spotMarketIdsToCancelAll"];
  int spot_market_ids_to_cancel_all_size() const;
  private:
  int _internal_spot_market_ids_to_cancel_all_size() const;

  public:
  void clear_spot_market_ids_to_cancel_all() ;
  const std::string& spot_market_ids_to_cancel_all(int index) const;
  std::string* mutable_spot_market_ids_to_cancel_all(int index);
  void set_spot_market_ids_to_cancel_all(int index, const std::string& value);
  void set_spot_market_ids_to_cancel_all(int index, std::string&& value);
  void set_spot_market_ids_to_cancel_all(int index, const char* value);
  void set_spot_market_ids_to_cancel_all(int index, const char* value, std::size_t size);
  void set_spot_market_ids_to_cancel_all(int index, absl::string_view value);
  std::string* add_spot_market_ids_to_cancel_all();
  void add_spot_market_ids_to_cancel_all(const std::string& value);
  void add_spot_market_ids_to_cancel_all(std::string&& value);
  void add_spot_market_ids_to_cancel_all(const char* value);
  void add_spot_market_ids_to_cancel_all(const char* value, std::size_t size);
  void add_spot_market_ids_to_cancel_all(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& spot_market_ids_to_cancel_all() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_spot_market_ids_to_cancel_all();

  private:
  const std::string& _internal_spot_market_ids_to_cancel_all(int index) const;
  std::string* _internal_add_spot_market_ids_to_cancel_all();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_spot_market_ids_to_cancel_all() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_spot_market_ids_to_cancel_all();

  public:
  // repeated string derivative_market_ids_to_cancel_all = 4 [json_name = "derivativeMarketIdsToCancelAll"];
  int derivative_market_ids_to_cancel_all_size() const;
  private:
  int _internal_derivative_market_ids_to_cancel_all_size() const;

  public:
  void clear_derivative_market_ids_to_cancel_all() ;
  const std::string& derivative_market_ids_to_cancel_all(int index) const;
  std::string* mutable_derivative_market_ids_to_cancel_all(int index);
  void set_derivative_market_ids_to_cancel_all(int index, const std::string& value);
  void set_derivative_market_ids_to_cancel_all(int index, std::string&& value);
  void set_derivative_market_ids_to_cancel_all(int index, const char* value);
  void set_derivative_market_ids_to_cancel_all(int index, const char* value, std::size_t size);
  void set_derivative_market_ids_to_cancel_all(int index, absl::string_view value);
  std::string* add_derivative_market_ids_to_cancel_all();
  void add_derivative_market_ids_to_cancel_all(const std::string& value);
  void add_derivative_market_ids_to_cancel_all(std::string&& value);
  void add_derivative_market_ids_to_cancel_all(const char* value);
  void add_derivative_market_ids_to_cancel_all(const char* value, std::size_t size);
  void add_derivative_market_ids_to_cancel_all(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& derivative_market_ids_to_cancel_all() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_derivative_market_ids_to_cancel_all();

  private:
  const std::string& _internal_derivative_market_ids_to_cancel_all(int index) const;
  std::string* _internal_add_derivative_market_ids_to_cancel_all();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_derivative_market_ids_to_cancel_all() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_derivative_market_ids_to_cancel_all();

  public:
  // repeated .injective.exchange.v1beta1.OrderData spot_orders_to_cancel = 5 [json_name = "spotOrdersToCancel", (.gogoproto.nullable) = true];
  int spot_orders_to_cancel_size() const;
  private:
  int _internal_spot_orders_to_cancel_size() const;

  public:
  void clear_spot_orders_to_cancel() ;
  ::injective::exchange::v1beta1::OrderData* mutable_spot_orders_to_cancel(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
      mutable_spot_orders_to_cancel();
  private:
  const ::injective::exchange::v1beta1::OrderData& _internal_spot_orders_to_cancel(int index) const;
  ::injective::exchange::v1beta1::OrderData* _internal_add_spot_orders_to_cancel();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>& _internal_spot_orders_to_cancel() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>* _internal_mutable_spot_orders_to_cancel();
  public:
  const ::injective::exchange::v1beta1::OrderData& spot_orders_to_cancel(int index) const;
  ::injective::exchange::v1beta1::OrderData* add_spot_orders_to_cancel();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
      spot_orders_to_cancel() const;
  // repeated .injective.exchange.v1beta1.OrderData derivative_orders_to_cancel = 6 [json_name = "derivativeOrdersToCancel", (.gogoproto.nullable) = true];
  int derivative_orders_to_cancel_size() const;
  private:
  int _internal_derivative_orders_to_cancel_size() const;

  public:
  void clear_derivative_orders_to_cancel() ;
  ::injective::exchange::v1beta1::OrderData* mutable_derivative_orders_to_cancel(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
      mutable_derivative_orders_to_cancel();
  private:
  const ::injective::exchange::v1beta1::OrderData& _internal_derivative_orders_to_cancel(int index) const;
  ::injective::exchange::v1beta1::OrderData* _internal_add_derivative_orders_to_cancel();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>& _internal_derivative_orders_to_cancel() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>* _internal_mutable_derivative_orders_to_cancel();
  public:
  const ::injective::exchange::v1beta1::OrderData& derivative_orders_to_cancel(int index) const;
  ::injective::exchange::v1beta1::OrderData* add_derivative_orders_to_cancel();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
      derivative_orders_to_cancel() const;
  // repeated .injective.exchange.v1beta1.SpotOrder spot_orders_to_create = 7 [json_name = "spotOrdersToCreate", (.gogoproto.nullable) = true];
  int spot_orders_to_create_size() const;
  private:
  int _internal_spot_orders_to_create_size() const;

  public:
  void clear_spot_orders_to_create() ;
  ::injective::exchange::v1beta1::SpotOrder* mutable_spot_orders_to_create(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >*
      mutable_spot_orders_to_create();
  private:
  const ::injective::exchange::v1beta1::SpotOrder& _internal_spot_orders_to_create(int index) const;
  ::injective::exchange::v1beta1::SpotOrder* _internal_add_spot_orders_to_create();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>& _internal_spot_orders_to_create() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>* _internal_mutable_spot_orders_to_create();
  public:
  const ::injective::exchange::v1beta1::SpotOrder& spot_orders_to_create(int index) const;
  ::injective::exchange::v1beta1::SpotOrder* add_spot_orders_to_create();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >&
      spot_orders_to_create() const;
  // repeated .injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create = 8 [json_name = "derivativeOrdersToCreate", (.gogoproto.nullable) = true];
  int derivative_orders_to_create_size() const;
  private:
  int _internal_derivative_orders_to_create_size() const;

  public:
  void clear_derivative_orders_to_create() ;
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_derivative_orders_to_create(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >*
      mutable_derivative_orders_to_create();
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_derivative_orders_to_create(int index) const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_add_derivative_orders_to_create();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>& _internal_derivative_orders_to_create() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>* _internal_mutable_derivative_orders_to_create();
  public:
  const ::injective::exchange::v1beta1::DerivativeOrder& derivative_orders_to_create(int index) const;
  ::injective::exchange::v1beta1::DerivativeOrder* add_derivative_orders_to_create();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >&
      derivative_orders_to_create() const;
  // repeated .injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel = 9 [json_name = "binaryOptionsOrdersToCancel", (.gogoproto.nullable) = true];
  int binary_options_orders_to_cancel_size() const;
  private:
  int _internal_binary_options_orders_to_cancel_size() const;

  public:
  void clear_binary_options_orders_to_cancel() ;
  ::injective::exchange::v1beta1::OrderData* mutable_binary_options_orders_to_cancel(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
      mutable_binary_options_orders_to_cancel();
  private:
  const ::injective::exchange::v1beta1::OrderData& _internal_binary_options_orders_to_cancel(int index) const;
  ::injective::exchange::v1beta1::OrderData* _internal_add_binary_options_orders_to_cancel();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>& _internal_binary_options_orders_to_cancel() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>* _internal_mutable_binary_options_orders_to_cancel();
  public:
  const ::injective::exchange::v1beta1::OrderData& binary_options_orders_to_cancel(int index) const;
  ::injective::exchange::v1beta1::OrderData* add_binary_options_orders_to_cancel();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
      binary_options_orders_to_cancel() const;
  // repeated string binary_options_market_ids_to_cancel_all = 10 [json_name = "binaryOptionsMarketIdsToCancelAll"];
  int binary_options_market_ids_to_cancel_all_size() const;
  private:
  int _internal_binary_options_market_ids_to_cancel_all_size() const;

  public:
  void clear_binary_options_market_ids_to_cancel_all() ;
  const std::string& binary_options_market_ids_to_cancel_all(int index) const;
  std::string* mutable_binary_options_market_ids_to_cancel_all(int index);
  void set_binary_options_market_ids_to_cancel_all(int index, const std::string& value);
  void set_binary_options_market_ids_to_cancel_all(int index, std::string&& value);
  void set_binary_options_market_ids_to_cancel_all(int index, const char* value);
  void set_binary_options_market_ids_to_cancel_all(int index, const char* value, std::size_t size);
  void set_binary_options_market_ids_to_cancel_all(int index, absl::string_view value);
  std::string* add_binary_options_market_ids_to_cancel_all();
  void add_binary_options_market_ids_to_cancel_all(const std::string& value);
  void add_binary_options_market_ids_to_cancel_all(std::string&& value);
  void add_binary_options_market_ids_to_cancel_all(const char* value);
  void add_binary_options_market_ids_to_cancel_all(const char* value, std::size_t size);
  void add_binary_options_market_ids_to_cancel_all(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& binary_options_market_ids_to_cancel_all() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_binary_options_market_ids_to_cancel_all();

  private:
  const std::string& _internal_binary_options_market_ids_to_cancel_all(int index) const;
  std::string* _internal_add_binary_options_market_ids_to_cancel_all();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_binary_options_market_ids_to_cancel_all() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_binary_options_market_ids_to_cancel_all();

  public:
  // repeated .injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create = 11 [json_name = "binaryOptionsOrdersToCreate", (.gogoproto.nullable) = true];
  int binary_options_orders_to_create_size() const;
  private:
  int _internal_binary_options_orders_to_create_size() const;

  public:
  void clear_binary_options_orders_to_create() ;
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_binary_options_orders_to_create(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >*
      mutable_binary_options_orders_to_create();
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_binary_options_orders_to_create(int index) const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_add_binary_options_orders_to_create();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>& _internal_binary_options_orders_to_create() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>* _internal_mutable_binary_options_orders_to_create();
  public:
  const ::injective::exchange::v1beta1::DerivativeOrder& binary_options_orders_to_create(int index) const;
  ::injective::exchange::v1beta1::DerivativeOrder* add_binary_options_orders_to_create();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >&
      binary_options_orders_to_create() const;
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchUpdateOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> spot_market_ids_to_cancel_all_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> derivative_market_ids_to_cancel_all_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData > spot_orders_to_cancel_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData > derivative_orders_to_cancel_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder > spot_orders_to_create_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder > derivative_orders_to_create_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData > binary_options_orders_to_cancel_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> binary_options_market_ids_to_cancel_all_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder > binary_options_orders_to_create_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchUpdateOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse) */ {
 public:
  inline MsgBatchUpdateOrdersResponse() : MsgBatchUpdateOrdersResponse(nullptr) {}
  ~MsgBatchUpdateOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchUpdateOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchUpdateOrdersResponse(const MsgBatchUpdateOrdersResponse& from);
  MsgBatchUpdateOrdersResponse(MsgBatchUpdateOrdersResponse&& from) noexcept
    : MsgBatchUpdateOrdersResponse() {
    *this = ::std::move(from);
  }

  inline MsgBatchUpdateOrdersResponse& operator=(const MsgBatchUpdateOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchUpdateOrdersResponse& operator=(MsgBatchUpdateOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchUpdateOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchUpdateOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const MsgBatchUpdateOrdersResponse*>(
               &_MsgBatchUpdateOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(MsgBatchUpdateOrdersResponse& a, MsgBatchUpdateOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchUpdateOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchUpdateOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchUpdateOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchUpdateOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchUpdateOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchUpdateOrdersResponse& from) {
    MsgBatchUpdateOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchUpdateOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse";
  }
  protected:
  explicit MsgBatchUpdateOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpotCancelSuccessFieldNumber = 1,
    kDerivativeCancelSuccessFieldNumber = 2,
    kSpotOrderHashesFieldNumber = 3,
    kDerivativeOrderHashesFieldNumber = 4,
    kBinaryOptionsCancelSuccessFieldNumber = 5,
    kBinaryOptionsOrderHashesFieldNumber = 6,
  };
  // repeated bool spot_cancel_success = 1 [json_name = "spotCancelSuccess"];
  int spot_cancel_success_size() const;
  private:
  int _internal_spot_cancel_success_size() const;

  public:
  void clear_spot_cancel_success() ;
  bool spot_cancel_success(int index) const;
  void set_spot_cancel_success(int index, bool value);
  void add_spot_cancel_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& spot_cancel_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* mutable_spot_cancel_success();

  private:
  bool _internal_spot_cancel_success(int index) const;
  void _internal_add_spot_cancel_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& _internal_spot_cancel_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* _internal_mutable_spot_cancel_success();

  public:
  // repeated bool derivative_cancel_success = 2 [json_name = "derivativeCancelSuccess"];
  int derivative_cancel_success_size() const;
  private:
  int _internal_derivative_cancel_success_size() const;

  public:
  void clear_derivative_cancel_success() ;
  bool derivative_cancel_success(int index) const;
  void set_derivative_cancel_success(int index, bool value);
  void add_derivative_cancel_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& derivative_cancel_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* mutable_derivative_cancel_success();

  private:
  bool _internal_derivative_cancel_success(int index) const;
  void _internal_add_derivative_cancel_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& _internal_derivative_cancel_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* _internal_mutable_derivative_cancel_success();

  public:
  // repeated string spot_order_hashes = 3 [json_name = "spotOrderHashes"];
  int spot_order_hashes_size() const;
  private:
  int _internal_spot_order_hashes_size() const;

  public:
  void clear_spot_order_hashes() ;
  const std::string& spot_order_hashes(int index) const;
  std::string* mutable_spot_order_hashes(int index);
  void set_spot_order_hashes(int index, const std::string& value);
  void set_spot_order_hashes(int index, std::string&& value);
  void set_spot_order_hashes(int index, const char* value);
  void set_spot_order_hashes(int index, const char* value, std::size_t size);
  void set_spot_order_hashes(int index, absl::string_view value);
  std::string* add_spot_order_hashes();
  void add_spot_order_hashes(const std::string& value);
  void add_spot_order_hashes(std::string&& value);
  void add_spot_order_hashes(const char* value);
  void add_spot_order_hashes(const char* value, std::size_t size);
  void add_spot_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& spot_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_spot_order_hashes();

  private:
  const std::string& _internal_spot_order_hashes(int index) const;
  std::string* _internal_add_spot_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_spot_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_spot_order_hashes();

  public:
  // repeated string derivative_order_hashes = 4 [json_name = "derivativeOrderHashes"];
  int derivative_order_hashes_size() const;
  private:
  int _internal_derivative_order_hashes_size() const;

  public:
  void clear_derivative_order_hashes() ;
  const std::string& derivative_order_hashes(int index) const;
  std::string* mutable_derivative_order_hashes(int index);
  void set_derivative_order_hashes(int index, const std::string& value);
  void set_derivative_order_hashes(int index, std::string&& value);
  void set_derivative_order_hashes(int index, const char* value);
  void set_derivative_order_hashes(int index, const char* value, std::size_t size);
  void set_derivative_order_hashes(int index, absl::string_view value);
  std::string* add_derivative_order_hashes();
  void add_derivative_order_hashes(const std::string& value);
  void add_derivative_order_hashes(std::string&& value);
  void add_derivative_order_hashes(const char* value);
  void add_derivative_order_hashes(const char* value, std::size_t size);
  void add_derivative_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& derivative_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_derivative_order_hashes();

  private:
  const std::string& _internal_derivative_order_hashes(int index) const;
  std::string* _internal_add_derivative_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_derivative_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_derivative_order_hashes();

  public:
  // repeated bool binary_options_cancel_success = 5 [json_name = "binaryOptionsCancelSuccess"];
  int binary_options_cancel_success_size() const;
  private:
  int _internal_binary_options_cancel_success_size() const;

  public:
  void clear_binary_options_cancel_success() ;
  bool binary_options_cancel_success(int index) const;
  void set_binary_options_cancel_success(int index, bool value);
  void add_binary_options_cancel_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& binary_options_cancel_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* mutable_binary_options_cancel_success();

  private:
  bool _internal_binary_options_cancel_success(int index) const;
  void _internal_add_binary_options_cancel_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& _internal_binary_options_cancel_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* _internal_mutable_binary_options_cancel_success();

  public:
  // repeated string binary_options_order_hashes = 6 [json_name = "binaryOptionsOrderHashes"];
  int binary_options_order_hashes_size() const;
  private:
  int _internal_binary_options_order_hashes_size() const;

  public:
  void clear_binary_options_order_hashes() ;
  const std::string& binary_options_order_hashes(int index) const;
  std::string* mutable_binary_options_order_hashes(int index);
  void set_binary_options_order_hashes(int index, const std::string& value);
  void set_binary_options_order_hashes(int index, std::string&& value);
  void set_binary_options_order_hashes(int index, const char* value);
  void set_binary_options_order_hashes(int index, const char* value, std::size_t size);
  void set_binary_options_order_hashes(int index, absl::string_view value);
  std::string* add_binary_options_order_hashes();
  void add_binary_options_order_hashes(const std::string& value);
  void add_binary_options_order_hashes(std::string&& value);
  void add_binary_options_order_hashes(const char* value);
  void add_binary_options_order_hashes(const char* value, std::size_t size);
  void add_binary_options_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& binary_options_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_binary_options_order_hashes();

  private:
  const std::string& _internal_binary_options_order_hashes(int index) const;
  std::string* _internal_add_binary_options_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_binary_options_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_binary_options_order_hashes();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool> spot_cancel_success_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool> derivative_cancel_success_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> spot_order_hashes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> derivative_order_hashes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool> binary_options_cancel_success_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> binary_options_order_hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateDerivativeMarketOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder) */ {
 public:
  inline MsgCreateDerivativeMarketOrder() : MsgCreateDerivativeMarketOrder(nullptr) {}
  ~MsgCreateDerivativeMarketOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateDerivativeMarketOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateDerivativeMarketOrder(const MsgCreateDerivativeMarketOrder& from);
  MsgCreateDerivativeMarketOrder(MsgCreateDerivativeMarketOrder&& from) noexcept
    : MsgCreateDerivativeMarketOrder() {
    *this = ::std::move(from);
  }

  inline MsgCreateDerivativeMarketOrder& operator=(const MsgCreateDerivativeMarketOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateDerivativeMarketOrder& operator=(MsgCreateDerivativeMarketOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateDerivativeMarketOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateDerivativeMarketOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCreateDerivativeMarketOrder*>(
               &_MsgCreateDerivativeMarketOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(MsgCreateDerivativeMarketOrder& a, MsgCreateDerivativeMarketOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateDerivativeMarketOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateDerivativeMarketOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateDerivativeMarketOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateDerivativeMarketOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateDerivativeMarketOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateDerivativeMarketOrder& from) {
    MsgCreateDerivativeMarketOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateDerivativeMarketOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder";
  }
  protected:
  explicit MsgCreateDerivativeMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::DerivativeOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeOrder* release_order();
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order);
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_order() const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::DerivativeOrder* order);
  ::injective::exchange::v1beta1::DerivativeOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::exchange::v1beta1::DerivativeOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateDerivativeMarketOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse) */ {
 public:
  inline MsgCreateDerivativeMarketOrderResponse() : MsgCreateDerivativeMarketOrderResponse(nullptr) {}
  ~MsgCreateDerivativeMarketOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateDerivativeMarketOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateDerivativeMarketOrderResponse(const MsgCreateDerivativeMarketOrderResponse& from);
  MsgCreateDerivativeMarketOrderResponse(MsgCreateDerivativeMarketOrderResponse&& from) noexcept
    : MsgCreateDerivativeMarketOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateDerivativeMarketOrderResponse& operator=(const MsgCreateDerivativeMarketOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateDerivativeMarketOrderResponse& operator=(MsgCreateDerivativeMarketOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateDerivativeMarketOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateDerivativeMarketOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateDerivativeMarketOrderResponse*>(
               &_MsgCreateDerivativeMarketOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MsgCreateDerivativeMarketOrderResponse& a, MsgCreateDerivativeMarketOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateDerivativeMarketOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateDerivativeMarketOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateDerivativeMarketOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateDerivativeMarketOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateDerivativeMarketOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateDerivativeMarketOrderResponse& from) {
    MsgCreateDerivativeMarketOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateDerivativeMarketOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse";
  }
  protected:
  explicit MsgCreateDerivativeMarketOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // .injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2 [json_name = "results", (.gogoproto.nullable) = true];
  bool has_results() const;
  void clear_results() ;
  const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& results() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarketOrderResults* release_results();
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* mutable_results();
  void set_allocated_results(::injective::exchange::v1beta1::DerivativeMarketOrderResults* results);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& _internal_results() const;
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* _internal_mutable_results();
  public:
  void unsafe_arena_set_allocated_results(
      ::injective::exchange::v1beta1::DerivativeMarketOrderResults* results);
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* unsafe_arena_release_results();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::injective::exchange::v1beta1::DerivativeMarketOrderResults* results_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class DerivativeMarketOrderResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeMarketOrderResults) */ {
 public:
  inline DerivativeMarketOrderResults() : DerivativeMarketOrderResults(nullptr) {}
  ~DerivativeMarketOrderResults() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeMarketOrderResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeMarketOrderResults(const DerivativeMarketOrderResults& from);
  DerivativeMarketOrderResults(DerivativeMarketOrderResults&& from) noexcept
    : DerivativeMarketOrderResults() {
    *this = ::std::move(from);
  }

  inline DerivativeMarketOrderResults& operator=(const DerivativeMarketOrderResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeMarketOrderResults& operator=(DerivativeMarketOrderResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeMarketOrderResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeMarketOrderResults* internal_default_instance() {
    return reinterpret_cast<const DerivativeMarketOrderResults*>(
               &_DerivativeMarketOrderResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DerivativeMarketOrderResults& a, DerivativeMarketOrderResults& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeMarketOrderResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeMarketOrderResults* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeMarketOrderResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeMarketOrderResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeMarketOrderResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeMarketOrderResults& from) {
    DerivativeMarketOrderResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeMarketOrderResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeMarketOrderResults";
  }
  protected:
  explicit DerivativeMarketOrderResults(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantityFieldNumber = 1,
    kPriceFieldNumber = 2,
    kFeeFieldNumber = 3,
    kPayoutFieldNumber = 5,
    kPositionDeltaFieldNumber = 4,
  };
  // string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string fee = 3 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fee() ;
  const std::string& fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee(Arg_&& arg, Args_... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* ptr);

  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(
      const std::string& value);
  std::string* _internal_mutable_fee();

  public:
  // string payout = 5 [json_name = "payout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_payout() ;
  const std::string& payout() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payout(Arg_&& arg, Args_... args);
  std::string* mutable_payout();
  PROTOBUF_NODISCARD std::string* release_payout();
  void set_allocated_payout(std::string* ptr);

  private:
  const std::string& _internal_payout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payout(
      const std::string& value);
  std::string* _internal_mutable_payout();

  public:
  // .injective.exchange.v1beta1.PositionDelta position_delta = 4 [json_name = "positionDelta", (.gogoproto.nullable) = false];
  bool has_position_delta() const;
  void clear_position_delta() ;
  const ::injective::exchange::v1beta1::PositionDelta& position_delta() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PositionDelta* release_position_delta();
  ::injective::exchange::v1beta1::PositionDelta* mutable_position_delta();
  void set_allocated_position_delta(::injective::exchange::v1beta1::PositionDelta* position_delta);
  private:
  const ::injective::exchange::v1beta1::PositionDelta& _internal_position_delta() const;
  ::injective::exchange::v1beta1::PositionDelta* _internal_mutable_position_delta();
  public:
  void unsafe_arena_set_allocated_position_delta(
      ::injective::exchange::v1beta1::PositionDelta* position_delta);
  ::injective::exchange::v1beta1::PositionDelta* unsafe_arena_release_position_delta();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeMarketOrderResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payout_;
    ::injective::exchange::v1beta1::PositionDelta* position_delta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateBinaryOptionsMarketOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder) */ {
 public:
  inline MsgCreateBinaryOptionsMarketOrder() : MsgCreateBinaryOptionsMarketOrder(nullptr) {}
  ~MsgCreateBinaryOptionsMarketOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateBinaryOptionsMarketOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateBinaryOptionsMarketOrder(const MsgCreateBinaryOptionsMarketOrder& from);
  MsgCreateBinaryOptionsMarketOrder(MsgCreateBinaryOptionsMarketOrder&& from) noexcept
    : MsgCreateBinaryOptionsMarketOrder() {
    *this = ::std::move(from);
  }

  inline MsgCreateBinaryOptionsMarketOrder& operator=(const MsgCreateBinaryOptionsMarketOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateBinaryOptionsMarketOrder& operator=(MsgCreateBinaryOptionsMarketOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateBinaryOptionsMarketOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateBinaryOptionsMarketOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCreateBinaryOptionsMarketOrder*>(
               &_MsgCreateBinaryOptionsMarketOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(MsgCreateBinaryOptionsMarketOrder& a, MsgCreateBinaryOptionsMarketOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateBinaryOptionsMarketOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateBinaryOptionsMarketOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateBinaryOptionsMarketOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateBinaryOptionsMarketOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateBinaryOptionsMarketOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateBinaryOptionsMarketOrder& from) {
    MsgCreateBinaryOptionsMarketOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateBinaryOptionsMarketOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder";
  }
  protected:
  explicit MsgCreateBinaryOptionsMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::DerivativeOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeOrder* release_order();
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order);
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_order() const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::DerivativeOrder* order);
  ::injective::exchange::v1beta1::DerivativeOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::injective::exchange::v1beta1::DerivativeOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCreateBinaryOptionsMarketOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse) */ {
 public:
  inline MsgCreateBinaryOptionsMarketOrderResponse() : MsgCreateBinaryOptionsMarketOrderResponse(nullptr) {}
  ~MsgCreateBinaryOptionsMarketOrderResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCreateBinaryOptionsMarketOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCreateBinaryOptionsMarketOrderResponse(const MsgCreateBinaryOptionsMarketOrderResponse& from);
  MsgCreateBinaryOptionsMarketOrderResponse(MsgCreateBinaryOptionsMarketOrderResponse&& from) noexcept
    : MsgCreateBinaryOptionsMarketOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCreateBinaryOptionsMarketOrderResponse& operator=(const MsgCreateBinaryOptionsMarketOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCreateBinaryOptionsMarketOrderResponse& operator=(MsgCreateBinaryOptionsMarketOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCreateBinaryOptionsMarketOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCreateBinaryOptionsMarketOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCreateBinaryOptionsMarketOrderResponse*>(
               &_MsgCreateBinaryOptionsMarketOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(MsgCreateBinaryOptionsMarketOrderResponse& a, MsgCreateBinaryOptionsMarketOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCreateBinaryOptionsMarketOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCreateBinaryOptionsMarketOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCreateBinaryOptionsMarketOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCreateBinaryOptionsMarketOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCreateBinaryOptionsMarketOrderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCreateBinaryOptionsMarketOrderResponse& from) {
    MsgCreateBinaryOptionsMarketOrderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCreateBinaryOptionsMarketOrderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse";
  }
  protected:
  explicit MsgCreateBinaryOptionsMarketOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // .injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2 [json_name = "results", (.gogoproto.nullable) = true];
  bool has_results() const;
  void clear_results() ;
  const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& results() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarketOrderResults* release_results();
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* mutable_results();
  void set_allocated_results(::injective::exchange::v1beta1::DerivativeMarketOrderResults* results);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& _internal_results() const;
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* _internal_mutable_results();
  public:
  void unsafe_arena_set_allocated_results(
      ::injective::exchange::v1beta1::DerivativeMarketOrderResults* results);
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* unsafe_arena_release_results();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::injective::exchange::v1beta1::DerivativeMarketOrderResults* results_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCancelDerivativeOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCancelDerivativeOrder) */ {
 public:
  inline MsgCancelDerivativeOrder() : MsgCancelDerivativeOrder(nullptr) {}
  ~MsgCancelDerivativeOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCancelDerivativeOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCancelDerivativeOrder(const MsgCancelDerivativeOrder& from);
  MsgCancelDerivativeOrder(MsgCancelDerivativeOrder&& from) noexcept
    : MsgCancelDerivativeOrder() {
    *this = ::std::move(from);
  }

  inline MsgCancelDerivativeOrder& operator=(const MsgCancelDerivativeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCancelDerivativeOrder& operator=(MsgCancelDerivativeOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCancelDerivativeOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCancelDerivativeOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCancelDerivativeOrder*>(
               &_MsgCancelDerivativeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MsgCancelDerivativeOrder& a, MsgCancelDerivativeOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCancelDerivativeOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCancelDerivativeOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCancelDerivativeOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCancelDerivativeOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCancelDerivativeOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCancelDerivativeOrder& from) {
    MsgCancelDerivativeOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCancelDerivativeOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCancelDerivativeOrder";
  }
  protected:
  explicit MsgCancelDerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kOrderHashFieldNumber = 4,
    kOrderMaskFieldNumber = 5,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string order_hash = 4 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // int32 order_mask = 5 [json_name = "orderMask"];
  void clear_order_mask() ;
  ::int32_t order_mask() const;
  void set_order_mask(::int32_t value);

  private:
  ::int32_t _internal_order_mask() const;
  void _internal_set_order_mask(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCancelDerivativeOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::int32_t order_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCancelDerivativeOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse) */ {
 public:
  inline MsgCancelDerivativeOrderResponse() : MsgCancelDerivativeOrderResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCancelDerivativeOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCancelDerivativeOrderResponse(const MsgCancelDerivativeOrderResponse& from);
  MsgCancelDerivativeOrderResponse(MsgCancelDerivativeOrderResponse&& from) noexcept
    : MsgCancelDerivativeOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCancelDerivativeOrderResponse& operator=(const MsgCancelDerivativeOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCancelDerivativeOrderResponse& operator=(MsgCancelDerivativeOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCancelDerivativeOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCancelDerivativeOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCancelDerivativeOrderResponse*>(
               &_MsgCancelDerivativeOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MsgCancelDerivativeOrderResponse& a, MsgCancelDerivativeOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCancelDerivativeOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCancelDerivativeOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCancelDerivativeOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCancelDerivativeOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgCancelDerivativeOrderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgCancelDerivativeOrderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse";
  }
  protected:
  explicit MsgCancelDerivativeOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCancelBinaryOptionsOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder) */ {
 public:
  inline MsgCancelBinaryOptionsOrder() : MsgCancelBinaryOptionsOrder(nullptr) {}
  ~MsgCancelBinaryOptionsOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCancelBinaryOptionsOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCancelBinaryOptionsOrder(const MsgCancelBinaryOptionsOrder& from);
  MsgCancelBinaryOptionsOrder(MsgCancelBinaryOptionsOrder&& from) noexcept
    : MsgCancelBinaryOptionsOrder() {
    *this = ::std::move(from);
  }

  inline MsgCancelBinaryOptionsOrder& operator=(const MsgCancelBinaryOptionsOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCancelBinaryOptionsOrder& operator=(MsgCancelBinaryOptionsOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCancelBinaryOptionsOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCancelBinaryOptionsOrder* internal_default_instance() {
    return reinterpret_cast<const MsgCancelBinaryOptionsOrder*>(
               &_MsgCancelBinaryOptionsOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(MsgCancelBinaryOptionsOrder& a, MsgCancelBinaryOptionsOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCancelBinaryOptionsOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCancelBinaryOptionsOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCancelBinaryOptionsOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCancelBinaryOptionsOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCancelBinaryOptionsOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgCancelBinaryOptionsOrder& from) {
    MsgCancelBinaryOptionsOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCancelBinaryOptionsOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder";
  }
  protected:
  explicit MsgCancelBinaryOptionsOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kOrderHashFieldNumber = 4,
    kOrderMaskFieldNumber = 5,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string order_hash = 4 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // int32 order_mask = 5 [json_name = "orderMask"];
  void clear_order_mask() ;
  ::int32_t order_mask() const;
  void set_order_mask(::int32_t value);

  private:
  ::int32_t _internal_order_mask() const;
  void _internal_set_order_mask(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::int32_t order_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgCancelBinaryOptionsOrderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse) */ {
 public:
  inline MsgCancelBinaryOptionsOrderResponse() : MsgCancelBinaryOptionsOrderResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgCancelBinaryOptionsOrderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCancelBinaryOptionsOrderResponse(const MsgCancelBinaryOptionsOrderResponse& from);
  MsgCancelBinaryOptionsOrderResponse(MsgCancelBinaryOptionsOrderResponse&& from) noexcept
    : MsgCancelBinaryOptionsOrderResponse() {
    *this = ::std::move(from);
  }

  inline MsgCancelBinaryOptionsOrderResponse& operator=(const MsgCancelBinaryOptionsOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCancelBinaryOptionsOrderResponse& operator=(MsgCancelBinaryOptionsOrderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCancelBinaryOptionsOrderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCancelBinaryOptionsOrderResponse* internal_default_instance() {
    return reinterpret_cast<const MsgCancelBinaryOptionsOrderResponse*>(
               &_MsgCancelBinaryOptionsOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MsgCancelBinaryOptionsOrderResponse& a, MsgCancelBinaryOptionsOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCancelBinaryOptionsOrderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCancelBinaryOptionsOrderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCancelBinaryOptionsOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCancelBinaryOptionsOrderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgCancelBinaryOptionsOrderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgCancelBinaryOptionsOrderResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse";
  }
  protected:
  explicit MsgCancelBinaryOptionsOrderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class OrderData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.OrderData) */ {
 public:
  inline OrderData() : OrderData(nullptr) {}
  ~OrderData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderData(const OrderData& from);
  OrderData(OrderData&& from) noexcept
    : OrderData() {
    *this = ::std::move(from);
  }

  inline OrderData& operator=(const OrderData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderData& operator=(OrderData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderData& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderData* internal_default_instance() {
    return reinterpret_cast<const OrderData*>(
               &_OrderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(OrderData& a, OrderData& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderData& from) {
    OrderData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.OrderData";
  }
  protected:
  explicit OrderData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kOrderHashFieldNumber = 3,
    kOrderMaskFieldNumber = 4,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string order_hash = 3 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // int32 order_mask = 4 [json_name = "orderMask"];
  void clear_order_mask() ;
  ::int32_t order_mask() const;
  void set_order_mask(::int32_t value);

  private:
  ::int32_t _internal_order_mask() const;
  void _internal_set_order_mask(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.OrderData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::int32_t order_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCancelDerivativeOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders) */ {
 public:
  inline MsgBatchCancelDerivativeOrders() : MsgBatchCancelDerivativeOrders(nullptr) {}
  ~MsgBatchCancelDerivativeOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCancelDerivativeOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCancelDerivativeOrders(const MsgBatchCancelDerivativeOrders& from);
  MsgBatchCancelDerivativeOrders(MsgBatchCancelDerivativeOrders&& from) noexcept
    : MsgBatchCancelDerivativeOrders() {
    *this = ::std::move(from);
  }

  inline MsgBatchCancelDerivativeOrders& operator=(const MsgBatchCancelDerivativeOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCancelDerivativeOrders& operator=(MsgBatchCancelDerivativeOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCancelDerivativeOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCancelDerivativeOrders* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCancelDerivativeOrders*>(
               &_MsgBatchCancelDerivativeOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MsgBatchCancelDerivativeOrders& a, MsgBatchCancelDerivativeOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCancelDerivativeOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCancelDerivativeOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCancelDerivativeOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCancelDerivativeOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCancelDerivativeOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCancelDerivativeOrders& from) {
    MsgBatchCancelDerivativeOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCancelDerivativeOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders";
  }
  protected:
  explicit MsgBatchCancelDerivativeOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kSenderFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.OrderData data = 2 [json_name = "data", (.gogoproto.nullable) = false];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective::exchange::v1beta1::OrderData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
      mutable_data();
  private:
  const ::injective::exchange::v1beta1::OrderData& _internal_data(int index) const;
  ::injective::exchange::v1beta1::OrderData* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>* _internal_mutable_data();
  public:
  const ::injective::exchange::v1beta1::OrderData& data(int index) const;
  ::injective::exchange::v1beta1::OrderData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
      data() const;
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgBatchCancelDerivativeOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse) */ {
 public:
  inline MsgBatchCancelDerivativeOrdersResponse() : MsgBatchCancelDerivativeOrdersResponse(nullptr) {}
  ~MsgBatchCancelDerivativeOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgBatchCancelDerivativeOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgBatchCancelDerivativeOrdersResponse(const MsgBatchCancelDerivativeOrdersResponse& from);
  MsgBatchCancelDerivativeOrdersResponse(MsgBatchCancelDerivativeOrdersResponse&& from) noexcept
    : MsgBatchCancelDerivativeOrdersResponse() {
    *this = ::std::move(from);
  }

  inline MsgBatchCancelDerivativeOrdersResponse& operator=(const MsgBatchCancelDerivativeOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgBatchCancelDerivativeOrdersResponse& operator=(MsgBatchCancelDerivativeOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgBatchCancelDerivativeOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgBatchCancelDerivativeOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const MsgBatchCancelDerivativeOrdersResponse*>(
               &_MsgBatchCancelDerivativeOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MsgBatchCancelDerivativeOrdersResponse& a, MsgBatchCancelDerivativeOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgBatchCancelDerivativeOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgBatchCancelDerivativeOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgBatchCancelDerivativeOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgBatchCancelDerivativeOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgBatchCancelDerivativeOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgBatchCancelDerivativeOrdersResponse& from) {
    MsgBatchCancelDerivativeOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgBatchCancelDerivativeOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse";
  }
  protected:
  explicit MsgBatchCancelDerivativeOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // repeated bool success = 1 [json_name = "success"];
  int success_size() const;
  private:
  int _internal_success_size() const;

  public:
  void clear_success() ;
  bool success(int index) const;
  void set_success(int index, bool value);
  void add_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* mutable_success();

  private:
  bool _internal_success(int index) const;
  void _internal_add_success(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& _internal_success() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* _internal_mutable_success();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool> success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSubaccountTransfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgSubaccountTransfer) */ {
 public:
  inline MsgSubaccountTransfer() : MsgSubaccountTransfer(nullptr) {}
  ~MsgSubaccountTransfer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSubaccountTransfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSubaccountTransfer(const MsgSubaccountTransfer& from);
  MsgSubaccountTransfer(MsgSubaccountTransfer&& from) noexcept
    : MsgSubaccountTransfer() {
    *this = ::std::move(from);
  }

  inline MsgSubaccountTransfer& operator=(const MsgSubaccountTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSubaccountTransfer& operator=(MsgSubaccountTransfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSubaccountTransfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSubaccountTransfer* internal_default_instance() {
    return reinterpret_cast<const MsgSubaccountTransfer*>(
               &_MsgSubaccountTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(MsgSubaccountTransfer& a, MsgSubaccountTransfer& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSubaccountTransfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSubaccountTransfer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSubaccountTransfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSubaccountTransfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgSubaccountTransfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgSubaccountTransfer& from) {
    MsgSubaccountTransfer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgSubaccountTransfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgSubaccountTransfer";
  }
  protected:
  explicit MsgSubaccountTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kSourceSubaccountIdFieldNumber = 2,
    kDestinationSubaccountIdFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string source_subaccount_id = 2 [json_name = "sourceSubaccountId"];
  void clear_source_subaccount_id() ;
  const std::string& source_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_source_subaccount_id();
  void set_allocated_source_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_source_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_source_subaccount_id();

  public:
  // string destination_subaccount_id = 3 [json_name = "destinationSubaccountId"];
  void clear_destination_subaccount_id() ;
  const std::string& destination_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_destination_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_destination_subaccount_id();
  void set_allocated_destination_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_destination_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_destination_subaccount_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 4 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgSubaccountTransfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_subaccount_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSubaccountTransferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgSubaccountTransferResponse) */ {
 public:
  inline MsgSubaccountTransferResponse() : MsgSubaccountTransferResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSubaccountTransferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSubaccountTransferResponse(const MsgSubaccountTransferResponse& from);
  MsgSubaccountTransferResponse(MsgSubaccountTransferResponse&& from) noexcept
    : MsgSubaccountTransferResponse() {
    *this = ::std::move(from);
  }

  inline MsgSubaccountTransferResponse& operator=(const MsgSubaccountTransferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSubaccountTransferResponse& operator=(MsgSubaccountTransferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSubaccountTransferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSubaccountTransferResponse* internal_default_instance() {
    return reinterpret_cast<const MsgSubaccountTransferResponse*>(
               &_MsgSubaccountTransferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(MsgSubaccountTransferResponse& a, MsgSubaccountTransferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSubaccountTransferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSubaccountTransferResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSubaccountTransferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSubaccountTransferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgSubaccountTransferResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgSubaccountTransferResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgSubaccountTransferResponse";
  }
  protected:
  explicit MsgSubaccountTransferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgSubaccountTransferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgExternalTransfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgExternalTransfer) */ {
 public:
  inline MsgExternalTransfer() : MsgExternalTransfer(nullptr) {}
  ~MsgExternalTransfer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgExternalTransfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgExternalTransfer(const MsgExternalTransfer& from);
  MsgExternalTransfer(MsgExternalTransfer&& from) noexcept
    : MsgExternalTransfer() {
    *this = ::std::move(from);
  }

  inline MsgExternalTransfer& operator=(const MsgExternalTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgExternalTransfer& operator=(MsgExternalTransfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgExternalTransfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgExternalTransfer* internal_default_instance() {
    return reinterpret_cast<const MsgExternalTransfer*>(
               &_MsgExternalTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(MsgExternalTransfer& a, MsgExternalTransfer& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgExternalTransfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgExternalTransfer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgExternalTransfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgExternalTransfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgExternalTransfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgExternalTransfer& from) {
    MsgExternalTransfer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgExternalTransfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgExternalTransfer";
  }
  protected:
  explicit MsgExternalTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kSourceSubaccountIdFieldNumber = 2,
    kDestinationSubaccountIdFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string source_subaccount_id = 2 [json_name = "sourceSubaccountId"];
  void clear_source_subaccount_id() ;
  const std::string& source_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_source_subaccount_id();
  void set_allocated_source_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_source_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_source_subaccount_id();

  public:
  // string destination_subaccount_id = 3 [json_name = "destinationSubaccountId"];
  void clear_destination_subaccount_id() ;
  const std::string& destination_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_destination_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_destination_subaccount_id();
  void set_allocated_destination_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_destination_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_destination_subaccount_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 4 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgExternalTransfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_subaccount_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgExternalTransferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgExternalTransferResponse) */ {
 public:
  inline MsgExternalTransferResponse() : MsgExternalTransferResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgExternalTransferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgExternalTransferResponse(const MsgExternalTransferResponse& from);
  MsgExternalTransferResponse(MsgExternalTransferResponse&& from) noexcept
    : MsgExternalTransferResponse() {
    *this = ::std::move(from);
  }

  inline MsgExternalTransferResponse& operator=(const MsgExternalTransferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgExternalTransferResponse& operator=(MsgExternalTransferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgExternalTransferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgExternalTransferResponse* internal_default_instance() {
    return reinterpret_cast<const MsgExternalTransferResponse*>(
               &_MsgExternalTransferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(MsgExternalTransferResponse& a, MsgExternalTransferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgExternalTransferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgExternalTransferResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgExternalTransferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgExternalTransferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgExternalTransferResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgExternalTransferResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgExternalTransferResponse";
  }
  protected:
  explicit MsgExternalTransferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgExternalTransferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgLiquidatePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgLiquidatePosition) */ {
 public:
  inline MsgLiquidatePosition() : MsgLiquidatePosition(nullptr) {}
  ~MsgLiquidatePosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgLiquidatePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgLiquidatePosition(const MsgLiquidatePosition& from);
  MsgLiquidatePosition(MsgLiquidatePosition&& from) noexcept
    : MsgLiquidatePosition() {
    *this = ::std::move(from);
  }

  inline MsgLiquidatePosition& operator=(const MsgLiquidatePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgLiquidatePosition& operator=(MsgLiquidatePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgLiquidatePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgLiquidatePosition* internal_default_instance() {
    return reinterpret_cast<const MsgLiquidatePosition*>(
               &_MsgLiquidatePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(MsgLiquidatePosition& a, MsgLiquidatePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgLiquidatePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgLiquidatePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgLiquidatePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgLiquidatePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgLiquidatePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgLiquidatePosition& from) {
    MsgLiquidatePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgLiquidatePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgLiquidatePosition";
  }
  protected:
  explicit MsgLiquidatePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kOrderFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective.exchange.v1beta1.DerivativeOrder order = 4 [json_name = "order", (.gogoproto.nullable) = true];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::DerivativeOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeOrder* release_order();
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order);
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_order() const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::DerivativeOrder* order);
  ::injective::exchange::v1beta1::DerivativeOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgLiquidatePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective::exchange::v1beta1::DerivativeOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgLiquidatePositionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgLiquidatePositionResponse) */ {
 public:
  inline MsgLiquidatePositionResponse() : MsgLiquidatePositionResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgLiquidatePositionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgLiquidatePositionResponse(const MsgLiquidatePositionResponse& from);
  MsgLiquidatePositionResponse(MsgLiquidatePositionResponse&& from) noexcept
    : MsgLiquidatePositionResponse() {
    *this = ::std::move(from);
  }

  inline MsgLiquidatePositionResponse& operator=(const MsgLiquidatePositionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgLiquidatePositionResponse& operator=(MsgLiquidatePositionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgLiquidatePositionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgLiquidatePositionResponse* internal_default_instance() {
    return reinterpret_cast<const MsgLiquidatePositionResponse*>(
               &_MsgLiquidatePositionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(MsgLiquidatePositionResponse& a, MsgLiquidatePositionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgLiquidatePositionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgLiquidatePositionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgLiquidatePositionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgLiquidatePositionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgLiquidatePositionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgLiquidatePositionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgLiquidatePositionResponse";
  }
  protected:
  explicit MsgLiquidatePositionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgLiquidatePositionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgIncreasePositionMargin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgIncreasePositionMargin) */ {
 public:
  inline MsgIncreasePositionMargin() : MsgIncreasePositionMargin(nullptr) {}
  ~MsgIncreasePositionMargin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgIncreasePositionMargin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgIncreasePositionMargin(const MsgIncreasePositionMargin& from);
  MsgIncreasePositionMargin(MsgIncreasePositionMargin&& from) noexcept
    : MsgIncreasePositionMargin() {
    *this = ::std::move(from);
  }

  inline MsgIncreasePositionMargin& operator=(const MsgIncreasePositionMargin& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgIncreasePositionMargin& operator=(MsgIncreasePositionMargin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgIncreasePositionMargin& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgIncreasePositionMargin* internal_default_instance() {
    return reinterpret_cast<const MsgIncreasePositionMargin*>(
               &_MsgIncreasePositionMargin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(MsgIncreasePositionMargin& a, MsgIncreasePositionMargin& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgIncreasePositionMargin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgIncreasePositionMargin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgIncreasePositionMargin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgIncreasePositionMargin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgIncreasePositionMargin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgIncreasePositionMargin& from) {
    MsgIncreasePositionMargin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgIncreasePositionMargin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgIncreasePositionMargin";
  }
  protected:
  explicit MsgIncreasePositionMargin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kSourceSubaccountIdFieldNumber = 2,
    kDestinationSubaccountIdFieldNumber = 3,
    kMarketIdFieldNumber = 4,
    kAmountFieldNumber = 5,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string source_subaccount_id = 2 [json_name = "sourceSubaccountId"];
  void clear_source_subaccount_id() ;
  const std::string& source_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_source_subaccount_id();
  void set_allocated_source_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_source_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_source_subaccount_id();

  public:
  // string destination_subaccount_id = 3 [json_name = "destinationSubaccountId"];
  void clear_destination_subaccount_id() ;
  const std::string& destination_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_destination_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_destination_subaccount_id();
  void set_allocated_destination_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_destination_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_destination_subaccount_id();

  public:
  // string market_id = 4 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string amount = 5 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgIncreasePositionMargin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgIncreasePositionMarginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgIncreasePositionMarginResponse) */ {
 public:
  inline MsgIncreasePositionMarginResponse() : MsgIncreasePositionMarginResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgIncreasePositionMarginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgIncreasePositionMarginResponse(const MsgIncreasePositionMarginResponse& from);
  MsgIncreasePositionMarginResponse(MsgIncreasePositionMarginResponse&& from) noexcept
    : MsgIncreasePositionMarginResponse() {
    *this = ::std::move(from);
  }

  inline MsgIncreasePositionMarginResponse& operator=(const MsgIncreasePositionMarginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgIncreasePositionMarginResponse& operator=(MsgIncreasePositionMarginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgIncreasePositionMarginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgIncreasePositionMarginResponse* internal_default_instance() {
    return reinterpret_cast<const MsgIncreasePositionMarginResponse*>(
               &_MsgIncreasePositionMarginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(MsgIncreasePositionMarginResponse& a, MsgIncreasePositionMarginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgIncreasePositionMarginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgIncreasePositionMarginResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgIncreasePositionMarginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgIncreasePositionMarginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgIncreasePositionMarginResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgIncreasePositionMarginResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgIncreasePositionMarginResponse";
  }
  protected:
  explicit MsgIncreasePositionMarginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgIncreasePositionMarginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgPrivilegedExecuteContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgPrivilegedExecuteContract) */ {
 public:
  inline MsgPrivilegedExecuteContract() : MsgPrivilegedExecuteContract(nullptr) {}
  ~MsgPrivilegedExecuteContract() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgPrivilegedExecuteContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPrivilegedExecuteContract(const MsgPrivilegedExecuteContract& from);
  MsgPrivilegedExecuteContract(MsgPrivilegedExecuteContract&& from) noexcept
    : MsgPrivilegedExecuteContract() {
    *this = ::std::move(from);
  }

  inline MsgPrivilegedExecuteContract& operator=(const MsgPrivilegedExecuteContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPrivilegedExecuteContract& operator=(MsgPrivilegedExecuteContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPrivilegedExecuteContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPrivilegedExecuteContract* internal_default_instance() {
    return reinterpret_cast<const MsgPrivilegedExecuteContract*>(
               &_MsgPrivilegedExecuteContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(MsgPrivilegedExecuteContract& a, MsgPrivilegedExecuteContract& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPrivilegedExecuteContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPrivilegedExecuteContract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPrivilegedExecuteContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPrivilegedExecuteContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgPrivilegedExecuteContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgPrivilegedExecuteContract& from) {
    MsgPrivilegedExecuteContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgPrivilegedExecuteContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgPrivilegedExecuteContract";
  }
  protected:
  explicit MsgPrivilegedExecuteContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kFundsFieldNumber = 2,
    kContractAddressFieldNumber = 3,
    kDataFieldNumber = 4,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string funds = 2 [json_name = "funds"];
  void clear_funds() ;
  const std::string& funds() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_funds(Arg_&& arg, Args_... args);
  std::string* mutable_funds();
  PROTOBUF_NODISCARD std::string* release_funds();
  void set_allocated_funds(std::string* ptr);

  private:
  const std::string& _internal_funds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funds(
      const std::string& value);
  std::string* _internal_mutable_funds();

  public:
  // string contract_address = 3 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // string data = 4 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgPrivilegedExecuteContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgPrivilegedExecuteContractResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse) */ {
 public:
  inline MsgPrivilegedExecuteContractResponse() : MsgPrivilegedExecuteContractResponse(nullptr) {}
  ~MsgPrivilegedExecuteContractResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgPrivilegedExecuteContractResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPrivilegedExecuteContractResponse(const MsgPrivilegedExecuteContractResponse& from);
  MsgPrivilegedExecuteContractResponse(MsgPrivilegedExecuteContractResponse&& from) noexcept
    : MsgPrivilegedExecuteContractResponse() {
    *this = ::std::move(from);
  }

  inline MsgPrivilegedExecuteContractResponse& operator=(const MsgPrivilegedExecuteContractResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPrivilegedExecuteContractResponse& operator=(MsgPrivilegedExecuteContractResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPrivilegedExecuteContractResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPrivilegedExecuteContractResponse* internal_default_instance() {
    return reinterpret_cast<const MsgPrivilegedExecuteContractResponse*>(
               &_MsgPrivilegedExecuteContractResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(MsgPrivilegedExecuteContractResponse& a, MsgPrivilegedExecuteContractResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPrivilegedExecuteContractResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPrivilegedExecuteContractResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPrivilegedExecuteContractResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPrivilegedExecuteContractResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgPrivilegedExecuteContractResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgPrivilegedExecuteContractResponse& from) {
    MsgPrivilegedExecuteContractResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgPrivilegedExecuteContractResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse";
  }
  protected:
  explicit MsgPrivilegedExecuteContractResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsDiffFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin funds_diff = 1 [json_name = "fundsDiff", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  int funds_diff_size() const;
  private:
  int _internal_funds_diff_size() const;

  public:
  void clear_funds_diff() ;
  ::cosmos::base::v1beta1::Coin* mutable_funds_diff(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_funds_diff();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_funds_diff(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_funds_diff();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_funds_diff() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_funds_diff();
  public:
  const ::cosmos::base::v1beta1::Coin& funds_diff(int index) const;
  ::cosmos::base::v1beta1::Coin* add_funds_diff();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      funds_diff() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > funds_diff_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class SpotMarketParamUpdateProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SpotMarketParamUpdateProposal) */ {
 public:
  inline SpotMarketParamUpdateProposal() : SpotMarketParamUpdateProposal(nullptr) {}
  ~SpotMarketParamUpdateProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotMarketParamUpdateProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotMarketParamUpdateProposal(const SpotMarketParamUpdateProposal& from);
  SpotMarketParamUpdateProposal(SpotMarketParamUpdateProposal&& from) noexcept
    : SpotMarketParamUpdateProposal() {
    *this = ::std::move(from);
  }

  inline SpotMarketParamUpdateProposal& operator=(const SpotMarketParamUpdateProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotMarketParamUpdateProposal& operator=(SpotMarketParamUpdateProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotMarketParamUpdateProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotMarketParamUpdateProposal* internal_default_instance() {
    return reinterpret_cast<const SpotMarketParamUpdateProposal*>(
               &_SpotMarketParamUpdateProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(SpotMarketParamUpdateProposal& a, SpotMarketParamUpdateProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotMarketParamUpdateProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotMarketParamUpdateProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotMarketParamUpdateProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotMarketParamUpdateProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotMarketParamUpdateProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotMarketParamUpdateProposal& from) {
    SpotMarketParamUpdateProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotMarketParamUpdateProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SpotMarketParamUpdateProposal";
  }
  protected:
  explicit SpotMarketParamUpdateProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kMakerFeeRateFieldNumber = 4,
    kTakerFeeRateFieldNumber = 5,
    kRelayerFeeShareRateFieldNumber = 6,
    kMinPriceTickSizeFieldNumber = 7,
    kMinQuantityTickSizeFieldNumber = 8,
    kStatusFieldNumber = 9,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_relayer_fee_share_rate() ;
  const std::string& relayer_fee_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer_fee_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_relayer_fee_share_rate();
  PROTOBUF_NODISCARD std::string* release_relayer_fee_share_rate();
  void set_allocated_relayer_fee_share_rate(std::string* ptr);

  private:
  const std::string& _internal_relayer_fee_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer_fee_share_rate(
      const std::string& value);
  std::string* _internal_mutable_relayer_fee_share_rate();

  public:
  // string min_price_tick_size = 7 [json_name = "minPriceTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 8 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective.exchange.v1beta1.MarketStatus status = 9 [json_name = "status"];
  void clear_status() ;
  ::injective::exchange::v1beta1::MarketStatus status() const;
  void set_status(::injective::exchange::v1beta1::MarketStatus value);

  private:
  ::injective::exchange::v1beta1::MarketStatus _internal_status() const;
  void _internal_set_status(::injective::exchange::v1beta1::MarketStatus value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SpotMarketParamUpdateProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_fee_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class ExchangeEnableProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.ExchangeEnableProposal) */ {
 public:
  inline ExchangeEnableProposal() : ExchangeEnableProposal(nullptr) {}
  ~ExchangeEnableProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeEnableProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeEnableProposal(const ExchangeEnableProposal& from);
  ExchangeEnableProposal(ExchangeEnableProposal&& from) noexcept
    : ExchangeEnableProposal() {
    *this = ::std::move(from);
  }

  inline ExchangeEnableProposal& operator=(const ExchangeEnableProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeEnableProposal& operator=(ExchangeEnableProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeEnableProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeEnableProposal* internal_default_instance() {
    return reinterpret_cast<const ExchangeEnableProposal*>(
               &_ExchangeEnableProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ExchangeEnableProposal& a, ExchangeEnableProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeEnableProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeEnableProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeEnableProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeEnableProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeEnableProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExchangeEnableProposal& from) {
    ExchangeEnableProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeEnableProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.ExchangeEnableProposal";
  }
  protected:
  explicit ExchangeEnableProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kExchangeTypeFieldNumber = 3,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .injective.exchange.v1beta1.ExchangeType exchangeType = 3 [json_name = "exchangeType"];
  void clear_exchangetype() ;
  ::injective::exchange::v1beta1::ExchangeType exchangetype() const;
  void set_exchangetype(::injective::exchange::v1beta1::ExchangeType value);

  private:
  ::injective::exchange::v1beta1::ExchangeType _internal_exchangetype() const;
  void _internal_set_exchangetype(::injective::exchange::v1beta1::ExchangeType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.ExchangeEnableProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int exchangetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class BatchExchangeModificationProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.BatchExchangeModificationProposal) */ {
 public:
  inline BatchExchangeModificationProposal() : BatchExchangeModificationProposal(nullptr) {}
  ~BatchExchangeModificationProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BatchExchangeModificationProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchExchangeModificationProposal(const BatchExchangeModificationProposal& from);
  BatchExchangeModificationProposal(BatchExchangeModificationProposal&& from) noexcept
    : BatchExchangeModificationProposal() {
    *this = ::std::move(from);
  }

  inline BatchExchangeModificationProposal& operator=(const BatchExchangeModificationProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchExchangeModificationProposal& operator=(BatchExchangeModificationProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchExchangeModificationProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchExchangeModificationProposal* internal_default_instance() {
    return reinterpret_cast<const BatchExchangeModificationProposal*>(
               &_BatchExchangeModificationProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(BatchExchangeModificationProposal& a, BatchExchangeModificationProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchExchangeModificationProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchExchangeModificationProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchExchangeModificationProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchExchangeModificationProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchExchangeModificationProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchExchangeModificationProposal& from) {
    BatchExchangeModificationProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchExchangeModificationProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.BatchExchangeModificationProposal";
  }
  protected:
  explicit BatchExchangeModificationProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpotMarketParamUpdateProposalsFieldNumber = 3,
    kDerivativeMarketParamUpdateProposalsFieldNumber = 4,
    kSpotMarketLaunchProposalsFieldNumber = 5,
    kPerpetualMarketLaunchProposalsFieldNumber = 6,
    kExpiryFuturesMarketLaunchProposalsFieldNumber = 7,
    kBinaryOptionsMarketLaunchProposalsFieldNumber = 9,
    kBinaryOptionsParamUpdateProposalsFieldNumber = 10,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTradingRewardCampaignUpdateProposalFieldNumber = 8,
    kDenomDecimalsUpdateProposalFieldNumber = 11,
  };
  // repeated .injective.exchange.v1beta1.SpotMarketParamUpdateProposal spot_market_param_update_proposals = 3 [json_name = "spotMarketParamUpdateProposals"];
  int spot_market_param_update_proposals_size() const;
  private:
  int _internal_spot_market_param_update_proposals_size() const;

  public:
  void clear_spot_market_param_update_proposals() ;
  ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* mutable_spot_market_param_update_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal >*
      mutable_spot_market_param_update_proposals();
  private:
  const ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal& _internal_spot_market_param_update_proposals(int index) const;
  ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* _internal_add_spot_market_param_update_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketParamUpdateProposal>& _internal_spot_market_param_update_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketParamUpdateProposal>* _internal_mutable_spot_market_param_update_proposals();
  public:
  const ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal& spot_market_param_update_proposals(int index) const;
  ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* add_spot_market_param_update_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal >&
      spot_market_param_update_proposals() const;
  // repeated .injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals = 4 [json_name = "derivativeMarketParamUpdateProposals"];
  int derivative_market_param_update_proposals_size() const;
  private:
  int _internal_derivative_market_param_update_proposals_size() const;

  public:
  void clear_derivative_market_param_update_proposals() ;
  ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* mutable_derivative_market_param_update_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal >*
      mutable_derivative_market_param_update_proposals();
  private:
  const ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal& _internal_derivative_market_param_update_proposals(int index) const;
  ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* _internal_add_derivative_market_param_update_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal>& _internal_derivative_market_param_update_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal>* _internal_mutable_derivative_market_param_update_proposals();
  public:
  const ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal& derivative_market_param_update_proposals(int index) const;
  ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* add_derivative_market_param_update_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal >&
      derivative_market_param_update_proposals() const;
  // repeated .injective.exchange.v1beta1.SpotMarketLaunchProposal spot_market_launch_proposals = 5 [json_name = "spotMarketLaunchProposals"];
  int spot_market_launch_proposals_size() const;
  private:
  int _internal_spot_market_launch_proposals_size() const;

  public:
  void clear_spot_market_launch_proposals() ;
  ::injective::exchange::v1beta1::SpotMarketLaunchProposal* mutable_spot_market_launch_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketLaunchProposal >*
      mutable_spot_market_launch_proposals();
  private:
  const ::injective::exchange::v1beta1::SpotMarketLaunchProposal& _internal_spot_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::SpotMarketLaunchProposal* _internal_add_spot_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketLaunchProposal>& _internal_spot_market_launch_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketLaunchProposal>* _internal_mutable_spot_market_launch_proposals();
  public:
  const ::injective::exchange::v1beta1::SpotMarketLaunchProposal& spot_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::SpotMarketLaunchProposal* add_spot_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketLaunchProposal >&
      spot_market_launch_proposals() const;
  // repeated .injective.exchange.v1beta1.PerpetualMarketLaunchProposal perpetual_market_launch_proposals = 6 [json_name = "perpetualMarketLaunchProposals"];
  int perpetual_market_launch_proposals_size() const;
  private:
  int _internal_perpetual_market_launch_proposals_size() const;

  public:
  void clear_perpetual_market_launch_proposals() ;
  ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* mutable_perpetual_market_launch_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal >*
      mutable_perpetual_market_launch_proposals();
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal& _internal_perpetual_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* _internal_add_perpetual_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PerpetualMarketLaunchProposal>& _internal_perpetual_market_launch_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PerpetualMarketLaunchProposal>* _internal_mutable_perpetual_market_launch_proposals();
  public:
  const ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal& perpetual_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* add_perpetual_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal >&
      perpetual_market_launch_proposals() const;
  // repeated .injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals = 7 [json_name = "expiryFuturesMarketLaunchProposals"];
  int expiry_futures_market_launch_proposals_size() const;
  private:
  int _internal_expiry_futures_market_launch_proposals_size() const;

  public:
  void clear_expiry_futures_market_launch_proposals() ;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* mutable_expiry_futures_market_launch_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal >*
      mutable_expiry_futures_market_launch_proposals();
  private:
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal& _internal_expiry_futures_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* _internal_add_expiry_futures_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal>& _internal_expiry_futures_market_launch_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal>* _internal_mutable_expiry_futures_market_launch_proposals();
  public:
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal& expiry_futures_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* add_expiry_futures_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal >&
      expiry_futures_market_launch_proposals() const;
  // repeated .injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals = 9 [json_name = "binaryOptionsMarketLaunchProposals"];
  int binary_options_market_launch_proposals_size() const;
  private:
  int _internal_binary_options_market_launch_proposals_size() const;

  public:
  void clear_binary_options_market_launch_proposals() ;
  ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* mutable_binary_options_market_launch_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal >*
      mutable_binary_options_market_launch_proposals();
  private:
  const ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal& _internal_binary_options_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* _internal_add_binary_options_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal>& _internal_binary_options_market_launch_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal>* _internal_mutable_binary_options_market_launch_proposals();
  public:
  const ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal& binary_options_market_launch_proposals(int index) const;
  ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* add_binary_options_market_launch_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal >&
      binary_options_market_launch_proposals() const;
  // repeated .injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals = 10 [json_name = "binaryOptionsParamUpdateProposals"];
  int binary_options_param_update_proposals_size() const;
  private:
  int _internal_binary_options_param_update_proposals_size() const;

  public:
  void clear_binary_options_param_update_proposals() ;
  ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* mutable_binary_options_param_update_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal >*
      mutable_binary_options_param_update_proposals();
  private:
  const ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal& _internal_binary_options_param_update_proposals(int index) const;
  ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* _internal_add_binary_options_param_update_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal>& _internal_binary_options_param_update_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal>* _internal_mutable_binary_options_param_update_proposals();
  public:
  const ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal& binary_options_param_update_proposals(int index) const;
  ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* add_binary_options_param_update_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal >&
      binary_options_param_update_proposals() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal = 8 [json_name = "tradingRewardCampaignUpdateProposal"];
  bool has_trading_reward_campaign_update_proposal() const;
  void clear_trading_reward_campaign_update_proposal() ;
  const ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal& trading_reward_campaign_update_proposal() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* release_trading_reward_campaign_update_proposal();
  ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* mutable_trading_reward_campaign_update_proposal();
  void set_allocated_trading_reward_campaign_update_proposal(::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* trading_reward_campaign_update_proposal);
  private:
  const ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal& _internal_trading_reward_campaign_update_proposal() const;
  ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* _internal_mutable_trading_reward_campaign_update_proposal();
  public:
  void unsafe_arena_set_allocated_trading_reward_campaign_update_proposal(
      ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* trading_reward_campaign_update_proposal);
  ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* unsafe_arena_release_trading_reward_campaign_update_proposal();
  // .injective.exchange.v1beta1.UpdateDenomDecimalsProposal denom_decimals_update_proposal = 11 [json_name = "denomDecimalsUpdateProposal"];
  bool has_denom_decimals_update_proposal() const;
  void clear_denom_decimals_update_proposal() ;
  const ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal& denom_decimals_update_proposal() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* release_denom_decimals_update_proposal();
  ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* mutable_denom_decimals_update_proposal();
  void set_allocated_denom_decimals_update_proposal(::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* denom_decimals_update_proposal);
  private:
  const ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal& _internal_denom_decimals_update_proposal() const;
  ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* _internal_mutable_denom_decimals_update_proposal();
  public:
  void unsafe_arena_set_allocated_denom_decimals_update_proposal(
      ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* denom_decimals_update_proposal);
  ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* unsafe_arena_release_denom_decimals_update_proposal();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.BatchExchangeModificationProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal > spot_market_param_update_proposals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal > derivative_market_param_update_proposals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketLaunchProposal > spot_market_launch_proposals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal > perpetual_market_launch_proposals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal > expiry_futures_market_launch_proposals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal > binary_options_market_launch_proposals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal > binary_options_param_update_proposals_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* trading_reward_campaign_update_proposal_;
    ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* denom_decimals_update_proposal_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class SpotMarketLaunchProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SpotMarketLaunchProposal) */ {
 public:
  inline SpotMarketLaunchProposal() : SpotMarketLaunchProposal(nullptr) {}
  ~SpotMarketLaunchProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpotMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpotMarketLaunchProposal(const SpotMarketLaunchProposal& from);
  SpotMarketLaunchProposal(SpotMarketLaunchProposal&& from) noexcept
    : SpotMarketLaunchProposal() {
    *this = ::std::move(from);
  }

  inline SpotMarketLaunchProposal& operator=(const SpotMarketLaunchProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotMarketLaunchProposal& operator=(SpotMarketLaunchProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpotMarketLaunchProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpotMarketLaunchProposal* internal_default_instance() {
    return reinterpret_cast<const SpotMarketLaunchProposal*>(
               &_SpotMarketLaunchProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(SpotMarketLaunchProposal& a, SpotMarketLaunchProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotMarketLaunchProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotMarketLaunchProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpotMarketLaunchProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpotMarketLaunchProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpotMarketLaunchProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpotMarketLaunchProposal& from) {
    SpotMarketLaunchProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotMarketLaunchProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SpotMarketLaunchProposal";
  }
  protected:
  explicit SpotMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTickerFieldNumber = 3,
    kBaseDenomFieldNumber = 4,
    kQuoteDenomFieldNumber = 5,
    kMinPriceTickSizeFieldNumber = 6,
    kMinQuantityTickSizeFieldNumber = 7,
    kMakerFeeRateFieldNumber = 8,
    kTakerFeeRateFieldNumber = 9,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string ticker = 3 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string base_denom = 4 [json_name = "baseDenom"];
  void clear_base_denom() ;
  const std::string& base_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_denom(Arg_&& arg, Args_... args);
  std::string* mutable_base_denom();
  PROTOBUF_NODISCARD std::string* release_base_denom();
  void set_allocated_base_denom(std::string* ptr);

  private:
  const std::string& _internal_base_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_denom(
      const std::string& value);
  std::string* _internal_mutable_base_denom();

  public:
  // string quote_denom = 5 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string min_price_tick_size = 6 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 7 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // string maker_fee_rate = 8 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 9 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SpotMarketLaunchProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class PerpetualMarketLaunchProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.PerpetualMarketLaunchProposal) */ {
 public:
  inline PerpetualMarketLaunchProposal() : PerpetualMarketLaunchProposal(nullptr) {}
  ~PerpetualMarketLaunchProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerpetualMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerpetualMarketLaunchProposal(const PerpetualMarketLaunchProposal& from);
  PerpetualMarketLaunchProposal(PerpetualMarketLaunchProposal&& from) noexcept
    : PerpetualMarketLaunchProposal() {
    *this = ::std::move(from);
  }

  inline PerpetualMarketLaunchProposal& operator=(const PerpetualMarketLaunchProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerpetualMarketLaunchProposal& operator=(PerpetualMarketLaunchProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerpetualMarketLaunchProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerpetualMarketLaunchProposal* internal_default_instance() {
    return reinterpret_cast<const PerpetualMarketLaunchProposal*>(
               &_PerpetualMarketLaunchProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(PerpetualMarketLaunchProposal& a, PerpetualMarketLaunchProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(PerpetualMarketLaunchProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerpetualMarketLaunchProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerpetualMarketLaunchProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerpetualMarketLaunchProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerpetualMarketLaunchProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerpetualMarketLaunchProposal& from) {
    PerpetualMarketLaunchProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerpetualMarketLaunchProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.PerpetualMarketLaunchProposal";
  }
  protected:
  explicit PerpetualMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTickerFieldNumber = 3,
    kQuoteDenomFieldNumber = 4,
    kOracleBaseFieldNumber = 5,
    kOracleQuoteFieldNumber = 6,
    kInitialMarginRatioFieldNumber = 9,
    kMaintenanceMarginRatioFieldNumber = 10,
    kMakerFeeRateFieldNumber = 11,
    kTakerFeeRateFieldNumber = 12,
    kMinPriceTickSizeFieldNumber = 13,
    kMinQuantityTickSizeFieldNumber = 14,
    kOracleScaleFactorFieldNumber = 7,
    kOracleTypeFieldNumber = 8,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string ticker = 3 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string quote_denom = 4 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string oracle_base = 5 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 6 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // string initial_margin_ratio = 9 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_initial_margin_ratio() ;
  const std::string& initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_initial_margin_ratio();
  void set_allocated_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_initial_margin_ratio();

  public:
  // string maintenance_margin_ratio = 10 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maintenance_margin_ratio() ;
  const std::string& maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_maintenance_margin_ratio();
  void set_allocated_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_maintenance_margin_ratio();

  public:
  // string maker_fee_rate = 11 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 12 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string min_price_tick_size = 13 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 14 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 8 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.PerpetualMarketLaunchProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::uint32_t oracle_scale_factor_;
    int oracle_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarketLaunchProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal) */ {
 public:
  inline BinaryOptionsMarketLaunchProposal() : BinaryOptionsMarketLaunchProposal(nullptr) {}
  ~BinaryOptionsMarketLaunchProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarketLaunchProposal(const BinaryOptionsMarketLaunchProposal& from);
  BinaryOptionsMarketLaunchProposal(BinaryOptionsMarketLaunchProposal&& from) noexcept
    : BinaryOptionsMarketLaunchProposal() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarketLaunchProposal& operator=(const BinaryOptionsMarketLaunchProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarketLaunchProposal& operator=(BinaryOptionsMarketLaunchProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarketLaunchProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarketLaunchProposal* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarketLaunchProposal*>(
               &_BinaryOptionsMarketLaunchProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(BinaryOptionsMarketLaunchProposal& a, BinaryOptionsMarketLaunchProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarketLaunchProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarketLaunchProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarketLaunchProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarketLaunchProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarketLaunchProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarketLaunchProposal& from) {
    BinaryOptionsMarketLaunchProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarketLaunchProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal";
  }
  protected:
  explicit BinaryOptionsMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTickerFieldNumber = 3,
    kOracleSymbolFieldNumber = 4,
    kOracleProviderFieldNumber = 5,
    kAdminFieldNumber = 10,
    kQuoteDenomFieldNumber = 11,
    kMakerFeeRateFieldNumber = 12,
    kTakerFeeRateFieldNumber = 13,
    kMinPriceTickSizeFieldNumber = 14,
    kMinQuantityTickSizeFieldNumber = 15,
    kOracleTypeFieldNumber = 6,
    kOracleScaleFactorFieldNumber = 7,
    kExpirationTimestampFieldNumber = 8,
    kSettlementTimestampFieldNumber = 9,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string ticker = 3 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string oracle_symbol = 4 [json_name = "oracleSymbol"];
  void clear_oracle_symbol() ;
  const std::string& oracle_symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_symbol();
  PROTOBUF_NODISCARD std::string* release_oracle_symbol();
  void set_allocated_oracle_symbol(std::string* ptr);

  private:
  const std::string& _internal_oracle_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_symbol(
      const std::string& value);
  std::string* _internal_mutable_oracle_symbol();

  public:
  // string oracle_provider = 5 [json_name = "oracleProvider"];
  void clear_oracle_provider() ;
  const std::string& oracle_provider() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_provider(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_provider();
  PROTOBUF_NODISCARD std::string* release_oracle_provider();
  void set_allocated_oracle_provider(std::string* ptr);

  private:
  const std::string& _internal_oracle_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_provider(
      const std::string& value);
  std::string* _internal_mutable_oracle_provider();

  public:
  // string admin = 10 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string quote_denom = 11 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string maker_fee_rate = 12 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 13 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string min_price_tick_size = 14 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 15 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 6 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // int64 expiration_timestamp = 8 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // int64 settlement_timestamp = 9 [json_name = "settlementTimestamp"];
  void clear_settlement_timestamp() ;
  ::int64_t settlement_timestamp() const;
  void set_settlement_timestamp(::int64_t value);

  private:
  ::int64_t _internal_settlement_timestamp() const;
  void _internal_set_settlement_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    int oracle_type_;
    ::uint32_t oracle_scale_factor_;
    ::int64_t expiration_timestamp_;
    ::int64_t settlement_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class ExpiryFuturesMarketLaunchProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal) */ {
 public:
  inline ExpiryFuturesMarketLaunchProposal() : ExpiryFuturesMarketLaunchProposal(nullptr) {}
  ~ExpiryFuturesMarketLaunchProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExpiryFuturesMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpiryFuturesMarketLaunchProposal(const ExpiryFuturesMarketLaunchProposal& from);
  ExpiryFuturesMarketLaunchProposal(ExpiryFuturesMarketLaunchProposal&& from) noexcept
    : ExpiryFuturesMarketLaunchProposal() {
    *this = ::std::move(from);
  }

  inline ExpiryFuturesMarketLaunchProposal& operator=(const ExpiryFuturesMarketLaunchProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpiryFuturesMarketLaunchProposal& operator=(ExpiryFuturesMarketLaunchProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpiryFuturesMarketLaunchProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpiryFuturesMarketLaunchProposal* internal_default_instance() {
    return reinterpret_cast<const ExpiryFuturesMarketLaunchProposal*>(
               &_ExpiryFuturesMarketLaunchProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ExpiryFuturesMarketLaunchProposal& a, ExpiryFuturesMarketLaunchProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpiryFuturesMarketLaunchProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpiryFuturesMarketLaunchProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpiryFuturesMarketLaunchProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpiryFuturesMarketLaunchProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpiryFuturesMarketLaunchProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpiryFuturesMarketLaunchProposal& from) {
    ExpiryFuturesMarketLaunchProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpiryFuturesMarketLaunchProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal";
  }
  protected:
  explicit ExpiryFuturesMarketLaunchProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTickerFieldNumber = 3,
    kQuoteDenomFieldNumber = 4,
    kOracleBaseFieldNumber = 5,
    kOracleQuoteFieldNumber = 6,
    kInitialMarginRatioFieldNumber = 10,
    kMaintenanceMarginRatioFieldNumber = 11,
    kMakerFeeRateFieldNumber = 12,
    kTakerFeeRateFieldNumber = 13,
    kMinPriceTickSizeFieldNumber = 14,
    kMinQuantityTickSizeFieldNumber = 15,
    kOracleScaleFactorFieldNumber = 7,
    kOracleTypeFieldNumber = 8,
    kExpiryFieldNumber = 9,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string ticker = 3 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string quote_denom = 4 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string oracle_base = 5 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 6 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // string initial_margin_ratio = 10 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_initial_margin_ratio() ;
  const std::string& initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_initial_margin_ratio();
  void set_allocated_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_initial_margin_ratio();

  public:
  // string maintenance_margin_ratio = 11 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maintenance_margin_ratio() ;
  const std::string& maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_maintenance_margin_ratio();
  void set_allocated_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_maintenance_margin_ratio();

  public:
  // string maker_fee_rate = 12 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 13 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string min_price_tick_size = 14 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 15 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 8 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // int64 expiry = 9 [json_name = "expiry"];
  void clear_expiry() ;
  ::int64_t expiry() const;
  void set_expiry(::int64_t value);

  private:
  ::int64_t _internal_expiry() const;
  void _internal_set_expiry(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::uint32_t oracle_scale_factor_;
    int oracle_type_;
    ::int64_t expiry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class DerivativeMarketParamUpdateProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal) */ {
 public:
  inline DerivativeMarketParamUpdateProposal() : DerivativeMarketParamUpdateProposal(nullptr) {}
  ~DerivativeMarketParamUpdateProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeMarketParamUpdateProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeMarketParamUpdateProposal(const DerivativeMarketParamUpdateProposal& from);
  DerivativeMarketParamUpdateProposal(DerivativeMarketParamUpdateProposal&& from) noexcept
    : DerivativeMarketParamUpdateProposal() {
    *this = ::std::move(from);
  }

  inline DerivativeMarketParamUpdateProposal& operator=(const DerivativeMarketParamUpdateProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeMarketParamUpdateProposal& operator=(DerivativeMarketParamUpdateProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeMarketParamUpdateProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeMarketParamUpdateProposal* internal_default_instance() {
    return reinterpret_cast<const DerivativeMarketParamUpdateProposal*>(
               &_DerivativeMarketParamUpdateProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(DerivativeMarketParamUpdateProposal& a, DerivativeMarketParamUpdateProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeMarketParamUpdateProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeMarketParamUpdateProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeMarketParamUpdateProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeMarketParamUpdateProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeMarketParamUpdateProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeMarketParamUpdateProposal& from) {
    DerivativeMarketParamUpdateProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeMarketParamUpdateProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal";
  }
  protected:
  explicit DerivativeMarketParamUpdateProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kInitialMarginRatioFieldNumber = 4,
    kMaintenanceMarginRatioFieldNumber = 5,
    kMakerFeeRateFieldNumber = 6,
    kTakerFeeRateFieldNumber = 7,
    kRelayerFeeShareRateFieldNumber = 8,
    kMinPriceTickSizeFieldNumber = 9,
    kMinQuantityTickSizeFieldNumber = 10,
    kHourlyInterestRateFieldNumber = 11,
    kHourlyFundingRateCapFieldNumber = 12,
    kOracleParamsFieldNumber = 14,
    kStatusFieldNumber = 13,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string initial_margin_ratio = 4 [json_name = "initialMarginRatio", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_initial_margin_ratio() ;
  const std::string& initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_initial_margin_ratio();
  void set_allocated_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_initial_margin_ratio();

  public:
  // string maintenance_margin_ratio = 5 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maintenance_margin_ratio() ;
  const std::string& maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_maintenance_margin_ratio();
  void set_allocated_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_maintenance_margin_ratio();

  public:
  // string maker_fee_rate = 6 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 7 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string relayer_fee_share_rate = 8 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_relayer_fee_share_rate() ;
  const std::string& relayer_fee_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer_fee_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_relayer_fee_share_rate();
  PROTOBUF_NODISCARD std::string* release_relayer_fee_share_rate();
  void set_allocated_relayer_fee_share_rate(std::string* ptr);

  private:
  const std::string& _internal_relayer_fee_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer_fee_share_rate(
      const std::string& value);
  std::string* _internal_mutable_relayer_fee_share_rate();

  public:
  // string min_price_tick_size = 9 [json_name = "minPriceTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 10 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // string HourlyInterestRate = 11 [json_name = "HourlyInterestRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_hourlyinterestrate() ;
  const std::string& hourlyinterestrate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hourlyinterestrate(Arg_&& arg, Args_... args);
  std::string* mutable_hourlyinterestrate();
  PROTOBUF_NODISCARD std::string* release_hourlyinterestrate();
  void set_allocated_hourlyinterestrate(std::string* ptr);

  private:
  const std::string& _internal_hourlyinterestrate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hourlyinterestrate(
      const std::string& value);
  std::string* _internal_mutable_hourlyinterestrate();

  public:
  // string HourlyFundingRateCap = 12 [json_name = "HourlyFundingRateCap", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_hourlyfundingratecap() ;
  const std::string& hourlyfundingratecap() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hourlyfundingratecap(Arg_&& arg, Args_... args);
  std::string* mutable_hourlyfundingratecap();
  PROTOBUF_NODISCARD std::string* release_hourlyfundingratecap();
  void set_allocated_hourlyfundingratecap(std::string* ptr);

  private:
  const std::string& _internal_hourlyfundingratecap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hourlyfundingratecap(
      const std::string& value);
  std::string* _internal_mutable_hourlyfundingratecap();

  public:
  // .injective.exchange.v1beta1.OracleParams oracle_params = 14 [json_name = "oracleParams"];
  bool has_oracle_params() const;
  void clear_oracle_params() ;
  const ::injective::exchange::v1beta1::OracleParams& oracle_params() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::OracleParams* release_oracle_params();
  ::injective::exchange::v1beta1::OracleParams* mutable_oracle_params();
  void set_allocated_oracle_params(::injective::exchange::v1beta1::OracleParams* oracle_params);
  private:
  const ::injective::exchange::v1beta1::OracleParams& _internal_oracle_params() const;
  ::injective::exchange::v1beta1::OracleParams* _internal_mutable_oracle_params();
  public:
  void unsafe_arena_set_allocated_oracle_params(
      ::injective::exchange::v1beta1::OracleParams* oracle_params);
  ::injective::exchange::v1beta1::OracleParams* unsafe_arena_release_oracle_params();
  // .injective.exchange.v1beta1.MarketStatus status = 13 [json_name = "status"];
  void clear_status() ;
  ::injective::exchange::v1beta1::MarketStatus status() const;
  void set_status(::injective::exchange::v1beta1::MarketStatus value);

  private:
  ::injective::exchange::v1beta1::MarketStatus _internal_status() const;
  void _internal_set_status(::injective::exchange::v1beta1::MarketStatus value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_fee_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hourlyinterestrate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hourlyfundingratecap_;
    ::injective::exchange::v1beta1::OracleParams* oracle_params_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MarketForcedSettlementProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MarketForcedSettlementProposal) */ {
 public:
  inline MarketForcedSettlementProposal() : MarketForcedSettlementProposal(nullptr) {}
  ~MarketForcedSettlementProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketForcedSettlementProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketForcedSettlementProposal(const MarketForcedSettlementProposal& from);
  MarketForcedSettlementProposal(MarketForcedSettlementProposal&& from) noexcept
    : MarketForcedSettlementProposal() {
    *this = ::std::move(from);
  }

  inline MarketForcedSettlementProposal& operator=(const MarketForcedSettlementProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketForcedSettlementProposal& operator=(MarketForcedSettlementProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketForcedSettlementProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketForcedSettlementProposal* internal_default_instance() {
    return reinterpret_cast<const MarketForcedSettlementProposal*>(
               &_MarketForcedSettlementProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(MarketForcedSettlementProposal& a, MarketForcedSettlementProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketForcedSettlementProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketForcedSettlementProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketForcedSettlementProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketForcedSettlementProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketForcedSettlementProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketForcedSettlementProposal& from) {
    MarketForcedSettlementProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketForcedSettlementProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MarketForcedSettlementProposal";
  }
  protected:
  explicit MarketForcedSettlementProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kSettlementPriceFieldNumber = 4,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string settlement_price = 4 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MarketForcedSettlementProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class UpdateDenomDecimalsProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.UpdateDenomDecimalsProposal) */ {
 public:
  inline UpdateDenomDecimalsProposal() : UpdateDenomDecimalsProposal(nullptr) {}
  ~UpdateDenomDecimalsProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateDenomDecimalsProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDenomDecimalsProposal(const UpdateDenomDecimalsProposal& from);
  UpdateDenomDecimalsProposal(UpdateDenomDecimalsProposal&& from) noexcept
    : UpdateDenomDecimalsProposal() {
    *this = ::std::move(from);
  }

  inline UpdateDenomDecimalsProposal& operator=(const UpdateDenomDecimalsProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDenomDecimalsProposal& operator=(UpdateDenomDecimalsProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDenomDecimalsProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDenomDecimalsProposal* internal_default_instance() {
    return reinterpret_cast<const UpdateDenomDecimalsProposal*>(
               &_UpdateDenomDecimalsProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(UpdateDenomDecimalsProposal& a, UpdateDenomDecimalsProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDenomDecimalsProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDenomDecimalsProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDenomDecimalsProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDenomDecimalsProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateDenomDecimalsProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateDenomDecimalsProposal& from) {
    UpdateDenomDecimalsProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateDenomDecimalsProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.UpdateDenomDecimalsProposal";
  }
  protected:
  explicit UpdateDenomDecimalsProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomDecimalsFieldNumber = 3,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 3 [json_name = "denomDecimals"];
  int denom_decimals_size() const;
  private:
  int _internal_denom_decimals_size() const;

  public:
  void clear_denom_decimals() ;
  ::injective::exchange::v1beta1::DenomDecimals* mutable_denom_decimals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >*
      mutable_denom_decimals();
  private:
  const ::injective::exchange::v1beta1::DenomDecimals& _internal_denom_decimals(int index) const;
  ::injective::exchange::v1beta1::DenomDecimals* _internal_add_denom_decimals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>& _internal_denom_decimals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>* _internal_mutable_denom_decimals();
  public:
  const ::injective::exchange::v1beta1::DenomDecimals& denom_decimals(int index) const;
  ::injective::exchange::v1beta1::DenomDecimals* add_denom_decimals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >&
      denom_decimals() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.UpdateDenomDecimalsProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals > denom_decimals_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarketParamUpdateProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal) */ {
 public:
  inline BinaryOptionsMarketParamUpdateProposal() : BinaryOptionsMarketParamUpdateProposal(nullptr) {}
  ~BinaryOptionsMarketParamUpdateProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarketParamUpdateProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarketParamUpdateProposal(const BinaryOptionsMarketParamUpdateProposal& from);
  BinaryOptionsMarketParamUpdateProposal(BinaryOptionsMarketParamUpdateProposal&& from) noexcept
    : BinaryOptionsMarketParamUpdateProposal() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarketParamUpdateProposal& operator=(const BinaryOptionsMarketParamUpdateProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarketParamUpdateProposal& operator=(BinaryOptionsMarketParamUpdateProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarketParamUpdateProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarketParamUpdateProposal* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarketParamUpdateProposal*>(
               &_BinaryOptionsMarketParamUpdateProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(BinaryOptionsMarketParamUpdateProposal& a, BinaryOptionsMarketParamUpdateProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarketParamUpdateProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarketParamUpdateProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarketParamUpdateProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarketParamUpdateProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarketParamUpdateProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarketParamUpdateProposal& from) {
    BinaryOptionsMarketParamUpdateProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarketParamUpdateProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal";
  }
  protected:
  explicit BinaryOptionsMarketParamUpdateProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kMakerFeeRateFieldNumber = 4,
    kTakerFeeRateFieldNumber = 5,
    kRelayerFeeShareRateFieldNumber = 6,
    kMinPriceTickSizeFieldNumber = 7,
    kMinQuantityTickSizeFieldNumber = 8,
    kSettlementPriceFieldNumber = 11,
    kAdminFieldNumber = 12,
    kOracleParamsFieldNumber = 14,
    kExpirationTimestampFieldNumber = 9,
    kSettlementTimestampFieldNumber = 10,
    kStatusFieldNumber = 13,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_relayer_fee_share_rate() ;
  const std::string& relayer_fee_share_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer_fee_share_rate(Arg_&& arg, Args_... args);
  std::string* mutable_relayer_fee_share_rate();
  PROTOBUF_NODISCARD std::string* release_relayer_fee_share_rate();
  void set_allocated_relayer_fee_share_rate(std::string* ptr);

  private:
  const std::string& _internal_relayer_fee_share_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer_fee_share_rate(
      const std::string& value);
  std::string* _internal_mutable_relayer_fee_share_rate();

  public:
  // string min_price_tick_size = 7 [json_name = "minPriceTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 8 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // string settlement_price = 11 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // string admin = 12 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // .injective.exchange.v1beta1.ProviderOracleParams oracle_params = 14 [json_name = "oracleParams"];
  bool has_oracle_params() const;
  void clear_oracle_params() ;
  const ::injective::exchange::v1beta1::ProviderOracleParams& oracle_params() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::ProviderOracleParams* release_oracle_params();
  ::injective::exchange::v1beta1::ProviderOracleParams* mutable_oracle_params();
  void set_allocated_oracle_params(::injective::exchange::v1beta1::ProviderOracleParams* oracle_params);
  private:
  const ::injective::exchange::v1beta1::ProviderOracleParams& _internal_oracle_params() const;
  ::injective::exchange::v1beta1::ProviderOracleParams* _internal_mutable_oracle_params();
  public:
  void unsafe_arena_set_allocated_oracle_params(
      ::injective::exchange::v1beta1::ProviderOracleParams* oracle_params);
  ::injective::exchange::v1beta1::ProviderOracleParams* unsafe_arena_release_oracle_params();
  // int64 expiration_timestamp = 9 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // int64 settlement_timestamp = 10 [json_name = "settlementTimestamp"];
  void clear_settlement_timestamp() ;
  ::int64_t settlement_timestamp() const;
  void set_settlement_timestamp(::int64_t value);

  private:
  ::int64_t _internal_settlement_timestamp() const;
  void _internal_set_settlement_timestamp(::int64_t value);

  public:
  // .injective.exchange.v1beta1.MarketStatus status = 13 [json_name = "status"];
  void clear_status() ;
  ::injective::exchange::v1beta1::MarketStatus status() const;
  void set_status(::injective::exchange::v1beta1::MarketStatus value);

  private:
  ::injective::exchange::v1beta1::MarketStatus _internal_status() const;
  void _internal_set_status(::injective::exchange::v1beta1::MarketStatus value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_fee_share_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::injective::exchange::v1beta1::ProviderOracleParams* oracle_params_;
    ::int64_t expiration_timestamp_;
    ::int64_t settlement_timestamp_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class ProviderOracleParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.ProviderOracleParams) */ {
 public:
  inline ProviderOracleParams() : ProviderOracleParams(nullptr) {}
  ~ProviderOracleParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProviderOracleParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProviderOracleParams(const ProviderOracleParams& from);
  ProviderOracleParams(ProviderOracleParams&& from) noexcept
    : ProviderOracleParams() {
    *this = ::std::move(from);
  }

  inline ProviderOracleParams& operator=(const ProviderOracleParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProviderOracleParams& operator=(ProviderOracleParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProviderOracleParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProviderOracleParams* internal_default_instance() {
    return reinterpret_cast<const ProviderOracleParams*>(
               &_ProviderOracleParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ProviderOracleParams& a, ProviderOracleParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ProviderOracleParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProviderOracleParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProviderOracleParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProviderOracleParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProviderOracleParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProviderOracleParams& from) {
    ProviderOracleParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProviderOracleParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.ProviderOracleParams";
  }
  protected:
  explicit ProviderOracleParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kProviderFieldNumber = 2,
    kOracleScaleFactorFieldNumber = 3,
    kOracleTypeFieldNumber = 4,
  };
  // string symbol = 1 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string provider = 2 [json_name = "provider"];
  void clear_provider() ;
  const std::string& provider() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_provider(Arg_&& arg, Args_... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* ptr);

  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(
      const std::string& value);
  std::string* _internal_mutable_provider();

  public:
  // uint32 oracle_scale_factor = 3 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.ProviderOracleParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    ::uint32_t oracle_scale_factor_;
    int oracle_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class OracleParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.OracleParams) */ {
 public:
  inline OracleParams() : OracleParams(nullptr) {}
  ~OracleParams() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OracleParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OracleParams(const OracleParams& from);
  OracleParams(OracleParams&& from) noexcept
    : OracleParams() {
    *this = ::std::move(from);
  }

  inline OracleParams& operator=(const OracleParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline OracleParams& operator=(OracleParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OracleParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const OracleParams* internal_default_instance() {
    return reinterpret_cast<const OracleParams*>(
               &_OracleParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(OracleParams& a, OracleParams& b) {
    a.Swap(&b);
  }
  inline void Swap(OracleParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OracleParams* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OracleParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OracleParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OracleParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OracleParams& from) {
    OracleParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OracleParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.OracleParams";
  }
  protected:
  explicit OracleParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOracleBaseFieldNumber = 1,
    kOracleQuoteFieldNumber = 2,
    kOracleScaleFactorFieldNumber = 3,
    kOracleTypeFieldNumber = 4,
  };
  // string oracle_base = 1 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 2 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // uint32 oracle_scale_factor = 3 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  void clear_oracle_type() ;
  ::injective::oracle::v1beta1::OracleType oracle_type() const;
  void set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  private:
  ::injective::oracle::v1beta1::OracleType _internal_oracle_type() const;
  void _internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.OracleParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::uint32_t oracle_scale_factor_;
    int oracle_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class TradingRewardCampaignLaunchProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal) */ {
 public:
  inline TradingRewardCampaignLaunchProposal() : TradingRewardCampaignLaunchProposal(nullptr) {}
  ~TradingRewardCampaignLaunchProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradingRewardCampaignLaunchProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradingRewardCampaignLaunchProposal(const TradingRewardCampaignLaunchProposal& from);
  TradingRewardCampaignLaunchProposal(TradingRewardCampaignLaunchProposal&& from) noexcept
    : TradingRewardCampaignLaunchProposal() {
    *this = ::std::move(from);
  }

  inline TradingRewardCampaignLaunchProposal& operator=(const TradingRewardCampaignLaunchProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingRewardCampaignLaunchProposal& operator=(TradingRewardCampaignLaunchProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradingRewardCampaignLaunchProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradingRewardCampaignLaunchProposal* internal_default_instance() {
    return reinterpret_cast<const TradingRewardCampaignLaunchProposal*>(
               &_TradingRewardCampaignLaunchProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(TradingRewardCampaignLaunchProposal& a, TradingRewardCampaignLaunchProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingRewardCampaignLaunchProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradingRewardCampaignLaunchProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradingRewardCampaignLaunchProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradingRewardCampaignLaunchProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradingRewardCampaignLaunchProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradingRewardCampaignLaunchProposal& from) {
    TradingRewardCampaignLaunchProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingRewardCampaignLaunchProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal";
  }
  protected:
  explicit TradingRewardCampaignLaunchProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCampaignRewardPoolsFieldNumber = 4,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kCampaignInfoFieldNumber = 3,
  };
  // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 4 [json_name = "campaignRewardPools"];
  int campaign_reward_pools_size() const;
  private:
  int _internal_campaign_reward_pools_size() const;

  public:
  void clear_campaign_reward_pools() ;
  ::injective::exchange::v1beta1::CampaignRewardPool* mutable_campaign_reward_pools(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
      mutable_campaign_reward_pools();
  private:
  const ::injective::exchange::v1beta1::CampaignRewardPool& _internal_campaign_reward_pools(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* _internal_add_campaign_reward_pools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>& _internal_campaign_reward_pools() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>* _internal_mutable_campaign_reward_pools();
  public:
  const ::injective::exchange::v1beta1::CampaignRewardPool& campaign_reward_pools(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* add_campaign_reward_pools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
      campaign_reward_pools() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3 [json_name = "campaignInfo"];
  bool has_campaign_info() const;
  void clear_campaign_info() ;
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& campaign_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::TradingRewardCampaignInfo* release_campaign_info();
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* mutable_campaign_info();
  void set_allocated_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info);
  private:
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& _internal_campaign_info() const;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _internal_mutable_campaign_info();
  public:
  void unsafe_arena_set_allocated_campaign_info(
      ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info);
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* unsafe_arena_release_campaign_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool > campaign_reward_pools_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class TradingRewardCampaignUpdateProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal) */ {
 public:
  inline TradingRewardCampaignUpdateProposal() : TradingRewardCampaignUpdateProposal(nullptr) {}
  ~TradingRewardCampaignUpdateProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradingRewardCampaignUpdateProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradingRewardCampaignUpdateProposal(const TradingRewardCampaignUpdateProposal& from);
  TradingRewardCampaignUpdateProposal(TradingRewardCampaignUpdateProposal&& from) noexcept
    : TradingRewardCampaignUpdateProposal() {
    *this = ::std::move(from);
  }

  inline TradingRewardCampaignUpdateProposal& operator=(const TradingRewardCampaignUpdateProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingRewardCampaignUpdateProposal& operator=(TradingRewardCampaignUpdateProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradingRewardCampaignUpdateProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradingRewardCampaignUpdateProposal* internal_default_instance() {
    return reinterpret_cast<const TradingRewardCampaignUpdateProposal*>(
               &_TradingRewardCampaignUpdateProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(TradingRewardCampaignUpdateProposal& a, TradingRewardCampaignUpdateProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingRewardCampaignUpdateProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradingRewardCampaignUpdateProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradingRewardCampaignUpdateProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradingRewardCampaignUpdateProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradingRewardCampaignUpdateProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradingRewardCampaignUpdateProposal& from) {
    TradingRewardCampaignUpdateProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingRewardCampaignUpdateProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal";
  }
  protected:
  explicit TradingRewardCampaignUpdateProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCampaignRewardPoolsAdditionsFieldNumber = 4,
    kCampaignRewardPoolsUpdatesFieldNumber = 5,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kCampaignInfoFieldNumber = 3,
  };
  // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_additions = 4 [json_name = "campaignRewardPoolsAdditions"];
  int campaign_reward_pools_additions_size() const;
  private:
  int _internal_campaign_reward_pools_additions_size() const;

  public:
  void clear_campaign_reward_pools_additions() ;
  ::injective::exchange::v1beta1::CampaignRewardPool* mutable_campaign_reward_pools_additions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
      mutable_campaign_reward_pools_additions();
  private:
  const ::injective::exchange::v1beta1::CampaignRewardPool& _internal_campaign_reward_pools_additions(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* _internal_add_campaign_reward_pools_additions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>& _internal_campaign_reward_pools_additions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>* _internal_mutable_campaign_reward_pools_additions();
  public:
  const ::injective::exchange::v1beta1::CampaignRewardPool& campaign_reward_pools_additions(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* add_campaign_reward_pools_additions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
      campaign_reward_pools_additions() const;
  // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_updates = 5 [json_name = "campaignRewardPoolsUpdates"];
  int campaign_reward_pools_updates_size() const;
  private:
  int _internal_campaign_reward_pools_updates_size() const;

  public:
  void clear_campaign_reward_pools_updates() ;
  ::injective::exchange::v1beta1::CampaignRewardPool* mutable_campaign_reward_pools_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
      mutable_campaign_reward_pools_updates();
  private:
  const ::injective::exchange::v1beta1::CampaignRewardPool& _internal_campaign_reward_pools_updates(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* _internal_add_campaign_reward_pools_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>& _internal_campaign_reward_pools_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>* _internal_mutable_campaign_reward_pools_updates();
  public:
  const ::injective::exchange::v1beta1::CampaignRewardPool& campaign_reward_pools_updates(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* add_campaign_reward_pools_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
      campaign_reward_pools_updates() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3 [json_name = "campaignInfo"];
  bool has_campaign_info() const;
  void clear_campaign_info() ;
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& campaign_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::TradingRewardCampaignInfo* release_campaign_info();
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* mutable_campaign_info();
  void set_allocated_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info);
  private:
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& _internal_campaign_info() const;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _internal_mutable_campaign_info();
  public:
  void unsafe_arena_set_allocated_campaign_info(
      ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info);
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* unsafe_arena_release_campaign_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool > campaign_reward_pools_additions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool > campaign_reward_pools_updates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class RewardPointUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.RewardPointUpdate) */ {
 public:
  inline RewardPointUpdate() : RewardPointUpdate(nullptr) {}
  ~RewardPointUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RewardPointUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RewardPointUpdate(const RewardPointUpdate& from);
  RewardPointUpdate(RewardPointUpdate&& from) noexcept
    : RewardPointUpdate() {
    *this = ::std::move(from);
  }

  inline RewardPointUpdate& operator=(const RewardPointUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RewardPointUpdate& operator=(RewardPointUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RewardPointUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RewardPointUpdate* internal_default_instance() {
    return reinterpret_cast<const RewardPointUpdate*>(
               &_RewardPointUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(RewardPointUpdate& a, RewardPointUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(RewardPointUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RewardPointUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RewardPointUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RewardPointUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RewardPointUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RewardPointUpdate& from) {
    RewardPointUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RewardPointUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.RewardPointUpdate";
  }
  protected:
  explicit RewardPointUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountAddressFieldNumber = 1,
    kNewPointsFieldNumber = 12,
  };
  // string account_address = 1 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // string new_points = 12 [json_name = "newPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_new_points() ;
  const std::string& new_points() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_points(Arg_&& arg, Args_... args);
  std::string* mutable_new_points();
  PROTOBUF_NODISCARD std::string* release_new_points();
  void set_allocated_new_points(std::string* ptr);

  private:
  const std::string& _internal_new_points() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_points(
      const std::string& value);
  std::string* _internal_mutable_new_points();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.RewardPointUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class TradingRewardPendingPointsUpdateProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal) */ {
 public:
  inline TradingRewardPendingPointsUpdateProposal() : TradingRewardPendingPointsUpdateProposal(nullptr) {}
  ~TradingRewardPendingPointsUpdateProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradingRewardPendingPointsUpdateProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradingRewardPendingPointsUpdateProposal(const TradingRewardPendingPointsUpdateProposal& from);
  TradingRewardPendingPointsUpdateProposal(TradingRewardPendingPointsUpdateProposal&& from) noexcept
    : TradingRewardPendingPointsUpdateProposal() {
    *this = ::std::move(from);
  }

  inline TradingRewardPendingPointsUpdateProposal& operator=(const TradingRewardPendingPointsUpdateProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradingRewardPendingPointsUpdateProposal& operator=(TradingRewardPendingPointsUpdateProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradingRewardPendingPointsUpdateProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradingRewardPendingPointsUpdateProposal* internal_default_instance() {
    return reinterpret_cast<const TradingRewardPendingPointsUpdateProposal*>(
               &_TradingRewardPendingPointsUpdateProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(TradingRewardPendingPointsUpdateProposal& a, TradingRewardPendingPointsUpdateProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(TradingRewardPendingPointsUpdateProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradingRewardPendingPointsUpdateProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradingRewardPendingPointsUpdateProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradingRewardPendingPointsUpdateProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradingRewardPendingPointsUpdateProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradingRewardPendingPointsUpdateProposal& from) {
    TradingRewardPendingPointsUpdateProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingRewardPendingPointsUpdateProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal";
  }
  protected:
  explicit TradingRewardPendingPointsUpdateProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardPointUpdatesFieldNumber = 4,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kPendingPoolTimestampFieldNumber = 3,
  };
  // repeated .injective.exchange.v1beta1.RewardPointUpdate reward_point_updates = 4 [json_name = "rewardPointUpdates"];
  int reward_point_updates_size() const;
  private:
  int _internal_reward_point_updates_size() const;

  public:
  void clear_reward_point_updates() ;
  ::injective::exchange::v1beta1::RewardPointUpdate* mutable_reward_point_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::RewardPointUpdate >*
      mutable_reward_point_updates();
  private:
  const ::injective::exchange::v1beta1::RewardPointUpdate& _internal_reward_point_updates(int index) const;
  ::injective::exchange::v1beta1::RewardPointUpdate* _internal_add_reward_point_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::RewardPointUpdate>& _internal_reward_point_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::RewardPointUpdate>* _internal_mutable_reward_point_updates();
  public:
  const ::injective::exchange::v1beta1::RewardPointUpdate& reward_point_updates(int index) const;
  ::injective::exchange::v1beta1::RewardPointUpdate* add_reward_point_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::RewardPointUpdate >&
      reward_point_updates() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // int64 pending_pool_timestamp = 3 [json_name = "pendingPoolTimestamp"];
  void clear_pending_pool_timestamp() ;
  ::int64_t pending_pool_timestamp() const;
  void set_pending_pool_timestamp(::int64_t value);

  private:
  ::int64_t _internal_pending_pool_timestamp() const;
  void _internal_set_pending_pool_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::RewardPointUpdate > reward_point_updates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::int64_t pending_pool_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class FeeDiscountProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.FeeDiscountProposal) */ {
 public:
  inline FeeDiscountProposal() : FeeDiscountProposal(nullptr) {}
  ~FeeDiscountProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeeDiscountProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeeDiscountProposal(const FeeDiscountProposal& from);
  FeeDiscountProposal(FeeDiscountProposal&& from) noexcept
    : FeeDiscountProposal() {
    *this = ::std::move(from);
  }

  inline FeeDiscountProposal& operator=(const FeeDiscountProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeDiscountProposal& operator=(FeeDiscountProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeeDiscountProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeeDiscountProposal* internal_default_instance() {
    return reinterpret_cast<const FeeDiscountProposal*>(
               &_FeeDiscountProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(FeeDiscountProposal& a, FeeDiscountProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeDiscountProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeDiscountProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeeDiscountProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeeDiscountProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeeDiscountProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeeDiscountProposal& from) {
    FeeDiscountProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeDiscountProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.FeeDiscountProposal";
  }
  protected:
  explicit FeeDiscountProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kScheduleFieldNumber = 3,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 3 [json_name = "schedule"];
  bool has_schedule() const;
  void clear_schedule() ;
  const ::injective::exchange::v1beta1::FeeDiscountSchedule& schedule() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::FeeDiscountSchedule* release_schedule();
  ::injective::exchange::v1beta1::FeeDiscountSchedule* mutable_schedule();
  void set_allocated_schedule(::injective::exchange::v1beta1::FeeDiscountSchedule* schedule);
  private:
  const ::injective::exchange::v1beta1::FeeDiscountSchedule& _internal_schedule() const;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* _internal_mutable_schedule();
  public:
  void unsafe_arena_set_allocated_schedule(
      ::injective::exchange::v1beta1::FeeDiscountSchedule* schedule);
  ::injective::exchange::v1beta1::FeeDiscountSchedule* unsafe_arena_release_schedule();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.FeeDiscountProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::injective::exchange::v1beta1::FeeDiscountSchedule* schedule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class BatchCommunityPoolSpendProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal) */ {
 public:
  inline BatchCommunityPoolSpendProposal() : BatchCommunityPoolSpendProposal(nullptr) {}
  ~BatchCommunityPoolSpendProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BatchCommunityPoolSpendProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCommunityPoolSpendProposal(const BatchCommunityPoolSpendProposal& from);
  BatchCommunityPoolSpendProposal(BatchCommunityPoolSpendProposal&& from) noexcept
    : BatchCommunityPoolSpendProposal() {
    *this = ::std::move(from);
  }

  inline BatchCommunityPoolSpendProposal& operator=(const BatchCommunityPoolSpendProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCommunityPoolSpendProposal& operator=(BatchCommunityPoolSpendProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCommunityPoolSpendProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchCommunityPoolSpendProposal* internal_default_instance() {
    return reinterpret_cast<const BatchCommunityPoolSpendProposal*>(
               &_BatchCommunityPoolSpendProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(BatchCommunityPoolSpendProposal& a, BatchCommunityPoolSpendProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCommunityPoolSpendProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCommunityPoolSpendProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCommunityPoolSpendProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCommunityPoolSpendProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCommunityPoolSpendProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCommunityPoolSpendProposal& from) {
    BatchCommunityPoolSpendProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCommunityPoolSpendProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.BatchCommunityPoolSpendProposal";
  }
  protected:
  explicit BatchCommunityPoolSpendProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalsFieldNumber = 3,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // repeated .cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals = 3 [json_name = "proposals"];
  int proposals_size() const;
  private:
  int _internal_proposals_size() const;

  public:
  void clear_proposals() ;
  ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* mutable_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal >*
      mutable_proposals();
  private:
  const ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal& _internal_proposals(int index) const;
  ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* _internal_add_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::CommunityPoolSpendProposal>& _internal_proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::CommunityPoolSpendProposal>* _internal_mutable_proposals();
  public:
  const ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal& proposals(int index) const;
  ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* add_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal >&
      proposals() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal > proposals_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRewardsOptOut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgRewardsOptOut) */ {
 public:
  inline MsgRewardsOptOut() : MsgRewardsOptOut(nullptr) {}
  ~MsgRewardsOptOut() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRewardsOptOut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRewardsOptOut(const MsgRewardsOptOut& from);
  MsgRewardsOptOut(MsgRewardsOptOut&& from) noexcept
    : MsgRewardsOptOut() {
    *this = ::std::move(from);
  }

  inline MsgRewardsOptOut& operator=(const MsgRewardsOptOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRewardsOptOut& operator=(MsgRewardsOptOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRewardsOptOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRewardsOptOut* internal_default_instance() {
    return reinterpret_cast<const MsgRewardsOptOut*>(
               &_MsgRewardsOptOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(MsgRewardsOptOut& a, MsgRewardsOptOut& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRewardsOptOut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRewardsOptOut* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRewardsOptOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRewardsOptOut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRewardsOptOut& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgRewardsOptOut& from) {
    MsgRewardsOptOut::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRewardsOptOut* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgRewardsOptOut";
  }
  protected:
  explicit MsgRewardsOptOut(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgRewardsOptOut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRewardsOptOutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgRewardsOptOutResponse) */ {
 public:
  inline MsgRewardsOptOutResponse() : MsgRewardsOptOutResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRewardsOptOutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRewardsOptOutResponse(const MsgRewardsOptOutResponse& from);
  MsgRewardsOptOutResponse(MsgRewardsOptOutResponse&& from) noexcept
    : MsgRewardsOptOutResponse() {
    *this = ::std::move(from);
  }

  inline MsgRewardsOptOutResponse& operator=(const MsgRewardsOptOutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRewardsOptOutResponse& operator=(MsgRewardsOptOutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRewardsOptOutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRewardsOptOutResponse* internal_default_instance() {
    return reinterpret_cast<const MsgRewardsOptOutResponse*>(
               &_MsgRewardsOptOutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(MsgRewardsOptOutResponse& a, MsgRewardsOptOutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRewardsOptOutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRewardsOptOutResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRewardsOptOutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRewardsOptOutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgRewardsOptOutResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgRewardsOptOutResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgRewardsOptOutResponse";
  }
  protected:
  explicit MsgRewardsOptOutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgRewardsOptOutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgReclaimLockedFunds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgReclaimLockedFunds) */ {
 public:
  inline MsgReclaimLockedFunds() : MsgReclaimLockedFunds(nullptr) {}
  ~MsgReclaimLockedFunds() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgReclaimLockedFunds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgReclaimLockedFunds(const MsgReclaimLockedFunds& from);
  MsgReclaimLockedFunds(MsgReclaimLockedFunds&& from) noexcept
    : MsgReclaimLockedFunds() {
    *this = ::std::move(from);
  }

  inline MsgReclaimLockedFunds& operator=(const MsgReclaimLockedFunds& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgReclaimLockedFunds& operator=(MsgReclaimLockedFunds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgReclaimLockedFunds& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgReclaimLockedFunds* internal_default_instance() {
    return reinterpret_cast<const MsgReclaimLockedFunds*>(
               &_MsgReclaimLockedFunds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(MsgReclaimLockedFunds& a, MsgReclaimLockedFunds& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgReclaimLockedFunds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgReclaimLockedFunds* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgReclaimLockedFunds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgReclaimLockedFunds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgReclaimLockedFunds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgReclaimLockedFunds& from) {
    MsgReclaimLockedFunds::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgReclaimLockedFunds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgReclaimLockedFunds";
  }
  protected:
  explicit MsgReclaimLockedFunds(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kLockedAccountPubKeyFieldNumber = 2,
    kSignatureFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // bytes lockedAccountPubKey = 2 [json_name = "lockedAccountPubKey"];
  void clear_lockedaccountpubkey() ;
  const std::string& lockedaccountpubkey() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lockedaccountpubkey(Arg_&& arg, Args_... args);
  std::string* mutable_lockedaccountpubkey();
  PROTOBUF_NODISCARD std::string* release_lockedaccountpubkey();
  void set_allocated_lockedaccountpubkey(std::string* ptr);

  private:
  const std::string& _internal_lockedaccountpubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lockedaccountpubkey(
      const std::string& value);
  std::string* _internal_mutable_lockedaccountpubkey();

  public:
  // bytes signature = 3 [json_name = "signature"];
  void clear_signature() ;
  const std::string& signature() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* ptr);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgReclaimLockedFunds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lockedaccountpubkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgReclaimLockedFundsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgReclaimLockedFundsResponse) */ {
 public:
  inline MsgReclaimLockedFundsResponse() : MsgReclaimLockedFundsResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgReclaimLockedFundsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgReclaimLockedFundsResponse(const MsgReclaimLockedFundsResponse& from);
  MsgReclaimLockedFundsResponse(MsgReclaimLockedFundsResponse&& from) noexcept
    : MsgReclaimLockedFundsResponse() {
    *this = ::std::move(from);
  }

  inline MsgReclaimLockedFundsResponse& operator=(const MsgReclaimLockedFundsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgReclaimLockedFundsResponse& operator=(MsgReclaimLockedFundsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgReclaimLockedFundsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgReclaimLockedFundsResponse* internal_default_instance() {
    return reinterpret_cast<const MsgReclaimLockedFundsResponse*>(
               &_MsgReclaimLockedFundsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(MsgReclaimLockedFundsResponse& a, MsgReclaimLockedFundsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgReclaimLockedFundsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgReclaimLockedFundsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgReclaimLockedFundsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgReclaimLockedFundsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgReclaimLockedFundsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgReclaimLockedFundsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgReclaimLockedFundsResponse";
  }
  protected:
  explicit MsgReclaimLockedFundsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgReclaimLockedFundsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSignData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgSignData) */ {
 public:
  inline MsgSignData() : MsgSignData(nullptr) {}
  ~MsgSignData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSignData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSignData(const MsgSignData& from);
  MsgSignData(MsgSignData&& from) noexcept
    : MsgSignData() {
    *this = ::std::move(from);
  }

  inline MsgSignData& operator=(const MsgSignData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSignData& operator=(MsgSignData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSignData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSignData* internal_default_instance() {
    return reinterpret_cast<const MsgSignData*>(
               &_MsgSignData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(MsgSignData& a, MsgSignData& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSignData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSignData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSignData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSignData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgSignData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgSignData& from) {
    MsgSignData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgSignData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgSignData";
  }
  protected:
  explicit MsgSignData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignerFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // bytes Signer = 1 [json_name = "Signer", (.gogoproto.jsontag) = "signer", (.gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // bytes Data = 2 [json_name = "Data", (.gogoproto.jsontag) = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgSignData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgSignDoc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgSignDoc) */ {
 public:
  inline MsgSignDoc() : MsgSignDoc(nullptr) {}
  ~MsgSignDoc() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgSignDoc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgSignDoc(const MsgSignDoc& from);
  MsgSignDoc(MsgSignDoc&& from) noexcept
    : MsgSignDoc() {
    *this = ::std::move(from);
  }

  inline MsgSignDoc& operator=(const MsgSignDoc& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgSignDoc& operator=(MsgSignDoc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgSignDoc& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgSignDoc* internal_default_instance() {
    return reinterpret_cast<const MsgSignDoc*>(
               &_MsgSignDoc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(MsgSignDoc& a, MsgSignDoc& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgSignDoc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgSignDoc* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgSignDoc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgSignDoc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgSignDoc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgSignDoc& from) {
    MsgSignDoc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgSignDoc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgSignDoc";
  }
  protected:
  explicit MsgSignDoc(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string sign_type = 1 [json_name = "signType", (.gogoproto.jsontag) = "type"];
  void clear_sign_type() ;
  const std::string& sign_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sign_type(Arg_&& arg, Args_... args);
  std::string* mutable_sign_type();
  PROTOBUF_NODISCARD std::string* release_sign_type();
  void set_allocated_sign_type(std::string* ptr);

  private:
  const std::string& _internal_sign_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_type(
      const std::string& value);
  std::string* _internal_mutable_sign_type();

  public:
  // .injective.exchange.v1beta1.MsgSignData value = 2 [json_name = "value", (.gogoproto.nullable) = false];
  bool has_value() const;
  void clear_value() ;
  const ::injective::exchange::v1beta1::MsgSignData& value() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::MsgSignData* release_value();
  ::injective::exchange::v1beta1::MsgSignData* mutable_value();
  void set_allocated_value(::injective::exchange::v1beta1::MsgSignData* value);
  private:
  const ::injective::exchange::v1beta1::MsgSignData& _internal_value() const;
  ::injective::exchange::v1beta1::MsgSignData* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::injective::exchange::v1beta1::MsgSignData* value);
  ::injective::exchange::v1beta1::MsgSignData* unsafe_arena_release_value();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgSignDoc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_type_;
    ::injective::exchange::v1beta1::MsgSignData* value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgAdminUpdateBinaryOptionsMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket) */ {
 public:
  inline MsgAdminUpdateBinaryOptionsMarket() : MsgAdminUpdateBinaryOptionsMarket(nullptr) {}
  ~MsgAdminUpdateBinaryOptionsMarket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgAdminUpdateBinaryOptionsMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgAdminUpdateBinaryOptionsMarket(const MsgAdminUpdateBinaryOptionsMarket& from);
  MsgAdminUpdateBinaryOptionsMarket(MsgAdminUpdateBinaryOptionsMarket&& from) noexcept
    : MsgAdminUpdateBinaryOptionsMarket() {
    *this = ::std::move(from);
  }

  inline MsgAdminUpdateBinaryOptionsMarket& operator=(const MsgAdminUpdateBinaryOptionsMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgAdminUpdateBinaryOptionsMarket& operator=(MsgAdminUpdateBinaryOptionsMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgAdminUpdateBinaryOptionsMarket& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgAdminUpdateBinaryOptionsMarket* internal_default_instance() {
    return reinterpret_cast<const MsgAdminUpdateBinaryOptionsMarket*>(
               &_MsgAdminUpdateBinaryOptionsMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(MsgAdminUpdateBinaryOptionsMarket& a, MsgAdminUpdateBinaryOptionsMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgAdminUpdateBinaryOptionsMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgAdminUpdateBinaryOptionsMarket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgAdminUpdateBinaryOptionsMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgAdminUpdateBinaryOptionsMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgAdminUpdateBinaryOptionsMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgAdminUpdateBinaryOptionsMarket& from) {
    MsgAdminUpdateBinaryOptionsMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgAdminUpdateBinaryOptionsMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket";
  }
  protected:
  explicit MsgAdminUpdateBinaryOptionsMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSettlementPriceFieldNumber = 3,
    kExpirationTimestampFieldNumber = 4,
    kSettlementTimestampFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string settlement_price = 3 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // int64 expiration_timestamp = 4 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // int64 settlement_timestamp = 5 [json_name = "settlementTimestamp"];
  void clear_settlement_timestamp() ;
  ::int64_t settlement_timestamp() const;
  void set_settlement_timestamp(::int64_t value);

  private:
  ::int64_t _internal_settlement_timestamp() const;
  void _internal_set_settlement_timestamp(::int64_t value);

  public:
  // .injective.exchange.v1beta1.MarketStatus status = 6 [json_name = "status"];
  void clear_status() ;
  ::injective::exchange::v1beta1::MarketStatus status() const;
  void set_status(::injective::exchange::v1beta1::MarketStatus value);

  private:
  ::injective::exchange::v1beta1::MarketStatus _internal_status() const;
  void _internal_set_status(::injective::exchange::v1beta1::MarketStatus value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    ::int64_t expiration_timestamp_;
    ::int64_t settlement_timestamp_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgAdminUpdateBinaryOptionsMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse) */ {
 public:
  inline MsgAdminUpdateBinaryOptionsMarketResponse() : MsgAdminUpdateBinaryOptionsMarketResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgAdminUpdateBinaryOptionsMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgAdminUpdateBinaryOptionsMarketResponse(const MsgAdminUpdateBinaryOptionsMarketResponse& from);
  MsgAdminUpdateBinaryOptionsMarketResponse(MsgAdminUpdateBinaryOptionsMarketResponse&& from) noexcept
    : MsgAdminUpdateBinaryOptionsMarketResponse() {
    *this = ::std::move(from);
  }

  inline MsgAdminUpdateBinaryOptionsMarketResponse& operator=(const MsgAdminUpdateBinaryOptionsMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgAdminUpdateBinaryOptionsMarketResponse& operator=(MsgAdminUpdateBinaryOptionsMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgAdminUpdateBinaryOptionsMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgAdminUpdateBinaryOptionsMarketResponse* internal_default_instance() {
    return reinterpret_cast<const MsgAdminUpdateBinaryOptionsMarketResponse*>(
               &_MsgAdminUpdateBinaryOptionsMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(MsgAdminUpdateBinaryOptionsMarketResponse& a, MsgAdminUpdateBinaryOptionsMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgAdminUpdateBinaryOptionsMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgAdminUpdateBinaryOptionsMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgAdminUpdateBinaryOptionsMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgAdminUpdateBinaryOptionsMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgAdminUpdateBinaryOptionsMarketResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgAdminUpdateBinaryOptionsMarketResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse";
  }
  protected:
  explicit MsgAdminUpdateBinaryOptionsMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};// -------------------------------------------------------------------

class AtomicMarketOrderFeeMultiplierScheduleProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal) */ {
 public:
  inline AtomicMarketOrderFeeMultiplierScheduleProposal() : AtomicMarketOrderFeeMultiplierScheduleProposal(nullptr) {}
  ~AtomicMarketOrderFeeMultiplierScheduleProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AtomicMarketOrderFeeMultiplierScheduleProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AtomicMarketOrderFeeMultiplierScheduleProposal(const AtomicMarketOrderFeeMultiplierScheduleProposal& from);
  AtomicMarketOrderFeeMultiplierScheduleProposal(AtomicMarketOrderFeeMultiplierScheduleProposal&& from) noexcept
    : AtomicMarketOrderFeeMultiplierScheduleProposal() {
    *this = ::std::move(from);
  }

  inline AtomicMarketOrderFeeMultiplierScheduleProposal& operator=(const AtomicMarketOrderFeeMultiplierScheduleProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline AtomicMarketOrderFeeMultiplierScheduleProposal& operator=(AtomicMarketOrderFeeMultiplierScheduleProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AtomicMarketOrderFeeMultiplierScheduleProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const AtomicMarketOrderFeeMultiplierScheduleProposal* internal_default_instance() {
    return reinterpret_cast<const AtomicMarketOrderFeeMultiplierScheduleProposal*>(
               &_AtomicMarketOrderFeeMultiplierScheduleProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(AtomicMarketOrderFeeMultiplierScheduleProposal& a, AtomicMarketOrderFeeMultiplierScheduleProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(AtomicMarketOrderFeeMultiplierScheduleProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AtomicMarketOrderFeeMultiplierScheduleProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AtomicMarketOrderFeeMultiplierScheduleProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AtomicMarketOrderFeeMultiplierScheduleProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AtomicMarketOrderFeeMultiplierScheduleProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AtomicMarketOrderFeeMultiplierScheduleProposal& from) {
    AtomicMarketOrderFeeMultiplierScheduleProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AtomicMarketOrderFeeMultiplierScheduleProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal";
  }
  protected:
  explicit AtomicMarketOrderFeeMultiplierScheduleProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFeeMultipliersFieldNumber = 3,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 3 [json_name = "marketFeeMultipliers"];
  int market_fee_multipliers_size() const;
  private:
  int _internal_market_fee_multipliers_size() const;

  public:
  void clear_market_fee_multipliers() ;
  ::injective::exchange::v1beta1::MarketFeeMultiplier* mutable_market_fee_multipliers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >*
      mutable_market_fee_multipliers();
  private:
  const ::injective::exchange::v1beta1::MarketFeeMultiplier& _internal_market_fee_multipliers(int index) const;
  ::injective::exchange::v1beta1::MarketFeeMultiplier* _internal_add_market_fee_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>& _internal_market_fee_multipliers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>* _internal_mutable_market_fee_multipliers();
  public:
  const ::injective::exchange::v1beta1::MarketFeeMultiplier& market_fee_multipliers(int index) const;
  ::injective::exchange::v1beta1::MarketFeeMultiplier* add_market_fee_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >&
      market_fee_multipliers() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier > market_fee_multipliers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2ftx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MsgUpdateParams

// string authority = 1 [json_name = "authority", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void MsgUpdateParams::clear_authority() {
  _impl_.authority_.ClearToEmpty();
}
inline const std::string& MsgUpdateParams::authority() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgUpdateParams.authority)
  return _internal_authority();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgUpdateParams::set_authority(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.authority_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgUpdateParams.authority)
}
inline std::string* MsgUpdateParams::mutable_authority() {
  std::string* _s = _internal_mutable_authority();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgUpdateParams.authority)
  return _s;
}
inline const std::string& MsgUpdateParams::_internal_authority() const {
  return _impl_.authority_.Get();
}
inline void MsgUpdateParams::_internal_set_authority(const std::string& value) {
  ;


  _impl_.authority_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::_internal_mutable_authority() {
  ;
  return _impl_.authority_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgUpdateParams::release_authority() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgUpdateParams.authority)
  return _impl_.authority_.Release();
}
inline void MsgUpdateParams::set_allocated_authority(std::string* value) {
  _impl_.authority_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.authority_.IsDefault()) {
          _impl_.authority_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgUpdateParams.authority)
}

// .injective.exchange.v1beta1.Params params = 2 [json_name = "params", (.gogoproto.nullable) = false];
inline bool MsgUpdateParams::has_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::Params& MsgUpdateParams::_internal_params() const {
  const ::injective::exchange::v1beta1::Params* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Params&>(
      ::injective::exchange::v1beta1::_Params_default_instance_);
}
inline const ::injective::exchange::v1beta1::Params& MsgUpdateParams::params() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgUpdateParams.params)
  return _internal_params();
}
inline void MsgUpdateParams::unsafe_arena_set_allocated_params(
    ::injective::exchange::v1beta1::Params* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgUpdateParams.params)
}
inline ::injective::exchange::v1beta1::Params* MsgUpdateParams::release_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Params* MsgUpdateParams::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgUpdateParams.params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Params* MsgUpdateParams::_internal_mutable_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Params>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::injective::exchange::v1beta1::Params* MsgUpdateParams::mutable_params() {
  ::injective::exchange::v1beta1::Params* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgUpdateParams.params)
  return _msg;
}
inline void MsgUpdateParams::set_allocated_params(::injective::exchange::v1beta1::Params* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgUpdateParams.params)
}

// -------------------------------------------------------------------

// MsgUpdateParamsResponse

// -------------------------------------------------------------------

// MsgDeposit

// string sender = 1 [json_name = "sender"];
inline void MsgDeposit::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgDeposit::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgDeposit.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgDeposit::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgDeposit.sender)
}
inline std::string* MsgDeposit::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgDeposit.sender)
  return _s;
}
inline const std::string& MsgDeposit::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgDeposit::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgDeposit::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgDeposit::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgDeposit.sender)
  return _impl_.sender_.Release();
}
inline void MsgDeposit::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgDeposit.sender)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void MsgDeposit::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgDeposit::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgDeposit.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgDeposit::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgDeposit.subaccount_id)
}
inline std::string* MsgDeposit::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgDeposit.subaccount_id)
  return _s;
}
inline const std::string& MsgDeposit::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void MsgDeposit::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgDeposit::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgDeposit::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgDeposit.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void MsgDeposit::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgDeposit.subaccount_id)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool MsgDeposit::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgDeposit::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgDeposit::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgDeposit.amount)
  return _internal_amount();
}
inline void MsgDeposit::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgDeposit.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgDeposit::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgDeposit::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgDeposit.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgDeposit::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgDeposit::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgDeposit.amount)
  return _msg;
}
inline void MsgDeposit::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgDeposit.amount)
}

// -------------------------------------------------------------------

// MsgDepositResponse

// -------------------------------------------------------------------

// MsgWithdraw

// string sender = 1 [json_name = "sender"];
inline void MsgWithdraw::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgWithdraw::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgWithdraw.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgWithdraw::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgWithdraw.sender)
}
inline std::string* MsgWithdraw::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgWithdraw.sender)
  return _s;
}
inline const std::string& MsgWithdraw::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgWithdraw::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgWithdraw::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgWithdraw::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgWithdraw.sender)
  return _impl_.sender_.Release();
}
inline void MsgWithdraw::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgWithdraw.sender)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void MsgWithdraw::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgWithdraw::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgWithdraw.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgWithdraw::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgWithdraw.subaccount_id)
}
inline std::string* MsgWithdraw::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgWithdraw.subaccount_id)
  return _s;
}
inline const std::string& MsgWithdraw::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void MsgWithdraw::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgWithdraw::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgWithdraw::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgWithdraw.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void MsgWithdraw::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgWithdraw.subaccount_id)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool MsgWithdraw::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgWithdraw::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgWithdraw::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgWithdraw.amount)
  return _internal_amount();
}
inline void MsgWithdraw::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgWithdraw.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdraw::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdraw::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgWithdraw.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdraw::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgWithdraw::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgWithdraw.amount)
  return _msg;
}
inline void MsgWithdraw::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgWithdraw.amount)
}

// -------------------------------------------------------------------

// MsgWithdrawResponse

// -------------------------------------------------------------------

// MsgCreateSpotLimitOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCreateSpotLimitOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateSpotLimitOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateSpotLimitOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.sender)
}
inline std::string* MsgCreateSpotLimitOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.sender)
  return _s;
}
inline const std::string& MsgCreateSpotLimitOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateSpotLimitOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateSpotLimitOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateSpotLimitOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateSpotLimitOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.sender)
}

// .injective.exchange.v1beta1.SpotOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
inline bool MsgCreateSpotLimitOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgCreateSpotLimitOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::SpotOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SpotOrder&>(
      ::injective::exchange::v1beta1::_SpotOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgCreateSpotLimitOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.order)
  return _internal_order();
}
inline void MsgCreateSpotLimitOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::SpotOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.order)
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotLimitOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotLimitOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotLimitOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SpotOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotLimitOrder::mutable_order() {
  ::injective::exchange::v1beta1::SpotOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.order)
  return _msg;
}
inline void MsgCreateSpotLimitOrder::set_allocated_order(::injective::exchange::v1beta1::SpotOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateSpotLimitOrder.order)
}

// -------------------------------------------------------------------

// MsgCreateSpotLimitOrderResponse

// string order_hash = 1 [json_name = "orderHash"];
inline void MsgCreateSpotLimitOrderResponse::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCreateSpotLimitOrderResponse::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateSpotLimitOrderResponse::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse.order_hash)
}
inline std::string* MsgCreateSpotLimitOrderResponse::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse.order_hash)
  return _s;
}
inline const std::string& MsgCreateSpotLimitOrderResponse::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCreateSpotLimitOrderResponse::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateSpotLimitOrderResponse::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateSpotLimitOrderResponse::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCreateSpotLimitOrderResponse::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse.order_hash)
}

// -------------------------------------------------------------------

// MsgBatchCreateSpotLimitOrders

// string sender = 1 [json_name = "sender"];
inline void MsgBatchCreateSpotLimitOrders::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgBatchCreateSpotLimitOrders::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBatchCreateSpotLimitOrders::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.sender)
}
inline std::string* MsgBatchCreateSpotLimitOrders::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.sender)
  return _s;
}
inline const std::string& MsgBatchCreateSpotLimitOrders::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgBatchCreateSpotLimitOrders::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBatchCreateSpotLimitOrders::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBatchCreateSpotLimitOrders::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.sender)
  return _impl_.sender_.Release();
}
inline void MsgBatchCreateSpotLimitOrders::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.sender)
}

// repeated .injective.exchange.v1beta1.SpotOrder orders = 2 [json_name = "orders", (.gogoproto.nullable) = false];
inline int MsgBatchCreateSpotLimitOrders::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int MsgBatchCreateSpotLimitOrders::orders_size() const {
  return _internal_orders_size();
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgBatchCreateSpotLimitOrders::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >*
MsgBatchCreateSpotLimitOrders::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgBatchCreateSpotLimitOrders::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgBatchCreateSpotLimitOrders::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgBatchCreateSpotLimitOrders::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgBatchCreateSpotLimitOrders::add_orders() {
  ::injective::exchange::v1beta1::SpotOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >&
MsgBatchCreateSpotLimitOrders::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>&
MsgBatchCreateSpotLimitOrders::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>*
MsgBatchCreateSpotLimitOrders::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// MsgBatchCreateSpotLimitOrdersResponse

// repeated string order_hashes = 1 [json_name = "orderHashes"];
inline int MsgBatchCreateSpotLimitOrdersResponse::_internal_order_hashes_size() const {
  return _impl_.order_hashes_.size();
}
inline int MsgBatchCreateSpotLimitOrdersResponse::order_hashes_size() const {
  return _internal_order_hashes_size();
}
inline void MsgBatchCreateSpotLimitOrdersResponse::clear_order_hashes() {
  _internal_mutable_order_hashes()->Clear();
}
inline std::string* MsgBatchCreateSpotLimitOrdersResponse::add_order_hashes() {
  std::string* _s = _internal_add_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
  return _s;
}
inline const std::string& MsgBatchCreateSpotLimitOrdersResponse::order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
  return _internal_order_hashes(index);
}
inline std::string* MsgBatchCreateSpotLimitOrdersResponse::mutable_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
  return _internal_mutable_order_hashes()->Mutable(index);
}
inline void MsgBatchCreateSpotLimitOrdersResponse::set_order_hashes(int index, const std::string& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::set_order_hashes(int index, std::string&& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::set_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::set_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::set_order_hashes(int index, absl::string_view value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::add_order_hashes(const std::string& value) {
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::add_order_hashes(std::string&& value) {
  _internal_mutable_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::add_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::add_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateSpotLimitOrdersResponse::add_order_hashes(absl::string_view value) {
  _internal_mutable_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchCreateSpotLimitOrdersResponse::order_hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
  return _internal_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchCreateSpotLimitOrdersResponse::mutable_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse.order_hashes)
  return _internal_mutable_order_hashes();
}
inline const std::string& MsgBatchCreateSpotLimitOrdersResponse::_internal_order_hashes(int index) const {
  return _internal_order_hashes().Get(index);
}
inline std::string* MsgBatchCreateSpotLimitOrdersResponse::_internal_add_order_hashes() {
  return _internal_mutable_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchCreateSpotLimitOrdersResponse::_internal_order_hashes() const {
  return _impl_.order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchCreateSpotLimitOrdersResponse::_internal_mutable_order_hashes() {
  return &_impl_.order_hashes_;
}

// -------------------------------------------------------------------

// MsgInstantSpotMarketLaunch

// string sender = 1 [json_name = "sender"];
inline void MsgInstantSpotMarketLaunch::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgInstantSpotMarketLaunch::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantSpotMarketLaunch::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.sender)
}
inline std::string* MsgInstantSpotMarketLaunch::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.sender)
  return _s;
}
inline const std::string& MsgInstantSpotMarketLaunch::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgInstantSpotMarketLaunch::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.sender)
  return _impl_.sender_.Release();
}
inline void MsgInstantSpotMarketLaunch::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.sender)
}

// string ticker = 2 [json_name = "ticker"];
inline void MsgInstantSpotMarketLaunch::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& MsgInstantSpotMarketLaunch::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantSpotMarketLaunch::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.ticker)
}
inline std::string* MsgInstantSpotMarketLaunch::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.ticker)
  return _s;
}
inline const std::string& MsgInstantSpotMarketLaunch::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void MsgInstantSpotMarketLaunch::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.ticker)
  return _impl_.ticker_.Release();
}
inline void MsgInstantSpotMarketLaunch::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.ticker)
}

// string base_denom = 3 [json_name = "baseDenom"];
inline void MsgInstantSpotMarketLaunch::clear_base_denom() {
  _impl_.base_denom_.ClearToEmpty();
}
inline const std::string& MsgInstantSpotMarketLaunch::base_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.base_denom)
  return _internal_base_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantSpotMarketLaunch::set_base_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.base_denom)
}
inline std::string* MsgInstantSpotMarketLaunch::mutable_base_denom() {
  std::string* _s = _internal_mutable_base_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.base_denom)
  return _s;
}
inline const std::string& MsgInstantSpotMarketLaunch::_internal_base_denom() const {
  return _impl_.base_denom_.Get();
}
inline void MsgInstantSpotMarketLaunch::_internal_set_base_denom(const std::string& value) {
  ;


  _impl_.base_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::_internal_mutable_base_denom() {
  ;
  return _impl_.base_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::release_base_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.base_denom)
  return _impl_.base_denom_.Release();
}
inline void MsgInstantSpotMarketLaunch::set_allocated_base_denom(std::string* value) {
  _impl_.base_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_denom_.IsDefault()) {
          _impl_.base_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.base_denom)
}

// string quote_denom = 4 [json_name = "quoteDenom"];
inline void MsgInstantSpotMarketLaunch::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& MsgInstantSpotMarketLaunch::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantSpotMarketLaunch::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.quote_denom)
}
inline std::string* MsgInstantSpotMarketLaunch::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.quote_denom)
  return _s;
}
inline const std::string& MsgInstantSpotMarketLaunch::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void MsgInstantSpotMarketLaunch::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void MsgInstantSpotMarketLaunch::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.quote_denom)
}

// string min_price_tick_size = 5 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantSpotMarketLaunch::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantSpotMarketLaunch::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantSpotMarketLaunch::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_price_tick_size)
}
inline std::string* MsgInstantSpotMarketLaunch::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_price_tick_size)
  return _s;
}
inline const std::string& MsgInstantSpotMarketLaunch::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void MsgInstantSpotMarketLaunch::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void MsgInstantSpotMarketLaunch::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_price_tick_size)
}

// string min_quantity_tick_size = 6 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantSpotMarketLaunch::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantSpotMarketLaunch::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantSpotMarketLaunch::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_quantity_tick_size)
}
inline std::string* MsgInstantSpotMarketLaunch::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_quantity_tick_size)
  return _s;
}
inline const std::string& MsgInstantSpotMarketLaunch::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void MsgInstantSpotMarketLaunch::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantSpotMarketLaunch::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void MsgInstantSpotMarketLaunch::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantSpotMarketLaunch.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// MsgInstantSpotMarketLaunchResponse

// -------------------------------------------------------------------

// MsgInstantPerpetualMarketLaunch

// string sender = 1 [json_name = "sender"];
inline void MsgInstantPerpetualMarketLaunch::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.sender)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.sender)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.sender)
  return _impl_.sender_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.sender)
}

// string ticker = 2 [json_name = "ticker"];
inline void MsgInstantPerpetualMarketLaunch::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.ticker)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.ticker)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.ticker)
  return _impl_.ticker_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.ticker)
}

// string quote_denom = 3 [json_name = "quoteDenom"];
inline void MsgInstantPerpetualMarketLaunch::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.quote_denom)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.quote_denom)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.quote_denom)
}

// string oracle_base = 4 [json_name = "oracleBase"];
inline void MsgInstantPerpetualMarketLaunch::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_base)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_base)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_base)
}

// string oracle_quote = 5 [json_name = "oracleQuote"];
inline void MsgInstantPerpetualMarketLaunch::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_quote)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_quote)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_quote)
}

// uint32 oracle_scale_factor = 6 [json_name = "oracleScaleFactor"];
inline void MsgInstantPerpetualMarketLaunch::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t MsgInstantPerpetualMarketLaunch::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void MsgInstantPerpetualMarketLaunch::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_scale_factor)
}
inline ::uint32_t MsgInstantPerpetualMarketLaunch::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// .injective.oracle.v1beta1.OracleType oracle_type = 7 [json_name = "oracleType"];
inline void MsgInstantPerpetualMarketLaunch::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType MsgInstantPerpetualMarketLaunch::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_type)
  return _internal_oracle_type();
}
inline void MsgInstantPerpetualMarketLaunch::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType MsgInstantPerpetualMarketLaunch::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// string maker_fee_rate = 8 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantPerpetualMarketLaunch::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maker_fee_rate)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maker_fee_rate)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maker_fee_rate)
}

// string taker_fee_rate = 9 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantPerpetualMarketLaunch::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.taker_fee_rate)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.taker_fee_rate)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.taker_fee_rate)
}

// string initial_margin_ratio = 10 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantPerpetualMarketLaunch::clear_initial_margin_ratio() {
  _impl_.initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.initial_margin_ratio)
  return _internal_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.initial_margin_ratio)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_initial_margin_ratio() {
  std::string* _s = _internal_mutable_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.initial_margin_ratio)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_initial_margin_ratio() const {
  return _impl_.initial_margin_ratio_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_initial_margin_ratio() {
  ;
  return _impl_.initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.initial_margin_ratio)
  return _impl_.initial_margin_ratio_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_initial_margin_ratio(std::string* value) {
  _impl_.initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_margin_ratio_.IsDefault()) {
          _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.initial_margin_ratio)
}

// string maintenance_margin_ratio = 11 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantPerpetualMarketLaunch::clear_maintenance_margin_ratio() {
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maintenance_margin_ratio)
  return _internal_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maintenance_margin_ratio)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maintenance_margin_ratio)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_maintenance_margin_ratio() const {
  return _impl_.maintenance_margin_ratio_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_maintenance_margin_ratio() {
  ;
  return _impl_.maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maintenance_margin_ratio)
  return _impl_.maintenance_margin_ratio_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_maintenance_margin_ratio(std::string* value) {
  _impl_.maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maintenance_margin_ratio_.IsDefault()) {
          _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.maintenance_margin_ratio)
}

// string min_price_tick_size = 12 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantPerpetualMarketLaunch::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_price_tick_size)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_price_tick_size)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_price_tick_size)
}

// string min_quantity_tick_size = 13 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantPerpetualMarketLaunch::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantPerpetualMarketLaunch::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantPerpetualMarketLaunch::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_quantity_tick_size)
}
inline std::string* MsgInstantPerpetualMarketLaunch::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_quantity_tick_size)
  return _s;
}
inline const std::string& MsgInstantPerpetualMarketLaunch::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void MsgInstantPerpetualMarketLaunch::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantPerpetualMarketLaunch::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void MsgInstantPerpetualMarketLaunch::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// MsgInstantPerpetualMarketLaunchResponse

// -------------------------------------------------------------------

// MsgInstantBinaryOptionsMarketLaunch

// string sender = 1 [json_name = "sender"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.sender)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.sender)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.sender)
  return _impl_.sender_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.sender)
}

// string ticker = 2 [json_name = "ticker"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.ticker)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.ticker)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.ticker)
  return _impl_.ticker_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.ticker)
}

// string oracle_symbol = 3 [json_name = "oracleSymbol"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_oracle_symbol() {
  _impl_.oracle_symbol_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::oracle_symbol() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_symbol)
  return _internal_oracle_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_oracle_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_symbol)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_oracle_symbol() {
  std::string* _s = _internal_mutable_oracle_symbol();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_symbol)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_oracle_symbol() const {
  return _impl_.oracle_symbol_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_oracle_symbol(const std::string& value) {
  ;


  _impl_.oracle_symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_oracle_symbol() {
  ;
  return _impl_.oracle_symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_oracle_symbol() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_symbol)
  return _impl_.oracle_symbol_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_oracle_symbol(std::string* value) {
  _impl_.oracle_symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_symbol_.IsDefault()) {
          _impl_.oracle_symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_symbol)
}

// string oracle_provider = 4 [json_name = "oracleProvider"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_oracle_provider() {
  _impl_.oracle_provider_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::oracle_provider() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_provider)
  return _internal_oracle_provider();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_oracle_provider(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_provider_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_provider)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_oracle_provider() {
  std::string* _s = _internal_mutable_oracle_provider();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_provider)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_oracle_provider() const {
  return _impl_.oracle_provider_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_oracle_provider(const std::string& value) {
  ;


  _impl_.oracle_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_oracle_provider() {
  ;
  return _impl_.oracle_provider_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_oracle_provider() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_provider)
  return _impl_.oracle_provider_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_oracle_provider(std::string* value) {
  _impl_.oracle_provider_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_provider_.IsDefault()) {
          _impl_.oracle_provider_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_provider)
}

// .injective.oracle.v1beta1.OracleType oracle_type = 5 [json_name = "oracleType"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType MsgInstantBinaryOptionsMarketLaunch::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_type)
  return _internal_oracle_type();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType MsgInstantBinaryOptionsMarketLaunch::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// uint32 oracle_scale_factor = 6 [json_name = "oracleScaleFactor"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t MsgInstantBinaryOptionsMarketLaunch::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.oracle_scale_factor)
}
inline ::uint32_t MsgInstantBinaryOptionsMarketLaunch::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// string maker_fee_rate = 7 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.maker_fee_rate)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.maker_fee_rate)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.maker_fee_rate)
}

// string taker_fee_rate = 8 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.taker_fee_rate)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.taker_fee_rate)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.taker_fee_rate)
}

// int64 expiration_timestamp = 9 [json_name = "expirationTimestamp"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t MsgInstantBinaryOptionsMarketLaunch::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.expiration_timestamp)
}
inline ::int64_t MsgInstantBinaryOptionsMarketLaunch::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// int64 settlement_timestamp = 10 [json_name = "settlementTimestamp"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_settlement_timestamp() {
  _impl_.settlement_timestamp_ = ::int64_t{0};
}
inline ::int64_t MsgInstantBinaryOptionsMarketLaunch::settlement_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.settlement_timestamp)
  return _internal_settlement_timestamp();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_settlement_timestamp(::int64_t value) {
  _internal_set_settlement_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.settlement_timestamp)
}
inline ::int64_t MsgInstantBinaryOptionsMarketLaunch::_internal_settlement_timestamp() const {
  return _impl_.settlement_timestamp_;
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_settlement_timestamp(::int64_t value) {
  ;
  _impl_.settlement_timestamp_ = value;
}

// string admin = 11 [json_name = "admin"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::admin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.admin)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.admin)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_admin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.admin)
  return _impl_.admin_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.admin)
}

// string quote_denom = 12 [json_name = "quoteDenom"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.quote_denom)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.quote_denom)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.quote_denom)
}

// string min_price_tick_size = 13 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_price_tick_size)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_price_tick_size)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_price_tick_size)
}

// string min_quantity_tick_size = 14 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantBinaryOptionsMarketLaunch::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantBinaryOptionsMarketLaunch::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_quantity_tick_size)
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_quantity_tick_size)
  return _s;
}
inline const std::string& MsgInstantBinaryOptionsMarketLaunch::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void MsgInstantBinaryOptionsMarketLaunch::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantBinaryOptionsMarketLaunch::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void MsgInstantBinaryOptionsMarketLaunch::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// MsgInstantBinaryOptionsMarketLaunchResponse

// -------------------------------------------------------------------

// MsgInstantExpiryFuturesMarketLaunch

// string sender = 1 [json_name = "sender"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.sender)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.sender)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.sender)
  return _impl_.sender_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.sender)
}

// string ticker = 2 [json_name = "ticker"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.ticker)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.ticker)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.ticker)
  return _impl_.ticker_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.ticker)
}

// string quote_denom = 3 [json_name = "quoteDenom"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.quote_denom)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.quote_denom)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.quote_denom)
}

// string oracle_base = 4 [json_name = "oracleBase"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_base)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_base)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_base)
}

// string oracle_quote = 5 [json_name = "oracleQuote"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_quote)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_quote)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_quote)
}

// .injective.oracle.v1beta1.OracleType oracle_type = 6 [json_name = "oracleType"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType MsgInstantExpiryFuturesMarketLaunch::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_type)
  return _internal_oracle_type();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType MsgInstantExpiryFuturesMarketLaunch::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t MsgInstantExpiryFuturesMarketLaunch::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.oracle_scale_factor)
}
inline ::uint32_t MsgInstantExpiryFuturesMarketLaunch::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// int64 expiry = 8 [json_name = "expiry"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_expiry() {
  _impl_.expiry_ = ::int64_t{0};
}
inline ::int64_t MsgInstantExpiryFuturesMarketLaunch::expiry() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.expiry)
  return _internal_expiry();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_expiry(::int64_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.expiry)
}
inline ::int64_t MsgInstantExpiryFuturesMarketLaunch::_internal_expiry() const {
  return _impl_.expiry_;
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_expiry(::int64_t value) {
  ;
  _impl_.expiry_ = value;
}

// string maker_fee_rate = 9 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maker_fee_rate)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maker_fee_rate)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maker_fee_rate)
}

// string taker_fee_rate = 10 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.taker_fee_rate)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.taker_fee_rate)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.taker_fee_rate)
}

// string initial_margin_ratio = 11 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_initial_margin_ratio() {
  _impl_.initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.initial_margin_ratio)
  return _internal_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.initial_margin_ratio)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_initial_margin_ratio() {
  std::string* _s = _internal_mutable_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.initial_margin_ratio)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_initial_margin_ratio() const {
  return _impl_.initial_margin_ratio_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_initial_margin_ratio() {
  ;
  return _impl_.initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.initial_margin_ratio)
  return _impl_.initial_margin_ratio_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_initial_margin_ratio(std::string* value) {
  _impl_.initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_margin_ratio_.IsDefault()) {
          _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.initial_margin_ratio)
}

// string maintenance_margin_ratio = 12 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_maintenance_margin_ratio() {
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maintenance_margin_ratio)
  return _internal_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maintenance_margin_ratio)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maintenance_margin_ratio)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_maintenance_margin_ratio() const {
  return _impl_.maintenance_margin_ratio_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_maintenance_margin_ratio() {
  ;
  return _impl_.maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maintenance_margin_ratio)
  return _impl_.maintenance_margin_ratio_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_maintenance_margin_ratio(std::string* value) {
  _impl_.maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maintenance_margin_ratio_.IsDefault()) {
          _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.maintenance_margin_ratio)
}

// string min_price_tick_size = 13 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_price_tick_size)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_price_tick_size)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_price_tick_size)
}

// string min_quantity_tick_size = 14 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgInstantExpiryFuturesMarketLaunch::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgInstantExpiryFuturesMarketLaunch::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_quantity_tick_size)
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_quantity_tick_size)
  return _s;
}
inline const std::string& MsgInstantExpiryFuturesMarketLaunch::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void MsgInstantExpiryFuturesMarketLaunch::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgInstantExpiryFuturesMarketLaunch::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void MsgInstantExpiryFuturesMarketLaunch::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// MsgInstantExpiryFuturesMarketLaunchResponse

// -------------------------------------------------------------------

// MsgCreateSpotMarketOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCreateSpotMarketOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateSpotMarketOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateSpotMarketOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.sender)
}
inline std::string* MsgCreateSpotMarketOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.sender)
  return _s;
}
inline const std::string& MsgCreateSpotMarketOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateSpotMarketOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateSpotMarketOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateSpotMarketOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateSpotMarketOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.sender)
}

// .injective.exchange.v1beta1.SpotOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
inline bool MsgCreateSpotMarketOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgCreateSpotMarketOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::SpotOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SpotOrder&>(
      ::injective::exchange::v1beta1::_SpotOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgCreateSpotMarketOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.order)
  return _internal_order();
}
inline void MsgCreateSpotMarketOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::SpotOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.order)
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotMarketOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotMarketOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotMarketOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SpotOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgCreateSpotMarketOrder::mutable_order() {
  ::injective::exchange::v1beta1::SpotOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.order)
  return _msg;
}
inline void MsgCreateSpotMarketOrder::set_allocated_order(::injective::exchange::v1beta1::SpotOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateSpotMarketOrder.order)
}

// -------------------------------------------------------------------

// MsgCreateSpotMarketOrderResponse

// string order_hash = 1 [json_name = "orderHash"];
inline void MsgCreateSpotMarketOrderResponse::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCreateSpotMarketOrderResponse::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateSpotMarketOrderResponse::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.order_hash)
}
inline std::string* MsgCreateSpotMarketOrderResponse::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.order_hash)
  return _s;
}
inline const std::string& MsgCreateSpotMarketOrderResponse::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCreateSpotMarketOrderResponse::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateSpotMarketOrderResponse::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateSpotMarketOrderResponse::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCreateSpotMarketOrderResponse::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.order_hash)
}

// .injective.exchange.v1beta1.SpotMarketOrderResults results = 2 [json_name = "results", (.gogoproto.nullable) = true];
inline bool MsgCreateSpotMarketOrderResponse::has_results() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.results_ != nullptr);
  return value;
}
inline void MsgCreateSpotMarketOrderResponse::clear_results() {
  if (_impl_.results_ != nullptr) _impl_.results_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::SpotMarketOrderResults& MsgCreateSpotMarketOrderResponse::_internal_results() const {
  const ::injective::exchange::v1beta1::SpotMarketOrderResults* p = _impl_.results_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SpotMarketOrderResults&>(
      ::injective::exchange::v1beta1::_SpotMarketOrderResults_default_instance_);
}
inline const ::injective::exchange::v1beta1::SpotMarketOrderResults& MsgCreateSpotMarketOrderResponse::results() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.results)
  return _internal_results();
}
inline void MsgCreateSpotMarketOrderResponse::unsafe_arena_set_allocated_results(
    ::injective::exchange::v1beta1::SpotMarketOrderResults* results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.results_);
  }
  _impl_.results_ = results;
  if (results) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.results)
}
inline ::injective::exchange::v1beta1::SpotMarketOrderResults* MsgCreateSpotMarketOrderResponse::release_results() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarketOrderResults* temp = _impl_.results_;
  _impl_.results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarketOrderResults* MsgCreateSpotMarketOrderResponse::unsafe_arena_release_results() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.results)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarketOrderResults* temp = _impl_.results_;
  _impl_.results_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarketOrderResults* MsgCreateSpotMarketOrderResponse::_internal_mutable_results() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.results_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarketOrderResults>(GetArenaForAllocation());
    _impl_.results_ = p;
  }
  return _impl_.results_;
}
inline ::injective::exchange::v1beta1::SpotMarketOrderResults* MsgCreateSpotMarketOrderResponse::mutable_results() {
  ::injective::exchange::v1beta1::SpotMarketOrderResults* _msg = _internal_mutable_results();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.results)
  return _msg;
}
inline void MsgCreateSpotMarketOrderResponse::set_allocated_results(::injective::exchange::v1beta1::SpotMarketOrderResults* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.results_;
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(results);
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.results_ = results;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse.results)
}

// -------------------------------------------------------------------

// SpotMarketOrderResults

// string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketOrderResults::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& SpotMarketOrderResults::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrderResults.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketOrderResults::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketOrderResults.quantity)
}
inline std::string* SpotMarketOrderResults::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketOrderResults.quantity)
  return _s;
}
inline const std::string& SpotMarketOrderResults::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void SpotMarketOrderResults::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketOrderResults::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketOrderResults::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketOrderResults.quantity)
  return _impl_.quantity_.Release();
}
inline void SpotMarketOrderResults::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketOrderResults.quantity)
}

// string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketOrderResults::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& SpotMarketOrderResults::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrderResults.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketOrderResults::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketOrderResults.price)
}
inline std::string* SpotMarketOrderResults::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketOrderResults.price)
  return _s;
}
inline const std::string& SpotMarketOrderResults::_internal_price() const {
  return _impl_.price_.Get();
}
inline void SpotMarketOrderResults::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketOrderResults::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketOrderResults::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketOrderResults.price)
  return _impl_.price_.Release();
}
inline void SpotMarketOrderResults::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketOrderResults.price)
}

// string fee = 3 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketOrderResults::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& SpotMarketOrderResults::fee() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketOrderResults.fee)
  return _internal_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketOrderResults::set_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketOrderResults.fee)
}
inline std::string* SpotMarketOrderResults::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketOrderResults.fee)
  return _s;
}
inline const std::string& SpotMarketOrderResults::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void SpotMarketOrderResults::_internal_set_fee(const std::string& value) {
  ;


  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketOrderResults::_internal_mutable_fee() {
  ;
  return _impl_.fee_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketOrderResults::release_fee() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketOrderResults.fee)
  return _impl_.fee_.Release();
}
inline void SpotMarketOrderResults::set_allocated_fee(std::string* value) {
  _impl_.fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_.IsDefault()) {
          _impl_.fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketOrderResults.fee)
}

// -------------------------------------------------------------------

// MsgCreateDerivativeLimitOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCreateDerivativeLimitOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateDerivativeLimitOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateDerivativeLimitOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.sender)
}
inline std::string* MsgCreateDerivativeLimitOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.sender)
  return _s;
}
inline const std::string& MsgCreateDerivativeLimitOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateDerivativeLimitOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeLimitOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeLimitOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateDerivativeLimitOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.sender)
}

// .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
inline bool MsgCreateDerivativeLimitOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateDerivativeLimitOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::DerivativeOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeOrder&>(
      ::injective::exchange::v1beta1::_DerivativeOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateDerivativeLimitOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.order)
  return _internal_order();
}
inline void MsgCreateDerivativeLimitOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::DerivativeOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.order)
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeLimitOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeLimitOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeLimitOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeLimitOrder::mutable_order() {
  ::injective::exchange::v1beta1::DerivativeOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.order)
  return _msg;
}
inline void MsgCreateDerivativeLimitOrder::set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder.order)
}

// -------------------------------------------------------------------

// MsgCreateDerivativeLimitOrderResponse

// string order_hash = 1 [json_name = "orderHash"];
inline void MsgCreateDerivativeLimitOrderResponse::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCreateDerivativeLimitOrderResponse::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateDerivativeLimitOrderResponse::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse.order_hash)
}
inline std::string* MsgCreateDerivativeLimitOrderResponse::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse.order_hash)
  return _s;
}
inline const std::string& MsgCreateDerivativeLimitOrderResponse::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCreateDerivativeLimitOrderResponse::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeLimitOrderResponse::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeLimitOrderResponse::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCreateDerivativeLimitOrderResponse::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse.order_hash)
}

// -------------------------------------------------------------------

// MsgCreateBinaryOptionsLimitOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCreateBinaryOptionsLimitOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateBinaryOptionsLimitOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateBinaryOptionsLimitOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.sender)
}
inline std::string* MsgCreateBinaryOptionsLimitOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.sender)
  return _s;
}
inline const std::string& MsgCreateBinaryOptionsLimitOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateBinaryOptionsLimitOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsLimitOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsLimitOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateBinaryOptionsLimitOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.sender)
}

// .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
inline bool MsgCreateBinaryOptionsLimitOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateBinaryOptionsLimitOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::DerivativeOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeOrder&>(
      ::injective::exchange::v1beta1::_DerivativeOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateBinaryOptionsLimitOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.order)
  return _internal_order();
}
inline void MsgCreateBinaryOptionsLimitOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::DerivativeOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.order)
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsLimitOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsLimitOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsLimitOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsLimitOrder::mutable_order() {
  ::injective::exchange::v1beta1::DerivativeOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.order)
  return _msg;
}
inline void MsgCreateBinaryOptionsLimitOrder::set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder.order)
}

// -------------------------------------------------------------------

// MsgCreateBinaryOptionsLimitOrderResponse

// string order_hash = 1 [json_name = "orderHash"];
inline void MsgCreateBinaryOptionsLimitOrderResponse::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCreateBinaryOptionsLimitOrderResponse::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateBinaryOptionsLimitOrderResponse::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse.order_hash)
}
inline std::string* MsgCreateBinaryOptionsLimitOrderResponse::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse.order_hash)
  return _s;
}
inline const std::string& MsgCreateBinaryOptionsLimitOrderResponse::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCreateBinaryOptionsLimitOrderResponse::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsLimitOrderResponse::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsLimitOrderResponse::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCreateBinaryOptionsLimitOrderResponse::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse.order_hash)
}

// -------------------------------------------------------------------

// MsgBatchCreateDerivativeLimitOrders

// string sender = 1 [json_name = "sender"];
inline void MsgBatchCreateDerivativeLimitOrders::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgBatchCreateDerivativeLimitOrders::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBatchCreateDerivativeLimitOrders::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.sender)
}
inline std::string* MsgBatchCreateDerivativeLimitOrders::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.sender)
  return _s;
}
inline const std::string& MsgBatchCreateDerivativeLimitOrders::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgBatchCreateDerivativeLimitOrders::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBatchCreateDerivativeLimitOrders::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBatchCreateDerivativeLimitOrders::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.sender)
  return _impl_.sender_.Release();
}
inline void MsgBatchCreateDerivativeLimitOrders::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.sender)
}

// repeated .injective.exchange.v1beta1.DerivativeOrder orders = 2 [json_name = "orders", (.gogoproto.nullable) = false];
inline int MsgBatchCreateDerivativeLimitOrders::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int MsgBatchCreateDerivativeLimitOrders::orders_size() const {
  return _internal_orders_size();
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchCreateDerivativeLimitOrders::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >*
MsgBatchCreateDerivativeLimitOrders::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgBatchCreateDerivativeLimitOrders::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgBatchCreateDerivativeLimitOrders::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchCreateDerivativeLimitOrders::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchCreateDerivativeLimitOrders::add_orders() {
  ::injective::exchange::v1beta1::DerivativeOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >&
MsgBatchCreateDerivativeLimitOrders::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>&
MsgBatchCreateDerivativeLimitOrders::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>*
MsgBatchCreateDerivativeLimitOrders::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// MsgBatchCreateDerivativeLimitOrdersResponse

// repeated string order_hashes = 1 [json_name = "orderHashes"];
inline int MsgBatchCreateDerivativeLimitOrdersResponse::_internal_order_hashes_size() const {
  return _impl_.order_hashes_.size();
}
inline int MsgBatchCreateDerivativeLimitOrdersResponse::order_hashes_size() const {
  return _internal_order_hashes_size();
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::clear_order_hashes() {
  _internal_mutable_order_hashes()->Clear();
}
inline std::string* MsgBatchCreateDerivativeLimitOrdersResponse::add_order_hashes() {
  std::string* _s = _internal_add_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
  return _s;
}
inline const std::string& MsgBatchCreateDerivativeLimitOrdersResponse::order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
  return _internal_order_hashes(index);
}
inline std::string* MsgBatchCreateDerivativeLimitOrdersResponse::mutable_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
  return _internal_mutable_order_hashes()->Mutable(index);
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::set_order_hashes(int index, const std::string& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::set_order_hashes(int index, std::string&& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::set_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::set_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::set_order_hashes(int index, absl::string_view value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::add_order_hashes(const std::string& value) {
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::add_order_hashes(std::string&& value) {
  _internal_mutable_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::add_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::add_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline void MsgBatchCreateDerivativeLimitOrdersResponse::add_order_hashes(absl::string_view value) {
  _internal_mutable_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchCreateDerivativeLimitOrdersResponse::order_hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
  return _internal_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchCreateDerivativeLimitOrdersResponse::mutable_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse.order_hashes)
  return _internal_mutable_order_hashes();
}
inline const std::string& MsgBatchCreateDerivativeLimitOrdersResponse::_internal_order_hashes(int index) const {
  return _internal_order_hashes().Get(index);
}
inline std::string* MsgBatchCreateDerivativeLimitOrdersResponse::_internal_add_order_hashes() {
  return _internal_mutable_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchCreateDerivativeLimitOrdersResponse::_internal_order_hashes() const {
  return _impl_.order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchCreateDerivativeLimitOrdersResponse::_internal_mutable_order_hashes() {
  return &_impl_.order_hashes_;
}

// -------------------------------------------------------------------

// MsgCancelSpotOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCancelSpotOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCancelSpotOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelSpotOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelSpotOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelSpotOrder.sender)
}
inline std::string* MsgCancelSpotOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelSpotOrder.sender)
  return _s;
}
inline const std::string& MsgCancelSpotOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCancelSpotOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelSpotOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCancelSpotOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelSpotOrder.sender)
}

// string market_id = 2 [json_name = "marketId"];
inline void MsgCancelSpotOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MsgCancelSpotOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelSpotOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelSpotOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelSpotOrder.market_id)
}
inline std::string* MsgCancelSpotOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelSpotOrder.market_id)
  return _s;
}
inline const std::string& MsgCancelSpotOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MsgCancelSpotOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelSpotOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void MsgCancelSpotOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelSpotOrder.market_id)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void MsgCancelSpotOrder::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgCancelSpotOrder::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelSpotOrder.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelSpotOrder::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelSpotOrder.subaccount_id)
}
inline std::string* MsgCancelSpotOrder::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelSpotOrder.subaccount_id)
  return _s;
}
inline const std::string& MsgCancelSpotOrder::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void MsgCancelSpotOrder::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelSpotOrder.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void MsgCancelSpotOrder::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelSpotOrder.subaccount_id)
}

// string order_hash = 4 [json_name = "orderHash"];
inline void MsgCancelSpotOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCancelSpotOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelSpotOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelSpotOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelSpotOrder.order_hash)
}
inline std::string* MsgCancelSpotOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelSpotOrder.order_hash)
  return _s;
}
inline const std::string& MsgCancelSpotOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCancelSpotOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelSpotOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelSpotOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCancelSpotOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelSpotOrder.order_hash)
}

// -------------------------------------------------------------------

// MsgCancelSpotOrderResponse

// -------------------------------------------------------------------

// MsgBatchCancelSpotOrders

// string sender = 1 [json_name = "sender"];
inline void MsgBatchCancelSpotOrders::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgBatchCancelSpotOrders::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBatchCancelSpotOrders::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.sender)
}
inline std::string* MsgBatchCancelSpotOrders::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.sender)
  return _s;
}
inline const std::string& MsgBatchCancelSpotOrders::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgBatchCancelSpotOrders::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBatchCancelSpotOrders::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBatchCancelSpotOrders::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.sender)
  return _impl_.sender_.Release();
}
inline void MsgBatchCancelSpotOrders::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.sender)
}

// repeated .injective.exchange.v1beta1.OrderData data = 2 [json_name = "data", (.gogoproto.nullable) = false];
inline int MsgBatchCancelSpotOrders::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int MsgBatchCancelSpotOrders::data_size() const {
  return _internal_data_size();
}
inline void MsgBatchCancelSpotOrders::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelSpotOrders::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
MsgBatchCancelSpotOrders::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.data)
  return _internal_mutable_data();
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchCancelSpotOrders::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchCancelSpotOrders::data(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.data)
  return _internal_data(index);
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelSpotOrders::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelSpotOrders::add_data() {
  ::injective::exchange::v1beta1::OrderData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
MsgBatchCancelSpotOrders::data() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCancelSpotOrders.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>&
MsgBatchCancelSpotOrders::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>*
MsgBatchCancelSpotOrders::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// MsgBatchCancelSpotOrdersResponse

// repeated bool success = 1 [json_name = "success"];
inline int MsgBatchCancelSpotOrdersResponse::_internal_success_size() const {
  return _impl_.success_.size();
}
inline int MsgBatchCancelSpotOrdersResponse::success_size() const {
  return _internal_success_size();
}
inline void MsgBatchCancelSpotOrdersResponse::clear_success() {
  _internal_mutable_success()->Clear();
}
inline bool MsgBatchCancelSpotOrdersResponse::success(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse.success)
  return _internal_success(index);
}
inline void MsgBatchCancelSpotOrdersResponse::set_success(int index, bool value) {
  _internal_mutable_success()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse.success)
}
inline void MsgBatchCancelSpotOrdersResponse::add_success(bool value) {
  _internal_add_success(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse.success)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchCancelSpotOrdersResponse::success() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse.success)
  return _internal_success();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchCancelSpotOrdersResponse::mutable_success() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse.success)
  return _internal_mutable_success();
}

inline bool MsgBatchCancelSpotOrdersResponse::_internal_success(int index) const {
  return _internal_success().Get(index);
}
inline void MsgBatchCancelSpotOrdersResponse::_internal_add_success(bool value) {
  _internal_mutable_success()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchCancelSpotOrdersResponse::_internal_success() const {
  return _impl_.success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchCancelSpotOrdersResponse::_internal_mutable_success() {
  return &_impl_.success_;
}

// -------------------------------------------------------------------

// MsgBatchCancelBinaryOptionsOrders

// string sender = 1 [json_name = "sender"];
inline void MsgBatchCancelBinaryOptionsOrders::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgBatchCancelBinaryOptionsOrders::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBatchCancelBinaryOptionsOrders::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.sender)
}
inline std::string* MsgBatchCancelBinaryOptionsOrders::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.sender)
  return _s;
}
inline const std::string& MsgBatchCancelBinaryOptionsOrders::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgBatchCancelBinaryOptionsOrders::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBatchCancelBinaryOptionsOrders::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBatchCancelBinaryOptionsOrders::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.sender)
  return _impl_.sender_.Release();
}
inline void MsgBatchCancelBinaryOptionsOrders::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.sender)
}

// repeated .injective.exchange.v1beta1.OrderData data = 2 [json_name = "data", (.gogoproto.nullable) = false];
inline int MsgBatchCancelBinaryOptionsOrders::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int MsgBatchCancelBinaryOptionsOrders::data_size() const {
  return _internal_data_size();
}
inline void MsgBatchCancelBinaryOptionsOrders::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelBinaryOptionsOrders::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
MsgBatchCancelBinaryOptionsOrders::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.data)
  return _internal_mutable_data();
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchCancelBinaryOptionsOrders::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchCancelBinaryOptionsOrders::data(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.data)
  return _internal_data(index);
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelBinaryOptionsOrders::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelBinaryOptionsOrders::add_data() {
  ::injective::exchange::v1beta1::OrderData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
MsgBatchCancelBinaryOptionsOrders::data() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>&
MsgBatchCancelBinaryOptionsOrders::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>*
MsgBatchCancelBinaryOptionsOrders::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// MsgBatchCancelBinaryOptionsOrdersResponse

// repeated bool success = 1 [json_name = "success"];
inline int MsgBatchCancelBinaryOptionsOrdersResponse::_internal_success_size() const {
  return _impl_.success_.size();
}
inline int MsgBatchCancelBinaryOptionsOrdersResponse::success_size() const {
  return _internal_success_size();
}
inline void MsgBatchCancelBinaryOptionsOrdersResponse::clear_success() {
  _internal_mutable_success()->Clear();
}
inline bool MsgBatchCancelBinaryOptionsOrdersResponse::success(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse.success)
  return _internal_success(index);
}
inline void MsgBatchCancelBinaryOptionsOrdersResponse::set_success(int index, bool value) {
  _internal_mutable_success()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse.success)
}
inline void MsgBatchCancelBinaryOptionsOrdersResponse::add_success(bool value) {
  _internal_add_success(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse.success)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchCancelBinaryOptionsOrdersResponse::success() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse.success)
  return _internal_success();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchCancelBinaryOptionsOrdersResponse::mutable_success() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse.success)
  return _internal_mutable_success();
}

inline bool MsgBatchCancelBinaryOptionsOrdersResponse::_internal_success(int index) const {
  return _internal_success().Get(index);
}
inline void MsgBatchCancelBinaryOptionsOrdersResponse::_internal_add_success(bool value) {
  _internal_mutable_success()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchCancelBinaryOptionsOrdersResponse::_internal_success() const {
  return _impl_.success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchCancelBinaryOptionsOrdersResponse::_internal_mutable_success() {
  return &_impl_.success_;
}

// -------------------------------------------------------------------

// MsgBatchUpdateOrders

// string sender = 1 [json_name = "sender"];
inline void MsgBatchUpdateOrders::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgBatchUpdateOrders::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBatchUpdateOrders::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.sender)
}
inline std::string* MsgBatchUpdateOrders::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.sender)
  return _s;
}
inline const std::string& MsgBatchUpdateOrders::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgBatchUpdateOrders::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBatchUpdateOrders::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBatchUpdateOrders::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgBatchUpdateOrders.sender)
  return _impl_.sender_.Release();
}
inline void MsgBatchUpdateOrders::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgBatchUpdateOrders.sender)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void MsgBatchUpdateOrders::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgBatchUpdateOrders::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBatchUpdateOrders::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.subaccount_id)
}
inline std::string* MsgBatchUpdateOrders::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.subaccount_id)
  return _s;
}
inline const std::string& MsgBatchUpdateOrders::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void MsgBatchUpdateOrders::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBatchUpdateOrders::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBatchUpdateOrders::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgBatchUpdateOrders.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void MsgBatchUpdateOrders::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgBatchUpdateOrders.subaccount_id)
}

// repeated string spot_market_ids_to_cancel_all = 3 [json_name = "spotMarketIdsToCancelAll"];
inline int MsgBatchUpdateOrders::_internal_spot_market_ids_to_cancel_all_size() const {
  return _impl_.spot_market_ids_to_cancel_all_.size();
}
inline int MsgBatchUpdateOrders::spot_market_ids_to_cancel_all_size() const {
  return _internal_spot_market_ids_to_cancel_all_size();
}
inline void MsgBatchUpdateOrders::clear_spot_market_ids_to_cancel_all() {
  _internal_mutable_spot_market_ids_to_cancel_all()->Clear();
}
inline std::string* MsgBatchUpdateOrders::add_spot_market_ids_to_cancel_all() {
  std::string* _s = _internal_add_spot_market_ids_to_cancel_all();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
  return _s;
}
inline const std::string& MsgBatchUpdateOrders::spot_market_ids_to_cancel_all(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
  return _internal_spot_market_ids_to_cancel_all(index);
}
inline std::string* MsgBatchUpdateOrders::mutable_spot_market_ids_to_cancel_all(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
  return _internal_mutable_spot_market_ids_to_cancel_all()->Mutable(index);
}
inline void MsgBatchUpdateOrders::set_spot_market_ids_to_cancel_all(int index, const std::string& value) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_spot_market_ids_to_cancel_all(int index, std::string&& value) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_spot_market_ids_to_cancel_all(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_market_ids_to_cancel_all()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_spot_market_ids_to_cancel_all(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_spot_market_ids_to_cancel_all(int index, absl::string_view value) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_spot_market_ids_to_cancel_all(const std::string& value) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_spot_market_ids_to_cancel_all(std::string&& value) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_spot_market_ids_to_cancel_all(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_market_ids_to_cancel_all()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_spot_market_ids_to_cancel_all(const char* value, std::size_t size) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_spot_market_ids_to_cancel_all(absl::string_view value) {
  _internal_mutable_spot_market_ids_to_cancel_all()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrders::spot_market_ids_to_cancel_all() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
  return _internal_spot_market_ids_to_cancel_all();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchUpdateOrders::mutable_spot_market_ids_to_cancel_all() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_market_ids_to_cancel_all)
  return _internal_mutable_spot_market_ids_to_cancel_all();
}
inline const std::string& MsgBatchUpdateOrders::_internal_spot_market_ids_to_cancel_all(int index) const {
  return _internal_spot_market_ids_to_cancel_all().Get(index);
}
inline std::string* MsgBatchUpdateOrders::_internal_add_spot_market_ids_to_cancel_all() {
  return _internal_mutable_spot_market_ids_to_cancel_all()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrders::_internal_spot_market_ids_to_cancel_all() const {
  return _impl_.spot_market_ids_to_cancel_all_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchUpdateOrders::_internal_mutable_spot_market_ids_to_cancel_all() {
  return &_impl_.spot_market_ids_to_cancel_all_;
}

// repeated string derivative_market_ids_to_cancel_all = 4 [json_name = "derivativeMarketIdsToCancelAll"];
inline int MsgBatchUpdateOrders::_internal_derivative_market_ids_to_cancel_all_size() const {
  return _impl_.derivative_market_ids_to_cancel_all_.size();
}
inline int MsgBatchUpdateOrders::derivative_market_ids_to_cancel_all_size() const {
  return _internal_derivative_market_ids_to_cancel_all_size();
}
inline void MsgBatchUpdateOrders::clear_derivative_market_ids_to_cancel_all() {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Clear();
}
inline std::string* MsgBatchUpdateOrders::add_derivative_market_ids_to_cancel_all() {
  std::string* _s = _internal_add_derivative_market_ids_to_cancel_all();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
  return _s;
}
inline const std::string& MsgBatchUpdateOrders::derivative_market_ids_to_cancel_all(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
  return _internal_derivative_market_ids_to_cancel_all(index);
}
inline std::string* MsgBatchUpdateOrders::mutable_derivative_market_ids_to_cancel_all(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
  return _internal_mutable_derivative_market_ids_to_cancel_all()->Mutable(index);
}
inline void MsgBatchUpdateOrders::set_derivative_market_ids_to_cancel_all(int index, const std::string& value) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_derivative_market_ids_to_cancel_all(int index, std::string&& value) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_derivative_market_ids_to_cancel_all(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_market_ids_to_cancel_all()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_derivative_market_ids_to_cancel_all(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_derivative_market_ids_to_cancel_all(int index, absl::string_view value) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_derivative_market_ids_to_cancel_all(const std::string& value) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_derivative_market_ids_to_cancel_all(std::string&& value) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_derivative_market_ids_to_cancel_all(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_market_ids_to_cancel_all()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_derivative_market_ids_to_cancel_all(const char* value, std::size_t size) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_derivative_market_ids_to_cancel_all(absl::string_view value) {
  _internal_mutable_derivative_market_ids_to_cancel_all()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrders::derivative_market_ids_to_cancel_all() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
  return _internal_derivative_market_ids_to_cancel_all();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchUpdateOrders::mutable_derivative_market_ids_to_cancel_all() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_market_ids_to_cancel_all)
  return _internal_mutable_derivative_market_ids_to_cancel_all();
}
inline const std::string& MsgBatchUpdateOrders::_internal_derivative_market_ids_to_cancel_all(int index) const {
  return _internal_derivative_market_ids_to_cancel_all().Get(index);
}
inline std::string* MsgBatchUpdateOrders::_internal_add_derivative_market_ids_to_cancel_all() {
  return _internal_mutable_derivative_market_ids_to_cancel_all()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrders::_internal_derivative_market_ids_to_cancel_all() const {
  return _impl_.derivative_market_ids_to_cancel_all_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchUpdateOrders::_internal_mutable_derivative_market_ids_to_cancel_all() {
  return &_impl_.derivative_market_ids_to_cancel_all_;
}

// repeated .injective.exchange.v1beta1.OrderData spot_orders_to_cancel = 5 [json_name = "spotOrdersToCancel", (.gogoproto.nullable) = true];
inline int MsgBatchUpdateOrders::_internal_spot_orders_to_cancel_size() const {
  return _impl_.spot_orders_to_cancel_.size();
}
inline int MsgBatchUpdateOrders::spot_orders_to_cancel_size() const {
  return _internal_spot_orders_to_cancel_size();
}
inline void MsgBatchUpdateOrders::clear_spot_orders_to_cancel() {
  _internal_mutable_spot_orders_to_cancel()->Clear();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::mutable_spot_orders_to_cancel(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_cancel)
  return _internal_mutable_spot_orders_to_cancel()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
MsgBatchUpdateOrders::mutable_spot_orders_to_cancel() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_cancel)
  return _internal_mutable_spot_orders_to_cancel();
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchUpdateOrders::_internal_spot_orders_to_cancel(int index) const {
  return _internal_spot_orders_to_cancel().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchUpdateOrders::spot_orders_to_cancel(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_cancel)
  return _internal_spot_orders_to_cancel(index);
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::_internal_add_spot_orders_to_cancel() {
  return _internal_mutable_spot_orders_to_cancel()->Add();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::add_spot_orders_to_cancel() {
  ::injective::exchange::v1beta1::OrderData* _add = _internal_add_spot_orders_to_cancel();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_cancel)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
MsgBatchUpdateOrders::spot_orders_to_cancel() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_cancel)
  return _internal_spot_orders_to_cancel();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>&
MsgBatchUpdateOrders::_internal_spot_orders_to_cancel() const {
  return _impl_.spot_orders_to_cancel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>*
MsgBatchUpdateOrders::_internal_mutable_spot_orders_to_cancel() {
  return &_impl_.spot_orders_to_cancel_;
}

// repeated .injective.exchange.v1beta1.OrderData derivative_orders_to_cancel = 6 [json_name = "derivativeOrdersToCancel", (.gogoproto.nullable) = true];
inline int MsgBatchUpdateOrders::_internal_derivative_orders_to_cancel_size() const {
  return _impl_.derivative_orders_to_cancel_.size();
}
inline int MsgBatchUpdateOrders::derivative_orders_to_cancel_size() const {
  return _internal_derivative_orders_to_cancel_size();
}
inline void MsgBatchUpdateOrders::clear_derivative_orders_to_cancel() {
  _internal_mutable_derivative_orders_to_cancel()->Clear();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::mutable_derivative_orders_to_cancel(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_cancel)
  return _internal_mutable_derivative_orders_to_cancel()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
MsgBatchUpdateOrders::mutable_derivative_orders_to_cancel() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_cancel)
  return _internal_mutable_derivative_orders_to_cancel();
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchUpdateOrders::_internal_derivative_orders_to_cancel(int index) const {
  return _internal_derivative_orders_to_cancel().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchUpdateOrders::derivative_orders_to_cancel(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_cancel)
  return _internal_derivative_orders_to_cancel(index);
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::_internal_add_derivative_orders_to_cancel() {
  return _internal_mutable_derivative_orders_to_cancel()->Add();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::add_derivative_orders_to_cancel() {
  ::injective::exchange::v1beta1::OrderData* _add = _internal_add_derivative_orders_to_cancel();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_cancel)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
MsgBatchUpdateOrders::derivative_orders_to_cancel() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_cancel)
  return _internal_derivative_orders_to_cancel();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>&
MsgBatchUpdateOrders::_internal_derivative_orders_to_cancel() const {
  return _impl_.derivative_orders_to_cancel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>*
MsgBatchUpdateOrders::_internal_mutable_derivative_orders_to_cancel() {
  return &_impl_.derivative_orders_to_cancel_;
}

// repeated .injective.exchange.v1beta1.SpotOrder spot_orders_to_create = 7 [json_name = "spotOrdersToCreate", (.gogoproto.nullable) = true];
inline int MsgBatchUpdateOrders::_internal_spot_orders_to_create_size() const {
  return _impl_.spot_orders_to_create_.size();
}
inline int MsgBatchUpdateOrders::spot_orders_to_create_size() const {
  return _internal_spot_orders_to_create_size();
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgBatchUpdateOrders::mutable_spot_orders_to_create(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_create)
  return _internal_mutable_spot_orders_to_create()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >*
MsgBatchUpdateOrders::mutable_spot_orders_to_create() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_create)
  return _internal_mutable_spot_orders_to_create();
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgBatchUpdateOrders::_internal_spot_orders_to_create(int index) const {
  return _internal_spot_orders_to_create().Get(index);
}
inline const ::injective::exchange::v1beta1::SpotOrder& MsgBatchUpdateOrders::spot_orders_to_create(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_create)
  return _internal_spot_orders_to_create(index);
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgBatchUpdateOrders::_internal_add_spot_orders_to_create() {
  return _internal_mutable_spot_orders_to_create()->Add();
}
inline ::injective::exchange::v1beta1::SpotOrder* MsgBatchUpdateOrders::add_spot_orders_to_create() {
  ::injective::exchange::v1beta1::SpotOrder* _add = _internal_add_spot_orders_to_create();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_create)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotOrder >&
MsgBatchUpdateOrders::spot_orders_to_create() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.spot_orders_to_create)
  return _internal_spot_orders_to_create();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>&
MsgBatchUpdateOrders::_internal_spot_orders_to_create() const {
  return _impl_.spot_orders_to_create_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotOrder>*
MsgBatchUpdateOrders::_internal_mutable_spot_orders_to_create() {
  return &_impl_.spot_orders_to_create_;
}

// repeated .injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create = 8 [json_name = "derivativeOrdersToCreate", (.gogoproto.nullable) = true];
inline int MsgBatchUpdateOrders::_internal_derivative_orders_to_create_size() const {
  return _impl_.derivative_orders_to_create_.size();
}
inline int MsgBatchUpdateOrders::derivative_orders_to_create_size() const {
  return _internal_derivative_orders_to_create_size();
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchUpdateOrders::mutable_derivative_orders_to_create(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_create)
  return _internal_mutable_derivative_orders_to_create()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >*
MsgBatchUpdateOrders::mutable_derivative_orders_to_create() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_create)
  return _internal_mutable_derivative_orders_to_create();
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgBatchUpdateOrders::_internal_derivative_orders_to_create(int index) const {
  return _internal_derivative_orders_to_create().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgBatchUpdateOrders::derivative_orders_to_create(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_create)
  return _internal_derivative_orders_to_create(index);
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchUpdateOrders::_internal_add_derivative_orders_to_create() {
  return _internal_mutable_derivative_orders_to_create()->Add();
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchUpdateOrders::add_derivative_orders_to_create() {
  ::injective::exchange::v1beta1::DerivativeOrder* _add = _internal_add_derivative_orders_to_create();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_create)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >&
MsgBatchUpdateOrders::derivative_orders_to_create() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.derivative_orders_to_create)
  return _internal_derivative_orders_to_create();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>&
MsgBatchUpdateOrders::_internal_derivative_orders_to_create() const {
  return _impl_.derivative_orders_to_create_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>*
MsgBatchUpdateOrders::_internal_mutable_derivative_orders_to_create() {
  return &_impl_.derivative_orders_to_create_;
}

// repeated .injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel = 9 [json_name = "binaryOptionsOrdersToCancel", (.gogoproto.nullable) = true];
inline int MsgBatchUpdateOrders::_internal_binary_options_orders_to_cancel_size() const {
  return _impl_.binary_options_orders_to_cancel_.size();
}
inline int MsgBatchUpdateOrders::binary_options_orders_to_cancel_size() const {
  return _internal_binary_options_orders_to_cancel_size();
}
inline void MsgBatchUpdateOrders::clear_binary_options_orders_to_cancel() {
  _internal_mutable_binary_options_orders_to_cancel()->Clear();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::mutable_binary_options_orders_to_cancel(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_cancel)
  return _internal_mutable_binary_options_orders_to_cancel()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
MsgBatchUpdateOrders::mutable_binary_options_orders_to_cancel() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_cancel)
  return _internal_mutable_binary_options_orders_to_cancel();
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchUpdateOrders::_internal_binary_options_orders_to_cancel(int index) const {
  return _internal_binary_options_orders_to_cancel().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchUpdateOrders::binary_options_orders_to_cancel(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_cancel)
  return _internal_binary_options_orders_to_cancel(index);
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::_internal_add_binary_options_orders_to_cancel() {
  return _internal_mutable_binary_options_orders_to_cancel()->Add();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchUpdateOrders::add_binary_options_orders_to_cancel() {
  ::injective::exchange::v1beta1::OrderData* _add = _internal_add_binary_options_orders_to_cancel();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_cancel)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
MsgBatchUpdateOrders::binary_options_orders_to_cancel() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_cancel)
  return _internal_binary_options_orders_to_cancel();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>&
MsgBatchUpdateOrders::_internal_binary_options_orders_to_cancel() const {
  return _impl_.binary_options_orders_to_cancel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>*
MsgBatchUpdateOrders::_internal_mutable_binary_options_orders_to_cancel() {
  return &_impl_.binary_options_orders_to_cancel_;
}

// repeated string binary_options_market_ids_to_cancel_all = 10 [json_name = "binaryOptionsMarketIdsToCancelAll"];
inline int MsgBatchUpdateOrders::_internal_binary_options_market_ids_to_cancel_all_size() const {
  return _impl_.binary_options_market_ids_to_cancel_all_.size();
}
inline int MsgBatchUpdateOrders::binary_options_market_ids_to_cancel_all_size() const {
  return _internal_binary_options_market_ids_to_cancel_all_size();
}
inline void MsgBatchUpdateOrders::clear_binary_options_market_ids_to_cancel_all() {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Clear();
}
inline std::string* MsgBatchUpdateOrders::add_binary_options_market_ids_to_cancel_all() {
  std::string* _s = _internal_add_binary_options_market_ids_to_cancel_all();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
  return _s;
}
inline const std::string& MsgBatchUpdateOrders::binary_options_market_ids_to_cancel_all(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
  return _internal_binary_options_market_ids_to_cancel_all(index);
}
inline std::string* MsgBatchUpdateOrders::mutable_binary_options_market_ids_to_cancel_all(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
  return _internal_mutable_binary_options_market_ids_to_cancel_all()->Mutable(index);
}
inline void MsgBatchUpdateOrders::set_binary_options_market_ids_to_cancel_all(int index, const std::string& value) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_binary_options_market_ids_to_cancel_all(int index, std::string&& value) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_binary_options_market_ids_to_cancel_all(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_binary_options_market_ids_to_cancel_all(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::set_binary_options_market_ids_to_cancel_all(int index, absl::string_view value) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_binary_options_market_ids_to_cancel_all(const std::string& value) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_binary_options_market_ids_to_cancel_all(std::string&& value) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_binary_options_market_ids_to_cancel_all(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_binary_options_market_ids_to_cancel_all(const char* value, std::size_t size) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline void MsgBatchUpdateOrders::add_binary_options_market_ids_to_cancel_all(absl::string_view value) {
  _internal_mutable_binary_options_market_ids_to_cancel_all()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrders::binary_options_market_ids_to_cancel_all() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
  return _internal_binary_options_market_ids_to_cancel_all();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchUpdateOrders::mutable_binary_options_market_ids_to_cancel_all() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_market_ids_to_cancel_all)
  return _internal_mutable_binary_options_market_ids_to_cancel_all();
}
inline const std::string& MsgBatchUpdateOrders::_internal_binary_options_market_ids_to_cancel_all(int index) const {
  return _internal_binary_options_market_ids_to_cancel_all().Get(index);
}
inline std::string* MsgBatchUpdateOrders::_internal_add_binary_options_market_ids_to_cancel_all() {
  return _internal_mutable_binary_options_market_ids_to_cancel_all()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrders::_internal_binary_options_market_ids_to_cancel_all() const {
  return _impl_.binary_options_market_ids_to_cancel_all_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchUpdateOrders::_internal_mutable_binary_options_market_ids_to_cancel_all() {
  return &_impl_.binary_options_market_ids_to_cancel_all_;
}

// repeated .injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create = 11 [json_name = "binaryOptionsOrdersToCreate", (.gogoproto.nullable) = true];
inline int MsgBatchUpdateOrders::_internal_binary_options_orders_to_create_size() const {
  return _impl_.binary_options_orders_to_create_.size();
}
inline int MsgBatchUpdateOrders::binary_options_orders_to_create_size() const {
  return _internal_binary_options_orders_to_create_size();
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchUpdateOrders::mutable_binary_options_orders_to_create(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_create)
  return _internal_mutable_binary_options_orders_to_create()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >*
MsgBatchUpdateOrders::mutable_binary_options_orders_to_create() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_create)
  return _internal_mutable_binary_options_orders_to_create();
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgBatchUpdateOrders::_internal_binary_options_orders_to_create(int index) const {
  return _internal_binary_options_orders_to_create().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgBatchUpdateOrders::binary_options_orders_to_create(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_create)
  return _internal_binary_options_orders_to_create(index);
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchUpdateOrders::_internal_add_binary_options_orders_to_create() {
  return _internal_mutable_binary_options_orders_to_create()->Add();
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgBatchUpdateOrders::add_binary_options_orders_to_create() {
  ::injective::exchange::v1beta1::DerivativeOrder* _add = _internal_add_binary_options_orders_to_create();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_create)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeOrder >&
MsgBatchUpdateOrders::binary_options_orders_to_create() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrders.binary_options_orders_to_create)
  return _internal_binary_options_orders_to_create();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>&
MsgBatchUpdateOrders::_internal_binary_options_orders_to_create() const {
  return _impl_.binary_options_orders_to_create_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeOrder>*
MsgBatchUpdateOrders::_internal_mutable_binary_options_orders_to_create() {
  return &_impl_.binary_options_orders_to_create_;
}

// -------------------------------------------------------------------

// MsgBatchUpdateOrdersResponse

// repeated bool spot_cancel_success = 1 [json_name = "spotCancelSuccess"];
inline int MsgBatchUpdateOrdersResponse::_internal_spot_cancel_success_size() const {
  return _impl_.spot_cancel_success_.size();
}
inline int MsgBatchUpdateOrdersResponse::spot_cancel_success_size() const {
  return _internal_spot_cancel_success_size();
}
inline void MsgBatchUpdateOrdersResponse::clear_spot_cancel_success() {
  _internal_mutable_spot_cancel_success()->Clear();
}
inline bool MsgBatchUpdateOrdersResponse::spot_cancel_success(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_cancel_success)
  return _internal_spot_cancel_success(index);
}
inline void MsgBatchUpdateOrdersResponse::set_spot_cancel_success(int index, bool value) {
  _internal_mutable_spot_cancel_success()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_cancel_success)
}
inline void MsgBatchUpdateOrdersResponse::add_spot_cancel_success(bool value) {
  _internal_add_spot_cancel_success(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_cancel_success)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchUpdateOrdersResponse::spot_cancel_success() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_cancel_success)
  return _internal_spot_cancel_success();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchUpdateOrdersResponse::mutable_spot_cancel_success() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_cancel_success)
  return _internal_mutable_spot_cancel_success();
}

inline bool MsgBatchUpdateOrdersResponse::_internal_spot_cancel_success(int index) const {
  return _internal_spot_cancel_success().Get(index);
}
inline void MsgBatchUpdateOrdersResponse::_internal_add_spot_cancel_success(bool value) {
  _internal_mutable_spot_cancel_success()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchUpdateOrdersResponse::_internal_spot_cancel_success() const {
  return _impl_.spot_cancel_success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchUpdateOrdersResponse::_internal_mutable_spot_cancel_success() {
  return &_impl_.spot_cancel_success_;
}

// repeated bool derivative_cancel_success = 2 [json_name = "derivativeCancelSuccess"];
inline int MsgBatchUpdateOrdersResponse::_internal_derivative_cancel_success_size() const {
  return _impl_.derivative_cancel_success_.size();
}
inline int MsgBatchUpdateOrdersResponse::derivative_cancel_success_size() const {
  return _internal_derivative_cancel_success_size();
}
inline void MsgBatchUpdateOrdersResponse::clear_derivative_cancel_success() {
  _internal_mutable_derivative_cancel_success()->Clear();
}
inline bool MsgBatchUpdateOrdersResponse::derivative_cancel_success(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_cancel_success)
  return _internal_derivative_cancel_success(index);
}
inline void MsgBatchUpdateOrdersResponse::set_derivative_cancel_success(int index, bool value) {
  _internal_mutable_derivative_cancel_success()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_cancel_success)
}
inline void MsgBatchUpdateOrdersResponse::add_derivative_cancel_success(bool value) {
  _internal_add_derivative_cancel_success(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_cancel_success)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchUpdateOrdersResponse::derivative_cancel_success() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_cancel_success)
  return _internal_derivative_cancel_success();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchUpdateOrdersResponse::mutable_derivative_cancel_success() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_cancel_success)
  return _internal_mutable_derivative_cancel_success();
}

inline bool MsgBatchUpdateOrdersResponse::_internal_derivative_cancel_success(int index) const {
  return _internal_derivative_cancel_success().Get(index);
}
inline void MsgBatchUpdateOrdersResponse::_internal_add_derivative_cancel_success(bool value) {
  _internal_mutable_derivative_cancel_success()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchUpdateOrdersResponse::_internal_derivative_cancel_success() const {
  return _impl_.derivative_cancel_success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchUpdateOrdersResponse::_internal_mutable_derivative_cancel_success() {
  return &_impl_.derivative_cancel_success_;
}

// repeated string spot_order_hashes = 3 [json_name = "spotOrderHashes"];
inline int MsgBatchUpdateOrdersResponse::_internal_spot_order_hashes_size() const {
  return _impl_.spot_order_hashes_.size();
}
inline int MsgBatchUpdateOrdersResponse::spot_order_hashes_size() const {
  return _internal_spot_order_hashes_size();
}
inline void MsgBatchUpdateOrdersResponse::clear_spot_order_hashes() {
  _internal_mutable_spot_order_hashes()->Clear();
}
inline std::string* MsgBatchUpdateOrdersResponse::add_spot_order_hashes() {
  std::string* _s = _internal_add_spot_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
  return _s;
}
inline const std::string& MsgBatchUpdateOrdersResponse::spot_order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
  return _internal_spot_order_hashes(index);
}
inline std::string* MsgBatchUpdateOrdersResponse::mutable_spot_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
  return _internal_mutable_spot_order_hashes()->Mutable(index);
}
inline void MsgBatchUpdateOrdersResponse::set_spot_order_hashes(int index, const std::string& value) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_spot_order_hashes(int index, std::string&& value) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_spot_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_spot_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_spot_order_hashes(int index, absl::string_view value) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_spot_order_hashes(const std::string& value) {
  _internal_mutable_spot_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_spot_order_hashes(std::string&& value) {
  _internal_mutable_spot_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_spot_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_spot_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_spot_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_spot_order_hashes(absl::string_view value) {
  _internal_mutable_spot_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrdersResponse::spot_order_hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
  return _internal_spot_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchUpdateOrdersResponse::mutable_spot_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.spot_order_hashes)
  return _internal_mutable_spot_order_hashes();
}
inline const std::string& MsgBatchUpdateOrdersResponse::_internal_spot_order_hashes(int index) const {
  return _internal_spot_order_hashes().Get(index);
}
inline std::string* MsgBatchUpdateOrdersResponse::_internal_add_spot_order_hashes() {
  return _internal_mutable_spot_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrdersResponse::_internal_spot_order_hashes() const {
  return _impl_.spot_order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchUpdateOrdersResponse::_internal_mutable_spot_order_hashes() {
  return &_impl_.spot_order_hashes_;
}

// repeated string derivative_order_hashes = 4 [json_name = "derivativeOrderHashes"];
inline int MsgBatchUpdateOrdersResponse::_internal_derivative_order_hashes_size() const {
  return _impl_.derivative_order_hashes_.size();
}
inline int MsgBatchUpdateOrdersResponse::derivative_order_hashes_size() const {
  return _internal_derivative_order_hashes_size();
}
inline void MsgBatchUpdateOrdersResponse::clear_derivative_order_hashes() {
  _internal_mutable_derivative_order_hashes()->Clear();
}
inline std::string* MsgBatchUpdateOrdersResponse::add_derivative_order_hashes() {
  std::string* _s = _internal_add_derivative_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
  return _s;
}
inline const std::string& MsgBatchUpdateOrdersResponse::derivative_order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
  return _internal_derivative_order_hashes(index);
}
inline std::string* MsgBatchUpdateOrdersResponse::mutable_derivative_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
  return _internal_mutable_derivative_order_hashes()->Mutable(index);
}
inline void MsgBatchUpdateOrdersResponse::set_derivative_order_hashes(int index, const std::string& value) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_derivative_order_hashes(int index, std::string&& value) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_derivative_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_derivative_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_derivative_order_hashes(int index, absl::string_view value) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_derivative_order_hashes(const std::string& value) {
  _internal_mutable_derivative_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_derivative_order_hashes(std::string&& value) {
  _internal_mutable_derivative_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_derivative_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_derivative_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_derivative_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_derivative_order_hashes(absl::string_view value) {
  _internal_mutable_derivative_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrdersResponse::derivative_order_hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
  return _internal_derivative_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchUpdateOrdersResponse::mutable_derivative_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.derivative_order_hashes)
  return _internal_mutable_derivative_order_hashes();
}
inline const std::string& MsgBatchUpdateOrdersResponse::_internal_derivative_order_hashes(int index) const {
  return _internal_derivative_order_hashes().Get(index);
}
inline std::string* MsgBatchUpdateOrdersResponse::_internal_add_derivative_order_hashes() {
  return _internal_mutable_derivative_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrdersResponse::_internal_derivative_order_hashes() const {
  return _impl_.derivative_order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchUpdateOrdersResponse::_internal_mutable_derivative_order_hashes() {
  return &_impl_.derivative_order_hashes_;
}

// repeated bool binary_options_cancel_success = 5 [json_name = "binaryOptionsCancelSuccess"];
inline int MsgBatchUpdateOrdersResponse::_internal_binary_options_cancel_success_size() const {
  return _impl_.binary_options_cancel_success_.size();
}
inline int MsgBatchUpdateOrdersResponse::binary_options_cancel_success_size() const {
  return _internal_binary_options_cancel_success_size();
}
inline void MsgBatchUpdateOrdersResponse::clear_binary_options_cancel_success() {
  _internal_mutable_binary_options_cancel_success()->Clear();
}
inline bool MsgBatchUpdateOrdersResponse::binary_options_cancel_success(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_cancel_success)
  return _internal_binary_options_cancel_success(index);
}
inline void MsgBatchUpdateOrdersResponse::set_binary_options_cancel_success(int index, bool value) {
  _internal_mutable_binary_options_cancel_success()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_cancel_success)
}
inline void MsgBatchUpdateOrdersResponse::add_binary_options_cancel_success(bool value) {
  _internal_add_binary_options_cancel_success(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_cancel_success)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchUpdateOrdersResponse::binary_options_cancel_success() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_cancel_success)
  return _internal_binary_options_cancel_success();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchUpdateOrdersResponse::mutable_binary_options_cancel_success() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_cancel_success)
  return _internal_mutable_binary_options_cancel_success();
}

inline bool MsgBatchUpdateOrdersResponse::_internal_binary_options_cancel_success(int index) const {
  return _internal_binary_options_cancel_success().Get(index);
}
inline void MsgBatchUpdateOrdersResponse::_internal_add_binary_options_cancel_success(bool value) {
  _internal_mutable_binary_options_cancel_success()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchUpdateOrdersResponse::_internal_binary_options_cancel_success() const {
  return _impl_.binary_options_cancel_success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchUpdateOrdersResponse::_internal_mutable_binary_options_cancel_success() {
  return &_impl_.binary_options_cancel_success_;
}

// repeated string binary_options_order_hashes = 6 [json_name = "binaryOptionsOrderHashes"];
inline int MsgBatchUpdateOrdersResponse::_internal_binary_options_order_hashes_size() const {
  return _impl_.binary_options_order_hashes_.size();
}
inline int MsgBatchUpdateOrdersResponse::binary_options_order_hashes_size() const {
  return _internal_binary_options_order_hashes_size();
}
inline void MsgBatchUpdateOrdersResponse::clear_binary_options_order_hashes() {
  _internal_mutable_binary_options_order_hashes()->Clear();
}
inline std::string* MsgBatchUpdateOrdersResponse::add_binary_options_order_hashes() {
  std::string* _s = _internal_add_binary_options_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
  return _s;
}
inline const std::string& MsgBatchUpdateOrdersResponse::binary_options_order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
  return _internal_binary_options_order_hashes(index);
}
inline std::string* MsgBatchUpdateOrdersResponse::mutable_binary_options_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
  return _internal_mutable_binary_options_order_hashes()->Mutable(index);
}
inline void MsgBatchUpdateOrdersResponse::set_binary_options_order_hashes(int index, const std::string& value) {
  _internal_mutable_binary_options_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_binary_options_order_hashes(int index, std::string&& value) {
  _internal_mutable_binary_options_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_binary_options_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_binary_options_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_binary_options_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_binary_options_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::set_binary_options_order_hashes(int index, absl::string_view value) {
  _internal_mutable_binary_options_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_binary_options_order_hashes(const std::string& value) {
  _internal_mutable_binary_options_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_binary_options_order_hashes(std::string&& value) {
  _internal_mutable_binary_options_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_binary_options_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_binary_options_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_binary_options_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_binary_options_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline void MsgBatchUpdateOrdersResponse::add_binary_options_order_hashes(absl::string_view value) {
  _internal_mutable_binary_options_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrdersResponse::binary_options_order_hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
  return _internal_binary_options_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgBatchUpdateOrdersResponse::mutable_binary_options_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse.binary_options_order_hashes)
  return _internal_mutable_binary_options_order_hashes();
}
inline const std::string& MsgBatchUpdateOrdersResponse::_internal_binary_options_order_hashes(int index) const {
  return _internal_binary_options_order_hashes().Get(index);
}
inline std::string* MsgBatchUpdateOrdersResponse::_internal_add_binary_options_order_hashes() {
  return _internal_mutable_binary_options_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgBatchUpdateOrdersResponse::_internal_binary_options_order_hashes() const {
  return _impl_.binary_options_order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgBatchUpdateOrdersResponse::_internal_mutable_binary_options_order_hashes() {
  return &_impl_.binary_options_order_hashes_;
}

// -------------------------------------------------------------------

// MsgCreateDerivativeMarketOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCreateDerivativeMarketOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateDerivativeMarketOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateDerivativeMarketOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.sender)
}
inline std::string* MsgCreateDerivativeMarketOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.sender)
  return _s;
}
inline const std::string& MsgCreateDerivativeMarketOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateDerivativeMarketOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeMarketOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeMarketOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateDerivativeMarketOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.sender)
}

// .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
inline bool MsgCreateDerivativeMarketOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateDerivativeMarketOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::DerivativeOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeOrder&>(
      ::injective::exchange::v1beta1::_DerivativeOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateDerivativeMarketOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.order)
  return _internal_order();
}
inline void MsgCreateDerivativeMarketOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::DerivativeOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.order)
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeMarketOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeMarketOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeMarketOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateDerivativeMarketOrder::mutable_order() {
  ::injective::exchange::v1beta1::DerivativeOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.order)
  return _msg;
}
inline void MsgCreateDerivativeMarketOrder::set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder.order)
}

// -------------------------------------------------------------------

// MsgCreateDerivativeMarketOrderResponse

// string order_hash = 1 [json_name = "orderHash"];
inline void MsgCreateDerivativeMarketOrderResponse::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCreateDerivativeMarketOrderResponse::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateDerivativeMarketOrderResponse::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.order_hash)
}
inline std::string* MsgCreateDerivativeMarketOrderResponse::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.order_hash)
  return _s;
}
inline const std::string& MsgCreateDerivativeMarketOrderResponse::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCreateDerivativeMarketOrderResponse::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeMarketOrderResponse::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateDerivativeMarketOrderResponse::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCreateDerivativeMarketOrderResponse::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.order_hash)
}

// .injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2 [json_name = "results", (.gogoproto.nullable) = true];
inline bool MsgCreateDerivativeMarketOrderResponse::has_results() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.results_ != nullptr);
  return value;
}
inline void MsgCreateDerivativeMarketOrderResponse::clear_results() {
  if (_impl_.results_ != nullptr) _impl_.results_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& MsgCreateDerivativeMarketOrderResponse::_internal_results() const {
  const ::injective::exchange::v1beta1::DerivativeMarketOrderResults* p = _impl_.results_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarketOrderResults&>(
      ::injective::exchange::v1beta1::_DerivativeMarketOrderResults_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& MsgCreateDerivativeMarketOrderResponse::results() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.results)
  return _internal_results();
}
inline void MsgCreateDerivativeMarketOrderResponse::unsafe_arena_set_allocated_results(
    ::injective::exchange::v1beta1::DerivativeMarketOrderResults* results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.results_);
  }
  _impl_.results_ = results;
  if (results) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.results)
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateDerivativeMarketOrderResponse::release_results() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* temp = _impl_.results_;
  _impl_.results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateDerivativeMarketOrderResponse::unsafe_arena_release_results() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.results)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* temp = _impl_.results_;
  _impl_.results_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateDerivativeMarketOrderResponse::_internal_mutable_results() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.results_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrderResults>(GetArenaForAllocation());
    _impl_.results_ = p;
  }
  return _impl_.results_;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateDerivativeMarketOrderResponse::mutable_results() {
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* _msg = _internal_mutable_results();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.results)
  return _msg;
}
inline void MsgCreateDerivativeMarketOrderResponse::set_allocated_results(::injective::exchange::v1beta1::DerivativeMarketOrderResults* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.results_;
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(results);
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.results_ = results;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse.results)
}

// -------------------------------------------------------------------

// DerivativeMarketOrderResults

// string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrderResults::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrderResults::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrderResults.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrderResults::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrderResults.quantity)
}
inline std::string* DerivativeMarketOrderResults::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrderResults.quantity)
  return _s;
}
inline const std::string& DerivativeMarketOrderResults::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void DerivativeMarketOrderResults::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrderResults.quantity)
  return _impl_.quantity_.Release();
}
inline void DerivativeMarketOrderResults::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderResults.quantity)
}

// string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrderResults::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrderResults::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrderResults.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrderResults::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrderResults.price)
}
inline std::string* DerivativeMarketOrderResults::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrderResults.price)
  return _s;
}
inline const std::string& DerivativeMarketOrderResults::_internal_price() const {
  return _impl_.price_.Get();
}
inline void DerivativeMarketOrderResults::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrderResults.price)
  return _impl_.price_.Release();
}
inline void DerivativeMarketOrderResults::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderResults.price)
}

// string fee = 3 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrderResults::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrderResults::fee() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrderResults.fee)
  return _internal_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrderResults::set_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrderResults.fee)
}
inline std::string* DerivativeMarketOrderResults::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrderResults.fee)
  return _s;
}
inline const std::string& DerivativeMarketOrderResults::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void DerivativeMarketOrderResults::_internal_set_fee(const std::string& value) {
  ;


  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::_internal_mutable_fee() {
  ;
  return _impl_.fee_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::release_fee() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrderResults.fee)
  return _impl_.fee_.Release();
}
inline void DerivativeMarketOrderResults::set_allocated_fee(std::string* value) {
  _impl_.fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_.IsDefault()) {
          _impl_.fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderResults.fee)
}

// .injective.exchange.v1beta1.PositionDelta position_delta = 4 [json_name = "positionDelta", (.gogoproto.nullable) = false];
inline bool DerivativeMarketOrderResults::has_position_delta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_delta_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PositionDelta& DerivativeMarketOrderResults::_internal_position_delta() const {
  const ::injective::exchange::v1beta1::PositionDelta* p = _impl_.position_delta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PositionDelta&>(
      ::injective::exchange::v1beta1::_PositionDelta_default_instance_);
}
inline const ::injective::exchange::v1beta1::PositionDelta& DerivativeMarketOrderResults::position_delta() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrderResults.position_delta)
  return _internal_position_delta();
}
inline void DerivativeMarketOrderResults::unsafe_arena_set_allocated_position_delta(
    ::injective::exchange::v1beta1::PositionDelta* position_delta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_delta_);
  }
  _impl_.position_delta_ = position_delta;
  if (position_delta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderResults.position_delta)
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeMarketOrderResults::release_position_delta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PositionDelta* temp = _impl_.position_delta_;
  _impl_.position_delta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeMarketOrderResults::unsafe_arena_release_position_delta() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrderResults.position_delta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PositionDelta* temp = _impl_.position_delta_;
  _impl_.position_delta_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeMarketOrderResults::_internal_mutable_position_delta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_delta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PositionDelta>(GetArenaForAllocation());
    _impl_.position_delta_ = p;
  }
  return _impl_.position_delta_;
}
inline ::injective::exchange::v1beta1::PositionDelta* DerivativeMarketOrderResults::mutable_position_delta() {
  ::injective::exchange::v1beta1::PositionDelta* _msg = _internal_mutable_position_delta();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrderResults.position_delta)
  return _msg;
}
inline void DerivativeMarketOrderResults::set_allocated_position_delta(::injective::exchange::v1beta1::PositionDelta* position_delta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_delta_);
  }
  if (position_delta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_delta));
    if (message_arena != submessage_arena) {
      position_delta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_delta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_delta_ = position_delta;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderResults.position_delta)
}

// string payout = 5 [json_name = "payout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrderResults::clear_payout() {
  _impl_.payout_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrderResults::payout() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrderResults.payout)
  return _internal_payout();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrderResults::set_payout(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payout_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrderResults.payout)
}
inline std::string* DerivativeMarketOrderResults::mutable_payout() {
  std::string* _s = _internal_mutable_payout();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrderResults.payout)
  return _s;
}
inline const std::string& DerivativeMarketOrderResults::_internal_payout() const {
  return _impl_.payout_.Get();
}
inline void DerivativeMarketOrderResults::_internal_set_payout(const std::string& value) {
  ;


  _impl_.payout_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::_internal_mutable_payout() {
  ;
  return _impl_.payout_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderResults::release_payout() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrderResults.payout)
  return _impl_.payout_.Release();
}
inline void DerivativeMarketOrderResults::set_allocated_payout(std::string* value) {
  _impl_.payout_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payout_.IsDefault()) {
          _impl_.payout_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderResults.payout)
}

// -------------------------------------------------------------------

// MsgCreateBinaryOptionsMarketOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCreateBinaryOptionsMarketOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCreateBinaryOptionsMarketOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateBinaryOptionsMarketOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.sender)
}
inline std::string* MsgCreateBinaryOptionsMarketOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.sender)
  return _s;
}
inline const std::string& MsgCreateBinaryOptionsMarketOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCreateBinaryOptionsMarketOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsMarketOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsMarketOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCreateBinaryOptionsMarketOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.sender)
}

// .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
inline bool MsgCreateBinaryOptionsMarketOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateBinaryOptionsMarketOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::DerivativeOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeOrder&>(
      ::injective::exchange::v1beta1::_DerivativeOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgCreateBinaryOptionsMarketOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.order)
  return _internal_order();
}
inline void MsgCreateBinaryOptionsMarketOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::DerivativeOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.order)
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsMarketOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsMarketOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsMarketOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgCreateBinaryOptionsMarketOrder::mutable_order() {
  ::injective::exchange::v1beta1::DerivativeOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.order)
  return _msg;
}
inline void MsgCreateBinaryOptionsMarketOrder::set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder.order)
}

// -------------------------------------------------------------------

// MsgCreateBinaryOptionsMarketOrderResponse

// string order_hash = 1 [json_name = "orderHash"];
inline void MsgCreateBinaryOptionsMarketOrderResponse::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCreateBinaryOptionsMarketOrderResponse::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCreateBinaryOptionsMarketOrderResponse::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.order_hash)
}
inline std::string* MsgCreateBinaryOptionsMarketOrderResponse::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.order_hash)
  return _s;
}
inline const std::string& MsgCreateBinaryOptionsMarketOrderResponse::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCreateBinaryOptionsMarketOrderResponse::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsMarketOrderResponse::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCreateBinaryOptionsMarketOrderResponse::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCreateBinaryOptionsMarketOrderResponse::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.order_hash)
}

// .injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2 [json_name = "results", (.gogoproto.nullable) = true];
inline bool MsgCreateBinaryOptionsMarketOrderResponse::has_results() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.results_ != nullptr);
  return value;
}
inline void MsgCreateBinaryOptionsMarketOrderResponse::clear_results() {
  if (_impl_.results_ != nullptr) _impl_.results_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& MsgCreateBinaryOptionsMarketOrderResponse::_internal_results() const {
  const ::injective::exchange::v1beta1::DerivativeMarketOrderResults* p = _impl_.results_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarketOrderResults&>(
      ::injective::exchange::v1beta1::_DerivativeMarketOrderResults_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrderResults& MsgCreateBinaryOptionsMarketOrderResponse::results() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.results)
  return _internal_results();
}
inline void MsgCreateBinaryOptionsMarketOrderResponse::unsafe_arena_set_allocated_results(
    ::injective::exchange::v1beta1::DerivativeMarketOrderResults* results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.results_);
  }
  _impl_.results_ = results;
  if (results) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.results)
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateBinaryOptionsMarketOrderResponse::release_results() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* temp = _impl_.results_;
  _impl_.results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateBinaryOptionsMarketOrderResponse::unsafe_arena_release_results() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.results)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* temp = _impl_.results_;
  _impl_.results_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateBinaryOptionsMarketOrderResponse::_internal_mutable_results() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.results_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrderResults>(GetArenaForAllocation());
    _impl_.results_ = p;
  }
  return _impl_.results_;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderResults* MsgCreateBinaryOptionsMarketOrderResponse::mutable_results() {
  ::injective::exchange::v1beta1::DerivativeMarketOrderResults* _msg = _internal_mutable_results();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.results)
  return _msg;
}
inline void MsgCreateBinaryOptionsMarketOrderResponse::set_allocated_results(::injective::exchange::v1beta1::DerivativeMarketOrderResults* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.results_;
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(results);
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.results_ = results;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse.results)
}

// -------------------------------------------------------------------

// MsgCancelDerivativeOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCancelDerivativeOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCancelDerivativeOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelDerivativeOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelDerivativeOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelDerivativeOrder.sender)
}
inline std::string* MsgCancelDerivativeOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelDerivativeOrder.sender)
  return _s;
}
inline const std::string& MsgCancelDerivativeOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCancelDerivativeOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelDerivativeOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCancelDerivativeOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelDerivativeOrder.sender)
}

// string market_id = 2 [json_name = "marketId"];
inline void MsgCancelDerivativeOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MsgCancelDerivativeOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelDerivativeOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelDerivativeOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelDerivativeOrder.market_id)
}
inline std::string* MsgCancelDerivativeOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelDerivativeOrder.market_id)
  return _s;
}
inline const std::string& MsgCancelDerivativeOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MsgCancelDerivativeOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelDerivativeOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void MsgCancelDerivativeOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelDerivativeOrder.market_id)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void MsgCancelDerivativeOrder::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgCancelDerivativeOrder::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelDerivativeOrder.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelDerivativeOrder::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelDerivativeOrder.subaccount_id)
}
inline std::string* MsgCancelDerivativeOrder::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelDerivativeOrder.subaccount_id)
  return _s;
}
inline const std::string& MsgCancelDerivativeOrder::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void MsgCancelDerivativeOrder::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelDerivativeOrder.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void MsgCancelDerivativeOrder::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelDerivativeOrder.subaccount_id)
}

// string order_hash = 4 [json_name = "orderHash"];
inline void MsgCancelDerivativeOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCancelDerivativeOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelDerivativeOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelDerivativeOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelDerivativeOrder.order_hash)
}
inline std::string* MsgCancelDerivativeOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelDerivativeOrder.order_hash)
  return _s;
}
inline const std::string& MsgCancelDerivativeOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCancelDerivativeOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelDerivativeOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelDerivativeOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCancelDerivativeOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelDerivativeOrder.order_hash)
}

// int32 order_mask = 5 [json_name = "orderMask"];
inline void MsgCancelDerivativeOrder::clear_order_mask() {
  _impl_.order_mask_ = 0;
}
inline ::int32_t MsgCancelDerivativeOrder::order_mask() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelDerivativeOrder.order_mask)
  return _internal_order_mask();
}
inline void MsgCancelDerivativeOrder::set_order_mask(::int32_t value) {
  _internal_set_order_mask(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelDerivativeOrder.order_mask)
}
inline ::int32_t MsgCancelDerivativeOrder::_internal_order_mask() const {
  return _impl_.order_mask_;
}
inline void MsgCancelDerivativeOrder::_internal_set_order_mask(::int32_t value) {
  ;
  _impl_.order_mask_ = value;
}

// -------------------------------------------------------------------

// MsgCancelDerivativeOrderResponse

// -------------------------------------------------------------------

// MsgCancelBinaryOptionsOrder

// string sender = 1 [json_name = "sender"];
inline void MsgCancelBinaryOptionsOrder::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgCancelBinaryOptionsOrder::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelBinaryOptionsOrder::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.sender)
}
inline std::string* MsgCancelBinaryOptionsOrder::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.sender)
  return _s;
}
inline const std::string& MsgCancelBinaryOptionsOrder::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgCancelBinaryOptionsOrder::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.sender)
  return _impl_.sender_.Release();
}
inline void MsgCancelBinaryOptionsOrder::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.sender)
}

// string market_id = 2 [json_name = "marketId"];
inline void MsgCancelBinaryOptionsOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MsgCancelBinaryOptionsOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelBinaryOptionsOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.market_id)
}
inline std::string* MsgCancelBinaryOptionsOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.market_id)
  return _s;
}
inline const std::string& MsgCancelBinaryOptionsOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MsgCancelBinaryOptionsOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void MsgCancelBinaryOptionsOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.market_id)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void MsgCancelBinaryOptionsOrder::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgCancelBinaryOptionsOrder::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelBinaryOptionsOrder::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.subaccount_id)
}
inline std::string* MsgCancelBinaryOptionsOrder::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.subaccount_id)
  return _s;
}
inline const std::string& MsgCancelBinaryOptionsOrder::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void MsgCancelBinaryOptionsOrder::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void MsgCancelBinaryOptionsOrder::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.subaccount_id)
}

// string order_hash = 4 [json_name = "orderHash"];
inline void MsgCancelBinaryOptionsOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& MsgCancelBinaryOptionsOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgCancelBinaryOptionsOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.order_hash)
}
inline std::string* MsgCancelBinaryOptionsOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.order_hash)
  return _s;
}
inline const std::string& MsgCancelBinaryOptionsOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void MsgCancelBinaryOptionsOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgCancelBinaryOptionsOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void MsgCancelBinaryOptionsOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.order_hash)
}

// int32 order_mask = 5 [json_name = "orderMask"];
inline void MsgCancelBinaryOptionsOrder::clear_order_mask() {
  _impl_.order_mask_ = 0;
}
inline ::int32_t MsgCancelBinaryOptionsOrder::order_mask() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.order_mask)
  return _internal_order_mask();
}
inline void MsgCancelBinaryOptionsOrder::set_order_mask(::int32_t value) {
  _internal_set_order_mask(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder.order_mask)
}
inline ::int32_t MsgCancelBinaryOptionsOrder::_internal_order_mask() const {
  return _impl_.order_mask_;
}
inline void MsgCancelBinaryOptionsOrder::_internal_set_order_mask(::int32_t value) {
  ;
  _impl_.order_mask_ = value;
}

// -------------------------------------------------------------------

// MsgCancelBinaryOptionsOrderResponse

// -------------------------------------------------------------------

// OrderData

// string market_id = 1 [json_name = "marketId"];
inline void OrderData::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderData::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderData.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderData::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderData.market_id)
}
inline std::string* OrderData::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderData.market_id)
  return _s;
}
inline const std::string& OrderData::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderData::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderData::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderData::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderData.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderData::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderData.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void OrderData::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& OrderData::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderData.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderData::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderData.subaccount_id)
}
inline std::string* OrderData::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderData.subaccount_id)
  return _s;
}
inline const std::string& OrderData::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void OrderData::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderData::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderData::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderData.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void OrderData::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderData.subaccount_id)
}

// string order_hash = 3 [json_name = "orderHash"];
inline void OrderData::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& OrderData::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderData.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderData::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderData.order_hash)
}
inline std::string* OrderData::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderData.order_hash)
  return _s;
}
inline const std::string& OrderData::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void OrderData::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderData::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderData::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderData.order_hash)
  return _impl_.order_hash_.Release();
}
inline void OrderData::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderData.order_hash)
}

// int32 order_mask = 4 [json_name = "orderMask"];
inline void OrderData::clear_order_mask() {
  _impl_.order_mask_ = 0;
}
inline ::int32_t OrderData::order_mask() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderData.order_mask)
  return _internal_order_mask();
}
inline void OrderData::set_order_mask(::int32_t value) {
  _internal_set_order_mask(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderData.order_mask)
}
inline ::int32_t OrderData::_internal_order_mask() const {
  return _impl_.order_mask_;
}
inline void OrderData::_internal_set_order_mask(::int32_t value) {
  ;
  _impl_.order_mask_ = value;
}

// -------------------------------------------------------------------

// MsgBatchCancelDerivativeOrders

// string sender = 1 [json_name = "sender"];
inline void MsgBatchCancelDerivativeOrders::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgBatchCancelDerivativeOrders::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgBatchCancelDerivativeOrders::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.sender)
}
inline std::string* MsgBatchCancelDerivativeOrders::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.sender)
  return _s;
}
inline const std::string& MsgBatchCancelDerivativeOrders::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgBatchCancelDerivativeOrders::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgBatchCancelDerivativeOrders::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgBatchCancelDerivativeOrders::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.sender)
  return _impl_.sender_.Release();
}
inline void MsgBatchCancelDerivativeOrders::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.sender)
}

// repeated .injective.exchange.v1beta1.OrderData data = 2 [json_name = "data", (.gogoproto.nullable) = false];
inline int MsgBatchCancelDerivativeOrders::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int MsgBatchCancelDerivativeOrders::data_size() const {
  return _internal_data_size();
}
inline void MsgBatchCancelDerivativeOrders::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelDerivativeOrders::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >*
MsgBatchCancelDerivativeOrders::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.data)
  return _internal_mutable_data();
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchCancelDerivativeOrders::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderData& MsgBatchCancelDerivativeOrders::data(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.data)
  return _internal_data(index);
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelDerivativeOrders::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective::exchange::v1beta1::OrderData* MsgBatchCancelDerivativeOrders::add_data() {
  ::injective::exchange::v1beta1::OrderData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderData >&
MsgBatchCancelDerivativeOrders::data() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>&
MsgBatchCancelDerivativeOrders::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderData>*
MsgBatchCancelDerivativeOrders::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// MsgBatchCancelDerivativeOrdersResponse

// repeated bool success = 1 [json_name = "success"];
inline int MsgBatchCancelDerivativeOrdersResponse::_internal_success_size() const {
  return _impl_.success_.size();
}
inline int MsgBatchCancelDerivativeOrdersResponse::success_size() const {
  return _internal_success_size();
}
inline void MsgBatchCancelDerivativeOrdersResponse::clear_success() {
  _internal_mutable_success()->Clear();
}
inline bool MsgBatchCancelDerivativeOrdersResponse::success(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse.success)
  return _internal_success(index);
}
inline void MsgBatchCancelDerivativeOrdersResponse::set_success(int index, bool value) {
  _internal_mutable_success()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse.success)
}
inline void MsgBatchCancelDerivativeOrdersResponse::add_success(bool value) {
  _internal_add_success(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse.success)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchCancelDerivativeOrdersResponse::success() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse.success)
  return _internal_success();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchCancelDerivativeOrdersResponse::mutable_success() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse.success)
  return _internal_mutable_success();
}

inline bool MsgBatchCancelDerivativeOrdersResponse::_internal_success(int index) const {
  return _internal_success().Get(index);
}
inline void MsgBatchCancelDerivativeOrdersResponse::_internal_add_success(bool value) {
  _internal_mutable_success()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>& MsgBatchCancelDerivativeOrdersResponse::_internal_success() const {
  return _impl_.success_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<bool>* MsgBatchCancelDerivativeOrdersResponse::_internal_mutable_success() {
  return &_impl_.success_;
}

// -------------------------------------------------------------------

// MsgSubaccountTransfer

// string sender = 1 [json_name = "sender"];
inline void MsgSubaccountTransfer::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgSubaccountTransfer::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSubaccountTransfer.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSubaccountTransfer::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgSubaccountTransfer.sender)
}
inline std::string* MsgSubaccountTransfer::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSubaccountTransfer.sender)
  return _s;
}
inline const std::string& MsgSubaccountTransfer::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgSubaccountTransfer::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSubaccountTransfer::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSubaccountTransfer::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSubaccountTransfer.sender)
  return _impl_.sender_.Release();
}
inline void MsgSubaccountTransfer::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSubaccountTransfer.sender)
}

// string source_subaccount_id = 2 [json_name = "sourceSubaccountId"];
inline void MsgSubaccountTransfer::clear_source_subaccount_id() {
  _impl_.source_subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgSubaccountTransfer::source_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSubaccountTransfer.source_subaccount_id)
  return _internal_source_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSubaccountTransfer::set_source_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgSubaccountTransfer.source_subaccount_id)
}
inline std::string* MsgSubaccountTransfer::mutable_source_subaccount_id() {
  std::string* _s = _internal_mutable_source_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSubaccountTransfer.source_subaccount_id)
  return _s;
}
inline const std::string& MsgSubaccountTransfer::_internal_source_subaccount_id() const {
  return _impl_.source_subaccount_id_.Get();
}
inline void MsgSubaccountTransfer::_internal_set_source_subaccount_id(const std::string& value) {
  ;


  _impl_.source_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSubaccountTransfer::_internal_mutable_source_subaccount_id() {
  ;
  return _impl_.source_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSubaccountTransfer::release_source_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSubaccountTransfer.source_subaccount_id)
  return _impl_.source_subaccount_id_.Release();
}
inline void MsgSubaccountTransfer::set_allocated_source_subaccount_id(std::string* value) {
  _impl_.source_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_subaccount_id_.IsDefault()) {
          _impl_.source_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSubaccountTransfer.source_subaccount_id)
}

// string destination_subaccount_id = 3 [json_name = "destinationSubaccountId"];
inline void MsgSubaccountTransfer::clear_destination_subaccount_id() {
  _impl_.destination_subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgSubaccountTransfer::destination_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSubaccountTransfer.destination_subaccount_id)
  return _internal_destination_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSubaccountTransfer::set_destination_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgSubaccountTransfer.destination_subaccount_id)
}
inline std::string* MsgSubaccountTransfer::mutable_destination_subaccount_id() {
  std::string* _s = _internal_mutable_destination_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSubaccountTransfer.destination_subaccount_id)
  return _s;
}
inline const std::string& MsgSubaccountTransfer::_internal_destination_subaccount_id() const {
  return _impl_.destination_subaccount_id_.Get();
}
inline void MsgSubaccountTransfer::_internal_set_destination_subaccount_id(const std::string& value) {
  ;


  _impl_.destination_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSubaccountTransfer::_internal_mutable_destination_subaccount_id() {
  ;
  return _impl_.destination_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSubaccountTransfer::release_destination_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSubaccountTransfer.destination_subaccount_id)
  return _impl_.destination_subaccount_id_.Release();
}
inline void MsgSubaccountTransfer::set_allocated_destination_subaccount_id(std::string* value) {
  _impl_.destination_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_subaccount_id_.IsDefault()) {
          _impl_.destination_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSubaccountTransfer.destination_subaccount_id)
}

// .cosmos.base.v1beta1.Coin amount = 4 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool MsgSubaccountTransfer::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgSubaccountTransfer::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgSubaccountTransfer::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSubaccountTransfer.amount)
  return _internal_amount();
}
inline void MsgSubaccountTransfer::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgSubaccountTransfer.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgSubaccountTransfer::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgSubaccountTransfer::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSubaccountTransfer.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgSubaccountTransfer::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgSubaccountTransfer::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSubaccountTransfer.amount)
  return _msg;
}
inline void MsgSubaccountTransfer::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSubaccountTransfer.amount)
}

// -------------------------------------------------------------------

// MsgSubaccountTransferResponse

// -------------------------------------------------------------------

// MsgExternalTransfer

// string sender = 1 [json_name = "sender"];
inline void MsgExternalTransfer::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgExternalTransfer::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgExternalTransfer.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExternalTransfer::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgExternalTransfer.sender)
}
inline std::string* MsgExternalTransfer::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgExternalTransfer.sender)
  return _s;
}
inline const std::string& MsgExternalTransfer::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgExternalTransfer::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExternalTransfer::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExternalTransfer::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgExternalTransfer.sender)
  return _impl_.sender_.Release();
}
inline void MsgExternalTransfer::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgExternalTransfer.sender)
}

// string source_subaccount_id = 2 [json_name = "sourceSubaccountId"];
inline void MsgExternalTransfer::clear_source_subaccount_id() {
  _impl_.source_subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgExternalTransfer::source_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgExternalTransfer.source_subaccount_id)
  return _internal_source_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExternalTransfer::set_source_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgExternalTransfer.source_subaccount_id)
}
inline std::string* MsgExternalTransfer::mutable_source_subaccount_id() {
  std::string* _s = _internal_mutable_source_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgExternalTransfer.source_subaccount_id)
  return _s;
}
inline const std::string& MsgExternalTransfer::_internal_source_subaccount_id() const {
  return _impl_.source_subaccount_id_.Get();
}
inline void MsgExternalTransfer::_internal_set_source_subaccount_id(const std::string& value) {
  ;


  _impl_.source_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExternalTransfer::_internal_mutable_source_subaccount_id() {
  ;
  return _impl_.source_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExternalTransfer::release_source_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgExternalTransfer.source_subaccount_id)
  return _impl_.source_subaccount_id_.Release();
}
inline void MsgExternalTransfer::set_allocated_source_subaccount_id(std::string* value) {
  _impl_.source_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_subaccount_id_.IsDefault()) {
          _impl_.source_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgExternalTransfer.source_subaccount_id)
}

// string destination_subaccount_id = 3 [json_name = "destinationSubaccountId"];
inline void MsgExternalTransfer::clear_destination_subaccount_id() {
  _impl_.destination_subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgExternalTransfer::destination_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgExternalTransfer.destination_subaccount_id)
  return _internal_destination_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgExternalTransfer::set_destination_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgExternalTransfer.destination_subaccount_id)
}
inline std::string* MsgExternalTransfer::mutable_destination_subaccount_id() {
  std::string* _s = _internal_mutable_destination_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgExternalTransfer.destination_subaccount_id)
  return _s;
}
inline const std::string& MsgExternalTransfer::_internal_destination_subaccount_id() const {
  return _impl_.destination_subaccount_id_.Get();
}
inline void MsgExternalTransfer::_internal_set_destination_subaccount_id(const std::string& value) {
  ;


  _impl_.destination_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgExternalTransfer::_internal_mutable_destination_subaccount_id() {
  ;
  return _impl_.destination_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgExternalTransfer::release_destination_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgExternalTransfer.destination_subaccount_id)
  return _impl_.destination_subaccount_id_.Release();
}
inline void MsgExternalTransfer::set_allocated_destination_subaccount_id(std::string* value) {
  _impl_.destination_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_subaccount_id_.IsDefault()) {
          _impl_.destination_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgExternalTransfer.destination_subaccount_id)
}

// .cosmos.base.v1beta1.Coin amount = 4 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool MsgExternalTransfer::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& MsgExternalTransfer::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& MsgExternalTransfer::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgExternalTransfer.amount)
  return _internal_amount();
}
inline void MsgExternalTransfer::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgExternalTransfer.amount)
}
inline ::cosmos::base::v1beta1::Coin* MsgExternalTransfer::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgExternalTransfer::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgExternalTransfer.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* MsgExternalTransfer::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* MsgExternalTransfer::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgExternalTransfer.amount)
  return _msg;
}
inline void MsgExternalTransfer::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgExternalTransfer.amount)
}

// -------------------------------------------------------------------

// MsgExternalTransferResponse

// -------------------------------------------------------------------

// MsgLiquidatePosition

// string sender = 1 [json_name = "sender"];
inline void MsgLiquidatePosition::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgLiquidatePosition::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgLiquidatePosition.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgLiquidatePosition::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgLiquidatePosition.sender)
}
inline std::string* MsgLiquidatePosition::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgLiquidatePosition.sender)
  return _s;
}
inline const std::string& MsgLiquidatePosition::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgLiquidatePosition::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgLiquidatePosition::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgLiquidatePosition::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgLiquidatePosition.sender)
  return _impl_.sender_.Release();
}
inline void MsgLiquidatePosition::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgLiquidatePosition.sender)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void MsgLiquidatePosition::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgLiquidatePosition::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgLiquidatePosition.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgLiquidatePosition::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgLiquidatePosition.subaccount_id)
}
inline std::string* MsgLiquidatePosition::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgLiquidatePosition.subaccount_id)
  return _s;
}
inline const std::string& MsgLiquidatePosition::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void MsgLiquidatePosition::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgLiquidatePosition::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgLiquidatePosition::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgLiquidatePosition.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void MsgLiquidatePosition::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgLiquidatePosition.subaccount_id)
}

// string market_id = 3 [json_name = "marketId"];
inline void MsgLiquidatePosition::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MsgLiquidatePosition::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgLiquidatePosition.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgLiquidatePosition::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgLiquidatePosition.market_id)
}
inline std::string* MsgLiquidatePosition::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgLiquidatePosition.market_id)
  return _s;
}
inline const std::string& MsgLiquidatePosition::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MsgLiquidatePosition::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgLiquidatePosition::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgLiquidatePosition::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgLiquidatePosition.market_id)
  return _impl_.market_id_.Release();
}
inline void MsgLiquidatePosition::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgLiquidatePosition.market_id)
}

// .injective.exchange.v1beta1.DerivativeOrder order = 4 [json_name = "order", (.gogoproto.nullable) = true];
inline bool MsgLiquidatePosition::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgLiquidatePosition::_internal_order() const {
  const ::injective::exchange::v1beta1::DerivativeOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeOrder&>(
      ::injective::exchange::v1beta1::_DerivativeOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& MsgLiquidatePosition::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgLiquidatePosition.order)
  return _internal_order();
}
inline void MsgLiquidatePosition::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::DerivativeOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgLiquidatePosition.order)
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgLiquidatePosition::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgLiquidatePosition::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgLiquidatePosition.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgLiquidatePosition::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* MsgLiquidatePosition::mutable_order() {
  ::injective::exchange::v1beta1::DerivativeOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgLiquidatePosition.order)
  return _msg;
}
inline void MsgLiquidatePosition::set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgLiquidatePosition.order)
}

// -------------------------------------------------------------------

// MsgLiquidatePositionResponse

// -------------------------------------------------------------------

// MsgIncreasePositionMargin

// string sender = 1 [json_name = "sender"];
inline void MsgIncreasePositionMargin::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgIncreasePositionMargin::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgIncreasePositionMargin.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgIncreasePositionMargin::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgIncreasePositionMargin.sender)
}
inline std::string* MsgIncreasePositionMargin::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgIncreasePositionMargin.sender)
  return _s;
}
inline const std::string& MsgIncreasePositionMargin::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgIncreasePositionMargin::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgIncreasePositionMargin.sender)
  return _impl_.sender_.Release();
}
inline void MsgIncreasePositionMargin::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgIncreasePositionMargin.sender)
}

// string source_subaccount_id = 2 [json_name = "sourceSubaccountId"];
inline void MsgIncreasePositionMargin::clear_source_subaccount_id() {
  _impl_.source_subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgIncreasePositionMargin::source_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgIncreasePositionMargin.source_subaccount_id)
  return _internal_source_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgIncreasePositionMargin::set_source_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgIncreasePositionMargin.source_subaccount_id)
}
inline std::string* MsgIncreasePositionMargin::mutable_source_subaccount_id() {
  std::string* _s = _internal_mutable_source_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgIncreasePositionMargin.source_subaccount_id)
  return _s;
}
inline const std::string& MsgIncreasePositionMargin::_internal_source_subaccount_id() const {
  return _impl_.source_subaccount_id_.Get();
}
inline void MsgIncreasePositionMargin::_internal_set_source_subaccount_id(const std::string& value) {
  ;


  _impl_.source_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::_internal_mutable_source_subaccount_id() {
  ;
  return _impl_.source_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::release_source_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgIncreasePositionMargin.source_subaccount_id)
  return _impl_.source_subaccount_id_.Release();
}
inline void MsgIncreasePositionMargin::set_allocated_source_subaccount_id(std::string* value) {
  _impl_.source_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_subaccount_id_.IsDefault()) {
          _impl_.source_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgIncreasePositionMargin.source_subaccount_id)
}

// string destination_subaccount_id = 3 [json_name = "destinationSubaccountId"];
inline void MsgIncreasePositionMargin::clear_destination_subaccount_id() {
  _impl_.destination_subaccount_id_.ClearToEmpty();
}
inline const std::string& MsgIncreasePositionMargin::destination_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgIncreasePositionMargin.destination_subaccount_id)
  return _internal_destination_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgIncreasePositionMargin::set_destination_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgIncreasePositionMargin.destination_subaccount_id)
}
inline std::string* MsgIncreasePositionMargin::mutable_destination_subaccount_id() {
  std::string* _s = _internal_mutable_destination_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgIncreasePositionMargin.destination_subaccount_id)
  return _s;
}
inline const std::string& MsgIncreasePositionMargin::_internal_destination_subaccount_id() const {
  return _impl_.destination_subaccount_id_.Get();
}
inline void MsgIncreasePositionMargin::_internal_set_destination_subaccount_id(const std::string& value) {
  ;


  _impl_.destination_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::_internal_mutable_destination_subaccount_id() {
  ;
  return _impl_.destination_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::release_destination_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgIncreasePositionMargin.destination_subaccount_id)
  return _impl_.destination_subaccount_id_.Release();
}
inline void MsgIncreasePositionMargin::set_allocated_destination_subaccount_id(std::string* value) {
  _impl_.destination_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_subaccount_id_.IsDefault()) {
          _impl_.destination_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgIncreasePositionMargin.destination_subaccount_id)
}

// string market_id = 4 [json_name = "marketId"];
inline void MsgIncreasePositionMargin::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MsgIncreasePositionMargin::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgIncreasePositionMargin.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgIncreasePositionMargin::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgIncreasePositionMargin.market_id)
}
inline std::string* MsgIncreasePositionMargin::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgIncreasePositionMargin.market_id)
  return _s;
}
inline const std::string& MsgIncreasePositionMargin::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MsgIncreasePositionMargin::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgIncreasePositionMargin.market_id)
  return _impl_.market_id_.Release();
}
inline void MsgIncreasePositionMargin::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgIncreasePositionMargin.market_id)
}

// string amount = 5 [json_name = "amount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgIncreasePositionMargin::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& MsgIncreasePositionMargin::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgIncreasePositionMargin.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgIncreasePositionMargin::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgIncreasePositionMargin.amount)
}
inline std::string* MsgIncreasePositionMargin::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgIncreasePositionMargin.amount)
  return _s;
}
inline const std::string& MsgIncreasePositionMargin::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void MsgIncreasePositionMargin::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgIncreasePositionMargin::release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgIncreasePositionMargin.amount)
  return _impl_.amount_.Release();
}
inline void MsgIncreasePositionMargin::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgIncreasePositionMargin.amount)
}

// -------------------------------------------------------------------

// MsgIncreasePositionMarginResponse

// -------------------------------------------------------------------

// MsgPrivilegedExecuteContract

// string sender = 1 [json_name = "sender"];
inline void MsgPrivilegedExecuteContract::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgPrivilegedExecuteContract::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgPrivilegedExecuteContract::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.sender)
}
inline std::string* MsgPrivilegedExecuteContract::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.sender)
  return _s;
}
inline const std::string& MsgPrivilegedExecuteContract::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgPrivilegedExecuteContract::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.sender)
  return _impl_.sender_.Release();
}
inline void MsgPrivilegedExecuteContract::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.sender)
}

// string funds = 2 [json_name = "funds"];
inline void MsgPrivilegedExecuteContract::clear_funds() {
  _impl_.funds_.ClearToEmpty();
}
inline const std::string& MsgPrivilegedExecuteContract::funds() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.funds)
  return _internal_funds();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgPrivilegedExecuteContract::set_funds(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.funds_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.funds)
}
inline std::string* MsgPrivilegedExecuteContract::mutable_funds() {
  std::string* _s = _internal_mutable_funds();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.funds)
  return _s;
}
inline const std::string& MsgPrivilegedExecuteContract::_internal_funds() const {
  return _impl_.funds_.Get();
}
inline void MsgPrivilegedExecuteContract::_internal_set_funds(const std::string& value) {
  ;


  _impl_.funds_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::_internal_mutable_funds() {
  ;
  return _impl_.funds_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::release_funds() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.funds)
  return _impl_.funds_.Release();
}
inline void MsgPrivilegedExecuteContract::set_allocated_funds(std::string* value) {
  _impl_.funds_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.funds_.IsDefault()) {
          _impl_.funds_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.funds)
}

// string contract_address = 3 [json_name = "contractAddress"];
inline void MsgPrivilegedExecuteContract::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& MsgPrivilegedExecuteContract::contract_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgPrivilegedExecuteContract::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.contract_address)
}
inline std::string* MsgPrivilegedExecuteContract::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.contract_address)
  return _s;
}
inline const std::string& MsgPrivilegedExecuteContract::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void MsgPrivilegedExecuteContract::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.contract_address)
  return _impl_.contract_address_.Release();
}
inline void MsgPrivilegedExecuteContract::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.contract_address)
}

// string data = 4 [json_name = "data"];
inline void MsgPrivilegedExecuteContract::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& MsgPrivilegedExecuteContract::data() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgPrivilegedExecuteContract::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.data)
}
inline std::string* MsgPrivilegedExecuteContract::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.data)
  return _s;
}
inline const std::string& MsgPrivilegedExecuteContract::_internal_data() const {
  return _impl_.data_.Get();
}
inline void MsgPrivilegedExecuteContract::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgPrivilegedExecuteContract::release_data() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.data)
  return _impl_.data_.Release();
}
inline void MsgPrivilegedExecuteContract::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgPrivilegedExecuteContract.data)
}

// -------------------------------------------------------------------

// MsgPrivilegedExecuteContractResponse

// repeated .cosmos.base.v1beta1.Coin funds_diff = 1 [json_name = "fundsDiff", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
inline int MsgPrivilegedExecuteContractResponse::_internal_funds_diff_size() const {
  return _impl_.funds_diff_.size();
}
inline int MsgPrivilegedExecuteContractResponse::funds_diff_size() const {
  return _internal_funds_diff_size();
}
inline ::cosmos::base::v1beta1::Coin* MsgPrivilegedExecuteContractResponse::mutable_funds_diff(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse.funds_diff)
  return _internal_mutable_funds_diff()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
MsgPrivilegedExecuteContractResponse::mutable_funds_diff() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse.funds_diff)
  return _internal_mutable_funds_diff();
}
inline const ::cosmos::base::v1beta1::Coin& MsgPrivilegedExecuteContractResponse::_internal_funds_diff(int index) const {
  return _internal_funds_diff().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& MsgPrivilegedExecuteContractResponse::funds_diff(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse.funds_diff)
  return _internal_funds_diff(index);
}
inline ::cosmos::base::v1beta1::Coin* MsgPrivilegedExecuteContractResponse::_internal_add_funds_diff() {
  return _internal_mutable_funds_diff()->Add();
}
inline ::cosmos::base::v1beta1::Coin* MsgPrivilegedExecuteContractResponse::add_funds_diff() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_funds_diff();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse.funds_diff)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
MsgPrivilegedExecuteContractResponse::funds_diff() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse.funds_diff)
  return _internal_funds_diff();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
MsgPrivilegedExecuteContractResponse::_internal_funds_diff() const {
  return _impl_.funds_diff_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
MsgPrivilegedExecuteContractResponse::_internal_mutable_funds_diff() {
  return &_impl_.funds_diff_;
}

// -------------------------------------------------------------------

// SpotMarketParamUpdateProposal

// string title = 1 [json_name = "title"];
inline void SpotMarketParamUpdateProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.title)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.title)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.title)
  return _impl_.title_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.title)
}

// string description = 2 [json_name = "description"];
inline void SpotMarketParamUpdateProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.description)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.description)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.description)
  return _impl_.description_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.description)
}

// string market_id = 3 [json_name = "marketId"];
inline void SpotMarketParamUpdateProposal::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.market_id)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.market_id)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.market_id)
  return _impl_.market_id_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.market_id)
}

// string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketParamUpdateProposal::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.maker_fee_rate)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.maker_fee_rate)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.maker_fee_rate)
}

// string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketParamUpdateProposal::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.taker_fee_rate)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.taker_fee_rate)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.taker_fee_rate)
}

// string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketParamUpdateProposal::clear_relayer_fee_share_rate() {
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::relayer_fee_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.relayer_fee_share_rate)
  return _internal_relayer_fee_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_relayer_fee_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_fee_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.relayer_fee_share_rate)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_relayer_fee_share_rate() {
  std::string* _s = _internal_mutable_relayer_fee_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.relayer_fee_share_rate)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_relayer_fee_share_rate() const {
  return _impl_.relayer_fee_share_rate_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_relayer_fee_share_rate(const std::string& value) {
  ;


  _impl_.relayer_fee_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_relayer_fee_share_rate() {
  ;
  return _impl_.relayer_fee_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_relayer_fee_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.relayer_fee_share_rate)
  return _impl_.relayer_fee_share_rate_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_relayer_fee_share_rate(std::string* value) {
  _impl_.relayer_fee_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_fee_share_rate_.IsDefault()) {
          _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.relayer_fee_share_rate)
}

// string min_price_tick_size = 7 [json_name = "minPriceTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketParamUpdateProposal::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_price_tick_size)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_price_tick_size)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_price_tick_size)
}

// string min_quantity_tick_size = 8 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketParamUpdateProposal::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarketParamUpdateProposal::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketParamUpdateProposal::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_quantity_tick_size)
}
inline std::string* SpotMarketParamUpdateProposal::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_quantity_tick_size)
  return _s;
}
inline const std::string& SpotMarketParamUpdateProposal::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void SpotMarketParamUpdateProposal::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketParamUpdateProposal::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void SpotMarketParamUpdateProposal::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.min_quantity_tick_size)
}

// .injective.exchange.v1beta1.MarketStatus status = 9 [json_name = "status"];
inline void SpotMarketParamUpdateProposal::clear_status() {
  _impl_.status_ = 0;
}
inline ::injective::exchange::v1beta1::MarketStatus SpotMarketParamUpdateProposal::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.status)
  return _internal_status();
}
inline void SpotMarketParamUpdateProposal::set_status(::injective::exchange::v1beta1::MarketStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketParamUpdateProposal.status)
}
inline ::injective::exchange::v1beta1::MarketStatus SpotMarketParamUpdateProposal::_internal_status() const {
  return static_cast<::injective::exchange::v1beta1::MarketStatus>(_impl_.status_);
}
inline void SpotMarketParamUpdateProposal::_internal_set_status(::injective::exchange::v1beta1::MarketStatus value) {
  ;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// ExchangeEnableProposal

// string title = 1 [json_name = "title"];
inline void ExchangeEnableProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ExchangeEnableProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExchangeEnableProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExchangeEnableProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExchangeEnableProposal.title)
}
inline std::string* ExchangeEnableProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExchangeEnableProposal.title)
  return _s;
}
inline const std::string& ExchangeEnableProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ExchangeEnableProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeEnableProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* ExchangeEnableProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExchangeEnableProposal.title)
  return _impl_.title_.Release();
}
inline void ExchangeEnableProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExchangeEnableProposal.title)
}

// string description = 2 [json_name = "description"];
inline void ExchangeEnableProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ExchangeEnableProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExchangeEnableProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExchangeEnableProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExchangeEnableProposal.description)
}
inline std::string* ExchangeEnableProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExchangeEnableProposal.description)
  return _s;
}
inline const std::string& ExchangeEnableProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ExchangeEnableProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangeEnableProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* ExchangeEnableProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExchangeEnableProposal.description)
  return _impl_.description_.Release();
}
inline void ExchangeEnableProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExchangeEnableProposal.description)
}

// .injective.exchange.v1beta1.ExchangeType exchangeType = 3 [json_name = "exchangeType"];
inline void ExchangeEnableProposal::clear_exchangetype() {
  _impl_.exchangetype_ = 0;
}
inline ::injective::exchange::v1beta1::ExchangeType ExchangeEnableProposal::exchangetype() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExchangeEnableProposal.exchangeType)
  return _internal_exchangetype();
}
inline void ExchangeEnableProposal::set_exchangetype(::injective::exchange::v1beta1::ExchangeType value) {
   _internal_set_exchangetype(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExchangeEnableProposal.exchangeType)
}
inline ::injective::exchange::v1beta1::ExchangeType ExchangeEnableProposal::_internal_exchangetype() const {
  return static_cast<::injective::exchange::v1beta1::ExchangeType>(_impl_.exchangetype_);
}
inline void ExchangeEnableProposal::_internal_set_exchangetype(::injective::exchange::v1beta1::ExchangeType value) {
  ;
  _impl_.exchangetype_ = value;
}

// -------------------------------------------------------------------

// BatchExchangeModificationProposal

// string title = 1 [json_name = "title"];
inline void BatchExchangeModificationProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& BatchExchangeModificationProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BatchExchangeModificationProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BatchExchangeModificationProposal.title)
}
inline std::string* BatchExchangeModificationProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.title)
  return _s;
}
inline const std::string& BatchExchangeModificationProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void BatchExchangeModificationProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchExchangeModificationProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* BatchExchangeModificationProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BatchExchangeModificationProposal.title)
  return _impl_.title_.Release();
}
inline void BatchExchangeModificationProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BatchExchangeModificationProposal.title)
}

// string description = 2 [json_name = "description"];
inline void BatchExchangeModificationProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& BatchExchangeModificationProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BatchExchangeModificationProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BatchExchangeModificationProposal.description)
}
inline std::string* BatchExchangeModificationProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.description)
  return _s;
}
inline const std::string& BatchExchangeModificationProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void BatchExchangeModificationProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchExchangeModificationProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* BatchExchangeModificationProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BatchExchangeModificationProposal.description)
  return _impl_.description_.Release();
}
inline void BatchExchangeModificationProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BatchExchangeModificationProposal.description)
}

// repeated .injective.exchange.v1beta1.SpotMarketParamUpdateProposal spot_market_param_update_proposals = 3 [json_name = "spotMarketParamUpdateProposals"];
inline int BatchExchangeModificationProposal::_internal_spot_market_param_update_proposals_size() const {
  return _impl_.spot_market_param_update_proposals_.size();
}
inline int BatchExchangeModificationProposal::spot_market_param_update_proposals_size() const {
  return _internal_spot_market_param_update_proposals_size();
}
inline void BatchExchangeModificationProposal::clear_spot_market_param_update_proposals() {
  _internal_mutable_spot_market_param_update_proposals()->Clear();
}
inline ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* BatchExchangeModificationProposal::mutable_spot_market_param_update_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_param_update_proposals)
  return _internal_mutable_spot_market_param_update_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal >*
BatchExchangeModificationProposal::mutable_spot_market_param_update_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_param_update_proposals)
  return _internal_mutable_spot_market_param_update_proposals();
}
inline const ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal& BatchExchangeModificationProposal::_internal_spot_market_param_update_proposals(int index) const {
  return _internal_spot_market_param_update_proposals().Get(index);
}
inline const ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal& BatchExchangeModificationProposal::spot_market_param_update_proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_param_update_proposals)
  return _internal_spot_market_param_update_proposals(index);
}
inline ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* BatchExchangeModificationProposal::_internal_add_spot_market_param_update_proposals() {
  return _internal_mutable_spot_market_param_update_proposals()->Add();
}
inline ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* BatchExchangeModificationProposal::add_spot_market_param_update_proposals() {
  ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal* _add = _internal_add_spot_market_param_update_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_param_update_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketParamUpdateProposal >&
BatchExchangeModificationProposal::spot_market_param_update_proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_param_update_proposals)
  return _internal_spot_market_param_update_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketParamUpdateProposal>&
BatchExchangeModificationProposal::_internal_spot_market_param_update_proposals() const {
  return _impl_.spot_market_param_update_proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketParamUpdateProposal>*
BatchExchangeModificationProposal::_internal_mutable_spot_market_param_update_proposals() {
  return &_impl_.spot_market_param_update_proposals_;
}

// repeated .injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals = 4 [json_name = "derivativeMarketParamUpdateProposals"];
inline int BatchExchangeModificationProposal::_internal_derivative_market_param_update_proposals_size() const {
  return _impl_.derivative_market_param_update_proposals_.size();
}
inline int BatchExchangeModificationProposal::derivative_market_param_update_proposals_size() const {
  return _internal_derivative_market_param_update_proposals_size();
}
inline void BatchExchangeModificationProposal::clear_derivative_market_param_update_proposals() {
  _internal_mutable_derivative_market_param_update_proposals()->Clear();
}
inline ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* BatchExchangeModificationProposal::mutable_derivative_market_param_update_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.derivative_market_param_update_proposals)
  return _internal_mutable_derivative_market_param_update_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal >*
BatchExchangeModificationProposal::mutable_derivative_market_param_update_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.derivative_market_param_update_proposals)
  return _internal_mutable_derivative_market_param_update_proposals();
}
inline const ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal& BatchExchangeModificationProposal::_internal_derivative_market_param_update_proposals(int index) const {
  return _internal_derivative_market_param_update_proposals().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal& BatchExchangeModificationProposal::derivative_market_param_update_proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.derivative_market_param_update_proposals)
  return _internal_derivative_market_param_update_proposals(index);
}
inline ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* BatchExchangeModificationProposal::_internal_add_derivative_market_param_update_proposals() {
  return _internal_mutable_derivative_market_param_update_proposals()->Add();
}
inline ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* BatchExchangeModificationProposal::add_derivative_market_param_update_proposals() {
  ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal* _add = _internal_add_derivative_market_param_update_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchExchangeModificationProposal.derivative_market_param_update_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal >&
BatchExchangeModificationProposal::derivative_market_param_update_proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.derivative_market_param_update_proposals)
  return _internal_derivative_market_param_update_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal>&
BatchExchangeModificationProposal::_internal_derivative_market_param_update_proposals() const {
  return _impl_.derivative_market_param_update_proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeMarketParamUpdateProposal>*
BatchExchangeModificationProposal::_internal_mutable_derivative_market_param_update_proposals() {
  return &_impl_.derivative_market_param_update_proposals_;
}

// repeated .injective.exchange.v1beta1.SpotMarketLaunchProposal spot_market_launch_proposals = 5 [json_name = "spotMarketLaunchProposals"];
inline int BatchExchangeModificationProposal::_internal_spot_market_launch_proposals_size() const {
  return _impl_.spot_market_launch_proposals_.size();
}
inline int BatchExchangeModificationProposal::spot_market_launch_proposals_size() const {
  return _internal_spot_market_launch_proposals_size();
}
inline void BatchExchangeModificationProposal::clear_spot_market_launch_proposals() {
  _internal_mutable_spot_market_launch_proposals()->Clear();
}
inline ::injective::exchange::v1beta1::SpotMarketLaunchProposal* BatchExchangeModificationProposal::mutable_spot_market_launch_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_launch_proposals)
  return _internal_mutable_spot_market_launch_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketLaunchProposal >*
BatchExchangeModificationProposal::mutable_spot_market_launch_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_launch_proposals)
  return _internal_mutable_spot_market_launch_proposals();
}
inline const ::injective::exchange::v1beta1::SpotMarketLaunchProposal& BatchExchangeModificationProposal::_internal_spot_market_launch_proposals(int index) const {
  return _internal_spot_market_launch_proposals().Get(index);
}
inline const ::injective::exchange::v1beta1::SpotMarketLaunchProposal& BatchExchangeModificationProposal::spot_market_launch_proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_launch_proposals)
  return _internal_spot_market_launch_proposals(index);
}
inline ::injective::exchange::v1beta1::SpotMarketLaunchProposal* BatchExchangeModificationProposal::_internal_add_spot_market_launch_proposals() {
  return _internal_mutable_spot_market_launch_proposals()->Add();
}
inline ::injective::exchange::v1beta1::SpotMarketLaunchProposal* BatchExchangeModificationProposal::add_spot_market_launch_proposals() {
  ::injective::exchange::v1beta1::SpotMarketLaunchProposal* _add = _internal_add_spot_market_launch_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_launch_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarketLaunchProposal >&
BatchExchangeModificationProposal::spot_market_launch_proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.spot_market_launch_proposals)
  return _internal_spot_market_launch_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketLaunchProposal>&
BatchExchangeModificationProposal::_internal_spot_market_launch_proposals() const {
  return _impl_.spot_market_launch_proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarketLaunchProposal>*
BatchExchangeModificationProposal::_internal_mutable_spot_market_launch_proposals() {
  return &_impl_.spot_market_launch_proposals_;
}

// repeated .injective.exchange.v1beta1.PerpetualMarketLaunchProposal perpetual_market_launch_proposals = 6 [json_name = "perpetualMarketLaunchProposals"];
inline int BatchExchangeModificationProposal::_internal_perpetual_market_launch_proposals_size() const {
  return _impl_.perpetual_market_launch_proposals_.size();
}
inline int BatchExchangeModificationProposal::perpetual_market_launch_proposals_size() const {
  return _internal_perpetual_market_launch_proposals_size();
}
inline void BatchExchangeModificationProposal::clear_perpetual_market_launch_proposals() {
  _internal_mutable_perpetual_market_launch_proposals()->Clear();
}
inline ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* BatchExchangeModificationProposal::mutable_perpetual_market_launch_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.perpetual_market_launch_proposals)
  return _internal_mutable_perpetual_market_launch_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal >*
BatchExchangeModificationProposal::mutable_perpetual_market_launch_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.perpetual_market_launch_proposals)
  return _internal_mutable_perpetual_market_launch_proposals();
}
inline const ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal& BatchExchangeModificationProposal::_internal_perpetual_market_launch_proposals(int index) const {
  return _internal_perpetual_market_launch_proposals().Get(index);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal& BatchExchangeModificationProposal::perpetual_market_launch_proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.perpetual_market_launch_proposals)
  return _internal_perpetual_market_launch_proposals(index);
}
inline ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* BatchExchangeModificationProposal::_internal_add_perpetual_market_launch_proposals() {
  return _internal_mutable_perpetual_market_launch_proposals()->Add();
}
inline ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* BatchExchangeModificationProposal::add_perpetual_market_launch_proposals() {
  ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal* _add = _internal_add_perpetual_market_launch_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchExchangeModificationProposal.perpetual_market_launch_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::PerpetualMarketLaunchProposal >&
BatchExchangeModificationProposal::perpetual_market_launch_proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.perpetual_market_launch_proposals)
  return _internal_perpetual_market_launch_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PerpetualMarketLaunchProposal>&
BatchExchangeModificationProposal::_internal_perpetual_market_launch_proposals() const {
  return _impl_.perpetual_market_launch_proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::PerpetualMarketLaunchProposal>*
BatchExchangeModificationProposal::_internal_mutable_perpetual_market_launch_proposals() {
  return &_impl_.perpetual_market_launch_proposals_;
}

// repeated .injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals = 7 [json_name = "expiryFuturesMarketLaunchProposals"];
inline int BatchExchangeModificationProposal::_internal_expiry_futures_market_launch_proposals_size() const {
  return _impl_.expiry_futures_market_launch_proposals_.size();
}
inline int BatchExchangeModificationProposal::expiry_futures_market_launch_proposals_size() const {
  return _internal_expiry_futures_market_launch_proposals_size();
}
inline void BatchExchangeModificationProposal::clear_expiry_futures_market_launch_proposals() {
  _internal_mutable_expiry_futures_market_launch_proposals()->Clear();
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* BatchExchangeModificationProposal::mutable_expiry_futures_market_launch_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.expiry_futures_market_launch_proposals)
  return _internal_mutable_expiry_futures_market_launch_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal >*
BatchExchangeModificationProposal::mutable_expiry_futures_market_launch_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.expiry_futures_market_launch_proposals)
  return _internal_mutable_expiry_futures_market_launch_proposals();
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal& BatchExchangeModificationProposal::_internal_expiry_futures_market_launch_proposals(int index) const {
  return _internal_expiry_futures_market_launch_proposals().Get(index);
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal& BatchExchangeModificationProposal::expiry_futures_market_launch_proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.expiry_futures_market_launch_proposals)
  return _internal_expiry_futures_market_launch_proposals(index);
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* BatchExchangeModificationProposal::_internal_add_expiry_futures_market_launch_proposals() {
  return _internal_mutable_expiry_futures_market_launch_proposals()->Add();
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* BatchExchangeModificationProposal::add_expiry_futures_market_launch_proposals() {
  ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal* _add = _internal_add_expiry_futures_market_launch_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchExchangeModificationProposal.expiry_futures_market_launch_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal >&
BatchExchangeModificationProposal::expiry_futures_market_launch_proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.expiry_futures_market_launch_proposals)
  return _internal_expiry_futures_market_launch_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal>&
BatchExchangeModificationProposal::_internal_expiry_futures_market_launch_proposals() const {
  return _impl_.expiry_futures_market_launch_proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::ExpiryFuturesMarketLaunchProposal>*
BatchExchangeModificationProposal::_internal_mutable_expiry_futures_market_launch_proposals() {
  return &_impl_.expiry_futures_market_launch_proposals_;
}

// .injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal = 8 [json_name = "tradingRewardCampaignUpdateProposal"];
inline bool BatchExchangeModificationProposal::has_trading_reward_campaign_update_proposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trading_reward_campaign_update_proposal_ != nullptr);
  return value;
}
inline void BatchExchangeModificationProposal::clear_trading_reward_campaign_update_proposal() {
  if (_impl_.trading_reward_campaign_update_proposal_ != nullptr) _impl_.trading_reward_campaign_update_proposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal& BatchExchangeModificationProposal::_internal_trading_reward_campaign_update_proposal() const {
  const ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* p = _impl_.trading_reward_campaign_update_proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal&>(
      ::injective::exchange::v1beta1::_TradingRewardCampaignUpdateProposal_default_instance_);
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal& BatchExchangeModificationProposal::trading_reward_campaign_update_proposal() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.trading_reward_campaign_update_proposal)
  return _internal_trading_reward_campaign_update_proposal();
}
inline void BatchExchangeModificationProposal::unsafe_arena_set_allocated_trading_reward_campaign_update_proposal(
    ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* trading_reward_campaign_update_proposal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trading_reward_campaign_update_proposal_);
  }
  _impl_.trading_reward_campaign_update_proposal_ = trading_reward_campaign_update_proposal;
  if (trading_reward_campaign_update_proposal) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.BatchExchangeModificationProposal.trading_reward_campaign_update_proposal)
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* BatchExchangeModificationProposal::release_trading_reward_campaign_update_proposal() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* temp = _impl_.trading_reward_campaign_update_proposal_;
  _impl_.trading_reward_campaign_update_proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* BatchExchangeModificationProposal::unsafe_arena_release_trading_reward_campaign_update_proposal() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BatchExchangeModificationProposal.trading_reward_campaign_update_proposal)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* temp = _impl_.trading_reward_campaign_update_proposal_;
  _impl_.trading_reward_campaign_update_proposal_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* BatchExchangeModificationProposal::_internal_mutable_trading_reward_campaign_update_proposal() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trading_reward_campaign_update_proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal>(GetArenaForAllocation());
    _impl_.trading_reward_campaign_update_proposal_ = p;
  }
  return _impl_.trading_reward_campaign_update_proposal_;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* BatchExchangeModificationProposal::mutable_trading_reward_campaign_update_proposal() {
  ::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* _msg = _internal_mutable_trading_reward_campaign_update_proposal();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.trading_reward_campaign_update_proposal)
  return _msg;
}
inline void BatchExchangeModificationProposal::set_allocated_trading_reward_campaign_update_proposal(::injective::exchange::v1beta1::TradingRewardCampaignUpdateProposal* trading_reward_campaign_update_proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trading_reward_campaign_update_proposal_;
  }
  if (trading_reward_campaign_update_proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trading_reward_campaign_update_proposal);
    if (message_arena != submessage_arena) {
      trading_reward_campaign_update_proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trading_reward_campaign_update_proposal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trading_reward_campaign_update_proposal_ = trading_reward_campaign_update_proposal;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BatchExchangeModificationProposal.trading_reward_campaign_update_proposal)
}

// repeated .injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals = 9 [json_name = "binaryOptionsMarketLaunchProposals"];
inline int BatchExchangeModificationProposal::_internal_binary_options_market_launch_proposals_size() const {
  return _impl_.binary_options_market_launch_proposals_.size();
}
inline int BatchExchangeModificationProposal::binary_options_market_launch_proposals_size() const {
  return _internal_binary_options_market_launch_proposals_size();
}
inline void BatchExchangeModificationProposal::clear_binary_options_market_launch_proposals() {
  _internal_mutable_binary_options_market_launch_proposals()->Clear();
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* BatchExchangeModificationProposal::mutable_binary_options_market_launch_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_market_launch_proposals)
  return _internal_mutable_binary_options_market_launch_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal >*
BatchExchangeModificationProposal::mutable_binary_options_market_launch_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_market_launch_proposals)
  return _internal_mutable_binary_options_market_launch_proposals();
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal& BatchExchangeModificationProposal::_internal_binary_options_market_launch_proposals(int index) const {
  return _internal_binary_options_market_launch_proposals().Get(index);
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal& BatchExchangeModificationProposal::binary_options_market_launch_proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_market_launch_proposals)
  return _internal_binary_options_market_launch_proposals(index);
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* BatchExchangeModificationProposal::_internal_add_binary_options_market_launch_proposals() {
  return _internal_mutable_binary_options_market_launch_proposals()->Add();
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* BatchExchangeModificationProposal::add_binary_options_market_launch_proposals() {
  ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal* _add = _internal_add_binary_options_market_launch_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_market_launch_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal >&
BatchExchangeModificationProposal::binary_options_market_launch_proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_market_launch_proposals)
  return _internal_binary_options_market_launch_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal>&
BatchExchangeModificationProposal::_internal_binary_options_market_launch_proposals() const {
  return _impl_.binary_options_market_launch_proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketLaunchProposal>*
BatchExchangeModificationProposal::_internal_mutable_binary_options_market_launch_proposals() {
  return &_impl_.binary_options_market_launch_proposals_;
}

// repeated .injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals = 10 [json_name = "binaryOptionsParamUpdateProposals"];
inline int BatchExchangeModificationProposal::_internal_binary_options_param_update_proposals_size() const {
  return _impl_.binary_options_param_update_proposals_.size();
}
inline int BatchExchangeModificationProposal::binary_options_param_update_proposals_size() const {
  return _internal_binary_options_param_update_proposals_size();
}
inline void BatchExchangeModificationProposal::clear_binary_options_param_update_proposals() {
  _internal_mutable_binary_options_param_update_proposals()->Clear();
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* BatchExchangeModificationProposal::mutable_binary_options_param_update_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_param_update_proposals)
  return _internal_mutable_binary_options_param_update_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal >*
BatchExchangeModificationProposal::mutable_binary_options_param_update_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_param_update_proposals)
  return _internal_mutable_binary_options_param_update_proposals();
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal& BatchExchangeModificationProposal::_internal_binary_options_param_update_proposals(int index) const {
  return _internal_binary_options_param_update_proposals().Get(index);
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal& BatchExchangeModificationProposal::binary_options_param_update_proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_param_update_proposals)
  return _internal_binary_options_param_update_proposals(index);
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* BatchExchangeModificationProposal::_internal_add_binary_options_param_update_proposals() {
  return _internal_mutable_binary_options_param_update_proposals()->Add();
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* BatchExchangeModificationProposal::add_binary_options_param_update_proposals() {
  ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal* _add = _internal_add_binary_options_param_update_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_param_update_proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal >&
BatchExchangeModificationProposal::binary_options_param_update_proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchExchangeModificationProposal.binary_options_param_update_proposals)
  return _internal_binary_options_param_update_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal>&
BatchExchangeModificationProposal::_internal_binary_options_param_update_proposals() const {
  return _impl_.binary_options_param_update_proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarketParamUpdateProposal>*
BatchExchangeModificationProposal::_internal_mutable_binary_options_param_update_proposals() {
  return &_impl_.binary_options_param_update_proposals_;
}

// .injective.exchange.v1beta1.UpdateDenomDecimalsProposal denom_decimals_update_proposal = 11 [json_name = "denomDecimalsUpdateProposal"];
inline bool BatchExchangeModificationProposal::has_denom_decimals_update_proposal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.denom_decimals_update_proposal_ != nullptr);
  return value;
}
inline void BatchExchangeModificationProposal::clear_denom_decimals_update_proposal() {
  if (_impl_.denom_decimals_update_proposal_ != nullptr) _impl_.denom_decimals_update_proposal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal& BatchExchangeModificationProposal::_internal_denom_decimals_update_proposal() const {
  const ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* p = _impl_.denom_decimals_update_proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal&>(
      ::injective::exchange::v1beta1::_UpdateDenomDecimalsProposal_default_instance_);
}
inline const ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal& BatchExchangeModificationProposal::denom_decimals_update_proposal() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchExchangeModificationProposal.denom_decimals_update_proposal)
  return _internal_denom_decimals_update_proposal();
}
inline void BatchExchangeModificationProposal::unsafe_arena_set_allocated_denom_decimals_update_proposal(
    ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* denom_decimals_update_proposal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.denom_decimals_update_proposal_);
  }
  _impl_.denom_decimals_update_proposal_ = denom_decimals_update_proposal;
  if (denom_decimals_update_proposal) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.BatchExchangeModificationProposal.denom_decimals_update_proposal)
}
inline ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* BatchExchangeModificationProposal::release_denom_decimals_update_proposal() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* temp = _impl_.denom_decimals_update_proposal_;
  _impl_.denom_decimals_update_proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* BatchExchangeModificationProposal::unsafe_arena_release_denom_decimals_update_proposal() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BatchExchangeModificationProposal.denom_decimals_update_proposal)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* temp = _impl_.denom_decimals_update_proposal_;
  _impl_.denom_decimals_update_proposal_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* BatchExchangeModificationProposal::_internal_mutable_denom_decimals_update_proposal() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.denom_decimals_update_proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::UpdateDenomDecimalsProposal>(GetArenaForAllocation());
    _impl_.denom_decimals_update_proposal_ = p;
  }
  return _impl_.denom_decimals_update_proposal_;
}
inline ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* BatchExchangeModificationProposal::mutable_denom_decimals_update_proposal() {
  ::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* _msg = _internal_mutable_denom_decimals_update_proposal();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchExchangeModificationProposal.denom_decimals_update_proposal)
  return _msg;
}
inline void BatchExchangeModificationProposal::set_allocated_denom_decimals_update_proposal(::injective::exchange::v1beta1::UpdateDenomDecimalsProposal* denom_decimals_update_proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.denom_decimals_update_proposal_;
  }
  if (denom_decimals_update_proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(denom_decimals_update_proposal);
    if (message_arena != submessage_arena) {
      denom_decimals_update_proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, denom_decimals_update_proposal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.denom_decimals_update_proposal_ = denom_decimals_update_proposal;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BatchExchangeModificationProposal.denom_decimals_update_proposal)
}

// -------------------------------------------------------------------

// SpotMarketLaunchProposal

// string title = 1 [json_name = "title"];
inline void SpotMarketLaunchProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.title)
}
inline std::string* SpotMarketLaunchProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.title)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.title)
  return _impl_.title_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.title)
}

// string description = 2 [json_name = "description"];
inline void SpotMarketLaunchProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.description)
}
inline std::string* SpotMarketLaunchProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.description)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.description)
  return _impl_.description_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.description)
}

// string ticker = 3 [json_name = "ticker"];
inline void SpotMarketLaunchProposal::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.ticker)
}
inline std::string* SpotMarketLaunchProposal::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.ticker)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.ticker)
  return _impl_.ticker_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.ticker)
}

// string base_denom = 4 [json_name = "baseDenom"];
inline void SpotMarketLaunchProposal::clear_base_denom() {
  _impl_.base_denom_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::base_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.base_denom)
  return _internal_base_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_base_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.base_denom)
}
inline std::string* SpotMarketLaunchProposal::mutable_base_denom() {
  std::string* _s = _internal_mutable_base_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.base_denom)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_base_denom() const {
  return _impl_.base_denom_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_base_denom(const std::string& value) {
  ;


  _impl_.base_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_base_denom() {
  ;
  return _impl_.base_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_base_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.base_denom)
  return _impl_.base_denom_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_base_denom(std::string* value) {
  _impl_.base_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_denom_.IsDefault()) {
          _impl_.base_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.base_denom)
}

// string quote_denom = 5 [json_name = "quoteDenom"];
inline void SpotMarketLaunchProposal::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.quote_denom)
}
inline std::string* SpotMarketLaunchProposal::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.quote_denom)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.quote_denom)
}

// string min_price_tick_size = 6 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketLaunchProposal::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_price_tick_size)
}
inline std::string* SpotMarketLaunchProposal::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_price_tick_size)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_price_tick_size)
}

// string min_quantity_tick_size = 7 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketLaunchProposal::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_quantity_tick_size)
}
inline std::string* SpotMarketLaunchProposal::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_quantity_tick_size)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.min_quantity_tick_size)
}

// string maker_fee_rate = 8 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketLaunchProposal::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.maker_fee_rate)
}
inline std::string* SpotMarketLaunchProposal::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.maker_fee_rate)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.maker_fee_rate)
}

// string taker_fee_rate = 9 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void SpotMarketLaunchProposal::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& SpotMarketLaunchProposal::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SpotMarketLaunchProposal.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpotMarketLaunchProposal::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SpotMarketLaunchProposal.taker_fee_rate)
}
inline std::string* SpotMarketLaunchProposal::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SpotMarketLaunchProposal.taker_fee_rate)
  return _s;
}
inline const std::string& SpotMarketLaunchProposal::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void SpotMarketLaunchProposal::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* SpotMarketLaunchProposal::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SpotMarketLaunchProposal.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void SpotMarketLaunchProposal::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SpotMarketLaunchProposal.taker_fee_rate)
}

// -------------------------------------------------------------------

// PerpetualMarketLaunchProposal

// string title = 1 [json_name = "title"];
inline void PerpetualMarketLaunchProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.title)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.title)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.title)
  return _impl_.title_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.title)
}

// string description = 2 [json_name = "description"];
inline void PerpetualMarketLaunchProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.description)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.description)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.description)
  return _impl_.description_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.description)
}

// string ticker = 3 [json_name = "ticker"];
inline void PerpetualMarketLaunchProposal::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.ticker)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.ticker)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.ticker)
  return _impl_.ticker_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.ticker)
}

// string quote_denom = 4 [json_name = "quoteDenom"];
inline void PerpetualMarketLaunchProposal::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.quote_denom)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.quote_denom)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.quote_denom)
}

// string oracle_base = 5 [json_name = "oracleBase"];
inline void PerpetualMarketLaunchProposal::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_base)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_base)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_base)
}

// string oracle_quote = 6 [json_name = "oracleQuote"];
inline void PerpetualMarketLaunchProposal::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_quote)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_quote)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_quote)
}

// uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
inline void PerpetualMarketLaunchProposal::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t PerpetualMarketLaunchProposal::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void PerpetualMarketLaunchProposal::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_scale_factor)
}
inline ::uint32_t PerpetualMarketLaunchProposal::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void PerpetualMarketLaunchProposal::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// .injective.oracle.v1beta1.OracleType oracle_type = 8 [json_name = "oracleType"];
inline void PerpetualMarketLaunchProposal::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType PerpetualMarketLaunchProposal::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_type)
  return _internal_oracle_type();
}
inline void PerpetualMarketLaunchProposal::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType PerpetualMarketLaunchProposal::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void PerpetualMarketLaunchProposal::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// string initial_margin_ratio = 9 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketLaunchProposal::clear_initial_margin_ratio() {
  _impl_.initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.initial_margin_ratio)
  return _internal_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.initial_margin_ratio)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_initial_margin_ratio() {
  std::string* _s = _internal_mutable_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.initial_margin_ratio)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_initial_margin_ratio() const {
  return _impl_.initial_margin_ratio_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_initial_margin_ratio() {
  ;
  return _impl_.initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.initial_margin_ratio)
  return _impl_.initial_margin_ratio_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_initial_margin_ratio(std::string* value) {
  _impl_.initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_margin_ratio_.IsDefault()) {
          _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.initial_margin_ratio)
}

// string maintenance_margin_ratio = 10 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketLaunchProposal::clear_maintenance_margin_ratio() {
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maintenance_margin_ratio)
  return _internal_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maintenance_margin_ratio)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maintenance_margin_ratio)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_maintenance_margin_ratio() const {
  return _impl_.maintenance_margin_ratio_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_maintenance_margin_ratio() {
  ;
  return _impl_.maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maintenance_margin_ratio)
  return _impl_.maintenance_margin_ratio_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_maintenance_margin_ratio(std::string* value) {
  _impl_.maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maintenance_margin_ratio_.IsDefault()) {
          _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maintenance_margin_ratio)
}

// string maker_fee_rate = 11 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketLaunchProposal::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maker_fee_rate)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maker_fee_rate)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.maker_fee_rate)
}

// string taker_fee_rate = 12 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketLaunchProposal::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.taker_fee_rate)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.taker_fee_rate)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.taker_fee_rate)
}

// string min_price_tick_size = 13 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketLaunchProposal::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_price_tick_size)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_price_tick_size)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_price_tick_size)
}

// string min_quantity_tick_size = 14 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PerpetualMarketLaunchProposal::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& PerpetualMarketLaunchProposal::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketLaunchProposal::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_quantity_tick_size)
}
inline std::string* PerpetualMarketLaunchProposal::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_quantity_tick_size)
  return _s;
}
inline const std::string& PerpetualMarketLaunchProposal::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void PerpetualMarketLaunchProposal::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketLaunchProposal::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void PerpetualMarketLaunchProposal::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketLaunchProposal.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// BinaryOptionsMarketLaunchProposal

// string title = 1 [json_name = "title"];
inline void BinaryOptionsMarketLaunchProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.title)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.title)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.title)
  return _impl_.title_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.title)
}

// string description = 2 [json_name = "description"];
inline void BinaryOptionsMarketLaunchProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.description)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.description)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.description)
  return _impl_.description_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.description)
}

// string ticker = 3 [json_name = "ticker"];
inline void BinaryOptionsMarketLaunchProposal::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.ticker)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.ticker)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.ticker)
  return _impl_.ticker_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.ticker)
}

// string oracle_symbol = 4 [json_name = "oracleSymbol"];
inline void BinaryOptionsMarketLaunchProposal::clear_oracle_symbol() {
  _impl_.oracle_symbol_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::oracle_symbol() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_symbol)
  return _internal_oracle_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_oracle_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_symbol)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_oracle_symbol() {
  std::string* _s = _internal_mutable_oracle_symbol();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_symbol)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_oracle_symbol() const {
  return _impl_.oracle_symbol_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_oracle_symbol(const std::string& value) {
  ;


  _impl_.oracle_symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_oracle_symbol() {
  ;
  return _impl_.oracle_symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_oracle_symbol() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_symbol)
  return _impl_.oracle_symbol_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_oracle_symbol(std::string* value) {
  _impl_.oracle_symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_symbol_.IsDefault()) {
          _impl_.oracle_symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_symbol)
}

// string oracle_provider = 5 [json_name = "oracleProvider"];
inline void BinaryOptionsMarketLaunchProposal::clear_oracle_provider() {
  _impl_.oracle_provider_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::oracle_provider() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_provider)
  return _internal_oracle_provider();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_oracle_provider(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_provider_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_provider)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_oracle_provider() {
  std::string* _s = _internal_mutable_oracle_provider();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_provider)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_oracle_provider() const {
  return _impl_.oracle_provider_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_oracle_provider(const std::string& value) {
  ;


  _impl_.oracle_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_oracle_provider() {
  ;
  return _impl_.oracle_provider_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_oracle_provider() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_provider)
  return _impl_.oracle_provider_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_oracle_provider(std::string* value) {
  _impl_.oracle_provider_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_provider_.IsDefault()) {
          _impl_.oracle_provider_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_provider)
}

// .injective.oracle.v1beta1.OracleType oracle_type = 6 [json_name = "oracleType"];
inline void BinaryOptionsMarketLaunchProposal::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType BinaryOptionsMarketLaunchProposal::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_type)
  return _internal_oracle_type();
}
inline void BinaryOptionsMarketLaunchProposal::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType BinaryOptionsMarketLaunchProposal::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
inline void BinaryOptionsMarketLaunchProposal::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t BinaryOptionsMarketLaunchProposal::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void BinaryOptionsMarketLaunchProposal::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.oracle_scale_factor)
}
inline ::uint32_t BinaryOptionsMarketLaunchProposal::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// int64 expiration_timestamp = 8 [json_name = "expirationTimestamp"];
inline void BinaryOptionsMarketLaunchProposal::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarketLaunchProposal::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void BinaryOptionsMarketLaunchProposal::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.expiration_timestamp)
}
inline ::int64_t BinaryOptionsMarketLaunchProposal::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// int64 settlement_timestamp = 9 [json_name = "settlementTimestamp"];
inline void BinaryOptionsMarketLaunchProposal::clear_settlement_timestamp() {
  _impl_.settlement_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarketLaunchProposal::settlement_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.settlement_timestamp)
  return _internal_settlement_timestamp();
}
inline void BinaryOptionsMarketLaunchProposal::set_settlement_timestamp(::int64_t value) {
  _internal_set_settlement_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.settlement_timestamp)
}
inline ::int64_t BinaryOptionsMarketLaunchProposal::_internal_settlement_timestamp() const {
  return _impl_.settlement_timestamp_;
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_settlement_timestamp(::int64_t value) {
  ;
  _impl_.settlement_timestamp_ = value;
}

// string admin = 10 [json_name = "admin"];
inline void BinaryOptionsMarketLaunchProposal::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::admin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.admin)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.admin)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_admin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.admin)
  return _impl_.admin_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.admin)
}

// string quote_denom = 11 [json_name = "quoteDenom"];
inline void BinaryOptionsMarketLaunchProposal::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.quote_denom)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.quote_denom)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.quote_denom)
}

// string maker_fee_rate = 12 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketLaunchProposal::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.maker_fee_rate)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.maker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.maker_fee_rate)
}

// string taker_fee_rate = 13 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketLaunchProposal::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.taker_fee_rate)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.taker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.taker_fee_rate)
}

// string min_price_tick_size = 14 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketLaunchProposal::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_price_tick_size)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_price_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_price_tick_size)
}

// string min_quantity_tick_size = 15 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketLaunchProposal::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketLaunchProposal::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketLaunchProposal::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_quantity_tick_size)
}
inline std::string* BinaryOptionsMarketLaunchProposal::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_quantity_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarketLaunchProposal::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void BinaryOptionsMarketLaunchProposal::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketLaunchProposal::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void BinaryOptionsMarketLaunchProposal::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// ExpiryFuturesMarketLaunchProposal

// string title = 1 [json_name = "title"];
inline void ExpiryFuturesMarketLaunchProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.title)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.title)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.title)
  return _impl_.title_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.title)
}

// string description = 2 [json_name = "description"];
inline void ExpiryFuturesMarketLaunchProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.description)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.description)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.description)
  return _impl_.description_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.description)
}

// string ticker = 3 [json_name = "ticker"];
inline void ExpiryFuturesMarketLaunchProposal::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::ticker() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.ticker)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.ticker)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_ticker() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.ticker)
  return _impl_.ticker_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.ticker)
}

// string quote_denom = 4 [json_name = "quoteDenom"];
inline void ExpiryFuturesMarketLaunchProposal::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.quote_denom)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.quote_denom)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.quote_denom)
}

// string oracle_base = 5 [json_name = "oracleBase"];
inline void ExpiryFuturesMarketLaunchProposal::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_base)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_base)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_base)
}

// string oracle_quote = 6 [json_name = "oracleQuote"];
inline void ExpiryFuturesMarketLaunchProposal::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_quote)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_quote)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_quote)
}

// uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
inline void ExpiryFuturesMarketLaunchProposal::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t ExpiryFuturesMarketLaunchProposal::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void ExpiryFuturesMarketLaunchProposal::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_scale_factor)
}
inline ::uint32_t ExpiryFuturesMarketLaunchProposal::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// .injective.oracle.v1beta1.OracleType oracle_type = 8 [json_name = "oracleType"];
inline void ExpiryFuturesMarketLaunchProposal::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType ExpiryFuturesMarketLaunchProposal::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_type)
  return _internal_oracle_type();
}
inline void ExpiryFuturesMarketLaunchProposal::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType ExpiryFuturesMarketLaunchProposal::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// int64 expiry = 9 [json_name = "expiry"];
inline void ExpiryFuturesMarketLaunchProposal::clear_expiry() {
  _impl_.expiry_ = ::int64_t{0};
}
inline ::int64_t ExpiryFuturesMarketLaunchProposal::expiry() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.expiry)
  return _internal_expiry();
}
inline void ExpiryFuturesMarketLaunchProposal::set_expiry(::int64_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.expiry)
}
inline ::int64_t ExpiryFuturesMarketLaunchProposal::_internal_expiry() const {
  return _impl_.expiry_;
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_expiry(::int64_t value) {
  ;
  _impl_.expiry_ = value;
}

// string initial_margin_ratio = 10 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketLaunchProposal::clear_initial_margin_ratio() {
  _impl_.initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.initial_margin_ratio)
  return _internal_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.initial_margin_ratio)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_initial_margin_ratio() {
  std::string* _s = _internal_mutable_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.initial_margin_ratio)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_initial_margin_ratio() const {
  return _impl_.initial_margin_ratio_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_initial_margin_ratio() {
  ;
  return _impl_.initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.initial_margin_ratio)
  return _impl_.initial_margin_ratio_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_initial_margin_ratio(std::string* value) {
  _impl_.initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_margin_ratio_.IsDefault()) {
          _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.initial_margin_ratio)
}

// string maintenance_margin_ratio = 11 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketLaunchProposal::clear_maintenance_margin_ratio() {
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maintenance_margin_ratio)
  return _internal_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maintenance_margin_ratio)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maintenance_margin_ratio)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_maintenance_margin_ratio() const {
  return _impl_.maintenance_margin_ratio_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_maintenance_margin_ratio() {
  ;
  return _impl_.maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maintenance_margin_ratio)
  return _impl_.maintenance_margin_ratio_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_maintenance_margin_ratio(std::string* value) {
  _impl_.maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maintenance_margin_ratio_.IsDefault()) {
          _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maintenance_margin_ratio)
}

// string maker_fee_rate = 12 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketLaunchProposal::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maker_fee_rate)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maker_fee_rate)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.maker_fee_rate)
}

// string taker_fee_rate = 13 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketLaunchProposal::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.taker_fee_rate)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.taker_fee_rate)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.taker_fee_rate)
}

// string min_price_tick_size = 14 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketLaunchProposal::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_price_tick_size)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_price_tick_size)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_price_tick_size)
}

// string min_quantity_tick_size = 15 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void ExpiryFuturesMarketLaunchProposal::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketLaunchProposal::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_quantity_tick_size)
}
inline std::string* ExpiryFuturesMarketLaunchProposal::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_quantity_tick_size)
  return _s;
}
inline const std::string& ExpiryFuturesMarketLaunchProposal::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void ExpiryFuturesMarketLaunchProposal::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketLaunchProposal::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void ExpiryFuturesMarketLaunchProposal::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal.min_quantity_tick_size)
}

// -------------------------------------------------------------------

// DerivativeMarketParamUpdateProposal

// string title = 1 [json_name = "title"];
inline void DerivativeMarketParamUpdateProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.title)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.title)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.title)
  return _impl_.title_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.title)
}

// string description = 2 [json_name = "description"];
inline void DerivativeMarketParamUpdateProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.description)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.description)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.description)
  return _impl_.description_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.description)
}

// string market_id = 3 [json_name = "marketId"];
inline void DerivativeMarketParamUpdateProposal::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.market_id)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.market_id)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.market_id)
}

// string initial_margin_ratio = 4 [json_name = "initialMarginRatio", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_initial_margin_ratio() {
  _impl_.initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.initial_margin_ratio)
  return _internal_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.initial_margin_ratio)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_initial_margin_ratio() {
  std::string* _s = _internal_mutable_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.initial_margin_ratio)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_initial_margin_ratio() const {
  return _impl_.initial_margin_ratio_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_initial_margin_ratio() {
  ;
  return _impl_.initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.initial_margin_ratio)
  return _impl_.initial_margin_ratio_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_initial_margin_ratio(std::string* value) {
  _impl_.initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_margin_ratio_.IsDefault()) {
          _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.initial_margin_ratio)
}

// string maintenance_margin_ratio = 5 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_maintenance_margin_ratio() {
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maintenance_margin_ratio)
  return _internal_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maintenance_margin_ratio)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maintenance_margin_ratio)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_maintenance_margin_ratio() const {
  return _impl_.maintenance_margin_ratio_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_maintenance_margin_ratio() {
  ;
  return _impl_.maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maintenance_margin_ratio)
  return _impl_.maintenance_margin_ratio_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_maintenance_margin_ratio(std::string* value) {
  _impl_.maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maintenance_margin_ratio_.IsDefault()) {
          _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maintenance_margin_ratio)
}

// string maker_fee_rate = 6 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maker_fee_rate)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maker_fee_rate)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.maker_fee_rate)
}

// string taker_fee_rate = 7 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.taker_fee_rate)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.taker_fee_rate)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.taker_fee_rate)
}

// string relayer_fee_share_rate = 8 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_relayer_fee_share_rate() {
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::relayer_fee_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.relayer_fee_share_rate)
  return _internal_relayer_fee_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_relayer_fee_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_fee_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.relayer_fee_share_rate)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_relayer_fee_share_rate() {
  std::string* _s = _internal_mutable_relayer_fee_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.relayer_fee_share_rate)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_relayer_fee_share_rate() const {
  return _impl_.relayer_fee_share_rate_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_relayer_fee_share_rate(const std::string& value) {
  ;


  _impl_.relayer_fee_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_relayer_fee_share_rate() {
  ;
  return _impl_.relayer_fee_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_relayer_fee_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.relayer_fee_share_rate)
  return _impl_.relayer_fee_share_rate_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_relayer_fee_share_rate(std::string* value) {
  _impl_.relayer_fee_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_fee_share_rate_.IsDefault()) {
          _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.relayer_fee_share_rate)
}

// string min_price_tick_size = 9 [json_name = "minPriceTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_price_tick_size)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_price_tick_size)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_price_tick_size)
}

// string min_quantity_tick_size = 10 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_quantity_tick_size)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_quantity_tick_size)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.min_quantity_tick_size)
}

// string HourlyInterestRate = 11 [json_name = "HourlyInterestRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_hourlyinterestrate() {
  _impl_.hourlyinterestrate_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::hourlyinterestrate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyInterestRate)
  return _internal_hourlyinterestrate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_hourlyinterestrate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hourlyinterestrate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyInterestRate)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_hourlyinterestrate() {
  std::string* _s = _internal_mutable_hourlyinterestrate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyInterestRate)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_hourlyinterestrate() const {
  return _impl_.hourlyinterestrate_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_hourlyinterestrate(const std::string& value) {
  ;


  _impl_.hourlyinterestrate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_hourlyinterestrate() {
  ;
  return _impl_.hourlyinterestrate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_hourlyinterestrate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyInterestRate)
  return _impl_.hourlyinterestrate_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_hourlyinterestrate(std::string* value) {
  _impl_.hourlyinterestrate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hourlyinterestrate_.IsDefault()) {
          _impl_.hourlyinterestrate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyInterestRate)
}

// string HourlyFundingRateCap = 12 [json_name = "HourlyFundingRateCap", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketParamUpdateProposal::clear_hourlyfundingratecap() {
  _impl_.hourlyfundingratecap_.ClearToEmpty();
}
inline const std::string& DerivativeMarketParamUpdateProposal::hourlyfundingratecap() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyFundingRateCap)
  return _internal_hourlyfundingratecap();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketParamUpdateProposal::set_hourlyfundingratecap(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hourlyfundingratecap_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyFundingRateCap)
}
inline std::string* DerivativeMarketParamUpdateProposal::mutable_hourlyfundingratecap() {
  std::string* _s = _internal_mutable_hourlyfundingratecap();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyFundingRateCap)
  return _s;
}
inline const std::string& DerivativeMarketParamUpdateProposal::_internal_hourlyfundingratecap() const {
  return _impl_.hourlyfundingratecap_.Get();
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_hourlyfundingratecap(const std::string& value) {
  ;


  _impl_.hourlyfundingratecap_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::_internal_mutable_hourlyfundingratecap() {
  ;
  return _impl_.hourlyfundingratecap_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketParamUpdateProposal::release_hourlyfundingratecap() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyFundingRateCap)
  return _impl_.hourlyfundingratecap_.Release();
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_hourlyfundingratecap(std::string* value) {
  _impl_.hourlyfundingratecap_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hourlyfundingratecap_.IsDefault()) {
          _impl_.hourlyfundingratecap_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.HourlyFundingRateCap)
}

// .injective.exchange.v1beta1.MarketStatus status = 13 [json_name = "status"];
inline void DerivativeMarketParamUpdateProposal::clear_status() {
  _impl_.status_ = 0;
}
inline ::injective::exchange::v1beta1::MarketStatus DerivativeMarketParamUpdateProposal::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.status)
  return _internal_status();
}
inline void DerivativeMarketParamUpdateProposal::set_status(::injective::exchange::v1beta1::MarketStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.status)
}
inline ::injective::exchange::v1beta1::MarketStatus DerivativeMarketParamUpdateProposal::_internal_status() const {
  return static_cast<::injective::exchange::v1beta1::MarketStatus>(_impl_.status_);
}
inline void DerivativeMarketParamUpdateProposal::_internal_set_status(::injective::exchange::v1beta1::MarketStatus value) {
  ;
  _impl_.status_ = value;
}

// .injective.exchange.v1beta1.OracleParams oracle_params = 14 [json_name = "oracleParams"];
inline bool DerivativeMarketParamUpdateProposal::has_oracle_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.oracle_params_ != nullptr);
  return value;
}
inline void DerivativeMarketParamUpdateProposal::clear_oracle_params() {
  if (_impl_.oracle_params_ != nullptr) _impl_.oracle_params_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::OracleParams& DerivativeMarketParamUpdateProposal::_internal_oracle_params() const {
  const ::injective::exchange::v1beta1::OracleParams* p = _impl_.oracle_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::OracleParams&>(
      ::injective::exchange::v1beta1::_OracleParams_default_instance_);
}
inline const ::injective::exchange::v1beta1::OracleParams& DerivativeMarketParamUpdateProposal::oracle_params() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.oracle_params)
  return _internal_oracle_params();
}
inline void DerivativeMarketParamUpdateProposal::unsafe_arena_set_allocated_oracle_params(
    ::injective::exchange::v1beta1::OracleParams* oracle_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oracle_params_);
  }
  _impl_.oracle_params_ = oracle_params;
  if (oracle_params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.oracle_params)
}
inline ::injective::exchange::v1beta1::OracleParams* DerivativeMarketParamUpdateProposal::release_oracle_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OracleParams* temp = _impl_.oracle_params_;
  _impl_.oracle_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::OracleParams* DerivativeMarketParamUpdateProposal::unsafe_arena_release_oracle_params() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.oracle_params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::OracleParams* temp = _impl_.oracle_params_;
  _impl_.oracle_params_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::OracleParams* DerivativeMarketParamUpdateProposal::_internal_mutable_oracle_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.oracle_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::OracleParams>(GetArenaForAllocation());
    _impl_.oracle_params_ = p;
  }
  return _impl_.oracle_params_;
}
inline ::injective::exchange::v1beta1::OracleParams* DerivativeMarketParamUpdateProposal::mutable_oracle_params() {
  ::injective::exchange::v1beta1::OracleParams* _msg = _internal_mutable_oracle_params();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.oracle_params)
  return _msg;
}
inline void DerivativeMarketParamUpdateProposal::set_allocated_oracle_params(::injective::exchange::v1beta1::OracleParams* oracle_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.oracle_params_;
  }
  if (oracle_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oracle_params);
    if (message_arena != submessage_arena) {
      oracle_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oracle_params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.oracle_params_ = oracle_params;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal.oracle_params)
}

// -------------------------------------------------------------------

// MarketForcedSettlementProposal

// string title = 1 [json_name = "title"];
inline void MarketForcedSettlementProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& MarketForcedSettlementProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketForcedSettlementProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketForcedSettlementProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketForcedSettlementProposal.title)
}
inline std::string* MarketForcedSettlementProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketForcedSettlementProposal.title)
  return _s;
}
inline const std::string& MarketForcedSettlementProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void MarketForcedSettlementProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketForcedSettlementProposal.title)
  return _impl_.title_.Release();
}
inline void MarketForcedSettlementProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketForcedSettlementProposal.title)
}

// string description = 2 [json_name = "description"];
inline void MarketForcedSettlementProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& MarketForcedSettlementProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketForcedSettlementProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketForcedSettlementProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketForcedSettlementProposal.description)
}
inline std::string* MarketForcedSettlementProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketForcedSettlementProposal.description)
  return _s;
}
inline const std::string& MarketForcedSettlementProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MarketForcedSettlementProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketForcedSettlementProposal.description)
  return _impl_.description_.Release();
}
inline void MarketForcedSettlementProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketForcedSettlementProposal.description)
}

// string market_id = 3 [json_name = "marketId"];
inline void MarketForcedSettlementProposal::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MarketForcedSettlementProposal::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketForcedSettlementProposal.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketForcedSettlementProposal::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketForcedSettlementProposal.market_id)
}
inline std::string* MarketForcedSettlementProposal::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketForcedSettlementProposal.market_id)
  return _s;
}
inline const std::string& MarketForcedSettlementProposal::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MarketForcedSettlementProposal::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketForcedSettlementProposal.market_id)
  return _impl_.market_id_.Release();
}
inline void MarketForcedSettlementProposal::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketForcedSettlementProposal.market_id)
}

// string settlement_price = 4 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MarketForcedSettlementProposal::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& MarketForcedSettlementProposal::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MarketForcedSettlementProposal.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketForcedSettlementProposal::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MarketForcedSettlementProposal.settlement_price)
}
inline std::string* MarketForcedSettlementProposal::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MarketForcedSettlementProposal.settlement_price)
  return _s;
}
inline const std::string& MarketForcedSettlementProposal::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void MarketForcedSettlementProposal::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketForcedSettlementProposal::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MarketForcedSettlementProposal.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void MarketForcedSettlementProposal::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MarketForcedSettlementProposal.settlement_price)
}

// -------------------------------------------------------------------

// UpdateDenomDecimalsProposal

// string title = 1 [json_name = "title"];
inline void UpdateDenomDecimalsProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& UpdateDenomDecimalsProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateDenomDecimalsProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.title)
}
inline std::string* UpdateDenomDecimalsProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.title)
  return _s;
}
inline const std::string& UpdateDenomDecimalsProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void UpdateDenomDecimalsProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateDenomDecimalsProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateDenomDecimalsProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.title)
  return _impl_.title_.Release();
}
inline void UpdateDenomDecimalsProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.title)
}

// string description = 2 [json_name = "description"];
inline void UpdateDenomDecimalsProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UpdateDenomDecimalsProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateDenomDecimalsProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.description)
}
inline std::string* UpdateDenomDecimalsProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.description)
  return _s;
}
inline const std::string& UpdateDenomDecimalsProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UpdateDenomDecimalsProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateDenomDecimalsProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateDenomDecimalsProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.description)
  return _impl_.description_.Release();
}
inline void UpdateDenomDecimalsProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.description)
}

// repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 3 [json_name = "denomDecimals"];
inline int UpdateDenomDecimalsProposal::_internal_denom_decimals_size() const {
  return _impl_.denom_decimals_.size();
}
inline int UpdateDenomDecimalsProposal::denom_decimals_size() const {
  return _internal_denom_decimals_size();
}
inline ::injective::exchange::v1beta1::DenomDecimals* UpdateDenomDecimalsProposal::mutable_denom_decimals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.denom_decimals)
  return _internal_mutable_denom_decimals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >*
UpdateDenomDecimalsProposal::mutable_denom_decimals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.denom_decimals)
  return _internal_mutable_denom_decimals();
}
inline const ::injective::exchange::v1beta1::DenomDecimals& UpdateDenomDecimalsProposal::_internal_denom_decimals(int index) const {
  return _internal_denom_decimals().Get(index);
}
inline const ::injective::exchange::v1beta1::DenomDecimals& UpdateDenomDecimalsProposal::denom_decimals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.denom_decimals)
  return _internal_denom_decimals(index);
}
inline ::injective::exchange::v1beta1::DenomDecimals* UpdateDenomDecimalsProposal::_internal_add_denom_decimals() {
  return _internal_mutable_denom_decimals()->Add();
}
inline ::injective::exchange::v1beta1::DenomDecimals* UpdateDenomDecimalsProposal::add_denom_decimals() {
  ::injective::exchange::v1beta1::DenomDecimals* _add = _internal_add_denom_decimals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.denom_decimals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >&
UpdateDenomDecimalsProposal::denom_decimals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.UpdateDenomDecimalsProposal.denom_decimals)
  return _internal_denom_decimals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>&
UpdateDenomDecimalsProposal::_internal_denom_decimals() const {
  return _impl_.denom_decimals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>*
UpdateDenomDecimalsProposal::_internal_mutable_denom_decimals() {
  return &_impl_.denom_decimals_;
}

// -------------------------------------------------------------------

// BinaryOptionsMarketParamUpdateProposal

// string title = 1 [json_name = "title"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.title)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.title)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.title)
  return _impl_.title_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.title)
}

// string description = 2 [json_name = "description"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.description)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.description)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.description)
  return _impl_.description_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.description)
}

// string market_id = 3 [json_name = "marketId"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.market_id)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.market_id)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.market_id)
  return _impl_.market_id_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.market_id)
}

// string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.maker_fee_rate)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.maker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.maker_fee_rate)
}

// string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.taker_fee_rate)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.taker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.taker_fee_rate)
}

// string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_relayer_fee_share_rate() {
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::relayer_fee_share_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.relayer_fee_share_rate)
  return _internal_relayer_fee_share_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_relayer_fee_share_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_fee_share_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.relayer_fee_share_rate)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_relayer_fee_share_rate() {
  std::string* _s = _internal_mutable_relayer_fee_share_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.relayer_fee_share_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_relayer_fee_share_rate() const {
  return _impl_.relayer_fee_share_rate_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_relayer_fee_share_rate(const std::string& value) {
  ;


  _impl_.relayer_fee_share_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_relayer_fee_share_rate() {
  ;
  return _impl_.relayer_fee_share_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_relayer_fee_share_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.relayer_fee_share_rate)
  return _impl_.relayer_fee_share_rate_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_relayer_fee_share_rate(std::string* value) {
  _impl_.relayer_fee_share_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_fee_share_rate_.IsDefault()) {
          _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.relayer_fee_share_rate)
}

// string min_price_tick_size = 7 [json_name = "minPriceTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_price_tick_size)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_price_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_price_tick_size)
}

// string min_quantity_tick_size = 8 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_quantity_tick_size)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_quantity_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.min_quantity_tick_size)
}

// int64 expiration_timestamp = 9 [json_name = "expirationTimestamp"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarketParamUpdateProposal::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.expiration_timestamp)
}
inline ::int64_t BinaryOptionsMarketParamUpdateProposal::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// int64 settlement_timestamp = 10 [json_name = "settlementTimestamp"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_settlement_timestamp() {
  _impl_.settlement_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarketParamUpdateProposal::settlement_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.settlement_timestamp)
  return _internal_settlement_timestamp();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_settlement_timestamp(::int64_t value) {
  _internal_set_settlement_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.settlement_timestamp)
}
inline ::int64_t BinaryOptionsMarketParamUpdateProposal::_internal_settlement_timestamp() const {
  return _impl_.settlement_timestamp_;
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_settlement_timestamp(::int64_t value) {
  ;
  _impl_.settlement_timestamp_ = value;
}

// string settlement_price = 11 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.settlement_price)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.settlement_price)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.settlement_price)
}

// string admin = 12 [json_name = "admin"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::admin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketParamUpdateProposal::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.admin)
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.admin)
  return _s;
}
inline const std::string& BinaryOptionsMarketParamUpdateProposal::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketParamUpdateProposal::release_admin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.admin)
  return _impl_.admin_.Release();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.admin)
}

// .injective.exchange.v1beta1.MarketStatus status = 13 [json_name = "status"];
inline void BinaryOptionsMarketParamUpdateProposal::clear_status() {
  _impl_.status_ = 0;
}
inline ::injective::exchange::v1beta1::MarketStatus BinaryOptionsMarketParamUpdateProposal::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.status)
  return _internal_status();
}
inline void BinaryOptionsMarketParamUpdateProposal::set_status(::injective::exchange::v1beta1::MarketStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.status)
}
inline ::injective::exchange::v1beta1::MarketStatus BinaryOptionsMarketParamUpdateProposal::_internal_status() const {
  return static_cast<::injective::exchange::v1beta1::MarketStatus>(_impl_.status_);
}
inline void BinaryOptionsMarketParamUpdateProposal::_internal_set_status(::injective::exchange::v1beta1::MarketStatus value) {
  ;
  _impl_.status_ = value;
}

// .injective.exchange.v1beta1.ProviderOracleParams oracle_params = 14 [json_name = "oracleParams"];
inline bool BinaryOptionsMarketParamUpdateProposal::has_oracle_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.oracle_params_ != nullptr);
  return value;
}
inline void BinaryOptionsMarketParamUpdateProposal::clear_oracle_params() {
  if (_impl_.oracle_params_ != nullptr) _impl_.oracle_params_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::ProviderOracleParams& BinaryOptionsMarketParamUpdateProposal::_internal_oracle_params() const {
  const ::injective::exchange::v1beta1::ProviderOracleParams* p = _impl_.oracle_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::ProviderOracleParams&>(
      ::injective::exchange::v1beta1::_ProviderOracleParams_default_instance_);
}
inline const ::injective::exchange::v1beta1::ProviderOracleParams& BinaryOptionsMarketParamUpdateProposal::oracle_params() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.oracle_params)
  return _internal_oracle_params();
}
inline void BinaryOptionsMarketParamUpdateProposal::unsafe_arena_set_allocated_oracle_params(
    ::injective::exchange::v1beta1::ProviderOracleParams* oracle_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oracle_params_);
  }
  _impl_.oracle_params_ = oracle_params;
  if (oracle_params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.oracle_params)
}
inline ::injective::exchange::v1beta1::ProviderOracleParams* BinaryOptionsMarketParamUpdateProposal::release_oracle_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::ProviderOracleParams* temp = _impl_.oracle_params_;
  _impl_.oracle_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::ProviderOracleParams* BinaryOptionsMarketParamUpdateProposal::unsafe_arena_release_oracle_params() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.oracle_params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::ProviderOracleParams* temp = _impl_.oracle_params_;
  _impl_.oracle_params_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::ProviderOracleParams* BinaryOptionsMarketParamUpdateProposal::_internal_mutable_oracle_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.oracle_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::ProviderOracleParams>(GetArenaForAllocation());
    _impl_.oracle_params_ = p;
  }
  return _impl_.oracle_params_;
}
inline ::injective::exchange::v1beta1::ProviderOracleParams* BinaryOptionsMarketParamUpdateProposal::mutable_oracle_params() {
  ::injective::exchange::v1beta1::ProviderOracleParams* _msg = _internal_mutable_oracle_params();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.oracle_params)
  return _msg;
}
inline void BinaryOptionsMarketParamUpdateProposal::set_allocated_oracle_params(::injective::exchange::v1beta1::ProviderOracleParams* oracle_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.oracle_params_;
  }
  if (oracle_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oracle_params);
    if (message_arena != submessage_arena) {
      oracle_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oracle_params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.oracle_params_ = oracle_params;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal.oracle_params)
}

// -------------------------------------------------------------------

// ProviderOracleParams

// string symbol = 1 [json_name = "symbol"];
inline void ProviderOracleParams::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ProviderOracleParams::symbol() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ProviderOracleParams.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProviderOracleParams::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ProviderOracleParams.symbol)
}
inline std::string* ProviderOracleParams::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ProviderOracleParams.symbol)
  return _s;
}
inline const std::string& ProviderOracleParams::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void ProviderOracleParams::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* ProviderOracleParams::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* ProviderOracleParams::release_symbol() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ProviderOracleParams.symbol)
  return _impl_.symbol_.Release();
}
inline void ProviderOracleParams::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ProviderOracleParams.symbol)
}

// string provider = 2 [json_name = "provider"];
inline void ProviderOracleParams::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& ProviderOracleParams::provider() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ProviderOracleParams.provider)
  return _internal_provider();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProviderOracleParams::set_provider(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.provider_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ProviderOracleParams.provider)
}
inline std::string* ProviderOracleParams::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.ProviderOracleParams.provider)
  return _s;
}
inline const std::string& ProviderOracleParams::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void ProviderOracleParams::_internal_set_provider(const std::string& value) {
  ;


  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* ProviderOracleParams::_internal_mutable_provider() {
  ;
  return _impl_.provider_.Mutable( GetArenaForAllocation());
}
inline std::string* ProviderOracleParams::release_provider() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.ProviderOracleParams.provider)
  return _impl_.provider_.Release();
}
inline void ProviderOracleParams::set_allocated_provider(std::string* value) {
  _impl_.provider_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.provider_.IsDefault()) {
          _impl_.provider_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.ProviderOracleParams.provider)
}

// uint32 oracle_scale_factor = 3 [json_name = "oracleScaleFactor"];
inline void ProviderOracleParams::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t ProviderOracleParams::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ProviderOracleParams.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void ProviderOracleParams::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ProviderOracleParams.oracle_scale_factor)
}
inline ::uint32_t ProviderOracleParams::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void ProviderOracleParams::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
inline void ProviderOracleParams::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType ProviderOracleParams::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.ProviderOracleParams.oracle_type)
  return _internal_oracle_type();
}
inline void ProviderOracleParams::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.ProviderOracleParams.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType ProviderOracleParams::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void ProviderOracleParams::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// -------------------------------------------------------------------

// OracleParams

// string oracle_base = 1 [json_name = "oracleBase"];
inline void OracleParams::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& OracleParams::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OracleParams.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OracleParams::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OracleParams.oracle_base)
}
inline std::string* OracleParams::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OracleParams.oracle_base)
  return _s;
}
inline const std::string& OracleParams::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void OracleParams::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* OracleParams::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* OracleParams::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OracleParams.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void OracleParams::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OracleParams.oracle_base)
}

// string oracle_quote = 2 [json_name = "oracleQuote"];
inline void OracleParams::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& OracleParams::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OracleParams.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OracleParams::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OracleParams.oracle_quote)
}
inline std::string* OracleParams::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OracleParams.oracle_quote)
  return _s;
}
inline const std::string& OracleParams::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void OracleParams::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* OracleParams::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* OracleParams::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OracleParams.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void OracleParams::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OracleParams.oracle_quote)
}

// uint32 oracle_scale_factor = 3 [json_name = "oracleScaleFactor"];
inline void OracleParams::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t OracleParams::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OracleParams.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void OracleParams::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OracleParams.oracle_scale_factor)
}
inline ::uint32_t OracleParams::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void OracleParams::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
inline void OracleParams::clear_oracle_type() {
  _impl_.oracle_type_ = 0;
}
inline ::injective::oracle::v1beta1::OracleType OracleParams::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OracleParams.oracle_type)
  return _internal_oracle_type();
}
inline void OracleParams::set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
   _internal_set_oracle_type(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OracleParams.oracle_type)
}
inline ::injective::oracle::v1beta1::OracleType OracleParams::_internal_oracle_type() const {
  return static_cast<::injective::oracle::v1beta1::OracleType>(_impl_.oracle_type_);
}
inline void OracleParams::_internal_set_oracle_type(::injective::oracle::v1beta1::OracleType value) {
  ;
  _impl_.oracle_type_ = value;
}

// -------------------------------------------------------------------

// TradingRewardCampaignLaunchProposal

// string title = 1 [json_name = "title"];
inline void TradingRewardCampaignLaunchProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& TradingRewardCampaignLaunchProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradingRewardCampaignLaunchProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.title)
}
inline std::string* TradingRewardCampaignLaunchProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.title)
  return _s;
}
inline const std::string& TradingRewardCampaignLaunchProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void TradingRewardCampaignLaunchProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignLaunchProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignLaunchProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.title)
  return _impl_.title_.Release();
}
inline void TradingRewardCampaignLaunchProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.title)
}

// string description = 2 [json_name = "description"];
inline void TradingRewardCampaignLaunchProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& TradingRewardCampaignLaunchProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradingRewardCampaignLaunchProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.description)
}
inline std::string* TradingRewardCampaignLaunchProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.description)
  return _s;
}
inline const std::string& TradingRewardCampaignLaunchProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void TradingRewardCampaignLaunchProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignLaunchProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignLaunchProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.description)
  return _impl_.description_.Release();
}
inline void TradingRewardCampaignLaunchProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.description)
}

// .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3 [json_name = "campaignInfo"];
inline bool TradingRewardCampaignLaunchProposal::has_campaign_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.campaign_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& TradingRewardCampaignLaunchProposal::_internal_campaign_info() const {
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo* p = _impl_.campaign_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::TradingRewardCampaignInfo&>(
      ::injective::exchange::v1beta1::_TradingRewardCampaignInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& TradingRewardCampaignLaunchProposal::campaign_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_info)
  return _internal_campaign_info();
}
inline void TradingRewardCampaignLaunchProposal::unsafe_arena_set_allocated_campaign_info(
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.campaign_info_);
  }
  _impl_.campaign_info_ = campaign_info;
  if (campaign_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_info)
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignLaunchProposal::release_campaign_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.campaign_info_;
  _impl_.campaign_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignLaunchProposal::unsafe_arena_release_campaign_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.campaign_info_;
  _impl_.campaign_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignLaunchProposal::_internal_mutable_campaign_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.campaign_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignInfo>(GetArenaForAllocation());
    _impl_.campaign_info_ = p;
  }
  return _impl_.campaign_info_;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignLaunchProposal::mutable_campaign_info() {
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _msg = _internal_mutable_campaign_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_info)
  return _msg;
}
inline void TradingRewardCampaignLaunchProposal::set_allocated_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.campaign_info_);
  }
  if (campaign_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(campaign_info));
    if (message_arena != submessage_arena) {
      campaign_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, campaign_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.campaign_info_ = campaign_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_info)
}

// repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 4 [json_name = "campaignRewardPools"];
inline int TradingRewardCampaignLaunchProposal::_internal_campaign_reward_pools_size() const {
  return _impl_.campaign_reward_pools_.size();
}
inline int TradingRewardCampaignLaunchProposal::campaign_reward_pools_size() const {
  return _internal_campaign_reward_pools_size();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignLaunchProposal::mutable_campaign_reward_pools(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_reward_pools)
  return _internal_mutable_campaign_reward_pools()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
TradingRewardCampaignLaunchProposal::mutable_campaign_reward_pools() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_reward_pools)
  return _internal_mutable_campaign_reward_pools();
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& TradingRewardCampaignLaunchProposal::_internal_campaign_reward_pools(int index) const {
  return _internal_campaign_reward_pools().Get(index);
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& TradingRewardCampaignLaunchProposal::campaign_reward_pools(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_reward_pools)
  return _internal_campaign_reward_pools(index);
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignLaunchProposal::_internal_add_campaign_reward_pools() {
  return _internal_mutable_campaign_reward_pools()->Add();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignLaunchProposal::add_campaign_reward_pools() {
  ::injective::exchange::v1beta1::CampaignRewardPool* _add = _internal_add_campaign_reward_pools();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_reward_pools)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
TradingRewardCampaignLaunchProposal::campaign_reward_pools() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal.campaign_reward_pools)
  return _internal_campaign_reward_pools();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>&
TradingRewardCampaignLaunchProposal::_internal_campaign_reward_pools() const {
  return _impl_.campaign_reward_pools_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>*
TradingRewardCampaignLaunchProposal::_internal_mutable_campaign_reward_pools() {
  return &_impl_.campaign_reward_pools_;
}

// -------------------------------------------------------------------

// TradingRewardCampaignUpdateProposal

// string title = 1 [json_name = "title"];
inline void TradingRewardCampaignUpdateProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& TradingRewardCampaignUpdateProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradingRewardCampaignUpdateProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.title)
}
inline std::string* TradingRewardCampaignUpdateProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.title)
  return _s;
}
inline const std::string& TradingRewardCampaignUpdateProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void TradingRewardCampaignUpdateProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignUpdateProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignUpdateProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.title)
  return _impl_.title_.Release();
}
inline void TradingRewardCampaignUpdateProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.title)
}

// string description = 2 [json_name = "description"];
inline void TradingRewardCampaignUpdateProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& TradingRewardCampaignUpdateProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradingRewardCampaignUpdateProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.description)
}
inline std::string* TradingRewardCampaignUpdateProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.description)
  return _s;
}
inline const std::string& TradingRewardCampaignUpdateProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void TradingRewardCampaignUpdateProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignUpdateProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* TradingRewardCampaignUpdateProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.description)
  return _impl_.description_.Release();
}
inline void TradingRewardCampaignUpdateProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.description)
}

// .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3 [json_name = "campaignInfo"];
inline bool TradingRewardCampaignUpdateProposal::has_campaign_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.campaign_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& TradingRewardCampaignUpdateProposal::_internal_campaign_info() const {
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo* p = _impl_.campaign_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::TradingRewardCampaignInfo&>(
      ::injective::exchange::v1beta1::_TradingRewardCampaignInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& TradingRewardCampaignUpdateProposal::campaign_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_info)
  return _internal_campaign_info();
}
inline void TradingRewardCampaignUpdateProposal::unsafe_arena_set_allocated_campaign_info(
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.campaign_info_);
  }
  _impl_.campaign_info_ = campaign_info;
  if (campaign_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_info)
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignUpdateProposal::release_campaign_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.campaign_info_;
  _impl_.campaign_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignUpdateProposal::unsafe_arena_release_campaign_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.campaign_info_;
  _impl_.campaign_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignUpdateProposal::_internal_mutable_campaign_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.campaign_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignInfo>(GetArenaForAllocation());
    _impl_.campaign_info_ = p;
  }
  return _impl_.campaign_info_;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* TradingRewardCampaignUpdateProposal::mutable_campaign_info() {
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _msg = _internal_mutable_campaign_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_info)
  return _msg;
}
inline void TradingRewardCampaignUpdateProposal::set_allocated_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.campaign_info_);
  }
  if (campaign_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(campaign_info));
    if (message_arena != submessage_arena) {
      campaign_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, campaign_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.campaign_info_ = campaign_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_info)
}

// repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_additions = 4 [json_name = "campaignRewardPoolsAdditions"];
inline int TradingRewardCampaignUpdateProposal::_internal_campaign_reward_pools_additions_size() const {
  return _impl_.campaign_reward_pools_additions_.size();
}
inline int TradingRewardCampaignUpdateProposal::campaign_reward_pools_additions_size() const {
  return _internal_campaign_reward_pools_additions_size();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignUpdateProposal::mutable_campaign_reward_pools_additions(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_additions)
  return _internal_mutable_campaign_reward_pools_additions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
TradingRewardCampaignUpdateProposal::mutable_campaign_reward_pools_additions() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_additions)
  return _internal_mutable_campaign_reward_pools_additions();
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& TradingRewardCampaignUpdateProposal::_internal_campaign_reward_pools_additions(int index) const {
  return _internal_campaign_reward_pools_additions().Get(index);
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& TradingRewardCampaignUpdateProposal::campaign_reward_pools_additions(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_additions)
  return _internal_campaign_reward_pools_additions(index);
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignUpdateProposal::_internal_add_campaign_reward_pools_additions() {
  return _internal_mutable_campaign_reward_pools_additions()->Add();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignUpdateProposal::add_campaign_reward_pools_additions() {
  ::injective::exchange::v1beta1::CampaignRewardPool* _add = _internal_add_campaign_reward_pools_additions();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_additions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
TradingRewardCampaignUpdateProposal::campaign_reward_pools_additions() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_additions)
  return _internal_campaign_reward_pools_additions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>&
TradingRewardCampaignUpdateProposal::_internal_campaign_reward_pools_additions() const {
  return _impl_.campaign_reward_pools_additions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>*
TradingRewardCampaignUpdateProposal::_internal_mutable_campaign_reward_pools_additions() {
  return &_impl_.campaign_reward_pools_additions_;
}

// repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_updates = 5 [json_name = "campaignRewardPoolsUpdates"];
inline int TradingRewardCampaignUpdateProposal::_internal_campaign_reward_pools_updates_size() const {
  return _impl_.campaign_reward_pools_updates_.size();
}
inline int TradingRewardCampaignUpdateProposal::campaign_reward_pools_updates_size() const {
  return _internal_campaign_reward_pools_updates_size();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignUpdateProposal::mutable_campaign_reward_pools_updates(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_updates)
  return _internal_mutable_campaign_reward_pools_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
TradingRewardCampaignUpdateProposal::mutable_campaign_reward_pools_updates() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_updates)
  return _internal_mutable_campaign_reward_pools_updates();
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& TradingRewardCampaignUpdateProposal::_internal_campaign_reward_pools_updates(int index) const {
  return _internal_campaign_reward_pools_updates().Get(index);
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& TradingRewardCampaignUpdateProposal::campaign_reward_pools_updates(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_updates)
  return _internal_campaign_reward_pools_updates(index);
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignUpdateProposal::_internal_add_campaign_reward_pools_updates() {
  return _internal_mutable_campaign_reward_pools_updates()->Add();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* TradingRewardCampaignUpdateProposal::add_campaign_reward_pools_updates() {
  ::injective::exchange::v1beta1::CampaignRewardPool* _add = _internal_add_campaign_reward_pools_updates();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
TradingRewardCampaignUpdateProposal::campaign_reward_pools_updates() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal.campaign_reward_pools_updates)
  return _internal_campaign_reward_pools_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>&
TradingRewardCampaignUpdateProposal::_internal_campaign_reward_pools_updates() const {
  return _impl_.campaign_reward_pools_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>*
TradingRewardCampaignUpdateProposal::_internal_mutable_campaign_reward_pools_updates() {
  return &_impl_.campaign_reward_pools_updates_;
}

// -------------------------------------------------------------------

// RewardPointUpdate

// string account_address = 1 [json_name = "accountAddress"];
inline void RewardPointUpdate::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& RewardPointUpdate::account_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.RewardPointUpdate.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RewardPointUpdate::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.RewardPointUpdate.account_address)
}
inline std::string* RewardPointUpdate::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.RewardPointUpdate.account_address)
  return _s;
}
inline const std::string& RewardPointUpdate::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void RewardPointUpdate::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* RewardPointUpdate::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* RewardPointUpdate::release_account_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.RewardPointUpdate.account_address)
  return _impl_.account_address_.Release();
}
inline void RewardPointUpdate::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.RewardPointUpdate.account_address)
}

// string new_points = 12 [json_name = "newPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void RewardPointUpdate::clear_new_points() {
  _impl_.new_points_.ClearToEmpty();
}
inline const std::string& RewardPointUpdate::new_points() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.RewardPointUpdate.new_points)
  return _internal_new_points();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RewardPointUpdate::set_new_points(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.new_points_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.RewardPointUpdate.new_points)
}
inline std::string* RewardPointUpdate::mutable_new_points() {
  std::string* _s = _internal_mutable_new_points();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.RewardPointUpdate.new_points)
  return _s;
}
inline const std::string& RewardPointUpdate::_internal_new_points() const {
  return _impl_.new_points_.Get();
}
inline void RewardPointUpdate::_internal_set_new_points(const std::string& value) {
  ;


  _impl_.new_points_.Set(value, GetArenaForAllocation());
}
inline std::string* RewardPointUpdate::_internal_mutable_new_points() {
  ;
  return _impl_.new_points_.Mutable( GetArenaForAllocation());
}
inline std::string* RewardPointUpdate::release_new_points() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.RewardPointUpdate.new_points)
  return _impl_.new_points_.Release();
}
inline void RewardPointUpdate::set_allocated_new_points(std::string* value) {
  _impl_.new_points_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_points_.IsDefault()) {
          _impl_.new_points_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.RewardPointUpdate.new_points)
}

// -------------------------------------------------------------------

// TradingRewardPendingPointsUpdateProposal

// string title = 1 [json_name = "title"];
inline void TradingRewardPendingPointsUpdateProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& TradingRewardPendingPointsUpdateProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradingRewardPendingPointsUpdateProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.title)
}
inline std::string* TradingRewardPendingPointsUpdateProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.title)
  return _s;
}
inline const std::string& TradingRewardPendingPointsUpdateProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void TradingRewardPendingPointsUpdateProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* TradingRewardPendingPointsUpdateProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* TradingRewardPendingPointsUpdateProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.title)
  return _impl_.title_.Release();
}
inline void TradingRewardPendingPointsUpdateProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.title)
}

// string description = 2 [json_name = "description"];
inline void TradingRewardPendingPointsUpdateProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& TradingRewardPendingPointsUpdateProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradingRewardPendingPointsUpdateProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.description)
}
inline std::string* TradingRewardPendingPointsUpdateProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.description)
  return _s;
}
inline const std::string& TradingRewardPendingPointsUpdateProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void TradingRewardPendingPointsUpdateProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* TradingRewardPendingPointsUpdateProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* TradingRewardPendingPointsUpdateProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.description)
  return _impl_.description_.Release();
}
inline void TradingRewardPendingPointsUpdateProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.description)
}

// int64 pending_pool_timestamp = 3 [json_name = "pendingPoolTimestamp"];
inline void TradingRewardPendingPointsUpdateProposal::clear_pending_pool_timestamp() {
  _impl_.pending_pool_timestamp_ = ::int64_t{0};
}
inline ::int64_t TradingRewardPendingPointsUpdateProposal::pending_pool_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.pending_pool_timestamp)
  return _internal_pending_pool_timestamp();
}
inline void TradingRewardPendingPointsUpdateProposal::set_pending_pool_timestamp(::int64_t value) {
  _internal_set_pending_pool_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.pending_pool_timestamp)
}
inline ::int64_t TradingRewardPendingPointsUpdateProposal::_internal_pending_pool_timestamp() const {
  return _impl_.pending_pool_timestamp_;
}
inline void TradingRewardPendingPointsUpdateProposal::_internal_set_pending_pool_timestamp(::int64_t value) {
  ;
  _impl_.pending_pool_timestamp_ = value;
}

// repeated .injective.exchange.v1beta1.RewardPointUpdate reward_point_updates = 4 [json_name = "rewardPointUpdates"];
inline int TradingRewardPendingPointsUpdateProposal::_internal_reward_point_updates_size() const {
  return _impl_.reward_point_updates_.size();
}
inline int TradingRewardPendingPointsUpdateProposal::reward_point_updates_size() const {
  return _internal_reward_point_updates_size();
}
inline void TradingRewardPendingPointsUpdateProposal::clear_reward_point_updates() {
  _internal_mutable_reward_point_updates()->Clear();
}
inline ::injective::exchange::v1beta1::RewardPointUpdate* TradingRewardPendingPointsUpdateProposal::mutable_reward_point_updates(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.reward_point_updates)
  return _internal_mutable_reward_point_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::RewardPointUpdate >*
TradingRewardPendingPointsUpdateProposal::mutable_reward_point_updates() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.reward_point_updates)
  return _internal_mutable_reward_point_updates();
}
inline const ::injective::exchange::v1beta1::RewardPointUpdate& TradingRewardPendingPointsUpdateProposal::_internal_reward_point_updates(int index) const {
  return _internal_reward_point_updates().Get(index);
}
inline const ::injective::exchange::v1beta1::RewardPointUpdate& TradingRewardPendingPointsUpdateProposal::reward_point_updates(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.reward_point_updates)
  return _internal_reward_point_updates(index);
}
inline ::injective::exchange::v1beta1::RewardPointUpdate* TradingRewardPendingPointsUpdateProposal::_internal_add_reward_point_updates() {
  return _internal_mutable_reward_point_updates()->Add();
}
inline ::injective::exchange::v1beta1::RewardPointUpdate* TradingRewardPendingPointsUpdateProposal::add_reward_point_updates() {
  ::injective::exchange::v1beta1::RewardPointUpdate* _add = _internal_add_reward_point_updates();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.reward_point_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::RewardPointUpdate >&
TradingRewardPendingPointsUpdateProposal::reward_point_updates() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal.reward_point_updates)
  return _internal_reward_point_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::RewardPointUpdate>&
TradingRewardPendingPointsUpdateProposal::_internal_reward_point_updates() const {
  return _impl_.reward_point_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::RewardPointUpdate>*
TradingRewardPendingPointsUpdateProposal::_internal_mutable_reward_point_updates() {
  return &_impl_.reward_point_updates_;
}

// -------------------------------------------------------------------

// FeeDiscountProposal

// string title = 1 [json_name = "title"];
inline void FeeDiscountProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& FeeDiscountProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeeDiscountProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountProposal.title)
}
inline std::string* FeeDiscountProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountProposal.title)
  return _s;
}
inline const std::string& FeeDiscountProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void FeeDiscountProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* FeeDiscountProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* FeeDiscountProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FeeDiscountProposal.title)
  return _impl_.title_.Release();
}
inline void FeeDiscountProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FeeDiscountProposal.title)
}

// string description = 2 [json_name = "description"];
inline void FeeDiscountProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& FeeDiscountProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeeDiscountProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FeeDiscountProposal.description)
}
inline std::string* FeeDiscountProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountProposal.description)
  return _s;
}
inline const std::string& FeeDiscountProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void FeeDiscountProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* FeeDiscountProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* FeeDiscountProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FeeDiscountProposal.description)
  return _impl_.description_.Release();
}
inline void FeeDiscountProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FeeDiscountProposal.description)
}

// .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 3 [json_name = "schedule"];
inline bool FeeDiscountProposal::has_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedule_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::FeeDiscountSchedule& FeeDiscountProposal::_internal_schedule() const {
  const ::injective::exchange::v1beta1::FeeDiscountSchedule* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::FeeDiscountSchedule&>(
      ::injective::exchange::v1beta1::_FeeDiscountSchedule_default_instance_);
}
inline const ::injective::exchange::v1beta1::FeeDiscountSchedule& FeeDiscountProposal::schedule() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FeeDiscountProposal.schedule)
  return _internal_schedule();
}
inline void FeeDiscountProposal::unsafe_arena_set_allocated_schedule(
    ::injective::exchange::v1beta1::FeeDiscountSchedule* schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = schedule;
  if (schedule) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.FeeDiscountProposal.schedule)
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* FeeDiscountProposal::release_schedule() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* FeeDiscountProposal::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FeeDiscountProposal.schedule)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* FeeDiscountProposal::_internal_mutable_schedule() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountSchedule>(GetArenaForAllocation());
    _impl_.schedule_ = p;
  }
  return _impl_.schedule_;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* FeeDiscountProposal::mutable_schedule() {
  ::injective::exchange::v1beta1::FeeDiscountSchedule* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FeeDiscountProposal.schedule)
  return _msg;
}
inline void FeeDiscountProposal::set_allocated_schedule(::injective::exchange::v1beta1::FeeDiscountSchedule* schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  if (schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schedule));
    if (message_arena != submessage_arena) {
      schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FeeDiscountProposal.schedule)
}

// -------------------------------------------------------------------

// BatchCommunityPoolSpendProposal

// string title = 1 [json_name = "title"];
inline void BatchCommunityPoolSpendProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& BatchCommunityPoolSpendProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BatchCommunityPoolSpendProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.title)
}
inline std::string* BatchCommunityPoolSpendProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.title)
  return _s;
}
inline const std::string& BatchCommunityPoolSpendProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void BatchCommunityPoolSpendProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchCommunityPoolSpendProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* BatchCommunityPoolSpendProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.title)
  return _impl_.title_.Release();
}
inline void BatchCommunityPoolSpendProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.title)
}

// string description = 2 [json_name = "description"];
inline void BatchCommunityPoolSpendProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& BatchCommunityPoolSpendProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BatchCommunityPoolSpendProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.description)
}
inline std::string* BatchCommunityPoolSpendProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.description)
  return _s;
}
inline const std::string& BatchCommunityPoolSpendProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void BatchCommunityPoolSpendProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchCommunityPoolSpendProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* BatchCommunityPoolSpendProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.description)
  return _impl_.description_.Release();
}
inline void BatchCommunityPoolSpendProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.description)
}

// repeated .cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals = 3 [json_name = "proposals"];
inline int BatchCommunityPoolSpendProposal::_internal_proposals_size() const {
  return _impl_.proposals_.size();
}
inline int BatchCommunityPoolSpendProposal::proposals_size() const {
  return _internal_proposals_size();
}
inline ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* BatchCommunityPoolSpendProposal::mutable_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.proposals)
  return _internal_mutable_proposals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal >*
BatchCommunityPoolSpendProposal::mutable_proposals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.proposals)
  return _internal_mutable_proposals();
}
inline const ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal& BatchCommunityPoolSpendProposal::_internal_proposals(int index) const {
  return _internal_proposals().Get(index);
}
inline const ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal& BatchCommunityPoolSpendProposal::proposals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.proposals)
  return _internal_proposals(index);
}
inline ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* BatchCommunityPoolSpendProposal::_internal_add_proposals() {
  return _internal_mutable_proposals()->Add();
}
inline ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* BatchCommunityPoolSpendProposal::add_proposals() {
  ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal* _add = _internal_add_proposals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::distribution::v1beta1::CommunityPoolSpendProposal >&
BatchCommunityPoolSpendProposal::proposals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.BatchCommunityPoolSpendProposal.proposals)
  return _internal_proposals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::CommunityPoolSpendProposal>&
BatchCommunityPoolSpendProposal::_internal_proposals() const {
  return _impl_.proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::distribution::v1beta1::CommunityPoolSpendProposal>*
BatchCommunityPoolSpendProposal::_internal_mutable_proposals() {
  return &_impl_.proposals_;
}

// -------------------------------------------------------------------

// MsgRewardsOptOut

// string sender = 1 [json_name = "sender"];
inline void MsgRewardsOptOut::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgRewardsOptOut::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgRewardsOptOut.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRewardsOptOut::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgRewardsOptOut.sender)
}
inline std::string* MsgRewardsOptOut::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgRewardsOptOut.sender)
  return _s;
}
inline const std::string& MsgRewardsOptOut::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgRewardsOptOut::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRewardsOptOut::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRewardsOptOut::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgRewardsOptOut.sender)
  return _impl_.sender_.Release();
}
inline void MsgRewardsOptOut::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgRewardsOptOut.sender)
}

// -------------------------------------------------------------------

// MsgRewardsOptOutResponse

// -------------------------------------------------------------------

// MsgReclaimLockedFunds

// string sender = 1 [json_name = "sender"];
inline void MsgReclaimLockedFunds::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgReclaimLockedFunds::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgReclaimLockedFunds.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgReclaimLockedFunds::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgReclaimLockedFunds.sender)
}
inline std::string* MsgReclaimLockedFunds::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgReclaimLockedFunds.sender)
  return _s;
}
inline const std::string& MsgReclaimLockedFunds::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgReclaimLockedFunds::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReclaimLockedFunds::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgReclaimLockedFunds::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgReclaimLockedFunds.sender)
  return _impl_.sender_.Release();
}
inline void MsgReclaimLockedFunds::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgReclaimLockedFunds.sender)
}

// bytes lockedAccountPubKey = 2 [json_name = "lockedAccountPubKey"];
inline void MsgReclaimLockedFunds::clear_lockedaccountpubkey() {
  _impl_.lockedaccountpubkey_.ClearToEmpty();
}
inline const std::string& MsgReclaimLockedFunds::lockedaccountpubkey() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgReclaimLockedFunds.lockedAccountPubKey)
  return _internal_lockedaccountpubkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgReclaimLockedFunds::set_lockedaccountpubkey(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.lockedaccountpubkey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgReclaimLockedFunds.lockedAccountPubKey)
}
inline std::string* MsgReclaimLockedFunds::mutable_lockedaccountpubkey() {
  std::string* _s = _internal_mutable_lockedaccountpubkey();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgReclaimLockedFunds.lockedAccountPubKey)
  return _s;
}
inline const std::string& MsgReclaimLockedFunds::_internal_lockedaccountpubkey() const {
  return _impl_.lockedaccountpubkey_.Get();
}
inline void MsgReclaimLockedFunds::_internal_set_lockedaccountpubkey(const std::string& value) {
  ;


  _impl_.lockedaccountpubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReclaimLockedFunds::_internal_mutable_lockedaccountpubkey() {
  ;
  return _impl_.lockedaccountpubkey_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgReclaimLockedFunds::release_lockedaccountpubkey() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgReclaimLockedFunds.lockedAccountPubKey)
  return _impl_.lockedaccountpubkey_.Release();
}
inline void MsgReclaimLockedFunds::set_allocated_lockedaccountpubkey(std::string* value) {
  _impl_.lockedaccountpubkey_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lockedaccountpubkey_.IsDefault()) {
          _impl_.lockedaccountpubkey_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgReclaimLockedFunds.lockedAccountPubKey)
}

// bytes signature = 3 [json_name = "signature"];
inline void MsgReclaimLockedFunds::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& MsgReclaimLockedFunds::signature() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgReclaimLockedFunds.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgReclaimLockedFunds::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgReclaimLockedFunds.signature)
}
inline std::string* MsgReclaimLockedFunds::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgReclaimLockedFunds.signature)
  return _s;
}
inline const std::string& MsgReclaimLockedFunds::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void MsgReclaimLockedFunds::_internal_set_signature(const std::string& value) {
  ;


  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReclaimLockedFunds::_internal_mutable_signature() {
  ;
  return _impl_.signature_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgReclaimLockedFunds::release_signature() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgReclaimLockedFunds.signature)
  return _impl_.signature_.Release();
}
inline void MsgReclaimLockedFunds::set_allocated_signature(std::string* value) {
  _impl_.signature_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgReclaimLockedFunds.signature)
}

// -------------------------------------------------------------------

// MsgReclaimLockedFundsResponse

// -------------------------------------------------------------------

// MsgSignData

// bytes Signer = 1 [json_name = "Signer", (.gogoproto.jsontag) = "signer", (.gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress"];
inline void MsgSignData::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgSignData::signer() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSignData.Signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSignData::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgSignData.Signer)
}
inline std::string* MsgSignData::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSignData.Signer)
  return _s;
}
inline const std::string& MsgSignData::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgSignData::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSignData::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSignData::release_signer() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSignData.Signer)
  return _impl_.signer_.Release();
}
inline void MsgSignData::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSignData.Signer)
}

// bytes Data = 2 [json_name = "Data", (.gogoproto.jsontag) = "data"];
inline void MsgSignData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& MsgSignData::data() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSignData.Data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSignData::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgSignData.Data)
}
inline std::string* MsgSignData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSignData.Data)
  return _s;
}
inline const std::string& MsgSignData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void MsgSignData::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSignData::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSignData::release_data() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSignData.Data)
  return _impl_.data_.Release();
}
inline void MsgSignData::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSignData.Data)
}

// -------------------------------------------------------------------

// MsgSignDoc

// string sign_type = 1 [json_name = "signType", (.gogoproto.jsontag) = "type"];
inline void MsgSignDoc::clear_sign_type() {
  _impl_.sign_type_.ClearToEmpty();
}
inline const std::string& MsgSignDoc::sign_type() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSignDoc.sign_type)
  return _internal_sign_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgSignDoc::set_sign_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sign_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgSignDoc.sign_type)
}
inline std::string* MsgSignDoc::mutable_sign_type() {
  std::string* _s = _internal_mutable_sign_type();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSignDoc.sign_type)
  return _s;
}
inline const std::string& MsgSignDoc::_internal_sign_type() const {
  return _impl_.sign_type_.Get();
}
inline void MsgSignDoc::_internal_set_sign_type(const std::string& value) {
  ;


  _impl_.sign_type_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgSignDoc::_internal_mutable_sign_type() {
  ;
  return _impl_.sign_type_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgSignDoc::release_sign_type() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSignDoc.sign_type)
  return _impl_.sign_type_.Release();
}
inline void MsgSignDoc::set_allocated_sign_type(std::string* value) {
  _impl_.sign_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sign_type_.IsDefault()) {
          _impl_.sign_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSignDoc.sign_type)
}

// .injective.exchange.v1beta1.MsgSignData value = 2 [json_name = "value", (.gogoproto.nullable) = false];
inline bool MsgSignDoc::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void MsgSignDoc::clear_value() {
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::MsgSignData& MsgSignDoc::_internal_value() const {
  const ::injective::exchange::v1beta1::MsgSignData* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::MsgSignData&>(
      ::injective::exchange::v1beta1::_MsgSignData_default_instance_);
}
inline const ::injective::exchange::v1beta1::MsgSignData& MsgSignDoc::value() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgSignDoc.value)
  return _internal_value();
}
inline void MsgSignDoc::unsafe_arena_set_allocated_value(
    ::injective::exchange::v1beta1::MsgSignData* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.MsgSignDoc.value)
}
inline ::injective::exchange::v1beta1::MsgSignData* MsgSignDoc::release_value() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::MsgSignData* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::MsgSignData* MsgSignDoc::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgSignDoc.value)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::MsgSignData* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::MsgSignData* MsgSignDoc::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::MsgSignData>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::injective::exchange::v1beta1::MsgSignData* MsgSignDoc::mutable_value() {
  ::injective::exchange::v1beta1::MsgSignData* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgSignDoc.value)
  return _msg;
}
inline void MsgSignDoc::set_allocated_value(::injective::exchange::v1beta1::MsgSignData* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgSignDoc.value)
}

// -------------------------------------------------------------------

// MsgAdminUpdateBinaryOptionsMarket

// string sender = 1 [json_name = "sender"];
inline void MsgAdminUpdateBinaryOptionsMarket::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& MsgAdminUpdateBinaryOptionsMarket::sender() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAdminUpdateBinaryOptionsMarket::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.sender)
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.sender)
  return _s;
}
inline const std::string& MsgAdminUpdateBinaryOptionsMarket::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void MsgAdminUpdateBinaryOptionsMarket::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::release_sender() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.sender)
  return _impl_.sender_.Release();
}
inline void MsgAdminUpdateBinaryOptionsMarket::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.sender)
}

// string market_id = 2 [json_name = "marketId"];
inline void MsgAdminUpdateBinaryOptionsMarket::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MsgAdminUpdateBinaryOptionsMarket::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAdminUpdateBinaryOptionsMarket::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.market_id)
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.market_id)
  return _s;
}
inline const std::string& MsgAdminUpdateBinaryOptionsMarket::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MsgAdminUpdateBinaryOptionsMarket::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.market_id)
  return _impl_.market_id_.Release();
}
inline void MsgAdminUpdateBinaryOptionsMarket::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.market_id)
}

// string settlement_price = 3 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void MsgAdminUpdateBinaryOptionsMarket::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& MsgAdminUpdateBinaryOptionsMarket::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAdminUpdateBinaryOptionsMarket::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.settlement_price)
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.settlement_price)
  return _s;
}
inline const std::string& MsgAdminUpdateBinaryOptionsMarket::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void MsgAdminUpdateBinaryOptionsMarket::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAdminUpdateBinaryOptionsMarket::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void MsgAdminUpdateBinaryOptionsMarket::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.settlement_price)
}

// int64 expiration_timestamp = 4 [json_name = "expirationTimestamp"];
inline void MsgAdminUpdateBinaryOptionsMarket::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t MsgAdminUpdateBinaryOptionsMarket::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void MsgAdminUpdateBinaryOptionsMarket::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.expiration_timestamp)
}
inline ::int64_t MsgAdminUpdateBinaryOptionsMarket::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void MsgAdminUpdateBinaryOptionsMarket::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// int64 settlement_timestamp = 5 [json_name = "settlementTimestamp"];
inline void MsgAdminUpdateBinaryOptionsMarket::clear_settlement_timestamp() {
  _impl_.settlement_timestamp_ = ::int64_t{0};
}
inline ::int64_t MsgAdminUpdateBinaryOptionsMarket::settlement_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.settlement_timestamp)
  return _internal_settlement_timestamp();
}
inline void MsgAdminUpdateBinaryOptionsMarket::set_settlement_timestamp(::int64_t value) {
  _internal_set_settlement_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.settlement_timestamp)
}
inline ::int64_t MsgAdminUpdateBinaryOptionsMarket::_internal_settlement_timestamp() const {
  return _impl_.settlement_timestamp_;
}
inline void MsgAdminUpdateBinaryOptionsMarket::_internal_set_settlement_timestamp(::int64_t value) {
  ;
  _impl_.settlement_timestamp_ = value;
}

// .injective.exchange.v1beta1.MarketStatus status = 6 [json_name = "status"];
inline void MsgAdminUpdateBinaryOptionsMarket::clear_status() {
  _impl_.status_ = 0;
}
inline ::injective::exchange::v1beta1::MarketStatus MsgAdminUpdateBinaryOptionsMarket::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.status)
  return _internal_status();
}
inline void MsgAdminUpdateBinaryOptionsMarket::set_status(::injective::exchange::v1beta1::MarketStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket.status)
}
inline ::injective::exchange::v1beta1::MarketStatus MsgAdminUpdateBinaryOptionsMarket::_internal_status() const {
  return static_cast<::injective::exchange::v1beta1::MarketStatus>(_impl_.status_);
}
inline void MsgAdminUpdateBinaryOptionsMarket::_internal_set_status(::injective::exchange::v1beta1::MarketStatus value) {
  ;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// MsgAdminUpdateBinaryOptionsMarketResponse

// -------------------------------------------------------------------

// AtomicMarketOrderFeeMultiplierScheduleProposal

// string title = 1 [json_name = "title"];
inline void AtomicMarketOrderFeeMultiplierScheduleProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& AtomicMarketOrderFeeMultiplierScheduleProposal::title() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AtomicMarketOrderFeeMultiplierScheduleProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.title)
}
inline std::string* AtomicMarketOrderFeeMultiplierScheduleProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.title)
  return _s;
}
inline const std::string& AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* AtomicMarketOrderFeeMultiplierScheduleProposal::release_title() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.title)
  return _impl_.title_.Release();
}
inline void AtomicMarketOrderFeeMultiplierScheduleProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.title)
}

// string description = 2 [json_name = "description"];
inline void AtomicMarketOrderFeeMultiplierScheduleProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& AtomicMarketOrderFeeMultiplierScheduleProposal::description() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AtomicMarketOrderFeeMultiplierScheduleProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.description)
}
inline std::string* AtomicMarketOrderFeeMultiplierScheduleProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.description)
  return _s;
}
inline const std::string& AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* AtomicMarketOrderFeeMultiplierScheduleProposal::release_description() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.description)
  return _impl_.description_.Release();
}
inline void AtomicMarketOrderFeeMultiplierScheduleProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.description)
}

// repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 3 [json_name = "marketFeeMultipliers"];
inline int AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_market_fee_multipliers_size() const {
  return _impl_.market_fee_multipliers_.size();
}
inline int AtomicMarketOrderFeeMultiplierScheduleProposal::market_fee_multipliers_size() const {
  return _internal_market_fee_multipliers_size();
}
inline ::injective::exchange::v1beta1::MarketFeeMultiplier* AtomicMarketOrderFeeMultiplierScheduleProposal::mutable_market_fee_multipliers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.market_fee_multipliers)
  return _internal_mutable_market_fee_multipliers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >*
AtomicMarketOrderFeeMultiplierScheduleProposal::mutable_market_fee_multipliers() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.market_fee_multipliers)
  return _internal_mutable_market_fee_multipliers();
}
inline const ::injective::exchange::v1beta1::MarketFeeMultiplier& AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_market_fee_multipliers(int index) const {
  return _internal_market_fee_multipliers().Get(index);
}
inline const ::injective::exchange::v1beta1::MarketFeeMultiplier& AtomicMarketOrderFeeMultiplierScheduleProposal::market_fee_multipliers(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.market_fee_multipliers)
  return _internal_market_fee_multipliers(index);
}
inline ::injective::exchange::v1beta1::MarketFeeMultiplier* AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_add_market_fee_multipliers() {
  return _internal_mutable_market_fee_multipliers()->Add();
}
inline ::injective::exchange::v1beta1::MarketFeeMultiplier* AtomicMarketOrderFeeMultiplierScheduleProposal::add_market_fee_multipliers() {
  ::injective::exchange::v1beta1::MarketFeeMultiplier* _add = _internal_add_market_fee_multipliers();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.market_fee_multipliers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >&
AtomicMarketOrderFeeMultiplierScheduleProposal::market_fee_multipliers() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal.market_fee_multipliers)
  return _internal_market_fee_multipliers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>&
AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_market_fee_multipliers() const {
  return _impl_.market_fee_multipliers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>*
AtomicMarketOrderFeeMultiplierScheduleProposal::_internal_mutable_market_fee_multipliers() {
  return &_impl_.market_fee_multipliers_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::injective::exchange::v1beta1::ExchangeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::ExchangeType>() {
  return ::injective::exchange::v1beta1::ExchangeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2ftx_2eproto_2epb_2eh
