// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/exchange/v1beta1/exchange.proto

#include "injective/exchange/v1beta1/exchange.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace injective {
namespace exchange {
namespace v1beta1 {
template <typename>
PROTOBUF_CONSTEXPR Params::Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.default_spot_maker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.default_spot_taker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.default_derivative_maker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.default_derivative_taker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.default_initial_margin_ratio_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.default_maintenance_margin_ratio_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.relayer_fee_share_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.default_hourly_funding_rate_cap_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.default_hourly_interest_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.inj_reward_staked_requirement_threshold_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.liquidator_reward_share_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.spot_atomic_market_order_fee_multiplier_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.derivative_atomic_market_order_fee_multiplier_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.binary_options_atomic_market_order_fee_multiplier_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.minimal_protocol_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.spot_market_instant_listing_fee_)*/nullptr
  , /*decltype(_impl_.derivative_market_instant_listing_fee_)*/nullptr
  , /*decltype(_impl_.binary_options_market_instant_listing_fee_)*/nullptr
  , /*decltype(_impl_.default_funding_interval_)*/ ::int64_t{0}

  , /*decltype(_impl_.funding_multiple_)*/ ::int64_t{0}

  , /*decltype(_impl_.trading_rewards_vesting_duration_)*/ ::int64_t{0}

  , /*decltype(_impl_.max_derivative_order_side_count_)*/ 0u

  , /*decltype(_impl_.atomic_market_order_access_level_)*/ 0

  , /*decltype(_impl_.is_instant_derivative_market_launch_enabled_)*/ false
} {}
struct ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParamsDefaultTypeInternal() {}
  union {
    Params _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParamsDefaultTypeInternal _Params_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketFeeMultiplier::MarketFeeMultiplier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_multiplier_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MarketFeeMultiplierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketFeeMultiplierDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketFeeMultiplierDefaultTypeInternal() {}
  union {
    MarketFeeMultiplier _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketFeeMultiplierDefaultTypeInternal _MarketFeeMultiplier_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeMarket::DerivativeMarket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ticker_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_base_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_quote_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quote_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.initial_margin_ratio_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.maintenance_margin_ratio_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.maker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.taker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.relayer_fee_share_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_price_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_quantity_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_type_)*/ 0

  , /*decltype(_impl_.oracle_scale_factor_)*/ 0u

  , /*decltype(_impl_.isperpetual_)*/ false

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DerivativeMarketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeMarketDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeMarketDefaultTypeInternal() {}
  union {
    DerivativeMarket _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeMarketDefaultTypeInternal _DerivativeMarket_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BinaryOptionsMarket::BinaryOptionsMarket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ticker_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_symbol_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_provider_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.admin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quote_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.maker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.taker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.relayer_fee_share_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_price_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_quantity_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.settlement_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.oracle_type_)*/ 0

  , /*decltype(_impl_.oracle_scale_factor_)*/ 0u

  , /*decltype(_impl_.expiration_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.settlement_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BinaryOptionsMarketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BinaryOptionsMarketDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BinaryOptionsMarketDefaultTypeInternal() {}
  union {
    BinaryOptionsMarket _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BinaryOptionsMarketDefaultTypeInternal _BinaryOptionsMarket_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ExpiryFuturesMarketInfo::ExpiryFuturesMarketInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.expiration_twap_start_price_cumulative_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.settlement_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.expiration_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.twap_start_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpiryFuturesMarketInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpiryFuturesMarketInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpiryFuturesMarketInfoDefaultTypeInternal() {}
  union {
    ExpiryFuturesMarketInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpiryFuturesMarketInfoDefaultTypeInternal _ExpiryFuturesMarketInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PerpetualMarketInfo::PerpetualMarketInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hourly_funding_rate_cap_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hourly_interest_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.next_funding_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_.funding_interval_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PerpetualMarketInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PerpetualMarketInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PerpetualMarketInfoDefaultTypeInternal() {}
  union {
    PerpetualMarketInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PerpetualMarketInfoDefaultTypeInternal _PerpetualMarketInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PerpetualMarketFunding::PerpetualMarketFunding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cumulative_funding_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.cumulative_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.last_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PerpetualMarketFundingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PerpetualMarketFundingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PerpetualMarketFundingDefaultTypeInternal() {}
  union {
    PerpetualMarketFunding _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PerpetualMarketFundingDefaultTypeInternal _PerpetualMarketFunding_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeMarketSettlementInfo::DerivativeMarketSettlementInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.settlement_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DerivativeMarketSettlementInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeMarketSettlementInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeMarketSettlementInfoDefaultTypeInternal() {}
  union {
    DerivativeMarketSettlementInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeMarketSettlementInfoDefaultTypeInternal _DerivativeMarketSettlementInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NextFundingTimestamp::NextFundingTimestamp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.next_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NextFundingTimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NextFundingTimestampDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NextFundingTimestampDefaultTypeInternal() {}
  union {
    NextFundingTimestamp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NextFundingTimestampDefaultTypeInternal _NextFundingTimestamp_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MidPriceAndTOB::MidPriceAndTOB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mid_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.best_buy_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.best_sell_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MidPriceAndTOBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MidPriceAndTOBDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MidPriceAndTOBDefaultTypeInternal() {}
  union {
    MidPriceAndTOB _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MidPriceAndTOBDefaultTypeInternal _MidPriceAndTOB_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotMarket::SpotMarket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ticker_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.base_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quote_denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.maker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.taker_fee_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.relayer_fee_share_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_price_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.min_quantity_tick_size_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpotMarketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotMarketDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotMarketDefaultTypeInternal() {}
  union {
    SpotMarket _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotMarketDefaultTypeInternal _SpotMarket_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Deposit::Deposit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.available_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.total_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DepositDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DepositDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DepositDefaultTypeInternal() {}
  union {
    Deposit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DepositDefaultTypeInternal _Deposit_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountTradeNonce::SubaccountTradeNonce(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nonce_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountTradeNonceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountTradeNonceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountTradeNonceDefaultTypeInternal() {}
  union {
    SubaccountTradeNonce _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountTradeNonceDefaultTypeInternal _SubaccountTradeNonce_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderInfo::OrderInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_recipient_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderInfoDefaultTypeInternal() {}
  union {
    OrderInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotOrder::SpotOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_info_)*/nullptr
  , /*decltype(_impl_.order_type_)*/ 0
} {}
struct SpotOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotOrderDefaultTypeInternal() {}
  union {
    SpotOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotOrderDefaultTypeInternal _SpotOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotLimitOrder::SpotLimitOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fillable_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_info_)*/nullptr
  , /*decltype(_impl_.order_type_)*/ 0
} {}
struct SpotLimitOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotLimitOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotLimitOrderDefaultTypeInternal() {}
  union {
    SpotLimitOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotLimitOrderDefaultTypeInternal _SpotLimitOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpotMarketOrder::SpotMarketOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.balance_hold_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_info_)*/nullptr
  , /*decltype(_impl_.order_type_)*/ 0
} {}
struct SpotMarketOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpotMarketOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpotMarketOrderDefaultTypeInternal() {}
  union {
    SpotMarketOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpotMarketOrderDefaultTypeInternal _SpotMarketOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeOrder::DerivativeOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.margin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_info_)*/nullptr
  , /*decltype(_impl_.order_type_)*/ 0
} {}
struct DerivativeOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeOrderDefaultTypeInternal() {}
  union {
    DerivativeOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeOrderDefaultTypeInternal _DerivativeOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountOrderbookMetadata::SubaccountOrderbookMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.aggregate_reduce_only_quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.aggregate_vanilla_quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.vanilla_limit_order_count_)*/ 0u

  , /*decltype(_impl_.reduce_only_limit_order_count_)*/ 0u

  , /*decltype(_impl_.vanilla_conditional_order_count_)*/ 0u

  , /*decltype(_impl_.reduce_only_conditional_order_count_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountOrderbookMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountOrderbookMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountOrderbookMetadataDefaultTypeInternal() {}
  union {
    SubaccountOrderbookMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountOrderbookMetadataDefaultTypeInternal _SubaccountOrderbookMetadata_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountOrder::SubaccountOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.isreduceonly_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountOrderDefaultTypeInternal() {}
  union {
    SubaccountOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountOrderDefaultTypeInternal _SubaccountOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountOrderData::SubaccountOrderData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_)*/nullptr} {}
struct SubaccountOrderDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountOrderDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountOrderDataDefaultTypeInternal() {}
  union {
    SubaccountOrderData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountOrderDataDefaultTypeInternal _SubaccountOrderData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeLimitOrder::DerivativeLimitOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.margin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fillable_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_info_)*/nullptr
  , /*decltype(_impl_.order_type_)*/ 0
} {}
struct DerivativeLimitOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeLimitOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeLimitOrderDefaultTypeInternal() {}
  union {
    DerivativeLimitOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeLimitOrderDefaultTypeInternal _DerivativeLimitOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeMarketOrder::DerivativeMarketOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.margin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.margin_hold_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trigger_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_info_)*/nullptr
  , /*decltype(_impl_.order_type_)*/ 0
} {}
struct DerivativeMarketOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeMarketOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeMarketOrderDefaultTypeInternal() {}
  union {
    DerivativeMarketOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeMarketOrderDefaultTypeInternal _DerivativeMarketOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Position::Position(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.entry_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.margin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.cumulative_funding_entry_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.islong_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionDefaultTypeInternal _Position_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketOrderIndicator::MarketOrderIndicator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.isbuy_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MarketOrderIndicatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketOrderIndicatorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketOrderIndicatorDefaultTypeInternal() {}
  union {
    MarketOrderIndicator _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketOrderIndicatorDefaultTypeInternal _MarketOrderIndicator_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradeLog::TradeLog(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_recipient_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TradeLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeLogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeLogDefaultTypeInternal() {}
  union {
    TradeLog _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeLogDefaultTypeInternal _TradeLog_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PositionDelta::PositionDelta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.execution_quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.execution_margin_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.execution_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.is_long_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PositionDeltaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionDeltaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionDeltaDefaultTypeInternal() {}
  union {
    PositionDelta _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionDeltaDefaultTypeInternal _PositionDelta_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeTradeLog::DerivativeTradeLog(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.payout_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fee_recipient_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.position_delta_)*/nullptr} {}
struct DerivativeTradeLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeTradeLogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeTradeLogDefaultTypeInternal() {}
  union {
    DerivativeTradeLog _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeTradeLogDefaultTypeInternal _DerivativeTradeLog_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountPosition::SubaccountPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.position_)*/nullptr} {}
struct SubaccountPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountPositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountPositionDefaultTypeInternal() {}
  union {
    SubaccountPosition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountPositionDefaultTypeInternal _SubaccountPosition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountDeposit::SubaccountDeposit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deposit_)*/nullptr} {}
struct SubaccountDepositDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountDepositDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountDepositDefaultTypeInternal() {}
  union {
    SubaccountDeposit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountDepositDefaultTypeInternal _SubaccountDeposit_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DepositUpdate::DepositUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.deposits_)*/{}
  , /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DepositUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DepositUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DepositUpdateDefaultTypeInternal() {}
  union {
    DepositUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DepositUpdateDefaultTypeInternal _DepositUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointsMultiplier::PointsMultiplier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.maker_points_multiplier_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.taker_points_multiplier_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointsMultiplierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointsMultiplierDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointsMultiplierDefaultTypeInternal() {}
  union {
    PointsMultiplier _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointsMultiplierDefaultTypeInternal _PointsMultiplier_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradingRewardCampaignBoostInfo::TradingRewardCampaignBoostInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.boosted_spot_market_ids_)*/{}
  , /*decltype(_impl_.spot_market_multipliers_)*/{}
  , /*decltype(_impl_.boosted_derivative_market_ids_)*/{}
  , /*decltype(_impl_.derivative_market_multipliers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TradingRewardCampaignBoostInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradingRewardCampaignBoostInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradingRewardCampaignBoostInfoDefaultTypeInternal() {}
  union {
    TradingRewardCampaignBoostInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradingRewardCampaignBoostInfoDefaultTypeInternal _TradingRewardCampaignBoostInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CampaignRewardPool::CampaignRewardPool(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.max_campaign_rewards_)*/{}
  , /*decltype(_impl_.start_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CampaignRewardPoolDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CampaignRewardPoolDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CampaignRewardPoolDefaultTypeInternal() {}
  union {
    CampaignRewardPool _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CampaignRewardPoolDefaultTypeInternal _CampaignRewardPool_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradingRewardCampaignInfo::TradingRewardCampaignInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.quote_denoms_)*/{}
  , /*decltype(_impl_.disqualified_market_ids_)*/{}
  , /*decltype(_impl_.trading_reward_boost_info_)*/nullptr
  , /*decltype(_impl_.campaign_duration_seconds_)*/ ::int64_t{0}
} {}
struct TradingRewardCampaignInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradingRewardCampaignInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradingRewardCampaignInfoDefaultTypeInternal() {}
  union {
    TradingRewardCampaignInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradingRewardCampaignInfoDefaultTypeInternal _TradingRewardCampaignInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeeDiscountTierInfo::FeeDiscountTierInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.maker_discount_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.taker_discount_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.staked_amount_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.volume_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeDiscountTierInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeDiscountTierInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeDiscountTierInfoDefaultTypeInternal() {}
  union {
    FeeDiscountTierInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeDiscountTierInfoDefaultTypeInternal _FeeDiscountTierInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeeDiscountSchedule::FeeDiscountSchedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.quote_denoms_)*/{}
  , /*decltype(_impl_.tier_infos_)*/{}
  , /*decltype(_impl_.disqualified_market_ids_)*/{}
  , /*decltype(_impl_.bucket_count_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.bucket_duration_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeDiscountScheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeDiscountScheduleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeDiscountScheduleDefaultTypeInternal() {}
  union {
    FeeDiscountSchedule _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeDiscountScheduleDefaultTypeInternal _FeeDiscountSchedule_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeeDiscountTierTTL::FeeDiscountTierTTL(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tier_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ttl_timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeeDiscountTierTTLDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeeDiscountTierTTLDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeeDiscountTierTTLDefaultTypeInternal() {}
  union {
    FeeDiscountTierTTL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeeDiscountTierTTLDefaultTypeInternal _FeeDiscountTierTTL_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR VolumeRecord::VolumeRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.maker_volume_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.taker_volume_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VolumeRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeRecordDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeRecordDefaultTypeInternal() {}
  union {
    VolumeRecord _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeRecordDefaultTypeInternal _VolumeRecord_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AccountRewards::AccountRewards(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rewards_)*/{}
  , /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountRewardsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountRewardsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountRewardsDefaultTypeInternal() {}
  union {
    AccountRewards _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountRewardsDefaultTypeInternal _AccountRewards_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradeRecords::TradeRecords(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.latest_trade_records_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TradeRecordsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeRecordsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeRecordsDefaultTypeInternal() {}
  union {
    TradeRecords _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeRecordsDefaultTypeInternal _TradeRecords_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountIDs::SubaccountIDs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccount_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountIDsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountIDsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountIDsDefaultTypeInternal() {}
  union {
    SubaccountIDs _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountIDsDefaultTypeInternal _SubaccountIDs_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TradeRecord::TradeRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TradeRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeRecordDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeRecordDefaultTypeInternal() {}
  union {
    TradeRecord _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeRecordDefaultTypeInternal _TradeRecord_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Level::Level(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.p_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.q_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LevelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LevelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LevelDefaultTypeInternal() {}
  union {
    Level _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LevelDefaultTypeInternal _Level_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AggregateSubaccountVolumeRecord::AggregateSubaccountVolumeRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_volumes_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AggregateSubaccountVolumeRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AggregateSubaccountVolumeRecordDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AggregateSubaccountVolumeRecordDefaultTypeInternal() {}
  union {
    AggregateSubaccountVolumeRecord _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AggregateSubaccountVolumeRecordDefaultTypeInternal _AggregateSubaccountVolumeRecord_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AggregateAccountVolumeRecord::AggregateAccountVolumeRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_volumes_)*/{}
  , /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AggregateAccountVolumeRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AggregateAccountVolumeRecordDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AggregateAccountVolumeRecordDefaultTypeInternal() {}
  union {
    AggregateAccountVolumeRecord _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AggregateAccountVolumeRecordDefaultTypeInternal _AggregateAccountVolumeRecord_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MarketVolume::MarketVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.volume_)*/nullptr} {}
struct MarketVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarketVolumeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarketVolumeDefaultTypeInternal() {}
  union {
    MarketVolume _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarketVolumeDefaultTypeInternal _MarketVolume_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DenomDecimals::DenomDecimals(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.decimals_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DenomDecimalsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DenomDecimalsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DenomDecimalsDefaultTypeInternal() {}
  union {
    DenomDecimals _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DenomDecimalsDefaultTypeInternal _DenomDecimals_default_instance_;
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
static ::_pb::Metadata file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[48];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto = nullptr;
const ::uint32_t TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.spot_market_instant_listing_fee_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.derivative_market_instant_listing_fee_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_spot_maker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_spot_taker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_derivative_maker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_derivative_taker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_initial_margin_ratio_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_maintenance_margin_ratio_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_funding_interval_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.funding_multiple_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.relayer_fee_share_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_hourly_funding_rate_cap_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.default_hourly_interest_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.max_derivative_order_side_count_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.inj_reward_staked_requirement_threshold_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.trading_rewards_vesting_duration_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.liquidator_reward_share_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.binary_options_market_instant_listing_fee_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.atomic_market_order_access_level_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.spot_atomic_market_order_fee_multiplier_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.derivative_atomic_market_order_fee_multiplier_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.binary_options_atomic_market_order_fee_multiplier_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.minimal_protocol_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Params, _impl_.is_instant_derivative_market_launch_enabled_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketFeeMultiplier, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketFeeMultiplier, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketFeeMultiplier, _impl_.fee_multiplier_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.ticker_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.oracle_base_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.oracle_quote_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.oracle_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.oracle_scale_factor_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.quote_denom_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.initial_margin_ratio_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.maintenance_margin_ratio_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.maker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.taker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.relayer_fee_share_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.isperpetual_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.min_price_tick_size_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarket, _impl_.min_quantity_tick_size_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.ticker_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.oracle_symbol_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.oracle_provider_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.oracle_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.oracle_scale_factor_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.expiration_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.settlement_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.admin_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.quote_denom_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.maker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.taker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.relayer_fee_share_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.min_price_tick_size_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.min_quantity_tick_size_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::BinaryOptionsMarket, _impl_.settlement_price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo, _impl_.expiration_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo, _impl_.twap_start_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo, _impl_.expiration_twap_start_price_cumulative_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo, _impl_.settlement_price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketInfo, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketInfo, _impl_.hourly_funding_rate_cap_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketInfo, _impl_.hourly_interest_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketInfo, _impl_.next_funding_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketInfo, _impl_.funding_interval_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFunding, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFunding, _impl_.cumulative_funding_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFunding, _impl_.cumulative_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PerpetualMarketFunding, _impl_.last_timestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketSettlementInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketSettlementInfo, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketSettlementInfo, _impl_.settlement_price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::NextFundingTimestamp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::NextFundingTimestamp, _impl_.next_timestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MidPriceAndTOB, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MidPriceAndTOB, _impl_.mid_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MidPriceAndTOB, _impl_.best_buy_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MidPriceAndTOB, _impl_.best_sell_price_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.ticker_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.base_denom_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.quote_denom_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.maker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.taker_fee_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.relayer_fee_share_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.min_price_tick_size_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarket, _impl_.min_quantity_tick_size_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Deposit, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Deposit, _impl_.available_balance_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Deposit, _impl_.total_balance_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountTradeNonce, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountTradeNonce, _impl_.nonce_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderInfo, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderInfo, _impl_.fee_recipient_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderInfo, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderInfo, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrder, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrder, _impl_.order_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrder, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotOrder, _impl_.trigger_price_),
    ~0u,
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotLimitOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotLimitOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotLimitOrder, _impl_.order_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotLimitOrder, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotLimitOrder, _impl_.fillable_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotLimitOrder, _impl_.trigger_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotLimitOrder, _impl_.order_hash_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarketOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarketOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarketOrder, _impl_.order_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarketOrder, _impl_.balance_hold_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarketOrder, _impl_.order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarketOrder, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SpotMarketOrder, _impl_.trigger_price_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrder, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrder, _impl_.order_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrder, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrder, _impl_.margin_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeOrder, _impl_.trigger_price_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderbookMetadata, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderbookMetadata, _impl_.vanilla_limit_order_count_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderbookMetadata, _impl_.reduce_only_limit_order_count_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderbookMetadata, _impl_.aggregate_reduce_only_quantity_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderbookMetadata, _impl_.aggregate_vanilla_quantity_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderbookMetadata, _impl_.vanilla_conditional_order_count_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderbookMetadata, _impl_.reduce_only_conditional_order_count_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrder, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrder, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrder, _impl_.isreduceonly_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderData, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountOrderData, _impl_.order_hash_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _impl_.order_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _impl_.margin_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _impl_.fillable_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _impl_.trigger_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeLimitOrder, _impl_.order_hash_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _impl_.order_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _impl_.margin_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _impl_.margin_hold_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _impl_.trigger_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrder, _impl_.order_hash_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Position, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Position, _impl_.islong_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Position, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Position, _impl_.entry_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Position, _impl_.margin_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Position, _impl_.cumulative_funding_entry_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketOrderIndicator, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketOrderIndicator, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketOrderIndicator, _impl_.isbuy_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeLog, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeLog, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeLog, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeLog, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeLog, _impl_.fee_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeLog, _impl_.order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeLog, _impl_.fee_recipient_address_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PositionDelta, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PositionDelta, _impl_.is_long_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PositionDelta, _impl_.execution_quantity_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PositionDelta, _impl_.execution_margin_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PositionDelta, _impl_.execution_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _impl_.position_delta_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _impl_.payout_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _impl_.fee_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _impl_.order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeTradeLog, _impl_.fee_recipient_address_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountPosition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountPosition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountPosition, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountPosition, _impl_.subaccount_id_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountDeposit, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountDeposit, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountDeposit, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountDeposit, _impl_.deposit_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DepositUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DepositUpdate, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DepositUpdate, _impl_.deposits_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PointsMultiplier, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PointsMultiplier, _impl_.maker_points_multiplier_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::PointsMultiplier, _impl_.taker_points_multiplier_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo, _impl_.boosted_spot_market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo, _impl_.spot_market_multipliers_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo, _impl_.boosted_derivative_market_ids_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo, _impl_.derivative_market_multipliers_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::CampaignRewardPool, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::CampaignRewardPool, _impl_.start_timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::CampaignRewardPool, _impl_.max_campaign_rewards_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignInfo, _impl_.campaign_duration_seconds_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignInfo, _impl_.quote_denoms_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignInfo, _impl_.trading_reward_boost_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradingRewardCampaignInfo, _impl_.disqualified_market_ids_),
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierInfo, _impl_.maker_discount_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierInfo, _impl_.taker_discount_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierInfo, _impl_.staked_amount_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierInfo, _impl_.volume_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountSchedule, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountSchedule, _impl_.bucket_count_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountSchedule, _impl_.bucket_duration_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountSchedule, _impl_.quote_denoms_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountSchedule, _impl_.tier_infos_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountSchedule, _impl_.disqualified_market_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierTTL, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierTTL, _impl_.tier_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::FeeDiscountTierTTL, _impl_.ttl_timestamp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::VolumeRecord, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::VolumeRecord, _impl_.maker_volume_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::VolumeRecord, _impl_.taker_volume_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AccountRewards, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AccountRewards, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AccountRewards, _impl_.rewards_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeRecords, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeRecords, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeRecords, _impl_.latest_trade_records_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountIDs, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::SubaccountIDs, _impl_.subaccount_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeRecord, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeRecord, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeRecord, _impl_.price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::TradeRecord, _impl_.quantity_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Level, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Level, _impl_.p_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Level, _impl_.q_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord, _impl_.market_volumes_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AggregateAccountVolumeRecord, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AggregateAccountVolumeRecord, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::AggregateAccountVolumeRecord, _impl_.market_volumes_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketVolume, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketVolume, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketVolume, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::MarketVolume, _impl_.volume_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DenomDecimals, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DenomDecimals, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DenomDecimals, _impl_.decimals_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 32, -1, sizeof(::injective::exchange::v1beta1::Params)},
        { 56, -1, -1, sizeof(::injective::exchange::v1beta1::MarketFeeMultiplier)},
        { 66, -1, -1, sizeof(::injective::exchange::v1beta1::DerivativeMarket)},
        { 90, -1, -1, sizeof(::injective::exchange::v1beta1::BinaryOptionsMarket)},
        { 115, -1, -1, sizeof(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo)},
        { 128, -1, -1, sizeof(::injective::exchange::v1beta1::PerpetualMarketInfo)},
        { 141, -1, -1, sizeof(::injective::exchange::v1beta1::PerpetualMarketFunding)},
        { 152, -1, -1, sizeof(::injective::exchange::v1beta1::DerivativeMarketSettlementInfo)},
        { 162, -1, -1, sizeof(::injective::exchange::v1beta1::NextFundingTimestamp)},
        { 171, -1, -1, sizeof(::injective::exchange::v1beta1::MidPriceAndTOB)},
        { 182, -1, -1, sizeof(::injective::exchange::v1beta1::SpotMarket)},
        { 200, -1, -1, sizeof(::injective::exchange::v1beta1::Deposit)},
        { 210, -1, -1, sizeof(::injective::exchange::v1beta1::SubaccountTradeNonce)},
        { 219, -1, -1, sizeof(::injective::exchange::v1beta1::OrderInfo)},
        { 231, 243, -1, sizeof(::injective::exchange::v1beta1::SpotOrder)},
        { 247, 260, -1, sizeof(::injective::exchange::v1beta1::SpotLimitOrder)},
        { 265, 278, -1, sizeof(::injective::exchange::v1beta1::SpotMarketOrder)},
        { 283, 296, -1, sizeof(::injective::exchange::v1beta1::DerivativeOrder)},
        { 301, -1, -1, sizeof(::injective::exchange::v1beta1::SubaccountOrderbookMetadata)},
        { 315, -1, -1, sizeof(::injective::exchange::v1beta1::SubaccountOrder)},
        { 326, 336, -1, sizeof(::injective::exchange::v1beta1::SubaccountOrderData)},
        { 338, 352, -1, sizeof(::injective::exchange::v1beta1::DerivativeLimitOrder)},
        { 358, 372, -1, sizeof(::injective::exchange::v1beta1::DerivativeMarketOrder)},
        { 378, -1, -1, sizeof(::injective::exchange::v1beta1::Position)},
        { 391, -1, -1, sizeof(::injective::exchange::v1beta1::MarketOrderIndicator)},
        { 401, -1, -1, sizeof(::injective::exchange::v1beta1::TradeLog)},
        { 415, -1, -1, sizeof(::injective::exchange::v1beta1::PositionDelta)},
        { 427, 441, -1, sizeof(::injective::exchange::v1beta1::DerivativeTradeLog)},
        { 447, 457, -1, sizeof(::injective::exchange::v1beta1::SubaccountPosition)},
        { 459, 469, -1, sizeof(::injective::exchange::v1beta1::SubaccountDeposit)},
        { 471, -1, -1, sizeof(::injective::exchange::v1beta1::DepositUpdate)},
        { 481, -1, -1, sizeof(::injective::exchange::v1beta1::PointsMultiplier)},
        { 491, -1, -1, sizeof(::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo)},
        { 503, -1, -1, sizeof(::injective::exchange::v1beta1::CampaignRewardPool)},
        { 513, 525, -1, sizeof(::injective::exchange::v1beta1::TradingRewardCampaignInfo)},
        { 529, -1, -1, sizeof(::injective::exchange::v1beta1::FeeDiscountTierInfo)},
        { 541, -1, -1, sizeof(::injective::exchange::v1beta1::FeeDiscountSchedule)},
        { 554, -1, -1, sizeof(::injective::exchange::v1beta1::FeeDiscountTierTTL)},
        { 564, -1, -1, sizeof(::injective::exchange::v1beta1::VolumeRecord)},
        { 574, -1, -1, sizeof(::injective::exchange::v1beta1::AccountRewards)},
        { 584, -1, -1, sizeof(::injective::exchange::v1beta1::TradeRecords)},
        { 594, -1, -1, sizeof(::injective::exchange::v1beta1::SubaccountIDs)},
        { 603, -1, -1, sizeof(::injective::exchange::v1beta1::TradeRecord)},
        { 614, -1, -1, sizeof(::injective::exchange::v1beta1::Level)},
        { 624, -1, -1, sizeof(::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord)},
        { 634, -1, -1, sizeof(::injective::exchange::v1beta1::AggregateAccountVolumeRecord)},
        { 644, 654, -1, sizeof(::injective::exchange::v1beta1::MarketVolume)},
        { 656, -1, -1, sizeof(::injective::exchange::v1beta1::DenomDecimals)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::injective::exchange::v1beta1::_Params_default_instance_._instance,
    &::injective::exchange::v1beta1::_MarketFeeMultiplier_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeMarket_default_instance_._instance,
    &::injective::exchange::v1beta1::_BinaryOptionsMarket_default_instance_._instance,
    &::injective::exchange::v1beta1::_ExpiryFuturesMarketInfo_default_instance_._instance,
    &::injective::exchange::v1beta1::_PerpetualMarketInfo_default_instance_._instance,
    &::injective::exchange::v1beta1::_PerpetualMarketFunding_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeMarketSettlementInfo_default_instance_._instance,
    &::injective::exchange::v1beta1::_NextFundingTimestamp_default_instance_._instance,
    &::injective::exchange::v1beta1::_MidPriceAndTOB_default_instance_._instance,
    &::injective::exchange::v1beta1::_SpotMarket_default_instance_._instance,
    &::injective::exchange::v1beta1::_Deposit_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountTradeNonce_default_instance_._instance,
    &::injective::exchange::v1beta1::_OrderInfo_default_instance_._instance,
    &::injective::exchange::v1beta1::_SpotOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_SpotLimitOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_SpotMarketOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountOrderbookMetadata_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountOrderData_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeLimitOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeMarketOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_Position_default_instance_._instance,
    &::injective::exchange::v1beta1::_MarketOrderIndicator_default_instance_._instance,
    &::injective::exchange::v1beta1::_TradeLog_default_instance_._instance,
    &::injective::exchange::v1beta1::_PositionDelta_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeTradeLog_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountPosition_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountDeposit_default_instance_._instance,
    &::injective::exchange::v1beta1::_DepositUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_PointsMultiplier_default_instance_._instance,
    &::injective::exchange::v1beta1::_TradingRewardCampaignBoostInfo_default_instance_._instance,
    &::injective::exchange::v1beta1::_CampaignRewardPool_default_instance_._instance,
    &::injective::exchange::v1beta1::_TradingRewardCampaignInfo_default_instance_._instance,
    &::injective::exchange::v1beta1::_FeeDiscountTierInfo_default_instance_._instance,
    &::injective::exchange::v1beta1::_FeeDiscountSchedule_default_instance_._instance,
    &::injective::exchange::v1beta1::_FeeDiscountTierTTL_default_instance_._instance,
    &::injective::exchange::v1beta1::_VolumeRecord_default_instance_._instance,
    &::injective::exchange::v1beta1::_AccountRewards_default_instance_._instance,
    &::injective::exchange::v1beta1::_TradeRecords_default_instance_._instance,
    &::injective::exchange::v1beta1::_SubaccountIDs_default_instance_._instance,
    &::injective::exchange::v1beta1::_TradeRecord_default_instance_._instance,
    &::injective::exchange::v1beta1::_Level_default_instance_._instance,
    &::injective::exchange::v1beta1::_AggregateSubaccountVolumeRecord_default_instance_._instance,
    &::injective::exchange::v1beta1::_AggregateAccountVolumeRecord_default_instance_._instance,
    &::injective::exchange::v1beta1::_MarketVolume_default_instance_._instance,
    &::injective::exchange::v1beta1::_DenomDecimals_default_instance_._instance,
};
const char descriptor_table_protodef_injective_2fexchange_2fv1beta1_2fexchange_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n)injective/exchange/v1beta1/exchange.pr"
    "oto\022\032injective.exchange.v1beta1\032\024gogopro"
    "to/gogo.proto\032\036cosmos/base/v1beta1/coin."
    "proto\032%injective/oracle/v1beta1/oracle.p"
    "roto\"\320\024\n\006Params\022e\n\037spot_market_instant_l"
    "isting_fee\030\001 \001(\0132\031.cosmos.base.v1beta1.C"
    "oinB\004\310\336\037\000R\033spotMarketInstantListingFee\022q"
    "\n%derivative_market_instant_listing_fee\030"
    "\002 \001(\0132\031.cosmos.base.v1beta1.CoinB\004\310\336\037\000R!"
    "derivativeMarketInstantListingFee\022l\n\033def"
    "ault_spot_maker_fee_rate\030\003 \001(\tB.\310\336\037\000\332\336\037&"
    "github.com/cosmos/cosmos-sdk/types.DecR\027"
    "defaultSpotMakerFeeRate\022l\n\033default_spot_"
    "taker_fee_rate\030\004 \001(\tB.\310\336\037\000\332\336\037&github.com"
    "/cosmos/cosmos-sdk/types.DecR\027defaultSpo"
    "tTakerFeeRate\022x\n!default_derivative_make"
    "r_fee_rate\030\005 \001(\tB.\310\336\037\000\332\336\037&github.com/cos"
    "mos/cosmos-sdk/types.DecR\035defaultDerivat"
    "iveMakerFeeRate\022x\n!default_derivative_ta"
    "ker_fee_rate\030\006 \001(\tB.\310\336\037\000\332\336\037&github.com/c"
    "osmos/cosmos-sdk/types.DecR\035defaultDeriv"
    "ativeTakerFeeRate\022o\n\034default_initial_mar"
    "gin_ratio\030\007 \001(\tB.\310\336\037\000\332\336\037&github.com/cosm"
    "os/cosmos-sdk/types.DecR\031defaultInitialM"
    "arginRatio\022w\n default_maintenance_margin"
    "_ratio\030\010 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/"
    "cosmos-sdk/types.DecR\035defaultMaintenance"
    "MarginRatio\0228\n\030default_funding_interval\030"
    "\t \001(\003R\026defaultFundingInterval\022)\n\020funding"
    "_multiple\030\n \001(\003R\017fundingMultiple\022c\n\026rela"
    "yer_fee_share_rate\030\013 \001(\tB.\310\336\037\000\332\336\037&github"
    ".com/cosmos/cosmos-sdk/types.DecR\023relaye"
    "rFeeShareRate\022t\n\037default_hourly_funding_"
    "rate_cap\030\014 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmo"
    "s/cosmos-sdk/types.DecR\033defaultHourlyFun"
    "dingRateCap\022o\n\034default_hourly_interest_r"
    "ate\030\r \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cos"
    "mos-sdk/types.DecR\031defaultHourlyInterest"
    "Rate\022D\n\037max_derivative_order_side_count\030"
    "\016 \001(\rR\033maxDerivativeOrderSideCount\022\204\001\n\'i"
    "nj_reward_staked_requirement_threshold\030\017"
    " \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-s"
    "dk/types.IntR#injRewardStakedRequirement"
    "Threshold\022G\n trading_rewards_vesting_dur"
    "ation\030\020 \001(\003R\035tradingRewardsVestingDurati"
    "on\022o\n\034liquidator_reward_share_rate\030\021 \001(\t"
    "B.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/t"
    "ypes.DecR\031liquidatorRewardShareRate\022x\n)b"
    "inary_options_market_instant_listing_fee"
    "\030\022 \001(\0132\031.cosmos.base.v1beta1.CoinB\004\310\336\037\000R"
    "$binaryOptionsMarketInstantListingFee\022\200\001"
    "\n atomic_market_order_access_level\030\023 \001(\016"
    "28.injective.exchange.v1beta1.AtomicMark"
    "etOrderAccessLevelR\034atomicMarketOrderAcc"
    "essLevel\022\203\001\n\'spot_atomic_market_order_fe"
    "e_multiplier\030\024 \001(\tB.\310\336\037\000\332\336\037&github.com/c"
    "osmos/cosmos-sdk/types.DecR\"spotAtomicMa"
    "rketOrderFeeMultiplier\022\217\001\n-derivative_at"
    "omic_market_order_fee_multiplier\030\025 \001(\tB."
    "\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/typ"
    "es.DecR(derivativeAtomicMarketOrderFeeMu"
    "ltiplier\022\226\001\n1binary_options_atomic_marke"
    "t_order_fee_multiplier\030\026 \001(\tB.\310\336\037\000\332\336\037&gi"
    "thub.com/cosmos/cosmos-sdk/types.DecR+bi"
    "naryOptionsAtomicMarketOrderFeeMultiplie"
    "r\022i\n\031minimal_protocol_fee_rate\030\027 \001(\tB.\310\336"
    "\037\000\332\336\037&github.com/cosmos/cosmos-sdk/types"
    ".DecR\026minimalProtocolFeeRate\022[\n+is_insta"
    "nt_derivative_market_launch_enabled\030\030 \001("
    "\010R&isInstantDerivativeMarketLaunchEnable"
    "d:\004\350\240\037\001\"\217\001\n\023MarketFeeMultiplier\022\033\n\tmarke"
    "t_id\030\001 \001(\tR\010marketId\022U\n\016fee_multiplier\030\002"
    " \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-s"
    "dk/types.DecR\rfeeMultiplier:\004\210\240\037\000\"\256\010\n\020De"
    "rivativeMarket\022\026\n\006ticker\030\001 \001(\tR\006ticker\022\037"
    "\n\013oracle_base\030\002 \001(\tR\noracleBase\022!\n\014oracl"
    "e_quote\030\003 \001(\tR\013oracleQuote\022E\n\013oracle_typ"
    "e\030\004 \001(\0162$.injective.oracle.v1beta1.Oracl"
    "eTypeR\noracleType\022.\n\023oracle_scale_factor"
    "\030\005 \001(\rR\021oracleScaleFactor\022\037\n\013quote_denom"
    "\030\006 \001(\tR\nquoteDenom\022\033\n\tmarket_id\030\007 \001(\tR\010m"
    "arketId\022`\n\024initial_margin_ratio\030\010 \001(\tB.\310"
    "\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/type"
    "s.DecR\022initialMarginRatio\022h\n\030maintenance"
    "_margin_ratio\030\t \001(\tB.\310\336\037\000\332\336\037&github.com/"
    "cosmos/cosmos-sdk/types.DecR\026maintenance"
    "MarginRatio\022T\n\016maker_fee_rate\030\n \001(\tB.\310\336\037"
    "\000\332\336\037&github.com/cosmos/cosmos-sdk/types."
    "DecR\014makerFeeRate\022T\n\016taker_fee_rate\030\013 \001("
    "\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/"
    "types.DecR\014takerFeeRate\022c\n\026relayer_fee_s"
    "hare_rate\030\014 \001(\tB.\310\336\037\000\332\336\037&github.com/cosm"
    "os/cosmos-sdk/types.DecR\023relayerFeeShare"
    "Rate\022 \n\013isPerpetual\030\r \001(\010R\013isPerpetual\022@"
    "\n\006status\030\016 \001(\0162(.injective.exchange.v1be"
    "ta1.MarketStatusR\006status\022]\n\023min_price_ti"
    "ck_size\030\017 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos"
    "/cosmos-sdk/types.DecR\020minPriceTickSize\022"
    "c\n\026min_quantity_tick_size\030\020 \001(\tB.\310\336\037\000\332\336\037"
    "&github.com/cosmos/cosmos-sdk/types.DecR"
    "\023minQuantityTickSize:\004\210\240\037\000\"\244\010\n\023BinaryOpt"
    "ionsMarket\022\026\n\006ticker\030\001 \001(\tR\006ticker\022#\n\ror"
    "acle_symbol\030\002 \001(\tR\014oracleSymbol\022\'\n\017oracl"
    "e_provider\030\003 \001(\tR\016oracleProvider\022E\n\013orac"
    "le_type\030\004 \001(\0162$.injective.oracle.v1beta1"
    ".OracleTypeR\noracleType\022.\n\023oracle_scale_"
    "factor\030\005 \001(\rR\021oracleScaleFactor\0221\n\024expir"
    "ation_timestamp\030\006 \001(\003R\023expirationTimesta"
    "mp\0221\n\024settlement_timestamp\030\007 \001(\003R\023settle"
    "mentTimestamp\022\024\n\005admin\030\010 \001(\tR\005admin\022\037\n\013q"
    "uote_denom\030\t \001(\tR\nquoteDenom\022\033\n\tmarket_i"
    "d\030\n \001(\tR\010marketId\022T\n\016maker_fee_rate\030\013 \001("
    "\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/"
    "types.DecR\014makerFeeRate\022T\n\016taker_fee_rat"
    "e\030\014 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmo"
    "s-sdk/types.DecR\014takerFeeRate\022c\n\026relayer"
    "_fee_share_rate\030\r \001(\tB.\310\336\037\000\332\336\037&github.co"
    "m/cosmos/cosmos-sdk/types.DecR\023relayerFe"
    "eShareRate\022@\n\006status\030\016 \001(\0162(.injective.e"
    "xchange.v1beta1.MarketStatusR\006status\022]\n\023"
    "min_price_tick_size\030\017 \001(\tB.\310\336\037\000\332\336\037&githu"
    "b.com/cosmos/cosmos-sdk/types.DecR\020minPr"
    "iceTickSize\022c\n\026min_quantity_tick_size\030\020 "
    "\001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sd"
    "k/types.DecR\023minQuantityTickSize\022Y\n\020sett"
    "lement_price\030\021 \001(\tB.\310\336\037\001\332\336\037&github.com/c"
    "osmos/cosmos-sdk/types.DecR\017settlementPr"
    "ice:\004\210\240\037\000\"\373\002\n\027ExpiryFuturesMarketInfo\022\033\n"
    "\tmarket_id\030\001 \001(\tR\010marketId\0221\n\024expiration"
    "_timestamp\030\002 \001(\003R\023expirationTimestamp\0220\n"
    "\024twap_start_timestamp\030\003 \001(\003R\022twapStartTi"
    "mestamp\022\202\001\n&expiration_twap_start_price_"
    "cumulative\030\004 \001(\tB.\310\336\037\000\332\336\037&github.com/cos"
    "mos/cosmos-sdk/types.DecR\"expirationTwap"
    "StartPriceCumulative\022Y\n\020settlement_price"
    "\030\005 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos"
    "-sdk/types.DecR\017settlementPrice\"\334\002\n\023Perp"
    "etualMarketInfo\022\033\n\tmarket_id\030\001 \001(\tR\010mark"
    "etId\022e\n\027hourly_funding_rate_cap\030\002 \001(\tB.\310"
    "\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/type"
    "s.DecR\024hourlyFundingRateCap\022`\n\024hourly_in"
    "terest_rate\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/co"
    "smos/cosmos-sdk/types.DecR\022hourlyInteres"
    "tRate\0224\n\026next_funding_timestamp\030\004 \001(\003R\024n"
    "extFundingTimestamp\022)\n\020funding_interval\030"
    "\005 \001(\003R\017fundingInterval\"\371\001\n\026PerpetualMark"
    "etFunding\022]\n\022cumulative_funding\030\001 \001(\tB.\310"
    "\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/type"
    "s.DecR\021cumulativeFunding\022Y\n\020cumulative_p"
    "rice\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/co"
    "smos-sdk/types.DecR\017cumulativePrice\022%\n\016l"
    "ast_timestamp\030\003 \001(\003R\rlastTimestamp\"\230\001\n\036D"
    "erivativeMarketSettlementInfo\022\033\n\tmarket_"
    "id\030\001 \001(\tR\010marketId\022Y\n\020settlement_price\030\002"
    " \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-s"
    "dk/types.DecR\017settlementPrice\"=\n\024NextFun"
    "dingTimestamp\022%\n\016next_timestamp\030\001 \001(\003R\rn"
    "extTimestamp\"\213\002\n\016MidPriceAndTOB\022K\n\tmid_p"
    "rice\030\001 \001(\tB.\310\336\037\001\332\336\037&github.com/cosmos/co"
    "smos-sdk/types.DecR\010midPrice\022T\n\016best_buy"
    "_price\030\002 \001(\tB.\310\336\037\001\332\336\037&github.com/cosmos/"
    "cosmos-sdk/types.DecR\014bestBuyPrice\022V\n\017be"
    "st_sell_price\030\003 \001(\tB.\310\336\037\001\332\336\037&github.com/"
    "cosmos/cosmos-sdk/types.DecR\rbestSellPri"
    "ce\"\230\005\n\nSpotMarket\022\026\n\006ticker\030\001 \001(\tR\006ticke"
    "r\022\035\n\nbase_denom\030\002 \001(\tR\tbaseDenom\022\037\n\013quot"
    "e_denom\030\003 \001(\tR\nquoteDenom\022T\n\016maker_fee_r"
    "ate\030\004 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cos"
    "mos-sdk/types.DecR\014makerFeeRate\022T\n\016taker"
    "_fee_rate\030\005 \001(\tB.\310\336\037\000\332\336\037&github.com/cosm"
    "os/cosmos-sdk/types.DecR\014takerFeeRate\022c\n"
    "\026relayer_fee_share_rate\030\006 \001(\tB.\310\336\037\000\332\336\037&g"
    "ithub.com/cosmos/cosmos-sdk/types.DecR\023r"
    "elayerFeeShareRate\022\033\n\tmarket_id\030\007 \001(\tR\010m"
    "arketId\022@\n\006status\030\010 \001(\0162(.injective.exch"
    "ange.v1beta1.MarketStatusR\006status\022]\n\023min"
    "_price_tick_size\030\t \001(\tB.\310\336\037\000\332\336\037&github.c"
    "om/cosmos/cosmos-sdk/types.DecR\020minPrice"
    "TickSize\022c\n\026min_quantity_tick_size\030\n \001(\t"
    "B.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/t"
    "ypes.DecR\023minQuantityTickSize\"\273\001\n\007Deposi"
    "t\022[\n\021available_balance\030\001 \001(\tB.\310\336\037\000\332\336\037&gi"
    "thub.com/cosmos/cosmos-sdk/types.DecR\020av"
    "ailableBalance\022S\n\rtotal_balance\030\002 \001(\tB.\310"
    "\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/type"
    "s.DecR\014totalBalance\",\n\024SubaccountTradeNo"
    "nce\022\024\n\005nonce\030\001 \001(\rR\005nonce\"\347\001\n\tOrderInfo\022"
    "#\n\rsubaccount_id\030\001 \001(\tR\014subaccountId\022#\n\r"
    "fee_recipient\030\002 \001(\tR\014feeRecipient\022D\n\005pri"
    "ce\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosm"
    "os-sdk/types.DecR\005price\022J\n\010quantity\030\004 \001("
    "\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/"
    "types.DecR\010quantity\"\217\002\n\tSpotOrder\022\033\n\tmar"
    "ket_id\030\001 \001(\tR\010marketId\022J\n\norder_info\030\002 \001"
    "(\0132%.injective.exchange.v1beta1.OrderInf"
    "oB\004\310\336\037\000R\torderInfo\022D\n\norder_type\030\003 \001(\0162%"
    ".injective.exchange.v1beta1.OrderTypeR\to"
    "rderType\022S\n\rtrigger_price\030\004 \001(\tB.\310\336\037\001\332\336\037"
    "&github.com/cosmos/cosmos-sdk/types.DecR"
    "\014triggerPrice\"\342\002\n\016SpotLimitOrder\022J\n\norde"
    "r_info\030\001 \001(\0132%.injective.exchange.v1beta"
    "1.OrderInfoB\004\310\336\037\000R\torderInfo\022D\n\norder_ty"
    "pe\030\002 \001(\0162%.injective.exchange.v1beta1.Or"
    "derTypeR\torderType\022J\n\010fillable\030\003 \001(\tB.\310\336"
    "\037\000\332\336\037&github.com/cosmos/cosmos-sdk/types"
    ".DecR\010fillable\022S\n\rtrigger_price\030\004 \001(\tB.\310"
    "\336\037\001\332\336\037&github.com/cosmos/cosmos-sdk/type"
    "s.DecR\014triggerPrice\022\035\n\norder_hash\030\005 \001(\014R"
    "\torderHash\"\352\002\n\017SpotMarketOrder\022J\n\norder_"
    "info\030\001 \001(\0132%.injective.exchange.v1beta1."
    "OrderInfoB\004\310\336\037\000R\torderInfo\022Q\n\014balance_ho"
    "ld\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosm"
    "os-sdk/types.DecR\013balanceHold\022\035\n\norder_h"
    "ash\030\003 \001(\014R\torderHash\022D\n\norder_type\030\004 \001(\016"
    "2%.injective.exchange.v1beta1.OrderTypeR"
    "\torderType\022S\n\rtrigger_price\030\005 \001(\tB.\310\336\037\001\332"
    "\336\037&github.com/cosmos/cosmos-sdk/types.De"
    "cR\014triggerPrice\"\335\002\n\017DerivativeOrder\022\033\n\tm"
    "arket_id\030\001 \001(\tR\010marketId\022J\n\norder_info\030\002"
    " \001(\0132%.injective.exchange.v1beta1.OrderI"
    "nfoB\004\310\336\037\000R\torderInfo\022D\n\norder_type\030\003 \001(\016"
    "2%.injective.exchange.v1beta1.OrderTypeR"
    "\torderType\022F\n\006margin\030\004 \001(\tB.\310\336\037\000\332\336\037&gith"
    "ub.com/cosmos/cosmos-sdk/types.DecR\006marg"
    "in\022S\n\rtrigger_price\030\005 \001(\tB.\310\336\037\001\332\336\037&githu"
    "b.com/cosmos/cosmos-sdk/types.DecR\014trigg"
    "erPrice\"\222\004\n\033SubaccountOrderbookMetadata\022"
    "9\n\031vanilla_limit_order_count\030\001 \001(\rR\026vani"
    "llaLimitOrderCount\022@\n\035reduce_only_limit_"
    "order_count\030\002 \001(\rR\031reduceOnlyLimitOrderC"
    "ount\022s\n\036aggregate_reduce_only_quantity\030\003"
    " \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-s"
    "dk/types.DecR\033aggregateReduceOnlyQuantit"
    "y\022l\n\032aggregate_vanilla_quantity\030\004 \001(\tB.\310"
    "\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/type"
    "s.DecR\030aggregateVanillaQuantity\022E\n\037vanil"
    "la_conditional_order_count\030\005 \001(\rR\034vanill"
    "aConditionalOrderCount\022L\n#reduce_only_co"
    "nditional_order_count\030\006 \001(\rR\037reduceOnlyC"
    "onditionalOrderCount\"\307\001\n\017SubaccountOrder"
    "\022D\n\005price\030\001 \001(\tB.\310\336\037\000\332\336\037&github.com/cosm"
    "os/cosmos-sdk/types.DecR\005price\022J\n\010quanti"
    "ty\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosm"
    "os-sdk/types.DecR\010quantity\022\"\n\014isReduceOn"
    "ly\030\003 \001(\010R\014isReduceOnly\"w\n\023SubaccountOrde"
    "rData\022A\n\005order\030\001 \001(\0132+.injective.exchang"
    "e.v1beta1.SubaccountOrderR\005order\022\035\n\norde"
    "r_hash\030\002 \001(\014R\torderHash\"\260\003\n\024DerivativeLi"
    "mitOrder\022J\n\norder_info\030\001 \001(\0132%.injective"
    ".exchange.v1beta1.OrderInfoB\004\310\336\037\000R\torder"
    "Info\022D\n\norder_type\030\002 \001(\0162%.injective.exc"
    "hange.v1beta1.OrderTypeR\torderType\022F\n\006ma"
    "rgin\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/co"
    "smos-sdk/types.DecR\006margin\022J\n\010fillable\030\004"
    " \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-s"
    "dk/types.DecR\010fillable\022S\n\rtrigger_price\030"
    "\005 \001(\tB.\310\336\037\001\332\336\037&github.com/cosmos/cosmos-"
    "sdk/types.DecR\014triggerPrice\022\035\n\norder_has"
    "h\030\006 \001(\014R\torderHash\"\266\003\n\025DerivativeMarketO"
    "rder\022J\n\norder_info\030\001 \001(\0132%.injective.exc"
    "hange.v1beta1.OrderInfoB\004\310\336\037\000R\torderInfo"
    "\022D\n\norder_type\030\002 \001(\0162%.injective.exchang"
    "e.v1beta1.OrderTypeR\torderType\022F\n\006margin"
    "\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos"
    "-sdk/types.DecR\006margin\022O\n\013margin_hold\030\004 "
    "\001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sd"
    "k/types.DecR\nmarginHold\022S\n\rtrigger_price"
    "\030\005 \001(\tB.\310\336\037\001\332\336\037&github.com/cosmos/cosmos"
    "-sdk/types.DecR\014triggerPrice\022\035\n\norder_ha"
    "sh\030\006 \001(\014R\torderHash\"\361\002\n\010Position\022\026\n\006isLo"
    "ng\030\001 \001(\010R\006isLong\022J\n\010quantity\030\002 \001(\tB.\310\336\037\000"
    "\332\336\037&github.com/cosmos/cosmos-sdk/types.D"
    "ecR\010quantity\022O\n\013entry_price\030\003 \001(\tB.\310\336\037\000\332"
    "\336\037&github.com/cosmos/cosmos-sdk/types.De"
    "cR\nentryPrice\022F\n\006margin\030\004 \001(\tB.\310\336\037\000\332\336\037&g"
    "ithub.com/cosmos/cosmos-sdk/types.DecR\006m"
    "argin\022h\n\030cumulative_funding_entry\030\005 \001(\tB"
    ".\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/ty"
    "pes.DecR\026cumulativeFundingEntry\"I\n\024Marke"
    "tOrderIndicator\022\033\n\tmarket_id\030\001 \001(\tR\010mark"
    "etId\022\024\n\005isBuy\030\002 \001(\010R\005isBuy\"\334\002\n\010TradeLog\022"
    "J\n\010quantity\030\001 \001(\tB.\310\336\037\000\332\336\037&github.com/co"
    "smos/cosmos-sdk/types.DecR\010quantity\022D\n\005p"
    "rice\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/co"
    "smos-sdk/types.DecR\005price\022#\n\rsubaccount_"
    "id\030\003 \001(\014R\014subaccountId\022@\n\003fee\030\004 \001(\tB.\310\336\037"
    "\000\332\336\037&github.com/cosmos/cosmos-sdk/types."
    "DecR\003fee\022\035\n\norder_hash\030\005 \001(\014R\torderHash\022"
    "8\n\025fee_recipient_address\030\006 \001(\014B\004\310\336\037\001R\023fe"
    "eRecipientAddress\"\273\002\n\rPositionDelta\022\027\n\007i"
    "s_long\030\001 \001(\010R\006isLong\022]\n\022execution_quanti"
    "ty\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosm"
    "os-sdk/types.DecR\021executionQuantity\022Y\n\020e"
    "xecution_margin\030\003 \001(\tB.\310\336\037\000\332\336\037&github.co"
    "m/cosmos/cosmos-sdk/types.DecR\017execution"
    "Margin\022W\n\017execution_price\030\004 \001(\tB.\310\336\037\000\332\336\037"
    "&github.com/cosmos/cosmos-sdk/types.DecR"
    "\016executionPrice\"\356\002\n\022DerivativeTradeLog\022#"
    "\n\rsubaccount_id\030\001 \001(\014R\014subaccountId\022P\n\016p"
    "osition_delta\030\002 \001(\0132).injective.exchange"
    ".v1beta1.PositionDeltaR\rpositionDelta\022F\n"
    "\006payout\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos"
    "/cosmos-sdk/types.DecR\006payout\022@\n\003fee\030\004 \001"
    "(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk"
    "/types.DecR\003fee\022\035\n\norder_hash\030\005 \001(\014R\tord"
    "erHash\0228\n\025fee_recipient_address\030\006 \001(\014B\004\310"
    "\336\037\001R\023feeRecipientAddress\"{\n\022SubaccountPo"
    "sition\022@\n\010position\030\001 \001(\0132$.injective.exc"
    "hange.v1beta1.PositionR\010position\022#\n\rsuba"
    "ccount_id\030\002 \001(\014R\014subaccountId\"w\n\021Subacco"
    "untDeposit\022#\n\rsubaccount_id\030\001 \001(\014R\014subac"
    "countId\022=\n\007deposit\030\002 \001(\0132#.injective.exc"
    "hange.v1beta1.DepositR\007deposit\"p\n\rDeposi"
    "tUpdate\022\024\n\005denom\030\001 \001(\tR\005denom\022I\n\010deposit"
    "s\030\002 \003(\0132-.injective.exchange.v1beta1.Sub"
    "accountDepositR\010deposits\"\342\001\n\020PointsMulti"
    "plier\022f\n\027maker_points_multiplier\030\001 \001(\tB."
    "\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/typ"
    "es.DecR\025makerPointsMultiplier\022f\n\027taker_p"
    "oints_multiplier\030\002 \001(\tB.\310\336\037\000\332\336\037&github.c"
    "om/cosmos/cosmos-sdk/types.DecR\025takerPoi"
    "ntsMultiplier\"\376\002\n\036TradingRewardCampaignB"
    "oostInfo\0225\n\027boosted_spot_market_ids\030\001 \003("
    "\tR\024boostedSpotMarketIds\022j\n\027spot_market_m"
    "ultipliers\030\002 \003(\0132,.injective.exchange.v1"
    "beta1.PointsMultiplierB\004\310\336\037\000R\025spotMarket"
    "Multipliers\022A\n\035boosted_derivative_market"
    "_ids\030\003 \003(\tR\032boostedDerivativeMarketIds\022v"
    "\n\035derivative_market_multipliers\030\004 \003(\0132,."
    "injective.exchange.v1beta1.PointsMultipl"
    "ierB\004\310\336\037\000R\033derivativeMarketMultipliers\"\274"
    "\001\n\022CampaignRewardPool\022\'\n\017start_timestamp"
    "\030\001 \001(\003R\016startTimestamp\022}\n\024max_campaign_r"
    "ewards\030\002 \003(\0132\031.cosmos.base.v1beta1.CoinB"
    "0\310\336\037\000\252\337\037(github.com/cosmos/cosmos-sdk/ty"
    "pes.CoinsR\022maxCampaignRewards\"\251\002\n\031Tradin"
    "gRewardCampaignInfo\022:\n\031campaign_duration"
    "_seconds\030\001 \001(\003R\027campaignDurationSeconds\022"
    "!\n\014quote_denoms\030\002 \003(\tR\013quoteDenoms\022u\n\031tr"
    "ading_reward_boost_info\030\003 \001(\0132:.injectiv"
    "e.exchange.v1beta1.TradingRewardCampaign"
    "BoostInfoR\026tradingRewardBoostInfo\0226\n\027dis"
    "qualified_market_ids\030\004 \003(\tR\025disqualified"
    "MarketIds\"\362\002\n\023FeeDiscountTierInfo\022^\n\023mak"
    "er_discount_rate\030\001 \001(\tB.\310\336\037\000\332\336\037&github.c"
    "om/cosmos/cosmos-sdk/types.DecR\021makerDis"
    "countRate\022^\n\023taker_discount_rate\030\002 \001(\tB."
    "\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/typ"
    "es.DecR\021takerDiscountRate\022S\n\rstaked_amou"
    "nt\030\003 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosm"
    "os-sdk/types.IntR\014stakedAmount\022F\n\006volume"
    "\030\004 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/cosmos"
    "-sdk/types.DecR\006volume\"\214\002\n\023FeeDiscountSc"
    "hedule\022!\n\014bucket_count\030\001 \001(\004R\013bucketCoun"
    "t\022\'\n\017bucket_duration\030\002 \001(\003R\016bucketDurati"
    "on\022!\n\014quote_denoms\030\003 \003(\tR\013quoteDenoms\022N\n"
    "\ntier_infos\030\004 \003(\0132/.injective.exchange.v"
    "1beta1.FeeDiscountTierInfoR\ttierInfos\0226\n"
    "\027disqualified_market_ids\030\005 \003(\tR\025disquali"
    "fiedMarketIds\"M\n\022FeeDiscountTierTTL\022\022\n\004t"
    "ier\030\001 \001(\004R\004tier\022#\n\rttl_timestamp\030\002 \001(\003R\014"
    "ttlTimestamp\"\264\001\n\014VolumeRecord\022Q\n\014maker_v"
    "olume\030\001 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/c"
    "osmos-sdk/types.DecR\013makerVolume\022Q\n\014take"
    "r_volume\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmo"
    "s/cosmos-sdk/types.DecR\013takerVolume\"\221\001\n\016"
    "AccountRewards\022\030\n\007account\030\001 \001(\tR\007account"
    "\022e\n\007rewards\030\002 \003(\0132\031.cosmos.base.v1beta1."
    "CoinB0\310\336\037\000\252\337\037(github.com/cosmos/cosmos-s"
    "dk/types.CoinsR\007rewards\"\206\001\n\014TradeRecords"
    "\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\022Y\n\024latest_"
    "trade_records\030\002 \003(\0132\'.injective.exchange"
    ".v1beta1.TradeRecordR\022latestTradeRecords"
    "\"6\n\rSubaccountIDs\022%\n\016subaccount_ids\030\001 \003("
    "\014R\rsubaccountIds\"\275\001\n\013TradeRecord\022\034\n\ttime"
    "stamp\030\001 \001(\003R\ttimestamp\022D\n\005price\030\002 \001(\tB.\310"
    "\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/type"
    "s.DecR\005price\022J\n\010quantity\030\003 \001(\tB.\310\336\037\000\332\336\037&"
    "github.com/cosmos/cosmos-sdk/types.DecR\010"
    "quantity\"\203\001\n\005Level\022<\n\001p\030\001 \001(\tB.\310\336\037\000\332\336\037&g"
    "ithub.com/cosmos/cosmos-sdk/types.DecR\001p"
    "\022<\n\001q\030\002 \001(\tB.\310\336\037\000\332\336\037&github.com/cosmos/c"
    "osmos-sdk/types.DecR\001q\"\227\001\n\037AggregateSuba"
    "ccountVolumeRecord\022#\n\rsubaccount_id\030\001 \001("
    "\tR\014subaccountId\022O\n\016market_volumes\030\002 \003(\0132"
    "(.injective.exchange.v1beta1.MarketVolum"
    "eR\rmarketVolumes\"\211\001\n\034AggregateAccountVol"
    "umeRecord\022\030\n\007account\030\001 \001(\tR\007account\022O\n\016m"
    "arket_volumes\030\002 \003(\0132(.injective.exchange"
    ".v1beta1.MarketVolumeR\rmarketVolumes\"s\n\014"
    "MarketVolume\022\033\n\tmarket_id\030\001 \001(\tR\010marketI"
    "d\022F\n\006volume\030\002 \001(\0132(.injective.exchange.v"
    "1beta1.VolumeRecordB\004\310\336\037\000R\006volume\"A\n\rDen"
    "omDecimals\022\024\n\005denom\030\001 \001(\tR\005denom\022\032\n\010deci"
    "mals\030\002 \001(\004R\010decimals*t\n\034AtomicMarketOrde"
    "rAccessLevel\022\n\n\006Nobody\020\000\022\"\n\036BeginBlocker"
    "SmartContractsOnly\020\001\022\026\n\022SmartContractsOn"
    "ly\020\002\022\014\n\010Everyone\020\003*T\n\014MarketStatus\022\017\n\013Un"
    "specified\020\000\022\n\n\006Active\020\001\022\n\n\006Paused\020\002\022\016\n\nD"
    "emolished\020\003\022\013\n\007Expired\020\004*\273\002\n\tOrderType\022 "
    "\n\013UNSPECIFIED\020\000\032\017\212\235 \013UNSPECIFIED\022\020\n\003BUY\020"
    "\001\032\007\212\235 \003BUY\022\022\n\004SELL\020\002\032\010\212\235 \004SELL\022\032\n\010STOP_B"
    "UY\020\003\032\014\212\235 \010STOP_BUY\022\034\n\tSTOP_SELL\020\004\032\r\212\235 \tS"
    "TOP_SELL\022\032\n\010TAKE_BUY\020\005\032\014\212\235 \010TAKE_BUY\022\034\n\t"
    "TAKE_SELL\020\006\032\r\212\235 \tTAKE_SELL\022\026\n\006BUY_PO\020\007\032\n"
    "\212\235 \006BUY_PO\022\030\n\007SELL_PO\020\010\032\013\212\235 \007SELL_PO\022\036\n\n"
    "BUY_ATOMIC\020\t\032\016\212\235 \nBUY_ATOMIC\022 \n\013SELL_ATO"
    "MIC\020\n\032\017\212\235 \013SELL_ATOMIC*\257\001\n\rExecutionType"
    "\022\034\n\030UnspecifiedExecutionType\020\000\022\n\n\006Market"
    "\020\001\022\r\n\tLimitFill\020\002\022\032\n\026LimitMatchRestingOr"
    "der\020\003\022\026\n\022LimitMatchNewOrder\020\004\022\025\n\021MarketL"
    "iquidation\020\005\022\032\n\026ExpiryMarketSettlement\020\006"
    "*\211\002\n\tOrderMask\022\026\n\006UNUSED\020\000\032\n\212\235 \006UNUSED\022\020"
    "\n\003ANY\020\001\032\007\212\235 \003ANY\022\030\n\007REGULAR\020\002\032\013\212\235 \007REGUL"
    "AR\022 \n\013CONDITIONAL\020\004\032\017\212\235 \013CONDITIONAL\022.\n\027"
    "DIRECTION_BUY_OR_HIGHER\020\010\032\021\212\235 \rBUY_OR_HI"
    "GHER\022.\n\027DIRECTION_SELL_OR_LOWER\020\020\032\021\212\235 \rS"
    "ELL_OR_LOWER\022\033\n\013TYPE_MARKET\020 \032\n\212\235 \006MARKE"
    "T\022\031\n\nTYPE_LIMIT\020@\032\t\212\235 \005LIMITB\211\002\n\036com.inj"
    "ective.exchange.v1beta1B\rExchangeProtoP\001"
    "ZNgithub.com/InjectiveLabs/injective-cor"
    "e/injective-chain/modules/exchange/types"
    "\242\002\003IEX\252\002\032Injective.Exchange.V1beta1\312\002\032In"
    "jective\\Exchange\\V1beta1\342\002&Injective\\Exc"
    "hange\\V1beta1\\GPBMetadata\352\002\034Injective::E"
    "xchange::V1beta1b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_deps[3] =
    {
        &::descriptor_table_cosmos_2fbase_2fv1beta1_2fcoin_2eproto,
        &::descriptor_table_gogoproto_2fgogo_2eproto,
        &::descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto,
};
static ::absl::once_flag descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto = {
    false,
    false,
    17024,
    descriptor_table_protodef_injective_2fexchange_2fv1beta1_2fexchange_2eproto,
    "injective/exchange/v1beta1/exchange.proto",
    &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
    descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_deps,
    3,
    48,
    schemas,
    file_default_instances,
    TableStruct_injective_2fexchange_2fv1beta1_2fexchange_2eproto::offsets,
    file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto,
    file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto,
    file_level_service_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter() {
  return &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_injective_2fexchange_2fv1beta1_2fexchange_2eproto(&descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto);
namespace injective {
namespace exchange {
namespace v1beta1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AtomicMarketOrderAccessLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto);
  return file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto[0];
}
bool AtomicMarketOrderAccessLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto);
  return file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto[1];
}
bool MarketStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto);
  return file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto[2];
}
bool OrderType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecutionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto);
  return file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto[3];
}
bool ExecutionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderMask_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto);
  return file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fexchange_2eproto[4];
}
bool OrderMask_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Params::_Internal {
 public:
  using HasBits = decltype(std::declval<Params>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Params, _impl_._has_bits_);
  static const ::cosmos::base::v1beta1::Coin& spot_market_instant_listing_fee(const Params* msg);
  static void set_has_spot_market_instant_listing_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cosmos::base::v1beta1::Coin& derivative_market_instant_listing_fee(const Params* msg);
  static void set_has_derivative_market_instant_listing_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::cosmos::base::v1beta1::Coin& binary_options_market_instant_listing_fee(const Params* msg);
  static void set_has_binary_options_market_instant_listing_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::cosmos::base::v1beta1::Coin&
Params::_Internal::spot_market_instant_listing_fee(const Params* msg) {
  return *msg->_impl_.spot_market_instant_listing_fee_;
}
const ::cosmos::base::v1beta1::Coin&
Params::_Internal::derivative_market_instant_listing_fee(const Params* msg) {
  return *msg->_impl_.derivative_market_instant_listing_fee_;
}
const ::cosmos::base::v1beta1::Coin&
Params::_Internal::binary_options_market_instant_listing_fee(const Params* msg) {
  return *msg->_impl_.binary_options_market_instant_listing_fee_;
}
void Params::clear_spot_market_instant_listing_fee() {
  if (_impl_.spot_market_instant_listing_fee_ != nullptr) _impl_.spot_market_instant_listing_fee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Params::clear_derivative_market_instant_listing_fee() {
  if (_impl_.derivative_market_instant_listing_fee_ != nullptr) _impl_.derivative_market_instant_listing_fee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void Params::clear_binary_options_market_instant_listing_fee() {
  if (_impl_.binary_options_market_instant_listing_fee_ != nullptr) _impl_.binary_options_market_instant_listing_fee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
Params::Params(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.Params)
}
Params::Params(const Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.default_spot_maker_fee_rate_) {}

    , decltype(_impl_.default_spot_taker_fee_rate_) {}

    , decltype(_impl_.default_derivative_maker_fee_rate_) {}

    , decltype(_impl_.default_derivative_taker_fee_rate_) {}

    , decltype(_impl_.default_initial_margin_ratio_) {}

    , decltype(_impl_.default_maintenance_margin_ratio_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.default_hourly_funding_rate_cap_) {}

    , decltype(_impl_.default_hourly_interest_rate_) {}

    , decltype(_impl_.inj_reward_staked_requirement_threshold_) {}

    , decltype(_impl_.liquidator_reward_share_rate_) {}

    , decltype(_impl_.spot_atomic_market_order_fee_multiplier_) {}

    , decltype(_impl_.derivative_atomic_market_order_fee_multiplier_) {}

    , decltype(_impl_.binary_options_atomic_market_order_fee_multiplier_) {}

    , decltype(_impl_.minimal_protocol_fee_rate_) {}

    , decltype(_impl_.spot_market_instant_listing_fee_){nullptr}
    , decltype(_impl_.derivative_market_instant_listing_fee_){nullptr}
    , decltype(_impl_.binary_options_market_instant_listing_fee_){nullptr}
    , decltype(_impl_.default_funding_interval_) {}

    , decltype(_impl_.funding_multiple_) {}

    , decltype(_impl_.trading_rewards_vesting_duration_) {}

    , decltype(_impl_.max_derivative_order_side_count_) {}

    , decltype(_impl_.atomic_market_order_access_level_) {}

    , decltype(_impl_.is_instant_derivative_market_launch_enabled_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.default_spot_maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_spot_maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_spot_maker_fee_rate().empty()) {
    _this->_impl_.default_spot_maker_fee_rate_.Set(from._internal_default_spot_maker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.default_spot_taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_spot_taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_spot_taker_fee_rate().empty()) {
    _this->_impl_.default_spot_taker_fee_rate_.Set(from._internal_default_spot_taker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.default_derivative_maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_derivative_maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_derivative_maker_fee_rate().empty()) {
    _this->_impl_.default_derivative_maker_fee_rate_.Set(from._internal_default_derivative_maker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.default_derivative_taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_derivative_taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_derivative_taker_fee_rate().empty()) {
    _this->_impl_.default_derivative_taker_fee_rate_.Set(from._internal_default_derivative_taker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.default_initial_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_initial_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_initial_margin_ratio().empty()) {
    _this->_impl_.default_initial_margin_ratio_.Set(from._internal_default_initial_margin_ratio(), _this->GetArenaForAllocation());
  }
  _impl_.default_maintenance_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_maintenance_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_maintenance_margin_ratio().empty()) {
    _this->_impl_.default_maintenance_margin_ratio_.Set(from._internal_default_maintenance_margin_ratio(), _this->GetArenaForAllocation());
  }
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_impl_.relayer_fee_share_rate_.Set(from._internal_relayer_fee_share_rate(), _this->GetArenaForAllocation());
  }
  _impl_.default_hourly_funding_rate_cap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_hourly_funding_rate_cap_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_hourly_funding_rate_cap().empty()) {
    _this->_impl_.default_hourly_funding_rate_cap_.Set(from._internal_default_hourly_funding_rate_cap(), _this->GetArenaForAllocation());
  }
  _impl_.default_hourly_interest_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_hourly_interest_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_hourly_interest_rate().empty()) {
    _this->_impl_.default_hourly_interest_rate_.Set(from._internal_default_hourly_interest_rate(), _this->GetArenaForAllocation());
  }
  _impl_.inj_reward_staked_requirement_threshold_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.inj_reward_staked_requirement_threshold_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_inj_reward_staked_requirement_threshold().empty()) {
    _this->_impl_.inj_reward_staked_requirement_threshold_.Set(from._internal_inj_reward_staked_requirement_threshold(), _this->GetArenaForAllocation());
  }
  _impl_.liquidator_reward_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.liquidator_reward_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_liquidator_reward_share_rate().empty()) {
    _this->_impl_.liquidator_reward_share_rate_.Set(from._internal_liquidator_reward_share_rate(), _this->GetArenaForAllocation());
  }
  _impl_.spot_atomic_market_order_fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.spot_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_spot_atomic_market_order_fee_multiplier().empty()) {
    _this->_impl_.spot_atomic_market_order_fee_multiplier_.Set(from._internal_spot_atomic_market_order_fee_multiplier(), _this->GetArenaForAllocation());
  }
  _impl_.derivative_atomic_market_order_fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.derivative_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_derivative_atomic_market_order_fee_multiplier().empty()) {
    _this->_impl_.derivative_atomic_market_order_fee_multiplier_.Set(from._internal_derivative_atomic_market_order_fee_multiplier(), _this->GetArenaForAllocation());
  }
  _impl_.binary_options_atomic_market_order_fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.binary_options_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_binary_options_atomic_market_order_fee_multiplier().empty()) {
    _this->_impl_.binary_options_atomic_market_order_fee_multiplier_.Set(from._internal_binary_options_atomic_market_order_fee_multiplier(), _this->GetArenaForAllocation());
  }
  _impl_.minimal_protocol_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.minimal_protocol_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_minimal_protocol_fee_rate().empty()) {
    _this->_impl_.minimal_protocol_fee_rate_.Set(from._internal_minimal_protocol_fee_rate(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.spot_market_instant_listing_fee_ = new ::cosmos::base::v1beta1::Coin(*from._impl_.spot_market_instant_listing_fee_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.derivative_market_instant_listing_fee_ = new ::cosmos::base::v1beta1::Coin(*from._impl_.derivative_market_instant_listing_fee_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.binary_options_market_instant_listing_fee_ = new ::cosmos::base::v1beta1::Coin(*from._impl_.binary_options_market_instant_listing_fee_);
  }
  ::memcpy(&_impl_.default_funding_interval_, &from._impl_.default_funding_interval_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_instant_derivative_market_launch_enabled_) -
    reinterpret_cast<char*>(&_impl_.default_funding_interval_)) + sizeof(_impl_.is_instant_derivative_market_launch_enabled_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.Params)
}

inline void Params::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.default_spot_maker_fee_rate_) {}

    , decltype(_impl_.default_spot_taker_fee_rate_) {}

    , decltype(_impl_.default_derivative_maker_fee_rate_) {}

    , decltype(_impl_.default_derivative_taker_fee_rate_) {}

    , decltype(_impl_.default_initial_margin_ratio_) {}

    , decltype(_impl_.default_maintenance_margin_ratio_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.default_hourly_funding_rate_cap_) {}

    , decltype(_impl_.default_hourly_interest_rate_) {}

    , decltype(_impl_.inj_reward_staked_requirement_threshold_) {}

    , decltype(_impl_.liquidator_reward_share_rate_) {}

    , decltype(_impl_.spot_atomic_market_order_fee_multiplier_) {}

    , decltype(_impl_.derivative_atomic_market_order_fee_multiplier_) {}

    , decltype(_impl_.binary_options_atomic_market_order_fee_multiplier_) {}

    , decltype(_impl_.minimal_protocol_fee_rate_) {}

    , decltype(_impl_.spot_market_instant_listing_fee_){nullptr}
    , decltype(_impl_.derivative_market_instant_listing_fee_){nullptr}
    , decltype(_impl_.binary_options_market_instant_listing_fee_){nullptr}
    , decltype(_impl_.default_funding_interval_) { ::int64_t{0} }

    , decltype(_impl_.funding_multiple_) { ::int64_t{0} }

    , decltype(_impl_.trading_rewards_vesting_duration_) { ::int64_t{0} }

    , decltype(_impl_.max_derivative_order_side_count_) { 0u }

    , decltype(_impl_.atomic_market_order_access_level_) { 0 }

    , decltype(_impl_.is_instant_derivative_market_launch_enabled_) { false }

  };
  _impl_.default_spot_maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_spot_maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_spot_taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_spot_taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_derivative_maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_derivative_maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_derivative_taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_derivative_taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_initial_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_initial_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_maintenance_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_maintenance_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_hourly_funding_rate_cap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_hourly_funding_rate_cap_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_hourly_interest_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.default_hourly_interest_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.inj_reward_staked_requirement_threshold_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.inj_reward_staked_requirement_threshold_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.liquidator_reward_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.liquidator_reward_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.spot_atomic_market_order_fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.spot_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.derivative_atomic_market_order_fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.derivative_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.binary_options_atomic_market_order_fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.binary_options_atomic_market_order_fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.minimal_protocol_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.minimal_protocol_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Params::~Params() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Params::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.default_spot_maker_fee_rate_.Destroy();
  _impl_.default_spot_taker_fee_rate_.Destroy();
  _impl_.default_derivative_maker_fee_rate_.Destroy();
  _impl_.default_derivative_taker_fee_rate_.Destroy();
  _impl_.default_initial_margin_ratio_.Destroy();
  _impl_.default_maintenance_margin_ratio_.Destroy();
  _impl_.relayer_fee_share_rate_.Destroy();
  _impl_.default_hourly_funding_rate_cap_.Destroy();
  _impl_.default_hourly_interest_rate_.Destroy();
  _impl_.inj_reward_staked_requirement_threshold_.Destroy();
  _impl_.liquidator_reward_share_rate_.Destroy();
  _impl_.spot_atomic_market_order_fee_multiplier_.Destroy();
  _impl_.derivative_atomic_market_order_fee_multiplier_.Destroy();
  _impl_.binary_options_atomic_market_order_fee_multiplier_.Destroy();
  _impl_.minimal_protocol_fee_rate_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spot_market_instant_listing_fee_;
  if (this != internal_default_instance()) delete _impl_.derivative_market_instant_listing_fee_;
  if (this != internal_default_instance()) delete _impl_.binary_options_market_instant_listing_fee_;
}

void Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Params::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.Params)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.default_spot_maker_fee_rate_.ClearToEmpty();
  _impl_.default_spot_taker_fee_rate_.ClearToEmpty();
  _impl_.default_derivative_maker_fee_rate_.ClearToEmpty();
  _impl_.default_derivative_taker_fee_rate_.ClearToEmpty();
  _impl_.default_initial_margin_ratio_.ClearToEmpty();
  _impl_.default_maintenance_margin_ratio_.ClearToEmpty();
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
  _impl_.default_hourly_funding_rate_cap_.ClearToEmpty();
  _impl_.default_hourly_interest_rate_.ClearToEmpty();
  _impl_.inj_reward_staked_requirement_threshold_.ClearToEmpty();
  _impl_.liquidator_reward_share_rate_.ClearToEmpty();
  _impl_.spot_atomic_market_order_fee_multiplier_.ClearToEmpty();
  _impl_.derivative_atomic_market_order_fee_multiplier_.ClearToEmpty();
  _impl_.binary_options_atomic_market_order_fee_multiplier_.ClearToEmpty();
  _impl_.minimal_protocol_fee_rate_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.spot_market_instant_listing_fee_ != nullptr);
      _impl_.spot_market_instant_listing_fee_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.derivative_market_instant_listing_fee_ != nullptr);
      _impl_.derivative_market_instant_listing_fee_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.binary_options_market_instant_listing_fee_ != nullptr);
      _impl_.binary_options_market_instant_listing_fee_->Clear();
    }
  }
  ::memset(&_impl_.default_funding_interval_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_instant_derivative_market_launch_enabled_) -
      reinterpret_cast<char*>(&_impl_.default_funding_interval_)) + sizeof(_impl_.is_instant_derivative_market_launch_enabled_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1 [json_name = "spotMarketInstantListingFee", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spot_market_instant_listing_fee(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2 [json_name = "derivativeMarketInstantListingFee", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_derivative_market_instant_listing_fee(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_spot_maker_fee_rate = 3 [json_name = "defaultSpotMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_default_spot_maker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_spot_maker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_spot_taker_fee_rate = 4 [json_name = "defaultSpotTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_default_spot_taker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_spot_taker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_derivative_maker_fee_rate = 5 [json_name = "defaultDerivativeMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_default_derivative_maker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_derivative_maker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_derivative_taker_fee_rate = 6 [json_name = "defaultDerivativeTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_default_derivative_taker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_derivative_taker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_initial_margin_ratio = 7 [json_name = "defaultInitialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_default_initial_margin_ratio();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_initial_margin_ratio"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_maintenance_margin_ratio = 8 [json_name = "defaultMaintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_default_maintenance_margin_ratio();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_maintenance_margin_ratio"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 default_funding_interval = 9 [json_name = "defaultFundingInterval"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.default_funding_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 funding_multiple = 10 [json_name = "fundingMultiple"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.funding_multiple_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string relayer_fee_share_rate = 11 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_relayer_fee_share_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.relayer_fee_share_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_hourly_funding_rate_cap = 12 [json_name = "defaultHourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_default_hourly_funding_rate_cap();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_hourly_funding_rate_cap"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string default_hourly_interest_rate = 13 [json_name = "defaultHourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_default_hourly_interest_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.default_hourly_interest_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 max_derivative_order_side_count = 14 [json_name = "maxDerivativeOrderSideCount"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _impl_.max_derivative_order_side_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string inj_reward_staked_requirement_threshold = 15 [json_name = "injRewardStakedRequirementThreshold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_inj_reward_staked_requirement_threshold();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.inj_reward_staked_requirement_threshold"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 trading_rewards_vesting_duration = 16 [json_name = "tradingRewardsVestingDuration"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _impl_.trading_rewards_vesting_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string liquidator_reward_share_rate = 17 [json_name = "liquidatorRewardShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_liquidator_reward_share_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.liquidator_reward_share_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18 [json_name = "binaryOptionsMarketInstantListingFee", (.gogoproto.nullable) = false];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_binary_options_market_instant_listing_fee(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19 [json_name = "atomicMarketOrderAccessLevel"];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_atomic_market_order_access_level(static_cast<::injective::exchange::v1beta1::AtomicMarketOrderAccessLevel>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string spot_atomic_market_order_fee_multiplier = 20 [json_name = "spotAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_spot_atomic_market_order_fee_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.spot_atomic_market_order_fee_multiplier"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string derivative_atomic_market_order_fee_multiplier = 21 [json_name = "derivativeAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_derivative_atomic_market_order_fee_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.derivative_atomic_market_order_fee_multiplier"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string binary_options_atomic_market_order_fee_multiplier = 22 [json_name = "binaryOptionsAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_binary_options_atomic_market_order_fee_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.binary_options_atomic_market_order_fee_multiplier"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string minimal_protocol_fee_rate = 23 [json_name = "minimalProtocolFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_minimal_protocol_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Params.minimal_protocol_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_instant_derivative_market_launch_enabled = 24 [json_name = "isInstantDerivativeMarketLaunchEnabled"];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 192)) {
          _impl_.is_instant_derivative_market_launch_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Params::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.Params)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1 [json_name = "spotMarketInstantListingFee", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::spot_market_instant_listing_fee(this),
        _Internal::spot_market_instant_listing_fee(this).GetCachedSize(), target, stream);
  }

  // .cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2 [json_name = "derivativeMarketInstantListingFee", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::derivative_market_instant_listing_fee(this),
        _Internal::derivative_market_instant_listing_fee(this).GetCachedSize(), target, stream);
  }

  // string default_spot_maker_fee_rate = 3 [json_name = "defaultSpotMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_spot_maker_fee_rate().empty()) {
    const std::string& _s = this->_internal_default_spot_maker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_spot_maker_fee_rate");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string default_spot_taker_fee_rate = 4 [json_name = "defaultSpotTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_spot_taker_fee_rate().empty()) {
    const std::string& _s = this->_internal_default_spot_taker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_spot_taker_fee_rate");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string default_derivative_maker_fee_rate = 5 [json_name = "defaultDerivativeMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_derivative_maker_fee_rate().empty()) {
    const std::string& _s = this->_internal_default_derivative_maker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_derivative_maker_fee_rate");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // string default_derivative_taker_fee_rate = 6 [json_name = "defaultDerivativeTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_derivative_taker_fee_rate().empty()) {
    const std::string& _s = this->_internal_default_derivative_taker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_derivative_taker_fee_rate");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // string default_initial_margin_ratio = 7 [json_name = "defaultInitialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_initial_margin_ratio().empty()) {
    const std::string& _s = this->_internal_default_initial_margin_ratio();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_initial_margin_ratio");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // string default_maintenance_margin_ratio = 8 [json_name = "defaultMaintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_maintenance_margin_ratio().empty()) {
    const std::string& _s = this->_internal_default_maintenance_margin_ratio();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_maintenance_margin_ratio");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // int64 default_funding_interval = 9 [json_name = "defaultFundingInterval"];
  if (this->_internal_default_funding_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        9, this->_internal_default_funding_interval(), target);
  }

  // int64 funding_multiple = 10 [json_name = "fundingMultiple"];
  if (this->_internal_funding_multiple() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        10, this->_internal_funding_multiple(), target);
  }

  // string relayer_fee_share_rate = 11 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    const std::string& _s = this->_internal_relayer_fee_share_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.relayer_fee_share_rate");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // string default_hourly_funding_rate_cap = 12 [json_name = "defaultHourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_hourly_funding_rate_cap().empty()) {
    const std::string& _s = this->_internal_default_hourly_funding_rate_cap();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_hourly_funding_rate_cap");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // string default_hourly_interest_rate = 13 [json_name = "defaultHourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_hourly_interest_rate().empty()) {
    const std::string& _s = this->_internal_default_hourly_interest_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.default_hourly_interest_rate");
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // uint32 max_derivative_order_side_count = 14 [json_name = "maxDerivativeOrderSideCount"];
  if (this->_internal_max_derivative_order_side_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        14, this->_internal_max_derivative_order_side_count(), target);
  }

  // string inj_reward_staked_requirement_threshold = 15 [json_name = "injRewardStakedRequirementThreshold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_inj_reward_staked_requirement_threshold().empty()) {
    const std::string& _s = this->_internal_inj_reward_staked_requirement_threshold();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.inj_reward_staked_requirement_threshold");
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  // int64 trading_rewards_vesting_duration = 16 [json_name = "tradingRewardsVestingDuration"];
  if (this->_internal_trading_rewards_vesting_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        16, this->_internal_trading_rewards_vesting_duration(), target);
  }

  // string liquidator_reward_share_rate = 17 [json_name = "liquidatorRewardShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_liquidator_reward_share_rate().empty()) {
    const std::string& _s = this->_internal_liquidator_reward_share_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.liquidator_reward_share_rate");
    target = stream->WriteStringMaybeAliased(17, _s, target);
  }

  // .cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18 [json_name = "binaryOptionsMarketInstantListingFee", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::binary_options_market_instant_listing_fee(this),
        _Internal::binary_options_market_instant_listing_fee(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19 [json_name = "atomicMarketOrderAccessLevel"];
  if (this->_internal_atomic_market_order_access_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        19, this->_internal_atomic_market_order_access_level(), target);
  }

  // string spot_atomic_market_order_fee_multiplier = 20 [json_name = "spotAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_spot_atomic_market_order_fee_multiplier().empty()) {
    const std::string& _s = this->_internal_spot_atomic_market_order_fee_multiplier();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.spot_atomic_market_order_fee_multiplier");
    target = stream->WriteStringMaybeAliased(20, _s, target);
  }

  // string derivative_atomic_market_order_fee_multiplier = 21 [json_name = "derivativeAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_derivative_atomic_market_order_fee_multiplier().empty()) {
    const std::string& _s = this->_internal_derivative_atomic_market_order_fee_multiplier();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.derivative_atomic_market_order_fee_multiplier");
    target = stream->WriteStringMaybeAliased(21, _s, target);
  }

  // string binary_options_atomic_market_order_fee_multiplier = 22 [json_name = "binaryOptionsAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_binary_options_atomic_market_order_fee_multiplier().empty()) {
    const std::string& _s = this->_internal_binary_options_atomic_market_order_fee_multiplier();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.binary_options_atomic_market_order_fee_multiplier");
    target = stream->WriteStringMaybeAliased(22, _s, target);
  }

  // string minimal_protocol_fee_rate = 23 [json_name = "minimalProtocolFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_minimal_protocol_fee_rate().empty()) {
    const std::string& _s = this->_internal_minimal_protocol_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Params.minimal_protocol_fee_rate");
    target = stream->WriteStringMaybeAliased(23, _s, target);
  }

  // bool is_instant_derivative_market_launch_enabled = 24 [json_name = "isInstantDerivativeMarketLaunchEnabled"];
  if (this->_internal_is_instant_derivative_market_launch_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        24, this->_internal_is_instant_derivative_market_launch_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.Params)
  return target;
}

::size_t Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.Params)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string default_spot_maker_fee_rate = 3 [json_name = "defaultSpotMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_spot_maker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_spot_maker_fee_rate());
  }

  // string default_spot_taker_fee_rate = 4 [json_name = "defaultSpotTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_spot_taker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_spot_taker_fee_rate());
  }

  // string default_derivative_maker_fee_rate = 5 [json_name = "defaultDerivativeMakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_derivative_maker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_derivative_maker_fee_rate());
  }

  // string default_derivative_taker_fee_rate = 6 [json_name = "defaultDerivativeTakerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_derivative_taker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_derivative_taker_fee_rate());
  }

  // string default_initial_margin_ratio = 7 [json_name = "defaultInitialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_initial_margin_ratio().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_initial_margin_ratio());
  }

  // string default_maintenance_margin_ratio = 8 [json_name = "defaultMaintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_maintenance_margin_ratio().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_maintenance_margin_ratio());
  }

  // string relayer_fee_share_rate = 11 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_relayer_fee_share_rate());
  }

  // string default_hourly_funding_rate_cap = 12 [json_name = "defaultHourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_hourly_funding_rate_cap().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_hourly_funding_rate_cap());
  }

  // string default_hourly_interest_rate = 13 [json_name = "defaultHourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_default_hourly_interest_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_default_hourly_interest_rate());
  }

  // string inj_reward_staked_requirement_threshold = 15 [json_name = "injRewardStakedRequirementThreshold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_inj_reward_staked_requirement_threshold().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_inj_reward_staked_requirement_threshold());
  }

  // string liquidator_reward_share_rate = 17 [json_name = "liquidatorRewardShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_liquidator_reward_share_rate().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_liquidator_reward_share_rate());
  }

  // string spot_atomic_market_order_fee_multiplier = 20 [json_name = "spotAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_spot_atomic_market_order_fee_multiplier().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_spot_atomic_market_order_fee_multiplier());
  }

  // string derivative_atomic_market_order_fee_multiplier = 21 [json_name = "derivativeAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_derivative_atomic_market_order_fee_multiplier().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_derivative_atomic_market_order_fee_multiplier());
  }

  // string binary_options_atomic_market_order_fee_multiplier = 22 [json_name = "binaryOptionsAtomicMarketOrderFeeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_binary_options_atomic_market_order_fee_multiplier().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_binary_options_atomic_market_order_fee_multiplier());
  }

  // string minimal_protocol_fee_rate = 23 [json_name = "minimalProtocolFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_minimal_protocol_fee_rate().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_minimal_protocol_fee_rate());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1 [json_name = "spotMarketInstantListingFee", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spot_market_instant_listing_fee_);
    }

    // .cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2 [json_name = "derivativeMarketInstantListingFee", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.derivative_market_instant_listing_fee_);
    }

    // .cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18 [json_name = "binaryOptionsMarketInstantListingFee", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.binary_options_market_instant_listing_fee_);
    }

  }
  // int64 default_funding_interval = 9 [json_name = "defaultFundingInterval"];
  if (this->_internal_default_funding_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_default_funding_interval());
  }

  // int64 funding_multiple = 10 [json_name = "fundingMultiple"];
  if (this->_internal_funding_multiple() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_funding_multiple());
  }

  // int64 trading_rewards_vesting_duration = 16 [json_name = "tradingRewardsVestingDuration"];
  if (this->_internal_trading_rewards_vesting_duration() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                    this->_internal_trading_rewards_vesting_duration());
  }

  // uint32 max_derivative_order_side_count = 14 [json_name = "maxDerivativeOrderSideCount"];
  if (this->_internal_max_derivative_order_side_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_max_derivative_order_side_count());
  }

  // .injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19 [json_name = "atomicMarketOrderAccessLevel"];
  if (this->_internal_atomic_market_order_access_level() != 0) {
    total_size += 2 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_atomic_market_order_access_level());
  }

  // bool is_instant_derivative_market_launch_enabled = 24 [json_name = "isInstantDerivativeMarketLaunchEnabled"];
  if (this->_internal_is_instant_derivative_market_launch_enabled() != 0) {
    total_size += 3;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Params::GetClassData() const { return &_class_data_; }


void Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Params*>(&to_msg);
  auto& from = static_cast<const Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.Params)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_default_spot_maker_fee_rate().empty()) {
    _this->_internal_set_default_spot_maker_fee_rate(from._internal_default_spot_maker_fee_rate());
  }
  if (!from._internal_default_spot_taker_fee_rate().empty()) {
    _this->_internal_set_default_spot_taker_fee_rate(from._internal_default_spot_taker_fee_rate());
  }
  if (!from._internal_default_derivative_maker_fee_rate().empty()) {
    _this->_internal_set_default_derivative_maker_fee_rate(from._internal_default_derivative_maker_fee_rate());
  }
  if (!from._internal_default_derivative_taker_fee_rate().empty()) {
    _this->_internal_set_default_derivative_taker_fee_rate(from._internal_default_derivative_taker_fee_rate());
  }
  if (!from._internal_default_initial_margin_ratio().empty()) {
    _this->_internal_set_default_initial_margin_ratio(from._internal_default_initial_margin_ratio());
  }
  if (!from._internal_default_maintenance_margin_ratio().empty()) {
    _this->_internal_set_default_maintenance_margin_ratio(from._internal_default_maintenance_margin_ratio());
  }
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_internal_set_relayer_fee_share_rate(from._internal_relayer_fee_share_rate());
  }
  if (!from._internal_default_hourly_funding_rate_cap().empty()) {
    _this->_internal_set_default_hourly_funding_rate_cap(from._internal_default_hourly_funding_rate_cap());
  }
  if (!from._internal_default_hourly_interest_rate().empty()) {
    _this->_internal_set_default_hourly_interest_rate(from._internal_default_hourly_interest_rate());
  }
  if (!from._internal_inj_reward_staked_requirement_threshold().empty()) {
    _this->_internal_set_inj_reward_staked_requirement_threshold(from._internal_inj_reward_staked_requirement_threshold());
  }
  if (!from._internal_liquidator_reward_share_rate().empty()) {
    _this->_internal_set_liquidator_reward_share_rate(from._internal_liquidator_reward_share_rate());
  }
  if (!from._internal_spot_atomic_market_order_fee_multiplier().empty()) {
    _this->_internal_set_spot_atomic_market_order_fee_multiplier(from._internal_spot_atomic_market_order_fee_multiplier());
  }
  if (!from._internal_derivative_atomic_market_order_fee_multiplier().empty()) {
    _this->_internal_set_derivative_atomic_market_order_fee_multiplier(from._internal_derivative_atomic_market_order_fee_multiplier());
  }
  if (!from._internal_binary_options_atomic_market_order_fee_multiplier().empty()) {
    _this->_internal_set_binary_options_atomic_market_order_fee_multiplier(from._internal_binary_options_atomic_market_order_fee_multiplier());
  }
  if (!from._internal_minimal_protocol_fee_rate().empty()) {
    _this->_internal_set_minimal_protocol_fee_rate(from._internal_minimal_protocol_fee_rate());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_spot_market_instant_listing_fee()->::cosmos::base::v1beta1::Coin::MergeFrom(
          from._internal_spot_market_instant_listing_fee());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_derivative_market_instant_listing_fee()->::cosmos::base::v1beta1::Coin::MergeFrom(
          from._internal_derivative_market_instant_listing_fee());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_binary_options_market_instant_listing_fee()->::cosmos::base::v1beta1::Coin::MergeFrom(
          from._internal_binary_options_market_instant_listing_fee());
    }
  }
  if (from._internal_default_funding_interval() != 0) {
    _this->_internal_set_default_funding_interval(from._internal_default_funding_interval());
  }
  if (from._internal_funding_multiple() != 0) {
    _this->_internal_set_funding_multiple(from._internal_funding_multiple());
  }
  if (from._internal_trading_rewards_vesting_duration() != 0) {
    _this->_internal_set_trading_rewards_vesting_duration(from._internal_trading_rewards_vesting_duration());
  }
  if (from._internal_max_derivative_order_side_count() != 0) {
    _this->_internal_set_max_derivative_order_side_count(from._internal_max_derivative_order_side_count());
  }
  if (from._internal_atomic_market_order_access_level() != 0) {
    _this->_internal_set_atomic_market_order_access_level(from._internal_atomic_market_order_access_level());
  }
  if (from._internal_is_instant_derivative_market_launch_enabled() != 0) {
    _this->_internal_set_is_instant_derivative_market_launch_enabled(from._internal_is_instant_derivative_market_launch_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Params::CopyFrom(const Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Params::IsInitialized() const {
  return true;
}

void Params::InternalSwap(Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_spot_maker_fee_rate_, lhs_arena,
                                       &other->_impl_.default_spot_maker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_spot_taker_fee_rate_, lhs_arena,
                                       &other->_impl_.default_spot_taker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_derivative_maker_fee_rate_, lhs_arena,
                                       &other->_impl_.default_derivative_maker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_derivative_taker_fee_rate_, lhs_arena,
                                       &other->_impl_.default_derivative_taker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_initial_margin_ratio_, lhs_arena,
                                       &other->_impl_.default_initial_margin_ratio_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_maintenance_margin_ratio_, lhs_arena,
                                       &other->_impl_.default_maintenance_margin_ratio_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.relayer_fee_share_rate_, lhs_arena,
                                       &other->_impl_.relayer_fee_share_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_hourly_funding_rate_cap_, lhs_arena,
                                       &other->_impl_.default_hourly_funding_rate_cap_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.default_hourly_interest_rate_, lhs_arena,
                                       &other->_impl_.default_hourly_interest_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.inj_reward_staked_requirement_threshold_, lhs_arena,
                                       &other->_impl_.inj_reward_staked_requirement_threshold_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.liquidator_reward_share_rate_, lhs_arena,
                                       &other->_impl_.liquidator_reward_share_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.spot_atomic_market_order_fee_multiplier_, lhs_arena,
                                       &other->_impl_.spot_atomic_market_order_fee_multiplier_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.derivative_atomic_market_order_fee_multiplier_, lhs_arena,
                                       &other->_impl_.derivative_atomic_market_order_fee_multiplier_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.binary_options_atomic_market_order_fee_multiplier_, lhs_arena,
                                       &other->_impl_.binary_options_atomic_market_order_fee_multiplier_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.minimal_protocol_fee_rate_, lhs_arena,
                                       &other->_impl_.minimal_protocol_fee_rate_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Params, _impl_.is_instant_derivative_market_launch_enabled_)
      + sizeof(Params::_impl_.is_instant_derivative_market_launch_enabled_)
      - PROTOBUF_FIELD_OFFSET(Params, _impl_.spot_market_instant_listing_fee_)>(
          reinterpret_cast<char*>(&_impl_.spot_market_instant_listing_fee_),
          reinterpret_cast<char*>(&other->_impl_.spot_market_instant_listing_fee_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[0]);
}
// ===================================================================

class MarketFeeMultiplier::_Internal {
 public:
};

MarketFeeMultiplier::MarketFeeMultiplier(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.MarketFeeMultiplier)
}
MarketFeeMultiplier::MarketFeeMultiplier(const MarketFeeMultiplier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketFeeMultiplier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.fee_multiplier_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_multiplier().empty()) {
    _this->_impl_.fee_multiplier_.Set(from._internal_fee_multiplier(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.MarketFeeMultiplier)
}

inline void MarketFeeMultiplier::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.fee_multiplier_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarketFeeMultiplier::~MarketFeeMultiplier() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.MarketFeeMultiplier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketFeeMultiplier::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.fee_multiplier_.Destroy();
}

void MarketFeeMultiplier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketFeeMultiplier::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.MarketFeeMultiplier)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.fee_multiplier_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketFeeMultiplier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.MarketFeeMultiplier.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string fee_multiplier = 2 [json_name = "feeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fee_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.MarketFeeMultiplier.fee_multiplier"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketFeeMultiplier::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.MarketFeeMultiplier)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.MarketFeeMultiplier.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string fee_multiplier = 2 [json_name = "feeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fee_multiplier().empty()) {
    const std::string& _s = this->_internal_fee_multiplier();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.MarketFeeMultiplier.fee_multiplier");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.MarketFeeMultiplier)
  return target;
}

::size_t MarketFeeMultiplier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.MarketFeeMultiplier)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string fee_multiplier = 2 [json_name = "feeMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fee_multiplier().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fee_multiplier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketFeeMultiplier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketFeeMultiplier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketFeeMultiplier::GetClassData() const { return &_class_data_; }


void MarketFeeMultiplier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketFeeMultiplier*>(&to_msg);
  auto& from = static_cast<const MarketFeeMultiplier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.MarketFeeMultiplier)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_fee_multiplier().empty()) {
    _this->_internal_set_fee_multiplier(from._internal_fee_multiplier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketFeeMultiplier::CopyFrom(const MarketFeeMultiplier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.MarketFeeMultiplier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketFeeMultiplier::IsInitialized() const {
  return true;
}

void MarketFeeMultiplier::InternalSwap(MarketFeeMultiplier* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_multiplier_, lhs_arena,
                                       &other->_impl_.fee_multiplier_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketFeeMultiplier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[1]);
}
// ===================================================================

class DerivativeMarket::_Internal {
 public:
};

DerivativeMarket::DerivativeMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeMarket)
}
DerivativeMarket::DerivativeMarket(const DerivativeMarket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeMarket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.oracle_base_) {}

    , decltype(_impl_.oracle_quote_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.initial_margin_ratio_) {}

    , decltype(_impl_.maintenance_margin_ratio_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.oracle_type_) {}

    , decltype(_impl_.oracle_scale_factor_) {}

    , decltype(_impl_.isperpetual_) {}

    , decltype(_impl_.status_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ticker().empty()) {
    _this->_impl_.ticker_.Set(from._internal_ticker(), _this->GetArenaForAllocation());
  }
  _impl_.oracle_base_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_base_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_oracle_base().empty()) {
    _this->_impl_.oracle_base_.Set(from._internal_oracle_base(), _this->GetArenaForAllocation());
  }
  _impl_.oracle_quote_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_quote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_oracle_quote().empty()) {
    _this->_impl_.oracle_quote_.Set(from._internal_oracle_quote(), _this->GetArenaForAllocation());
  }
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quote_denom().empty()) {
    _this->_impl_.quote_denom_.Set(from._internal_quote_denom(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.initial_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_initial_margin_ratio().empty()) {
    _this->_impl_.initial_margin_ratio_.Set(from._internal_initial_margin_ratio(), _this->GetArenaForAllocation());
  }
  _impl_.maintenance_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maintenance_margin_ratio().empty()) {
    _this->_impl_.maintenance_margin_ratio_.Set(from._internal_maintenance_margin_ratio(), _this->GetArenaForAllocation());
  }
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_impl_.maker_fee_rate_.Set(from._internal_maker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_impl_.taker_fee_rate_.Set(from._internal_taker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_impl_.relayer_fee_share_rate_.Set(from._internal_relayer_fee_share_rate(), _this->GetArenaForAllocation());
  }
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_impl_.min_price_tick_size_.Set(from._internal_min_price_tick_size(), _this->GetArenaForAllocation());
  }
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_impl_.min_quantity_tick_size_.Set(from._internal_min_quantity_tick_size(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.oracle_type_, &from._impl_.oracle_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.oracle_type_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeMarket)
}

inline void DerivativeMarket::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.oracle_base_) {}

    , decltype(_impl_.oracle_quote_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.initial_margin_ratio_) {}

    , decltype(_impl_.maintenance_margin_ratio_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.oracle_type_) { 0 }

    , decltype(_impl_.oracle_scale_factor_) { 0u }

    , decltype(_impl_.isperpetual_) { false }

    , decltype(_impl_.status_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oracle_base_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_base_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oracle_quote_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_quote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.initial_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.maintenance_margin_ratio_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeMarket::~DerivativeMarket() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeMarket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeMarket::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ticker_.Destroy();
  _impl_.oracle_base_.Destroy();
  _impl_.oracle_quote_.Destroy();
  _impl_.quote_denom_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.initial_margin_ratio_.Destroy();
  _impl_.maintenance_margin_ratio_.Destroy();
  _impl_.maker_fee_rate_.Destroy();
  _impl_.taker_fee_rate_.Destroy();
  _impl_.relayer_fee_share_rate_.Destroy();
  _impl_.min_price_tick_size_.Destroy();
  _impl_.min_quantity_tick_size_.Destroy();
}

void DerivativeMarket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeMarket::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeMarket)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ticker_.ClearToEmpty();
  _impl_.oracle_base_.ClearToEmpty();
  _impl_.oracle_quote_.ClearToEmpty();
  _impl_.quote_denom_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.initial_margin_ratio_.ClearToEmpty();
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
  _impl_.maker_fee_rate_.ClearToEmpty();
  _impl_.taker_fee_rate_.ClearToEmpty();
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
  _impl_.min_price_tick_size_.ClearToEmpty();
  _impl_.min_quantity_tick_size_.ClearToEmpty();
  ::memset(&_impl_.oracle_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.oracle_type_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeMarket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ticker = 1 [json_name = "ticker"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ticker();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.ticker"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string oracle_base = 2 [json_name = "oracleBase"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_oracle_base();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.oracle_base"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string oracle_quote = 3 [json_name = "oracleQuote"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_oracle_quote();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.oracle_quote"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_oracle_type(static_cast<::injective::oracle::v1beta1::OracleType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.oracle_scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string quote_denom = 6 [json_name = "quoteDenom"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_quote_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.quote_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 7 [json_name = "marketId"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string initial_margin_ratio = 8 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_initial_margin_ratio();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.initial_margin_ratio"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string maintenance_margin_ratio = 9 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_maintenance_margin_ratio();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.maintenance_margin_ratio"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string maker_fee_rate = 10 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_maker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.maker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string taker_fee_rate = 11 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_taker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.taker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string relayer_fee_share_rate = 12 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_relayer_fee_share_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.relayer_fee_share_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isPerpetual = 13 [json_name = "isPerpetual"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.isperpetual_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::injective::exchange::v1beta1::MarketStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_min_price_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.min_price_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_min_quantity_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarket.min_quantity_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeMarket::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeMarket)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ticker = 1 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    const std::string& _s = this->_internal_ticker();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.ticker");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string oracle_base = 2 [json_name = "oracleBase"];
  if (!this->_internal_oracle_base().empty()) {
    const std::string& _s = this->_internal_oracle_base();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.oracle_base");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string oracle_quote = 3 [json_name = "oracleQuote"];
  if (!this->_internal_oracle_quote().empty()) {
    const std::string& _s = this->_internal_oracle_quote();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.oracle_quote");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  if (this->_internal_oracle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_oracle_type(), target);
  }

  // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
  if (this->_internal_oracle_scale_factor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_oracle_scale_factor(), target);
  }

  // string quote_denom = 6 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    const std::string& _s = this->_internal_quote_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.quote_denom");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // string market_id = 7 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.market_id");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // string initial_margin_ratio = 8 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_initial_margin_ratio().empty()) {
    const std::string& _s = this->_internal_initial_margin_ratio();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.initial_margin_ratio");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string maintenance_margin_ratio = 9 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maintenance_margin_ratio().empty()) {
    const std::string& _s = this->_internal_maintenance_margin_ratio();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.maintenance_margin_ratio");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string maker_fee_rate = 10 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_fee_rate().empty()) {
    const std::string& _s = this->_internal_maker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.maker_fee_rate");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // string taker_fee_rate = 11 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_fee_rate().empty()) {
    const std::string& _s = this->_internal_taker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.taker_fee_rate");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // string relayer_fee_share_rate = 12 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    const std::string& _s = this->_internal_relayer_fee_share_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.relayer_fee_share_rate");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // bool isPerpetual = 13 [json_name = "isPerpetual"];
  if (this->_internal_isperpetual() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        13, this->_internal_isperpetual(), target);
  }

  // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this->_internal_status(), target);
  }

  // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price_tick_size().empty()) {
    const std::string& _s = this->_internal_min_price_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.min_price_tick_size");
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    const std::string& _s = this->_internal_min_quantity_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarket.min_quantity_tick_size");
    target = stream->WriteStringMaybeAliased(16, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeMarket)
  return target;
}

::size_t DerivativeMarket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeMarket)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ticker = 1 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ticker());
  }

  // string oracle_base = 2 [json_name = "oracleBase"];
  if (!this->_internal_oracle_base().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_oracle_base());
  }

  // string oracle_quote = 3 [json_name = "oracleQuote"];
  if (!this->_internal_oracle_quote().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_oracle_quote());
  }

  // string quote_denom = 6 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quote_denom());
  }

  // string market_id = 7 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string initial_margin_ratio = 8 [json_name = "initialMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_initial_margin_ratio().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_initial_margin_ratio());
  }

  // string maintenance_margin_ratio = 9 [json_name = "maintenanceMarginRatio", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maintenance_margin_ratio().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maintenance_margin_ratio());
  }

  // string maker_fee_rate = 10 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maker_fee_rate());
  }

  // string taker_fee_rate = 11 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_taker_fee_rate());
  }

  // string relayer_fee_share_rate = 12 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_relayer_fee_share_rate());
  }

  // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price_tick_size().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_price_tick_size());
  }

  // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_quantity_tick_size());
  }

  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  if (this->_internal_oracle_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_oracle_type());
  }

  // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
  if (this->_internal_oracle_scale_factor() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_oracle_scale_factor());
  }

  // bool isPerpetual = 13 [json_name = "isPerpetual"];
  if (this->_internal_isperpetual() != 0) {
    total_size += 2;
  }

  // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeMarket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeMarket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeMarket::GetClassData() const { return &_class_data_; }


void DerivativeMarket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeMarket*>(&to_msg);
  auto& from = static_cast<const DerivativeMarket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeMarket)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ticker().empty()) {
    _this->_internal_set_ticker(from._internal_ticker());
  }
  if (!from._internal_oracle_base().empty()) {
    _this->_internal_set_oracle_base(from._internal_oracle_base());
  }
  if (!from._internal_oracle_quote().empty()) {
    _this->_internal_set_oracle_quote(from._internal_oracle_quote());
  }
  if (!from._internal_quote_denom().empty()) {
    _this->_internal_set_quote_denom(from._internal_quote_denom());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_initial_margin_ratio().empty()) {
    _this->_internal_set_initial_margin_ratio(from._internal_initial_margin_ratio());
  }
  if (!from._internal_maintenance_margin_ratio().empty()) {
    _this->_internal_set_maintenance_margin_ratio(from._internal_maintenance_margin_ratio());
  }
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_internal_set_maker_fee_rate(from._internal_maker_fee_rate());
  }
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_internal_set_taker_fee_rate(from._internal_taker_fee_rate());
  }
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_internal_set_relayer_fee_share_rate(from._internal_relayer_fee_share_rate());
  }
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_internal_set_min_price_tick_size(from._internal_min_price_tick_size());
  }
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_internal_set_min_quantity_tick_size(from._internal_min_quantity_tick_size());
  }
  if (from._internal_oracle_type() != 0) {
    _this->_internal_set_oracle_type(from._internal_oracle_type());
  }
  if (from._internal_oracle_scale_factor() != 0) {
    _this->_internal_set_oracle_scale_factor(from._internal_oracle_scale_factor());
  }
  if (from._internal_isperpetual() != 0) {
    _this->_internal_set_isperpetual(from._internal_isperpetual());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeMarket::CopyFrom(const DerivativeMarket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeMarket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeMarket::IsInitialized() const {
  return true;
}

void DerivativeMarket::InternalSwap(DerivativeMarket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ticker_, lhs_arena,
                                       &other->_impl_.ticker_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.oracle_base_, lhs_arena,
                                       &other->_impl_.oracle_base_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.oracle_quote_, lhs_arena,
                                       &other->_impl_.oracle_quote_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quote_denom_, lhs_arena,
                                       &other->_impl_.quote_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.initial_margin_ratio_, lhs_arena,
                                       &other->_impl_.initial_margin_ratio_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maintenance_margin_ratio_, lhs_arena,
                                       &other->_impl_.maintenance_margin_ratio_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maker_fee_rate_, lhs_arena,
                                       &other->_impl_.maker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.taker_fee_rate_, lhs_arena,
                                       &other->_impl_.taker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.relayer_fee_share_rate_, lhs_arena,
                                       &other->_impl_.relayer_fee_share_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_price_tick_size_, lhs_arena,
                                       &other->_impl_.min_price_tick_size_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_quantity_tick_size_, lhs_arena,
                                       &other->_impl_.min_quantity_tick_size_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DerivativeMarket, _impl_.status_)
      + sizeof(DerivativeMarket::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(DerivativeMarket, _impl_.oracle_type_)>(
          reinterpret_cast<char*>(&_impl_.oracle_type_),
          reinterpret_cast<char*>(&other->_impl_.oracle_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeMarket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[2]);
}
// ===================================================================

class BinaryOptionsMarket::_Internal {
 public:
};

BinaryOptionsMarket::BinaryOptionsMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.BinaryOptionsMarket)
}
BinaryOptionsMarket::BinaryOptionsMarket(const BinaryOptionsMarket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BinaryOptionsMarket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.oracle_symbol_) {}

    , decltype(_impl_.oracle_provider_) {}

    , decltype(_impl_.admin_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.settlement_price_) {}

    , decltype(_impl_.oracle_type_) {}

    , decltype(_impl_.oracle_scale_factor_) {}

    , decltype(_impl_.expiration_timestamp_) {}

    , decltype(_impl_.settlement_timestamp_) {}

    , decltype(_impl_.status_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ticker().empty()) {
    _this->_impl_.ticker_.Set(from._internal_ticker(), _this->GetArenaForAllocation());
  }
  _impl_.oracle_symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_oracle_symbol().empty()) {
    _this->_impl_.oracle_symbol_.Set(from._internal_oracle_symbol(), _this->GetArenaForAllocation());
  }
  _impl_.oracle_provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_provider_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_oracle_provider().empty()) {
    _this->_impl_.oracle_provider_.Set(from._internal_oracle_provider(), _this->GetArenaForAllocation());
  }
  _impl_.admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_admin().empty()) {
    _this->_impl_.admin_.Set(from._internal_admin(), _this->GetArenaForAllocation());
  }
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quote_denom().empty()) {
    _this->_impl_.quote_denom_.Set(from._internal_quote_denom(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_impl_.maker_fee_rate_.Set(from._internal_maker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_impl_.taker_fee_rate_.Set(from._internal_taker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_impl_.relayer_fee_share_rate_.Set(from._internal_relayer_fee_share_rate(), _this->GetArenaForAllocation());
  }
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_impl_.min_price_tick_size_.Set(from._internal_min_price_tick_size(), _this->GetArenaForAllocation());
  }
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_impl_.min_quantity_tick_size_.Set(from._internal_min_quantity_tick_size(), _this->GetArenaForAllocation());
  }
  _impl_.settlement_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlement_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_settlement_price().empty()) {
    _this->_impl_.settlement_price_.Set(from._internal_settlement_price(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.oracle_type_, &from._impl_.oracle_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.oracle_type_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.BinaryOptionsMarket)
}

inline void BinaryOptionsMarket::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.oracle_symbol_) {}

    , decltype(_impl_.oracle_provider_) {}

    , decltype(_impl_.admin_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.settlement_price_) {}

    , decltype(_impl_.oracle_type_) { 0 }

    , decltype(_impl_.oracle_scale_factor_) { 0u }

    , decltype(_impl_.expiration_timestamp_) { ::int64_t{0} }

    , decltype(_impl_.settlement_timestamp_) { ::int64_t{0} }

    , decltype(_impl_.status_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oracle_symbol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_symbol_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oracle_provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.oracle_provider_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.admin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.admin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settlement_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlement_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BinaryOptionsMarket::~BinaryOptionsMarket() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.BinaryOptionsMarket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BinaryOptionsMarket::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ticker_.Destroy();
  _impl_.oracle_symbol_.Destroy();
  _impl_.oracle_provider_.Destroy();
  _impl_.admin_.Destroy();
  _impl_.quote_denom_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.maker_fee_rate_.Destroy();
  _impl_.taker_fee_rate_.Destroy();
  _impl_.relayer_fee_share_rate_.Destroy();
  _impl_.min_price_tick_size_.Destroy();
  _impl_.min_quantity_tick_size_.Destroy();
  _impl_.settlement_price_.Destroy();
}

void BinaryOptionsMarket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BinaryOptionsMarket::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.BinaryOptionsMarket)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ticker_.ClearToEmpty();
  _impl_.oracle_symbol_.ClearToEmpty();
  _impl_.oracle_provider_.ClearToEmpty();
  _impl_.admin_.ClearToEmpty();
  _impl_.quote_denom_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.maker_fee_rate_.ClearToEmpty();
  _impl_.taker_fee_rate_.ClearToEmpty();
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
  _impl_.min_price_tick_size_.ClearToEmpty();
  _impl_.min_quantity_tick_size_.ClearToEmpty();
  _impl_.settlement_price_.ClearToEmpty();
  ::memset(&_impl_.oracle_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.oracle_type_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BinaryOptionsMarket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ticker = 1 [json_name = "ticker"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ticker();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.ticker"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string oracle_symbol = 2 [json_name = "oracleSymbol"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_oracle_symbol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.oracle_symbol"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string oracle_provider = 3 [json_name = "oracleProvider"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_oracle_provider();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.oracle_provider"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_oracle_type(static_cast<::injective::oracle::v1beta1::OracleType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.oracle_scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 expiration_timestamp = 6 [json_name = "expirationTimestamp"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.expiration_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 settlement_timestamp = 7 [json_name = "settlementTimestamp"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.settlement_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string admin = 8 [json_name = "admin"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_admin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.admin"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quote_denom = 9 [json_name = "quoteDenom"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_quote_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.quote_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 10 [json_name = "marketId"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string maker_fee_rate = 11 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_maker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.maker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string taker_fee_rate = 12 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_taker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.taker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string relayer_fee_share_rate = 13 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_relayer_fee_share_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.relayer_fee_share_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::injective::exchange::v1beta1::MarketStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_min_price_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.min_price_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_min_quantity_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.min_quantity_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string settlement_price = 17 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_settlement_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.BinaryOptionsMarket.settlement_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BinaryOptionsMarket::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.BinaryOptionsMarket)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ticker = 1 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    const std::string& _s = this->_internal_ticker();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.ticker");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string oracle_symbol = 2 [json_name = "oracleSymbol"];
  if (!this->_internal_oracle_symbol().empty()) {
    const std::string& _s = this->_internal_oracle_symbol();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.oracle_symbol");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string oracle_provider = 3 [json_name = "oracleProvider"];
  if (!this->_internal_oracle_provider().empty()) {
    const std::string& _s = this->_internal_oracle_provider();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.oracle_provider");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  if (this->_internal_oracle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_oracle_type(), target);
  }

  // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
  if (this->_internal_oracle_scale_factor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_oracle_scale_factor(), target);
  }

  // int64 expiration_timestamp = 6 [json_name = "expirationTimestamp"];
  if (this->_internal_expiration_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_expiration_timestamp(), target);
  }

  // int64 settlement_timestamp = 7 [json_name = "settlementTimestamp"];
  if (this->_internal_settlement_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        7, this->_internal_settlement_timestamp(), target);
  }

  // string admin = 8 [json_name = "admin"];
  if (!this->_internal_admin().empty()) {
    const std::string& _s = this->_internal_admin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.admin");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // string quote_denom = 9 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    const std::string& _s = this->_internal_quote_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.quote_denom");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string market_id = 10 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.market_id");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // string maker_fee_rate = 11 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_fee_rate().empty()) {
    const std::string& _s = this->_internal_maker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.maker_fee_rate");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // string taker_fee_rate = 12 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_fee_rate().empty()) {
    const std::string& _s = this->_internal_taker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.taker_fee_rate");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // string relayer_fee_share_rate = 13 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    const std::string& _s = this->_internal_relayer_fee_share_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.relayer_fee_share_rate");
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this->_internal_status(), target);
  }

  // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price_tick_size().empty()) {
    const std::string& _s = this->_internal_min_price_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.min_price_tick_size");
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    const std::string& _s = this->_internal_min_quantity_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.min_quantity_tick_size");
    target = stream->WriteStringMaybeAliased(16, _s, target);
  }

  // string settlement_price = 17 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_settlement_price().empty()) {
    const std::string& _s = this->_internal_settlement_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.BinaryOptionsMarket.settlement_price");
    target = stream->WriteStringMaybeAliased(17, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.BinaryOptionsMarket)
  return target;
}

::size_t BinaryOptionsMarket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.BinaryOptionsMarket)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ticker = 1 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ticker());
  }

  // string oracle_symbol = 2 [json_name = "oracleSymbol"];
  if (!this->_internal_oracle_symbol().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_oracle_symbol());
  }

  // string oracle_provider = 3 [json_name = "oracleProvider"];
  if (!this->_internal_oracle_provider().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_oracle_provider());
  }

  // string admin = 8 [json_name = "admin"];
  if (!this->_internal_admin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_admin());
  }

  // string quote_denom = 9 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quote_denom());
  }

  // string market_id = 10 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string maker_fee_rate = 11 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maker_fee_rate());
  }

  // string taker_fee_rate = 12 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_taker_fee_rate());
  }

  // string relayer_fee_share_rate = 13 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_relayer_fee_share_rate());
  }

  // string min_price_tick_size = 15 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price_tick_size().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_price_tick_size());
  }

  // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_quantity_tick_size());
  }

  // string settlement_price = 17 [json_name = "settlementPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_settlement_price().empty()) {
    total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_settlement_price());
  }

  // .injective.oracle.v1beta1.OracleType oracle_type = 4 [json_name = "oracleType"];
  if (this->_internal_oracle_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_oracle_type());
  }

  // uint32 oracle_scale_factor = 5 [json_name = "oracleScaleFactor"];
  if (this->_internal_oracle_scale_factor() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_oracle_scale_factor());
  }

  // int64 expiration_timestamp = 6 [json_name = "expirationTimestamp"];
  if (this->_internal_expiration_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_expiration_timestamp());
  }

  // int64 settlement_timestamp = 7 [json_name = "settlementTimestamp"];
  if (this->_internal_settlement_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_settlement_timestamp());
  }

  // .injective.exchange.v1beta1.MarketStatus status = 14 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BinaryOptionsMarket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BinaryOptionsMarket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BinaryOptionsMarket::GetClassData() const { return &_class_data_; }


void BinaryOptionsMarket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BinaryOptionsMarket*>(&to_msg);
  auto& from = static_cast<const BinaryOptionsMarket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.BinaryOptionsMarket)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ticker().empty()) {
    _this->_internal_set_ticker(from._internal_ticker());
  }
  if (!from._internal_oracle_symbol().empty()) {
    _this->_internal_set_oracle_symbol(from._internal_oracle_symbol());
  }
  if (!from._internal_oracle_provider().empty()) {
    _this->_internal_set_oracle_provider(from._internal_oracle_provider());
  }
  if (!from._internal_admin().empty()) {
    _this->_internal_set_admin(from._internal_admin());
  }
  if (!from._internal_quote_denom().empty()) {
    _this->_internal_set_quote_denom(from._internal_quote_denom());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_internal_set_maker_fee_rate(from._internal_maker_fee_rate());
  }
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_internal_set_taker_fee_rate(from._internal_taker_fee_rate());
  }
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_internal_set_relayer_fee_share_rate(from._internal_relayer_fee_share_rate());
  }
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_internal_set_min_price_tick_size(from._internal_min_price_tick_size());
  }
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_internal_set_min_quantity_tick_size(from._internal_min_quantity_tick_size());
  }
  if (!from._internal_settlement_price().empty()) {
    _this->_internal_set_settlement_price(from._internal_settlement_price());
  }
  if (from._internal_oracle_type() != 0) {
    _this->_internal_set_oracle_type(from._internal_oracle_type());
  }
  if (from._internal_oracle_scale_factor() != 0) {
    _this->_internal_set_oracle_scale_factor(from._internal_oracle_scale_factor());
  }
  if (from._internal_expiration_timestamp() != 0) {
    _this->_internal_set_expiration_timestamp(from._internal_expiration_timestamp());
  }
  if (from._internal_settlement_timestamp() != 0) {
    _this->_internal_set_settlement_timestamp(from._internal_settlement_timestamp());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BinaryOptionsMarket::CopyFrom(const BinaryOptionsMarket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.BinaryOptionsMarket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BinaryOptionsMarket::IsInitialized() const {
  return true;
}

void BinaryOptionsMarket::InternalSwap(BinaryOptionsMarket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ticker_, lhs_arena,
                                       &other->_impl_.ticker_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.oracle_symbol_, lhs_arena,
                                       &other->_impl_.oracle_symbol_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.oracle_provider_, lhs_arena,
                                       &other->_impl_.oracle_provider_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.admin_, lhs_arena,
                                       &other->_impl_.admin_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quote_denom_, lhs_arena,
                                       &other->_impl_.quote_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maker_fee_rate_, lhs_arena,
                                       &other->_impl_.maker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.taker_fee_rate_, lhs_arena,
                                       &other->_impl_.taker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.relayer_fee_share_rate_, lhs_arena,
                                       &other->_impl_.relayer_fee_share_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_price_tick_size_, lhs_arena,
                                       &other->_impl_.min_price_tick_size_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_quantity_tick_size_, lhs_arena,
                                       &other->_impl_.min_quantity_tick_size_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.settlement_price_, lhs_arena,
                                       &other->_impl_.settlement_price_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BinaryOptionsMarket, _impl_.status_)
      + sizeof(BinaryOptionsMarket::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(BinaryOptionsMarket, _impl_.oracle_type_)>(
          reinterpret_cast<char*>(&_impl_.oracle_type_),
          reinterpret_cast<char*>(&other->_impl_.oracle_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BinaryOptionsMarket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[3]);
}
// ===================================================================

class ExpiryFuturesMarketInfo::_Internal {
 public:
};

ExpiryFuturesMarketInfo::ExpiryFuturesMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
}
ExpiryFuturesMarketInfo::ExpiryFuturesMarketInfo(const ExpiryFuturesMarketInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpiryFuturesMarketInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.expiration_twap_start_price_cumulative_) {}

    , decltype(_impl_.settlement_price_) {}

    , decltype(_impl_.expiration_timestamp_) {}

    , decltype(_impl_.twap_start_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.expiration_twap_start_price_cumulative_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.expiration_twap_start_price_cumulative_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_expiration_twap_start_price_cumulative().empty()) {
    _this->_impl_.expiration_twap_start_price_cumulative_.Set(from._internal_expiration_twap_start_price_cumulative(), _this->GetArenaForAllocation());
  }
  _impl_.settlement_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlement_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_settlement_price().empty()) {
    _this->_impl_.settlement_price_.Set(from._internal_settlement_price(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.expiration_timestamp_, &from._impl_.expiration_timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.twap_start_timestamp_) -
    reinterpret_cast<char*>(&_impl_.expiration_timestamp_)) + sizeof(_impl_.twap_start_timestamp_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
}

inline void ExpiryFuturesMarketInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.expiration_twap_start_price_cumulative_) {}

    , decltype(_impl_.settlement_price_) {}

    , decltype(_impl_.expiration_timestamp_) { ::int64_t{0} }

    , decltype(_impl_.twap_start_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.expiration_twap_start_price_cumulative_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.expiration_twap_start_price_cumulative_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settlement_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlement_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExpiryFuturesMarketInfo::~ExpiryFuturesMarketInfo() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpiryFuturesMarketInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.expiration_twap_start_price_cumulative_.Destroy();
  _impl_.settlement_price_.Destroy();
}

void ExpiryFuturesMarketInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpiryFuturesMarketInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.expiration_twap_start_price_cumulative_.ClearToEmpty();
  _impl_.settlement_price_.ClearToEmpty();
  ::memset(&_impl_.expiration_timestamp_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.twap_start_timestamp_) -
      reinterpret_cast<char*>(&_impl_.expiration_timestamp_)) + sizeof(_impl_.twap_start_timestamp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpiryFuturesMarketInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.ExpiryFuturesMarketInfo.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 expiration_timestamp = 2 [json_name = "expirationTimestamp"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.expiration_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 twap_start_timestamp = 3 [json_name = "twapStartTimestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.twap_start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string expiration_twap_start_price_cumulative = 4 [json_name = "expirationTwapStartPriceCumulative", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_expiration_twap_start_price_cumulative();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_twap_start_price_cumulative"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string settlement_price = 5 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_settlement_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.ExpiryFuturesMarketInfo.settlement_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ExpiryFuturesMarketInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.ExpiryFuturesMarketInfo.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int64 expiration_timestamp = 2 [json_name = "expirationTimestamp"];
  if (this->_internal_expiration_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_expiration_timestamp(), target);
  }

  // int64 twap_start_timestamp = 3 [json_name = "twapStartTimestamp"];
  if (this->_internal_twap_start_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_twap_start_timestamp(), target);
  }

  // string expiration_twap_start_price_cumulative = 4 [json_name = "expirationTwapStartPriceCumulative", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_expiration_twap_start_price_cumulative().empty()) {
    const std::string& _s = this->_internal_expiration_twap_start_price_cumulative();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.ExpiryFuturesMarketInfo.expiration_twap_start_price_cumulative");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string settlement_price = 5 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_settlement_price().empty()) {
    const std::string& _s = this->_internal_settlement_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.ExpiryFuturesMarketInfo.settlement_price");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
  return target;
}

::size_t ExpiryFuturesMarketInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string expiration_twap_start_price_cumulative = 4 [json_name = "expirationTwapStartPriceCumulative", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_expiration_twap_start_price_cumulative().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_expiration_twap_start_price_cumulative());
  }

  // string settlement_price = 5 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_settlement_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_settlement_price());
  }

  // int64 expiration_timestamp = 2 [json_name = "expirationTimestamp"];
  if (this->_internal_expiration_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_expiration_timestamp());
  }

  // int64 twap_start_timestamp = 3 [json_name = "twapStartTimestamp"];
  if (this->_internal_twap_start_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_twap_start_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpiryFuturesMarketInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpiryFuturesMarketInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpiryFuturesMarketInfo::GetClassData() const { return &_class_data_; }


void ExpiryFuturesMarketInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpiryFuturesMarketInfo*>(&to_msg);
  auto& from = static_cast<const ExpiryFuturesMarketInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_expiration_twap_start_price_cumulative().empty()) {
    _this->_internal_set_expiration_twap_start_price_cumulative(from._internal_expiration_twap_start_price_cumulative());
  }
  if (!from._internal_settlement_price().empty()) {
    _this->_internal_set_settlement_price(from._internal_settlement_price());
  }
  if (from._internal_expiration_timestamp() != 0) {
    _this->_internal_set_expiration_timestamp(from._internal_expiration_timestamp());
  }
  if (from._internal_twap_start_timestamp() != 0) {
    _this->_internal_set_twap_start_timestamp(from._internal_twap_start_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpiryFuturesMarketInfo::CopyFrom(const ExpiryFuturesMarketInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.ExpiryFuturesMarketInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpiryFuturesMarketInfo::IsInitialized() const {
  return true;
}

void ExpiryFuturesMarketInfo::InternalSwap(ExpiryFuturesMarketInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.expiration_twap_start_price_cumulative_, lhs_arena,
                                       &other->_impl_.expiration_twap_start_price_cumulative_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.settlement_price_, lhs_arena,
                                       &other->_impl_.settlement_price_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExpiryFuturesMarketInfo, _impl_.twap_start_timestamp_)
      + sizeof(ExpiryFuturesMarketInfo::_impl_.twap_start_timestamp_)
      - PROTOBUF_FIELD_OFFSET(ExpiryFuturesMarketInfo, _impl_.expiration_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.expiration_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.expiration_timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpiryFuturesMarketInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[4]);
}
// ===================================================================

class PerpetualMarketInfo::_Internal {
 public:
};

PerpetualMarketInfo::PerpetualMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.PerpetualMarketInfo)
}
PerpetualMarketInfo::PerpetualMarketInfo(const PerpetualMarketInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PerpetualMarketInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.hourly_funding_rate_cap_) {}

    , decltype(_impl_.hourly_interest_rate_) {}

    , decltype(_impl_.next_funding_timestamp_) {}

    , decltype(_impl_.funding_interval_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.hourly_funding_rate_cap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hourly_funding_rate_cap_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hourly_funding_rate_cap().empty()) {
    _this->_impl_.hourly_funding_rate_cap_.Set(from._internal_hourly_funding_rate_cap(), _this->GetArenaForAllocation());
  }
  _impl_.hourly_interest_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hourly_interest_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hourly_interest_rate().empty()) {
    _this->_impl_.hourly_interest_rate_.Set(from._internal_hourly_interest_rate(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.next_funding_timestamp_, &from._impl_.next_funding_timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.funding_interval_) -
    reinterpret_cast<char*>(&_impl_.next_funding_timestamp_)) + sizeof(_impl_.funding_interval_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.PerpetualMarketInfo)
}

inline void PerpetualMarketInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.hourly_funding_rate_cap_) {}

    , decltype(_impl_.hourly_interest_rate_) {}

    , decltype(_impl_.next_funding_timestamp_) { ::int64_t{0} }

    , decltype(_impl_.funding_interval_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hourly_funding_rate_cap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hourly_funding_rate_cap_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hourly_interest_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hourly_interest_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PerpetualMarketInfo::~PerpetualMarketInfo() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.PerpetualMarketInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PerpetualMarketInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.hourly_funding_rate_cap_.Destroy();
  _impl_.hourly_interest_rate_.Destroy();
}

void PerpetualMarketInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PerpetualMarketInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.PerpetualMarketInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.hourly_funding_rate_cap_.ClearToEmpty();
  _impl_.hourly_interest_rate_.ClearToEmpty();
  ::memset(&_impl_.next_funding_timestamp_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.funding_interval_) -
      reinterpret_cast<char*>(&_impl_.next_funding_timestamp_)) + sizeof(_impl_.funding_interval_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PerpetualMarketInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PerpetualMarketInfo.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string hourly_funding_rate_cap = 2 [json_name = "hourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hourly_funding_rate_cap();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PerpetualMarketInfo.hourly_funding_rate_cap"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string hourly_interest_rate = 3 [json_name = "hourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hourly_interest_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PerpetualMarketInfo.hourly_interest_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 next_funding_timestamp = 4 [json_name = "nextFundingTimestamp"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.next_funding_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 funding_interval = 5 [json_name = "fundingInterval"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.funding_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PerpetualMarketInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.PerpetualMarketInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PerpetualMarketInfo.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string hourly_funding_rate_cap = 2 [json_name = "hourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_hourly_funding_rate_cap().empty()) {
    const std::string& _s = this->_internal_hourly_funding_rate_cap();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PerpetualMarketInfo.hourly_funding_rate_cap");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string hourly_interest_rate = 3 [json_name = "hourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_hourly_interest_rate().empty()) {
    const std::string& _s = this->_internal_hourly_interest_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PerpetualMarketInfo.hourly_interest_rate");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // int64 next_funding_timestamp = 4 [json_name = "nextFundingTimestamp"];
  if (this->_internal_next_funding_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_next_funding_timestamp(), target);
  }

  // int64 funding_interval = 5 [json_name = "fundingInterval"];
  if (this->_internal_funding_interval() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_funding_interval(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.PerpetualMarketInfo)
  return target;
}

::size_t PerpetualMarketInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.PerpetualMarketInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string hourly_funding_rate_cap = 2 [json_name = "hourlyFundingRateCap", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_hourly_funding_rate_cap().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_hourly_funding_rate_cap());
  }

  // string hourly_interest_rate = 3 [json_name = "hourlyInterestRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_hourly_interest_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_hourly_interest_rate());
  }

  // int64 next_funding_timestamp = 4 [json_name = "nextFundingTimestamp"];
  if (this->_internal_next_funding_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_next_funding_timestamp());
  }

  // int64 funding_interval = 5 [json_name = "fundingInterval"];
  if (this->_internal_funding_interval() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_funding_interval());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PerpetualMarketInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PerpetualMarketInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PerpetualMarketInfo::GetClassData() const { return &_class_data_; }


void PerpetualMarketInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PerpetualMarketInfo*>(&to_msg);
  auto& from = static_cast<const PerpetualMarketInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.PerpetualMarketInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_hourly_funding_rate_cap().empty()) {
    _this->_internal_set_hourly_funding_rate_cap(from._internal_hourly_funding_rate_cap());
  }
  if (!from._internal_hourly_interest_rate().empty()) {
    _this->_internal_set_hourly_interest_rate(from._internal_hourly_interest_rate());
  }
  if (from._internal_next_funding_timestamp() != 0) {
    _this->_internal_set_next_funding_timestamp(from._internal_next_funding_timestamp());
  }
  if (from._internal_funding_interval() != 0) {
    _this->_internal_set_funding_interval(from._internal_funding_interval());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PerpetualMarketInfo::CopyFrom(const PerpetualMarketInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.PerpetualMarketInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerpetualMarketInfo::IsInitialized() const {
  return true;
}

void PerpetualMarketInfo::InternalSwap(PerpetualMarketInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hourly_funding_rate_cap_, lhs_arena,
                                       &other->_impl_.hourly_funding_rate_cap_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hourly_interest_rate_, lhs_arena,
                                       &other->_impl_.hourly_interest_rate_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PerpetualMarketInfo, _impl_.funding_interval_)
      + sizeof(PerpetualMarketInfo::_impl_.funding_interval_)
      - PROTOBUF_FIELD_OFFSET(PerpetualMarketInfo, _impl_.next_funding_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.next_funding_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.next_funding_timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PerpetualMarketInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[5]);
}
// ===================================================================

class PerpetualMarketFunding::_Internal {
 public:
};

PerpetualMarketFunding::PerpetualMarketFunding(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.PerpetualMarketFunding)
}
PerpetualMarketFunding::PerpetualMarketFunding(const PerpetualMarketFunding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PerpetualMarketFunding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cumulative_funding_) {}

    , decltype(_impl_.cumulative_price_) {}

    , decltype(_impl_.last_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cumulative_funding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_funding_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cumulative_funding().empty()) {
    _this->_impl_.cumulative_funding_.Set(from._internal_cumulative_funding(), _this->GetArenaForAllocation());
  }
  _impl_.cumulative_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cumulative_price().empty()) {
    _this->_impl_.cumulative_price_.Set(from._internal_cumulative_price(), _this->GetArenaForAllocation());
  }
  _this->_impl_.last_timestamp_ = from._impl_.last_timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.PerpetualMarketFunding)
}

inline void PerpetualMarketFunding::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.cumulative_funding_) {}

    , decltype(_impl_.cumulative_price_) {}

    , decltype(_impl_.last_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.cumulative_funding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_funding_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cumulative_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PerpetualMarketFunding::~PerpetualMarketFunding() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.PerpetualMarketFunding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PerpetualMarketFunding::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cumulative_funding_.Destroy();
  _impl_.cumulative_price_.Destroy();
}

void PerpetualMarketFunding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PerpetualMarketFunding::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.PerpetualMarketFunding)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cumulative_funding_.ClearToEmpty();
  _impl_.cumulative_price_.ClearToEmpty();
  _impl_.last_timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PerpetualMarketFunding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string cumulative_funding = 1 [json_name = "cumulativeFunding", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cumulative_funding();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_funding"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cumulative_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 last_timestamp = 3 [json_name = "lastTimestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.last_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PerpetualMarketFunding::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.PerpetualMarketFunding)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string cumulative_funding = 1 [json_name = "cumulativeFunding", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_funding().empty()) {
    const std::string& _s = this->_internal_cumulative_funding();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_funding");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_price().empty()) {
    const std::string& _s = this->_internal_cumulative_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PerpetualMarketFunding.cumulative_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int64 last_timestamp = 3 [json_name = "lastTimestamp"];
  if (this->_internal_last_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_last_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.PerpetualMarketFunding)
  return target;
}

::size_t PerpetualMarketFunding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.PerpetualMarketFunding)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string cumulative_funding = 1 [json_name = "cumulativeFunding", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_funding().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_cumulative_funding());
  }

  // string cumulative_price = 2 [json_name = "cumulativePrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_cumulative_price());
  }

  // int64 last_timestamp = 3 [json_name = "lastTimestamp"];
  if (this->_internal_last_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_last_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PerpetualMarketFunding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PerpetualMarketFunding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PerpetualMarketFunding::GetClassData() const { return &_class_data_; }


void PerpetualMarketFunding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PerpetualMarketFunding*>(&to_msg);
  auto& from = static_cast<const PerpetualMarketFunding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.PerpetualMarketFunding)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_cumulative_funding().empty()) {
    _this->_internal_set_cumulative_funding(from._internal_cumulative_funding());
  }
  if (!from._internal_cumulative_price().empty()) {
    _this->_internal_set_cumulative_price(from._internal_cumulative_price());
  }
  if (from._internal_last_timestamp() != 0) {
    _this->_internal_set_last_timestamp(from._internal_last_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PerpetualMarketFunding::CopyFrom(const PerpetualMarketFunding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.PerpetualMarketFunding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerpetualMarketFunding::IsInitialized() const {
  return true;
}

void PerpetualMarketFunding::InternalSwap(PerpetualMarketFunding* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.cumulative_funding_, lhs_arena,
                                       &other->_impl_.cumulative_funding_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.cumulative_price_, lhs_arena,
                                       &other->_impl_.cumulative_price_, rhs_arena);

  swap(_impl_.last_timestamp_, other->_impl_.last_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PerpetualMarketFunding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[6]);
}
// ===================================================================

class DerivativeMarketSettlementInfo::_Internal {
 public:
};

DerivativeMarketSettlementInfo::DerivativeMarketSettlementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
}
DerivativeMarketSettlementInfo::DerivativeMarketSettlementInfo(const DerivativeMarketSettlementInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeMarketSettlementInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settlement_price_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.settlement_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlement_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_settlement_price().empty()) {
    _this->_impl_.settlement_price_.Set(from._internal_settlement_price(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
}

inline void DerivativeMarketSettlementInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settlement_price_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settlement_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settlement_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeMarketSettlementInfo::~DerivativeMarketSettlementInfo() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeMarketSettlementInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.settlement_price_.Destroy();
}

void DerivativeMarketSettlementInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeMarketSettlementInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.settlement_price_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeMarketSettlementInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarketSettlementInfo.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string settlement_price = 2 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_settlement_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarketSettlementInfo.settlement_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeMarketSettlementInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarketSettlementInfo.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string settlement_price = 2 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_settlement_price().empty()) {
    const std::string& _s = this->_internal_settlement_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarketSettlementInfo.settlement_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
  return target;
}

::size_t DerivativeMarketSettlementInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string settlement_price = 2 [json_name = "settlementPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_settlement_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_settlement_price());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeMarketSettlementInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeMarketSettlementInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeMarketSettlementInfo::GetClassData() const { return &_class_data_; }


void DerivativeMarketSettlementInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeMarketSettlementInfo*>(&to_msg);
  auto& from = static_cast<const DerivativeMarketSettlementInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_settlement_price().empty()) {
    _this->_internal_set_settlement_price(from._internal_settlement_price());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeMarketSettlementInfo::CopyFrom(const DerivativeMarketSettlementInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeMarketSettlementInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeMarketSettlementInfo::IsInitialized() const {
  return true;
}

void DerivativeMarketSettlementInfo::InternalSwap(DerivativeMarketSettlementInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.settlement_price_, lhs_arena,
                                       &other->_impl_.settlement_price_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeMarketSettlementInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[7]);
}
// ===================================================================

class NextFundingTimestamp::_Internal {
 public:
};

NextFundingTimestamp::NextFundingTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.NextFundingTimestamp)
}
NextFundingTimestamp::NextFundingTimestamp(const NextFundingTimestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.NextFundingTimestamp)
}

inline void NextFundingTimestamp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.next_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NextFundingTimestamp::~NextFundingTimestamp() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.NextFundingTimestamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NextFundingTimestamp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void NextFundingTimestamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NextFundingTimestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.NextFundingTimestamp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.next_timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NextFundingTimestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 next_timestamp = 1 [json_name = "nextTimestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.next_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* NextFundingTimestamp::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.NextFundingTimestamp)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 next_timestamp = 1 [json_name = "nextTimestamp"];
  if (this->_internal_next_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_next_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.NextFundingTimestamp)
  return target;
}

::size_t NextFundingTimestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.NextFundingTimestamp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 next_timestamp = 1 [json_name = "nextTimestamp"];
  if (this->_internal_next_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_next_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NextFundingTimestamp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NextFundingTimestamp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NextFundingTimestamp::GetClassData() const { return &_class_data_; }


void NextFundingTimestamp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NextFundingTimestamp*>(&to_msg);
  auto& from = static_cast<const NextFundingTimestamp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.NextFundingTimestamp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_next_timestamp() != 0) {
    _this->_internal_set_next_timestamp(from._internal_next_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NextFundingTimestamp::CopyFrom(const NextFundingTimestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.NextFundingTimestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NextFundingTimestamp::IsInitialized() const {
  return true;
}

void NextFundingTimestamp::InternalSwap(NextFundingTimestamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.next_timestamp_, other->_impl_.next_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NextFundingTimestamp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[8]);
}
// ===================================================================

class MidPriceAndTOB::_Internal {
 public:
};

MidPriceAndTOB::MidPriceAndTOB(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.MidPriceAndTOB)
}
MidPriceAndTOB::MidPriceAndTOB(const MidPriceAndTOB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MidPriceAndTOB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mid_price_) {}

    , decltype(_impl_.best_buy_price_) {}

    , decltype(_impl_.best_sell_price_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mid_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mid_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mid_price().empty()) {
    _this->_impl_.mid_price_.Set(from._internal_mid_price(), _this->GetArenaForAllocation());
  }
  _impl_.best_buy_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.best_buy_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_best_buy_price().empty()) {
    _this->_impl_.best_buy_price_.Set(from._internal_best_buy_price(), _this->GetArenaForAllocation());
  }
  _impl_.best_sell_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.best_sell_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_best_sell_price().empty()) {
    _this->_impl_.best_sell_price_.Set(from._internal_best_sell_price(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.MidPriceAndTOB)
}

inline void MidPriceAndTOB::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.mid_price_) {}

    , decltype(_impl_.best_buy_price_) {}

    , decltype(_impl_.best_sell_price_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mid_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mid_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.best_buy_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.best_buy_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.best_sell_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.best_sell_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MidPriceAndTOB::~MidPriceAndTOB() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.MidPriceAndTOB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MidPriceAndTOB::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mid_price_.Destroy();
  _impl_.best_buy_price_.Destroy();
  _impl_.best_sell_price_.Destroy();
}

void MidPriceAndTOB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MidPriceAndTOB::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.MidPriceAndTOB)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mid_price_.ClearToEmpty();
  _impl_.best_buy_price_.ClearToEmpty();
  _impl_.best_sell_price_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MidPriceAndTOB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mid_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.MidPriceAndTOB.mid_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_best_buy_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.MidPriceAndTOB.best_buy_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_best_sell_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.MidPriceAndTOB.best_sell_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MidPriceAndTOB::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.MidPriceAndTOB)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_mid_price().empty()) {
    const std::string& _s = this->_internal_mid_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.MidPriceAndTOB.mid_price");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_best_buy_price().empty()) {
    const std::string& _s = this->_internal_best_buy_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.MidPriceAndTOB.best_buy_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_best_sell_price().empty()) {
    const std::string& _s = this->_internal_best_sell_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.MidPriceAndTOB.best_sell_price");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.MidPriceAndTOB)
  return target;
}

::size_t MidPriceAndTOB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.MidPriceAndTOB)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_mid_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_mid_price());
  }

  // string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_best_buy_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_best_buy_price());
  }

  // string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_best_sell_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_best_sell_price());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MidPriceAndTOB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MidPriceAndTOB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MidPriceAndTOB::GetClassData() const { return &_class_data_; }


void MidPriceAndTOB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MidPriceAndTOB*>(&to_msg);
  auto& from = static_cast<const MidPriceAndTOB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.MidPriceAndTOB)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mid_price().empty()) {
    _this->_internal_set_mid_price(from._internal_mid_price());
  }
  if (!from._internal_best_buy_price().empty()) {
    _this->_internal_set_best_buy_price(from._internal_best_buy_price());
  }
  if (!from._internal_best_sell_price().empty()) {
    _this->_internal_set_best_sell_price(from._internal_best_sell_price());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MidPriceAndTOB::CopyFrom(const MidPriceAndTOB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.MidPriceAndTOB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MidPriceAndTOB::IsInitialized() const {
  return true;
}

void MidPriceAndTOB::InternalSwap(MidPriceAndTOB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mid_price_, lhs_arena,
                                       &other->_impl_.mid_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.best_buy_price_, lhs_arena,
                                       &other->_impl_.best_buy_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.best_sell_price_, lhs_arena,
                                       &other->_impl_.best_sell_price_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata MidPriceAndTOB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[9]);
}
// ===================================================================

class SpotMarket::_Internal {
 public:
};

SpotMarket::SpotMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SpotMarket)
}
SpotMarket::SpotMarket(const SpotMarket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotMarket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.base_denom_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.status_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ticker().empty()) {
    _this->_impl_.ticker_.Set(from._internal_ticker(), _this->GetArenaForAllocation());
  }
  _impl_.base_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_base_denom().empty()) {
    _this->_impl_.base_denom_.Set(from._internal_base_denom(), _this->GetArenaForAllocation());
  }
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quote_denom().empty()) {
    _this->_impl_.quote_denom_.Set(from._internal_quote_denom(), _this->GetArenaForAllocation());
  }
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_impl_.maker_fee_rate_.Set(from._internal_maker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_impl_.taker_fee_rate_.Set(from._internal_taker_fee_rate(), _this->GetArenaForAllocation());
  }
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_impl_.relayer_fee_share_rate_.Set(from._internal_relayer_fee_share_rate(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_impl_.min_price_tick_size_.Set(from._internal_min_price_tick_size(), _this->GetArenaForAllocation());
  }
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_impl_.min_quantity_tick_size_.Set(from._internal_min_quantity_tick_size(), _this->GetArenaForAllocation());
  }
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SpotMarket)
}

inline void SpotMarket::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ticker_) {}

    , decltype(_impl_.base_denom_) {}

    , decltype(_impl_.quote_denom_) {}

    , decltype(_impl_.maker_fee_rate_) {}

    , decltype(_impl_.taker_fee_rate_) {}

    , decltype(_impl_.relayer_fee_share_rate_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.min_price_tick_size_) {}

    , decltype(_impl_.min_quantity_tick_size_) {}

    , decltype(_impl_.status_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ticker_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ticker_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.base_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quote_denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quote_denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.maker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taker_fee_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relayer_fee_share_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.relayer_fee_share_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_price_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_quantity_tick_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotMarket::~SpotMarket() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SpotMarket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotMarket::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ticker_.Destroy();
  _impl_.base_denom_.Destroy();
  _impl_.quote_denom_.Destroy();
  _impl_.maker_fee_rate_.Destroy();
  _impl_.taker_fee_rate_.Destroy();
  _impl_.relayer_fee_share_rate_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.min_price_tick_size_.Destroy();
  _impl_.min_quantity_tick_size_.Destroy();
}

void SpotMarket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotMarket::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SpotMarket)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ticker_.ClearToEmpty();
  _impl_.base_denom_.ClearToEmpty();
  _impl_.quote_denom_.ClearToEmpty();
  _impl_.maker_fee_rate_.ClearToEmpty();
  _impl_.taker_fee_rate_.ClearToEmpty();
  _impl_.relayer_fee_share_rate_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.min_price_tick_size_.ClearToEmpty();
  _impl_.min_quantity_tick_size_.ClearToEmpty();
  _impl_.status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotMarket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ticker = 1 [json_name = "ticker"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ticker();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.ticker"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string base_denom = 2 [json_name = "baseDenom"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_base_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.base_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quote_denom = 3 [json_name = "quoteDenom"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_quote_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.quote_denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_maker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.maker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_taker_fee_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.taker_fee_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_relayer_fee_share_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.relayer_fee_share_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 7 [json_name = "marketId"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.MarketStatus status = 8 [json_name = "status"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::injective::exchange::v1beta1::MarketStatus>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_price_tick_size = 9 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_min_price_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.min_price_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string min_quantity_tick_size = 10 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_min_quantity_tick_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarket.min_quantity_tick_size"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotMarket::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SpotMarket)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ticker = 1 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    const std::string& _s = this->_internal_ticker();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.ticker");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string base_denom = 2 [json_name = "baseDenom"];
  if (!this->_internal_base_denom().empty()) {
    const std::string& _s = this->_internal_base_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.base_denom");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string quote_denom = 3 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    const std::string& _s = this->_internal_quote_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.quote_denom");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_fee_rate().empty()) {
    const std::string& _s = this->_internal_maker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.maker_fee_rate");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_fee_rate().empty()) {
    const std::string& _s = this->_internal_taker_fee_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.taker_fee_rate");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    const std::string& _s = this->_internal_relayer_fee_share_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.relayer_fee_share_rate");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // string market_id = 7 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.market_id");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // .injective.exchange.v1beta1.MarketStatus status = 8 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_status(), target);
  }

  // string min_price_tick_size = 9 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price_tick_size().empty()) {
    const std::string& _s = this->_internal_min_price_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.min_price_tick_size");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // string min_quantity_tick_size = 10 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    const std::string& _s = this->_internal_min_quantity_tick_size();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarket.min_quantity_tick_size");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SpotMarket)
  return target;
}

::size_t SpotMarket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SpotMarket)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ticker = 1 [json_name = "ticker"];
  if (!this->_internal_ticker().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_ticker());
  }

  // string base_denom = 2 [json_name = "baseDenom"];
  if (!this->_internal_base_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_base_denom());
  }

  // string quote_denom = 3 [json_name = "quoteDenom"];
  if (!this->_internal_quote_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quote_denom());
  }

  // string maker_fee_rate = 4 [json_name = "makerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maker_fee_rate());
  }

  // string taker_fee_rate = 5 [json_name = "takerFeeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_fee_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_taker_fee_rate());
  }

  // string relayer_fee_share_rate = 6 [json_name = "relayerFeeShareRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_relayer_fee_share_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_relayer_fee_share_rate());
  }

  // string market_id = 7 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string min_price_tick_size = 9 [json_name = "minPriceTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_price_tick_size().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_price_tick_size());
  }

  // string min_quantity_tick_size = 10 [json_name = "minQuantityTickSize", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_min_quantity_tick_size().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_min_quantity_tick_size());
  }

  // .injective.exchange.v1beta1.MarketStatus status = 8 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotMarket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotMarket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotMarket::GetClassData() const { return &_class_data_; }


void SpotMarket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotMarket*>(&to_msg);
  auto& from = static_cast<const SpotMarket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SpotMarket)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ticker().empty()) {
    _this->_internal_set_ticker(from._internal_ticker());
  }
  if (!from._internal_base_denom().empty()) {
    _this->_internal_set_base_denom(from._internal_base_denom());
  }
  if (!from._internal_quote_denom().empty()) {
    _this->_internal_set_quote_denom(from._internal_quote_denom());
  }
  if (!from._internal_maker_fee_rate().empty()) {
    _this->_internal_set_maker_fee_rate(from._internal_maker_fee_rate());
  }
  if (!from._internal_taker_fee_rate().empty()) {
    _this->_internal_set_taker_fee_rate(from._internal_taker_fee_rate());
  }
  if (!from._internal_relayer_fee_share_rate().empty()) {
    _this->_internal_set_relayer_fee_share_rate(from._internal_relayer_fee_share_rate());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_min_price_tick_size().empty()) {
    _this->_internal_set_min_price_tick_size(from._internal_min_price_tick_size());
  }
  if (!from._internal_min_quantity_tick_size().empty()) {
    _this->_internal_set_min_quantity_tick_size(from._internal_min_quantity_tick_size());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotMarket::CopyFrom(const SpotMarket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SpotMarket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotMarket::IsInitialized() const {
  return true;
}

void SpotMarket::InternalSwap(SpotMarket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ticker_, lhs_arena,
                                       &other->_impl_.ticker_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.base_denom_, lhs_arena,
                                       &other->_impl_.base_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quote_denom_, lhs_arena,
                                       &other->_impl_.quote_denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maker_fee_rate_, lhs_arena,
                                       &other->_impl_.maker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.taker_fee_rate_, lhs_arena,
                                       &other->_impl_.taker_fee_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.relayer_fee_share_rate_, lhs_arena,
                                       &other->_impl_.relayer_fee_share_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_price_tick_size_, lhs_arena,
                                       &other->_impl_.min_price_tick_size_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.min_quantity_tick_size_, lhs_arena,
                                       &other->_impl_.min_quantity_tick_size_, rhs_arena);
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotMarket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[10]);
}
// ===================================================================

class Deposit::_Internal {
 public:
};

Deposit::Deposit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.Deposit)
}
Deposit::Deposit(const Deposit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Deposit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.available_balance_) {}

    , decltype(_impl_.total_balance_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_available_balance().empty()) {
    _this->_impl_.available_balance_.Set(from._internal_available_balance(), _this->GetArenaForAllocation());
  }
  _impl_.total_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.total_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_total_balance().empty()) {
    _this->_impl_.total_balance_.Set(from._internal_total_balance(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.Deposit)
}

inline void Deposit::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.available_balance_) {}

    , decltype(_impl_.total_balance_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.total_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.total_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Deposit::~Deposit() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.Deposit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Deposit::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.available_balance_.Destroy();
  _impl_.total_balance_.Destroy();
}

void Deposit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Deposit::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.Deposit)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_balance_.ClearToEmpty();
  _impl_.total_balance_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Deposit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string available_balance = 1 [json_name = "availableBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_available_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Deposit.available_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string total_balance = 2 [json_name = "totalBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_total_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Deposit.total_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Deposit::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.Deposit)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string available_balance = 1 [json_name = "availableBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_available_balance().empty()) {
    const std::string& _s = this->_internal_available_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Deposit.available_balance");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string total_balance = 2 [json_name = "totalBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_total_balance().empty()) {
    const std::string& _s = this->_internal_total_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Deposit.total_balance");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.Deposit)
  return target;
}

::size_t Deposit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.Deposit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string available_balance = 1 [json_name = "availableBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_available_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_available_balance());
  }

  // string total_balance = 2 [json_name = "totalBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_total_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_total_balance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Deposit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Deposit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Deposit::GetClassData() const { return &_class_data_; }


void Deposit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Deposit*>(&to_msg);
  auto& from = static_cast<const Deposit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.Deposit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_available_balance().empty()) {
    _this->_internal_set_available_balance(from._internal_available_balance());
  }
  if (!from._internal_total_balance().empty()) {
    _this->_internal_set_total_balance(from._internal_total_balance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Deposit::CopyFrom(const Deposit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.Deposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Deposit::IsInitialized() const {
  return true;
}

void Deposit::InternalSwap(Deposit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.available_balance_, lhs_arena,
                                       &other->_impl_.available_balance_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.total_balance_, lhs_arena,
                                       &other->_impl_.total_balance_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Deposit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[11]);
}
// ===================================================================

class SubaccountTradeNonce::_Internal {
 public:
};

SubaccountTradeNonce::SubaccountTradeNonce(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountTradeNonce)
}
SubaccountTradeNonce::SubaccountTradeNonce(const SubaccountTradeNonce& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountTradeNonce)
}

inline void SubaccountTradeNonce::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.nonce_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SubaccountTradeNonce::~SubaccountTradeNonce() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountTradeNonce)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountTradeNonce::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SubaccountTradeNonce::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountTradeNonce::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountTradeNonce)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nonce_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountTradeNonce::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 nonce = 1 [json_name = "nonce"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.nonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountTradeNonce::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountTradeNonce)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 nonce = 1 [json_name = "nonce"];
  if (this->_internal_nonce() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_nonce(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountTradeNonce)
  return target;
}

::size_t SubaccountTradeNonce::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountTradeNonce)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 nonce = 1 [json_name = "nonce"];
  if (this->_internal_nonce() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_nonce());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountTradeNonce::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountTradeNonce::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountTradeNonce::GetClassData() const { return &_class_data_; }


void SubaccountTradeNonce::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountTradeNonce*>(&to_msg);
  auto& from = static_cast<const SubaccountTradeNonce&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountTradeNonce)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_nonce() != 0) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountTradeNonce::CopyFrom(const SubaccountTradeNonce& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountTradeNonce)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountTradeNonce::IsInitialized() const {
  return true;
}

void SubaccountTradeNonce::InternalSwap(SubaccountTradeNonce* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountTradeNonce::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[12]);
}
// ===================================================================

class OrderInfo::_Internal {
 public:
};

OrderInfo::OrderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.OrderInfo)
}
OrderInfo::OrderInfo(const OrderInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.fee_recipient_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.fee_recipient_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_recipient().empty()) {
    _this->_impl_.fee_recipient_.Set(from._internal_fee_recipient(), _this->GetArenaForAllocation());
  }
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.OrderInfo)
}

inline void OrderInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.fee_recipient_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_recipient_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrderInfo::~OrderInfo() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.OrderInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.fee_recipient_.Destroy();
  _impl_.price_.Destroy();
  _impl_.quantity_.Destroy();
}

void OrderInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.OrderInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.fee_recipient_.ClearToEmpty();
  _impl_.price_.ClearToEmpty();
  _impl_.quantity_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.OrderInfo.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string fee_recipient = 2 [json_name = "feeRecipient"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fee_recipient();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.OrderInfo.fee_recipient"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string price = 3 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.OrderInfo.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 4 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.OrderInfo.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.OrderInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.OrderInfo.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string fee_recipient = 2 [json_name = "feeRecipient"];
  if (!this->_internal_fee_recipient().empty()) {
    const std::string& _s = this->_internal_fee_recipient();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.OrderInfo.fee_recipient");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string price = 3 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.OrderInfo.price");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string quantity = 4 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.OrderInfo.quantity");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.OrderInfo)
  return target;
}

::size_t OrderInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.OrderInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string fee_recipient = 2 [json_name = "feeRecipient"];
  if (!this->_internal_fee_recipient().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fee_recipient());
  }

  // string price = 3 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string quantity = 4 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderInfo::GetClassData() const { return &_class_data_; }


void OrderInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderInfo*>(&to_msg);
  auto& from = static_cast<const OrderInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.OrderInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_fee_recipient().empty()) {
    _this->_internal_set_fee_recipient(from._internal_fee_recipient());
  }
  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderInfo::CopyFrom(const OrderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.OrderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderInfo::IsInitialized() const {
  return true;
}

void OrderInfo::InternalSwap(OrderInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_recipient_, lhs_arena,
                                       &other->_impl_.fee_recipient_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[13]);
}
// ===================================================================

class SpotOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<SpotOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpotOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::OrderInfo& order_info(const SpotOrder* msg);
  static void set_has_order_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::OrderInfo&
SpotOrder::_Internal::order_info(const SpotOrder* msg) {
  return *msg->_impl_.order_info_;
}
SpotOrder::SpotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SpotOrder)
}
SpotOrder::SpotOrder(const SpotOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_info_ = new ::injective::exchange::v1beta1::OrderInfo(*from._impl_.order_info_);
  }
  _this->_impl_.order_type_ = from._impl_.order_type_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SpotOrder)
}

inline void SpotOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) { 0 }

  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotOrder::~SpotOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SpotOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.trigger_price_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_info_;
}

void SpotOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SpotOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_info_ != nullptr);
    _impl_.order_info_->Clear();
  }
  _impl_.order_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotOrder.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_order_type(static_cast<::injective::exchange::v1beta1::OrderType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotOrder.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SpotOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotOrder.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::order_info(this),
        _Internal::order_info(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_order_type(), target);
  }

  // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotOrder.trigger_price");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SpotOrder)
  return target;
}

::size_t SpotOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SpotOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_info_);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_order_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotOrder::GetClassData() const { return &_class_data_; }


void SpotOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotOrder*>(&to_msg);
  auto& from = static_cast<const SpotOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SpotOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order_info()->::injective::exchange::v1beta1::OrderInfo::MergeFrom(
        from._internal_order_info());
  }
  if (from._internal_order_type() != 0) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotOrder::CopyFrom(const SpotOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SpotOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotOrder::IsInitialized() const {
  return true;
}

void SpotOrder::InternalSwap(SpotOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpotOrder, _impl_.order_type_)
      + sizeof(SpotOrder::_impl_.order_type_)
      - PROTOBUF_FIELD_OFFSET(SpotOrder, _impl_.order_info_)>(
          reinterpret_cast<char*>(&_impl_.order_info_),
          reinterpret_cast<char*>(&other->_impl_.order_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[14]);
}
// ===================================================================

class SpotLimitOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<SpotLimitOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpotLimitOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::OrderInfo& order_info(const SpotLimitOrder* msg);
  static void set_has_order_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::OrderInfo&
SpotLimitOrder::_Internal::order_info(const SpotLimitOrder* msg) {
  return *msg->_impl_.order_info_;
}
SpotLimitOrder::SpotLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SpotLimitOrder)
}
SpotLimitOrder::SpotLimitOrder(const SpotLimitOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotLimitOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fillable_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fillable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fillable_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fillable().empty()) {
    _this->_impl_.fillable_.Set(from._internal_fillable(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_info_ = new ::injective::exchange::v1beta1::OrderInfo(*from._impl_.order_info_);
  }
  _this->_impl_.order_type_ = from._impl_.order_type_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SpotLimitOrder)
}

inline void SpotLimitOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fillable_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) { 0 }

  };
  _impl_.fillable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fillable_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotLimitOrder::~SpotLimitOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SpotLimitOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotLimitOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fillable_.Destroy();
  _impl_.trigger_price_.Destroy();
  _impl_.order_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_info_;
}

void SpotLimitOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotLimitOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SpotLimitOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fillable_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  _impl_.order_hash_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_info_ != nullptr);
    _impl_.order_info_->Clear();
  }
  _impl_.order_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotLimitOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_order_type(static_cast<::injective::exchange::v1beta1::OrderType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string fillable = 3 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fillable();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotLimitOrder.fillable"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotLimitOrder.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes order_hash = 5 [json_name = "orderHash"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotLimitOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SpotLimitOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order_info(this),
        _Internal::order_info(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_order_type(), target);
  }

  // string fillable = 3 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fillable().empty()) {
    const std::string& _s = this->_internal_fillable();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotLimitOrder.fillable");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotLimitOrder.trigger_price");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // bytes order_hash = 5 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SpotLimitOrder)
  return target;
}

::size_t SpotLimitOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SpotLimitOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string fillable = 3 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fillable().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fillable());
  }

  // string trigger_price = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // bytes order_hash = 5 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_order_hash());
  }

  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_info_);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_order_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotLimitOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotLimitOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotLimitOrder::GetClassData() const { return &_class_data_; }


void SpotLimitOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotLimitOrder*>(&to_msg);
  auto& from = static_cast<const SpotLimitOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SpotLimitOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_fillable().empty()) {
    _this->_internal_set_fillable(from._internal_fillable());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order_info()->::injective::exchange::v1beta1::OrderInfo::MergeFrom(
        from._internal_order_info());
  }
  if (from._internal_order_type() != 0) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotLimitOrder::CopyFrom(const SpotLimitOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SpotLimitOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotLimitOrder::IsInitialized() const {
  return true;
}

void SpotLimitOrder::InternalSwap(SpotLimitOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fillable_, lhs_arena,
                                       &other->_impl_.fillable_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpotLimitOrder, _impl_.order_type_)
      + sizeof(SpotLimitOrder::_impl_.order_type_)
      - PROTOBUF_FIELD_OFFSET(SpotLimitOrder, _impl_.order_info_)>(
          reinterpret_cast<char*>(&_impl_.order_info_),
          reinterpret_cast<char*>(&other->_impl_.order_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotLimitOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[15]);
}
// ===================================================================

class SpotMarketOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<SpotMarketOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpotMarketOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::OrderInfo& order_info(const SpotMarketOrder* msg);
  static void set_has_order_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::OrderInfo&
SpotMarketOrder::_Internal::order_info(const SpotMarketOrder* msg) {
  return *msg->_impl_.order_info_;
}
SpotMarketOrder::SpotMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SpotMarketOrder)
}
SpotMarketOrder::SpotMarketOrder(const SpotMarketOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpotMarketOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.balance_hold_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.balance_hold_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.balance_hold_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_balance_hold().empty()) {
    _this->_impl_.balance_hold_.Set(from._internal_balance_hold(), _this->GetArenaForAllocation());
  }
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_info_ = new ::injective::exchange::v1beta1::OrderInfo(*from._impl_.order_info_);
  }
  _this->_impl_.order_type_ = from._impl_.order_type_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SpotMarketOrder)
}

inline void SpotMarketOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.balance_hold_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) { 0 }

  };
  _impl_.balance_hold_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.balance_hold_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpotMarketOrder::~SpotMarketOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SpotMarketOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpotMarketOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.balance_hold_.Destroy();
  _impl_.order_hash_.Destroy();
  _impl_.trigger_price_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_info_;
}

void SpotMarketOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpotMarketOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SpotMarketOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.balance_hold_.ClearToEmpty();
  _impl_.order_hash_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_info_ != nullptr);
    _impl_.order_info_->Clear();
  }
  _impl_.order_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpotMarketOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string balance_hold = 2 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_balance_hold();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarketOrder.balance_hold"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes order_hash = 3 [json_name = "orderHash"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderType order_type = 4 [json_name = "orderType"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_order_type(static_cast<::injective::exchange::v1beta1::OrderType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SpotMarketOrder.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpotMarketOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SpotMarketOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order_info(this),
        _Internal::order_info(this).GetCachedSize(), target, stream);
  }

  // string balance_hold = 2 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_balance_hold().empty()) {
    const std::string& _s = this->_internal_balance_hold();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarketOrder.balance_hold");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // bytes order_hash = 3 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 4 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_order_type(), target);
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SpotMarketOrder.trigger_price");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SpotMarketOrder)
  return target;
}

::size_t SpotMarketOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SpotMarketOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string balance_hold = 2 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_balance_hold().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_balance_hold());
  }

  // bytes order_hash = 3 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_order_hash());
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_info_);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 4 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_order_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpotMarketOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpotMarketOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpotMarketOrder::GetClassData() const { return &_class_data_; }


void SpotMarketOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpotMarketOrder*>(&to_msg);
  auto& from = static_cast<const SpotMarketOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SpotMarketOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_balance_hold().empty()) {
    _this->_internal_set_balance_hold(from._internal_balance_hold());
  }
  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order_info()->::injective::exchange::v1beta1::OrderInfo::MergeFrom(
        from._internal_order_info());
  }
  if (from._internal_order_type() != 0) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpotMarketOrder::CopyFrom(const SpotMarketOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SpotMarketOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpotMarketOrder::IsInitialized() const {
  return true;
}

void SpotMarketOrder::InternalSwap(SpotMarketOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.balance_hold_, lhs_arena,
                                       &other->_impl_.balance_hold_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpotMarketOrder, _impl_.order_type_)
      + sizeof(SpotMarketOrder::_impl_.order_type_)
      - PROTOBUF_FIELD_OFFSET(SpotMarketOrder, _impl_.order_info_)>(
          reinterpret_cast<char*>(&_impl_.order_info_),
          reinterpret_cast<char*>(&other->_impl_.order_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpotMarketOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[16]);
}
// ===================================================================

class DerivativeOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<DerivativeOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DerivativeOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::OrderInfo& order_info(const DerivativeOrder* msg);
  static void set_has_order_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::OrderInfo&
DerivativeOrder::_Internal::order_info(const DerivativeOrder* msg) {
  return *msg->_impl_.order_info_;
}
DerivativeOrder::DerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeOrder)
}
DerivativeOrder::DerivativeOrder(const DerivativeOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.margin_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_margin().empty()) {
    _this->_impl_.margin_.Set(from._internal_margin(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_info_ = new ::injective::exchange::v1beta1::OrderInfo(*from._impl_.order_info_);
  }
  _this->_impl_.order_type_ = from._impl_.order_type_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeOrder)
}

inline void DerivativeOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.margin_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) { 0 }

  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeOrder::~DerivativeOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.margin_.Destroy();
  _impl_.trigger_price_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_info_;
}

void DerivativeOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.margin_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_info_ != nullptr);
    _impl_.order_info_->Clear();
  }
  _impl_.order_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeOrder.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_order_type(static_cast<::injective::exchange::v1beta1::OrderType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_margin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeOrder.margin"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeOrder.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeOrder.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::order_info(this),
        _Internal::order_info(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_order_type(), target);
  }

  // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    const std::string& _s = this->_internal_margin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeOrder.margin");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeOrder.trigger_price");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeOrder)
  return target;
}

::size_t DerivativeOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_margin());
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // .injective.exchange.v1beta1.OrderInfo order_info = 2 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_info_);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 3 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_order_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeOrder::GetClassData() const { return &_class_data_; }


void DerivativeOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeOrder*>(&to_msg);
  auto& from = static_cast<const DerivativeOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_margin().empty()) {
    _this->_internal_set_margin(from._internal_margin());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order_info()->::injective::exchange::v1beta1::OrderInfo::MergeFrom(
        from._internal_order_info());
  }
  if (from._internal_order_type() != 0) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeOrder::CopyFrom(const DerivativeOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeOrder::IsInitialized() const {
  return true;
}

void DerivativeOrder::InternalSwap(DerivativeOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.margin_, lhs_arena,
                                       &other->_impl_.margin_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DerivativeOrder, _impl_.order_type_)
      + sizeof(DerivativeOrder::_impl_.order_type_)
      - PROTOBUF_FIELD_OFFSET(DerivativeOrder, _impl_.order_info_)>(
          reinterpret_cast<char*>(&_impl_.order_info_),
          reinterpret_cast<char*>(&other->_impl_.order_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[17]);
}
// ===================================================================

class SubaccountOrderbookMetadata::_Internal {
 public:
};

SubaccountOrderbookMetadata::SubaccountOrderbookMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
}
SubaccountOrderbookMetadata::SubaccountOrderbookMetadata(const SubaccountOrderbookMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountOrderbookMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.aggregate_reduce_only_quantity_) {}

    , decltype(_impl_.aggregate_vanilla_quantity_) {}

    , decltype(_impl_.vanilla_limit_order_count_) {}

    , decltype(_impl_.reduce_only_limit_order_count_) {}

    , decltype(_impl_.vanilla_conditional_order_count_) {}

    , decltype(_impl_.reduce_only_conditional_order_count_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.aggregate_reduce_only_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.aggregate_reduce_only_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_aggregate_reduce_only_quantity().empty()) {
    _this->_impl_.aggregate_reduce_only_quantity_.Set(from._internal_aggregate_reduce_only_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.aggregate_vanilla_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.aggregate_vanilla_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_aggregate_vanilla_quantity().empty()) {
    _this->_impl_.aggregate_vanilla_quantity_.Set(from._internal_aggregate_vanilla_quantity(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.vanilla_limit_order_count_, &from._impl_.vanilla_limit_order_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.reduce_only_conditional_order_count_) -
    reinterpret_cast<char*>(&_impl_.vanilla_limit_order_count_)) + sizeof(_impl_.reduce_only_conditional_order_count_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
}

inline void SubaccountOrderbookMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.aggregate_reduce_only_quantity_) {}

    , decltype(_impl_.aggregate_vanilla_quantity_) {}

    , decltype(_impl_.vanilla_limit_order_count_) { 0u }

    , decltype(_impl_.reduce_only_limit_order_count_) { 0u }

    , decltype(_impl_.vanilla_conditional_order_count_) { 0u }

    , decltype(_impl_.reduce_only_conditional_order_count_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.aggregate_reduce_only_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.aggregate_reduce_only_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.aggregate_vanilla_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.aggregate_vanilla_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountOrderbookMetadata::~SubaccountOrderbookMetadata() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountOrderbookMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.aggregate_reduce_only_quantity_.Destroy();
  _impl_.aggregate_vanilla_quantity_.Destroy();
}

void SubaccountOrderbookMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountOrderbookMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.aggregate_reduce_only_quantity_.ClearToEmpty();
  _impl_.aggregate_vanilla_quantity_.ClearToEmpty();
  ::memset(&_impl_.vanilla_limit_order_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.reduce_only_conditional_order_count_) -
      reinterpret_cast<char*>(&_impl_.vanilla_limit_order_count_)) + sizeof(_impl_.reduce_only_conditional_order_count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountOrderbookMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 vanilla_limit_order_count = 1 [json_name = "vanillaLimitOrderCount"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.vanilla_limit_order_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 reduce_only_limit_order_count = 2 [json_name = "reduceOnlyLimitOrderCount"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.reduce_only_limit_order_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string aggregate_reduce_only_quantity = 3 [json_name = "aggregateReduceOnlyQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_aggregate_reduce_only_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_reduce_only_quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string aggregate_vanilla_quantity = 4 [json_name = "aggregateVanillaQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_aggregate_vanilla_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_vanilla_quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 vanilla_conditional_order_count = 5 [json_name = "vanillaConditionalOrderCount"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.vanilla_conditional_order_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 reduce_only_conditional_order_count = 6 [json_name = "reduceOnlyConditionalOrderCount"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.reduce_only_conditional_order_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountOrderbookMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 vanilla_limit_order_count = 1 [json_name = "vanillaLimitOrderCount"];
  if (this->_internal_vanilla_limit_order_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_vanilla_limit_order_count(), target);
  }

  // uint32 reduce_only_limit_order_count = 2 [json_name = "reduceOnlyLimitOrderCount"];
  if (this->_internal_reduce_only_limit_order_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_reduce_only_limit_order_count(), target);
  }

  // string aggregate_reduce_only_quantity = 3 [json_name = "aggregateReduceOnlyQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_aggregate_reduce_only_quantity().empty()) {
    const std::string& _s = this->_internal_aggregate_reduce_only_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_reduce_only_quantity");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string aggregate_vanilla_quantity = 4 [json_name = "aggregateVanillaQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_aggregate_vanilla_quantity().empty()) {
    const std::string& _s = this->_internal_aggregate_vanilla_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SubaccountOrderbookMetadata.aggregate_vanilla_quantity");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // uint32 vanilla_conditional_order_count = 5 [json_name = "vanillaConditionalOrderCount"];
  if (this->_internal_vanilla_conditional_order_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_vanilla_conditional_order_count(), target);
  }

  // uint32 reduce_only_conditional_order_count = 6 [json_name = "reduceOnlyConditionalOrderCount"];
  if (this->_internal_reduce_only_conditional_order_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_reduce_only_conditional_order_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
  return target;
}

::size_t SubaccountOrderbookMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string aggregate_reduce_only_quantity = 3 [json_name = "aggregateReduceOnlyQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_aggregate_reduce_only_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_aggregate_reduce_only_quantity());
  }

  // string aggregate_vanilla_quantity = 4 [json_name = "aggregateVanillaQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_aggregate_vanilla_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_aggregate_vanilla_quantity());
  }

  // uint32 vanilla_limit_order_count = 1 [json_name = "vanillaLimitOrderCount"];
  if (this->_internal_vanilla_limit_order_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_vanilla_limit_order_count());
  }

  // uint32 reduce_only_limit_order_count = 2 [json_name = "reduceOnlyLimitOrderCount"];
  if (this->_internal_reduce_only_limit_order_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_reduce_only_limit_order_count());
  }

  // uint32 vanilla_conditional_order_count = 5 [json_name = "vanillaConditionalOrderCount"];
  if (this->_internal_vanilla_conditional_order_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_vanilla_conditional_order_count());
  }

  // uint32 reduce_only_conditional_order_count = 6 [json_name = "reduceOnlyConditionalOrderCount"];
  if (this->_internal_reduce_only_conditional_order_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_reduce_only_conditional_order_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountOrderbookMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountOrderbookMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountOrderbookMetadata::GetClassData() const { return &_class_data_; }


void SubaccountOrderbookMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountOrderbookMetadata*>(&to_msg);
  auto& from = static_cast<const SubaccountOrderbookMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_aggregate_reduce_only_quantity().empty()) {
    _this->_internal_set_aggregate_reduce_only_quantity(from._internal_aggregate_reduce_only_quantity());
  }
  if (!from._internal_aggregate_vanilla_quantity().empty()) {
    _this->_internal_set_aggregate_vanilla_quantity(from._internal_aggregate_vanilla_quantity());
  }
  if (from._internal_vanilla_limit_order_count() != 0) {
    _this->_internal_set_vanilla_limit_order_count(from._internal_vanilla_limit_order_count());
  }
  if (from._internal_reduce_only_limit_order_count() != 0) {
    _this->_internal_set_reduce_only_limit_order_count(from._internal_reduce_only_limit_order_count());
  }
  if (from._internal_vanilla_conditional_order_count() != 0) {
    _this->_internal_set_vanilla_conditional_order_count(from._internal_vanilla_conditional_order_count());
  }
  if (from._internal_reduce_only_conditional_order_count() != 0) {
    _this->_internal_set_reduce_only_conditional_order_count(from._internal_reduce_only_conditional_order_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountOrderbookMetadata::CopyFrom(const SubaccountOrderbookMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountOrderbookMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountOrderbookMetadata::IsInitialized() const {
  return true;
}

void SubaccountOrderbookMetadata::InternalSwap(SubaccountOrderbookMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.aggregate_reduce_only_quantity_, lhs_arena,
                                       &other->_impl_.aggregate_reduce_only_quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.aggregate_vanilla_quantity_, lhs_arena,
                                       &other->_impl_.aggregate_vanilla_quantity_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubaccountOrderbookMetadata, _impl_.reduce_only_conditional_order_count_)
      + sizeof(SubaccountOrderbookMetadata::_impl_.reduce_only_conditional_order_count_)
      - PROTOBUF_FIELD_OFFSET(SubaccountOrderbookMetadata, _impl_.vanilla_limit_order_count_)>(
          reinterpret_cast<char*>(&_impl_.vanilla_limit_order_count_),
          reinterpret_cast<char*>(&other->_impl_.vanilla_limit_order_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountOrderbookMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[18]);
}
// ===================================================================

class SubaccountOrder::_Internal {
 public:
};

SubaccountOrder::SubaccountOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountOrder)
}
SubaccountOrder::SubaccountOrder(const SubaccountOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.isreduceonly_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  _this->_impl_.isreduceonly_ = from._impl_.isreduceonly_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountOrder)
}

inline void SubaccountOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.isreduceonly_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountOrder::~SubaccountOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_.Destroy();
  _impl_.quantity_.Destroy();
}

void SubaccountOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_.ClearToEmpty();
  _impl_.quantity_.ClearToEmpty();
  _impl_.isreduceonly_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SubaccountOrder.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.SubaccountOrder.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isReduceOnly = 3 [json_name = "isReduceOnly"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.isreduceonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SubaccountOrder.price");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.SubaccountOrder.quantity");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // bool isReduceOnly = 3 [json_name = "isReduceOnly"];
  if (this->_internal_isreduceonly() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_isreduceonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountOrder)
  return target;
}

::size_t SubaccountOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // bool isReduceOnly = 3 [json_name = "isReduceOnly"];
  if (this->_internal_isreduceonly() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountOrder::GetClassData() const { return &_class_data_; }


void SubaccountOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountOrder*>(&to_msg);
  auto& from = static_cast<const SubaccountOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (from._internal_isreduceonly() != 0) {
    _this->_internal_set_isreduceonly(from._internal_isreduceonly());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountOrder::CopyFrom(const SubaccountOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountOrder::IsInitialized() const {
  return true;
}

void SubaccountOrder::InternalSwap(SubaccountOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);

  swap(_impl_.isreduceonly_, other->_impl_.isreduceonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[19]);
}
// ===================================================================

class SubaccountOrderData::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountOrderData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountOrderData, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::SubaccountOrder& order(const SubaccountOrderData* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::SubaccountOrder&
SubaccountOrderData::_Internal::order(const SubaccountOrderData* msg) {
  return *msg->_impl_.order_;
}
SubaccountOrderData::SubaccountOrderData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountOrderData)
}
SubaccountOrderData::SubaccountOrderData(const SubaccountOrderData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountOrderData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::injective::exchange::v1beta1::SubaccountOrder(*from._impl_.order_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountOrderData)
}

inline void SubaccountOrderData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_){nullptr}
  };
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountOrderData::~SubaccountOrderData() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountOrderData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountOrderData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.order_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_;
}

void SubaccountOrderData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountOrderData::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountOrderData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.order_hash_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountOrderData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.SubaccountOrder order = 1 [json_name = "order"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes order_hash = 2 [json_name = "orderHash"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountOrderData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountOrderData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.SubaccountOrder order = 1 [json_name = "order"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  // bytes order_hash = 2 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountOrderData)
  return target;
}

::size_t SubaccountOrderData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountOrderData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes order_hash = 2 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_order_hash());
  }

  // .injective.exchange.v1beta1.SubaccountOrder order = 1 [json_name = "order"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountOrderData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountOrderData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountOrderData::GetClassData() const { return &_class_data_; }


void SubaccountOrderData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountOrderData*>(&to_msg);
  auto& from = static_cast<const SubaccountOrderData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountOrderData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::injective::exchange::v1beta1::SubaccountOrder::MergeFrom(
        from._internal_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountOrderData::CopyFrom(const SubaccountOrderData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountOrderData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountOrderData::IsInitialized() const {
  return true;
}

void SubaccountOrderData::InternalSwap(SubaccountOrderData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  swap(_impl_.order_, other->_impl_.order_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountOrderData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[20]);
}
// ===================================================================

class DerivativeLimitOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<DerivativeLimitOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DerivativeLimitOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::OrderInfo& order_info(const DerivativeLimitOrder* msg);
  static void set_has_order_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::OrderInfo&
DerivativeLimitOrder::_Internal::order_info(const DerivativeLimitOrder* msg) {
  return *msg->_impl_.order_info_;
}
DerivativeLimitOrder::DerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeLimitOrder)
}
DerivativeLimitOrder::DerivativeLimitOrder(const DerivativeLimitOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeLimitOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.margin_) {}

    , decltype(_impl_.fillable_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_margin().empty()) {
    _this->_impl_.margin_.Set(from._internal_margin(), _this->GetArenaForAllocation());
  }
  _impl_.fillable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fillable_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fillable().empty()) {
    _this->_impl_.fillable_.Set(from._internal_fillable(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_info_ = new ::injective::exchange::v1beta1::OrderInfo(*from._impl_.order_info_);
  }
  _this->_impl_.order_type_ = from._impl_.order_type_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeLimitOrder)
}

inline void DerivativeLimitOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.margin_) {}

    , decltype(_impl_.fillable_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) { 0 }

  };
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fillable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fillable_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeLimitOrder::~DerivativeLimitOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeLimitOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeLimitOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.margin_.Destroy();
  _impl_.fillable_.Destroy();
  _impl_.trigger_price_.Destroy();
  _impl_.order_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_info_;
}

void DerivativeLimitOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeLimitOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeLimitOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.margin_.ClearToEmpty();
  _impl_.fillable_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  _impl_.order_hash_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_info_ != nullptr);
    _impl_.order_info_->Clear();
  }
  _impl_.order_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeLimitOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_order_type(static_cast<::injective::exchange::v1beta1::OrderType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_margin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeLimitOrder.margin"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string fillable = 4 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fillable();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeLimitOrder.fillable"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeLimitOrder.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes order_hash = 6 [json_name = "orderHash"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeLimitOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeLimitOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order_info(this),
        _Internal::order_info(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_order_type(), target);
  }

  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    const std::string& _s = this->_internal_margin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeLimitOrder.margin");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string fillable = 4 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fillable().empty()) {
    const std::string& _s = this->_internal_fillable();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeLimitOrder.fillable");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeLimitOrder.trigger_price");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // bytes order_hash = 6 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeLimitOrder)
  return target;
}

::size_t DerivativeLimitOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeLimitOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_margin());
  }

  // string fillable = 4 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fillable().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fillable());
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // bytes order_hash = 6 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_order_hash());
  }

  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_info_);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_order_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeLimitOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeLimitOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeLimitOrder::GetClassData() const { return &_class_data_; }


void DerivativeLimitOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeLimitOrder*>(&to_msg);
  auto& from = static_cast<const DerivativeLimitOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeLimitOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_margin().empty()) {
    _this->_internal_set_margin(from._internal_margin());
  }
  if (!from._internal_fillable().empty()) {
    _this->_internal_set_fillable(from._internal_fillable());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order_info()->::injective::exchange::v1beta1::OrderInfo::MergeFrom(
        from._internal_order_info());
  }
  if (from._internal_order_type() != 0) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeLimitOrder::CopyFrom(const DerivativeLimitOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeLimitOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeLimitOrder::IsInitialized() const {
  return true;
}

void DerivativeLimitOrder::InternalSwap(DerivativeLimitOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.margin_, lhs_arena,
                                       &other->_impl_.margin_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fillable_, lhs_arena,
                                       &other->_impl_.fillable_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DerivativeLimitOrder, _impl_.order_type_)
      + sizeof(DerivativeLimitOrder::_impl_.order_type_)
      - PROTOBUF_FIELD_OFFSET(DerivativeLimitOrder, _impl_.order_info_)>(
          reinterpret_cast<char*>(&_impl_.order_info_),
          reinterpret_cast<char*>(&other->_impl_.order_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeLimitOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[21]);
}
// ===================================================================

class DerivativeMarketOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<DerivativeMarketOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DerivativeMarketOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::OrderInfo& order_info(const DerivativeMarketOrder* msg);
  static void set_has_order_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::OrderInfo&
DerivativeMarketOrder::_Internal::order_info(const DerivativeMarketOrder* msg) {
  return *msg->_impl_.order_info_;
}
DerivativeMarketOrder::DerivativeMarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeMarketOrder)
}
DerivativeMarketOrder::DerivativeMarketOrder(const DerivativeMarketOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeMarketOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.margin_) {}

    , decltype(_impl_.margin_hold_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_margin().empty()) {
    _this->_impl_.margin_.Set(from._internal_margin(), _this->GetArenaForAllocation());
  }
  _impl_.margin_hold_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_hold_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_margin_hold().empty()) {
    _this->_impl_.margin_hold_.Set(from._internal_margin_hold(), _this->GetArenaForAllocation());
  }
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trigger_price().empty()) {
    _this->_impl_.trigger_price_.Set(from._internal_trigger_price(), _this->GetArenaForAllocation());
  }
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_info_ = new ::injective::exchange::v1beta1::OrderInfo(*from._impl_.order_info_);
  }
  _this->_impl_.order_type_ = from._impl_.order_type_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeMarketOrder)
}

inline void DerivativeMarketOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.margin_) {}

    , decltype(_impl_.margin_hold_) {}

    , decltype(_impl_.trigger_price_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.order_info_){nullptr}
    , decltype(_impl_.order_type_) { 0 }

  };
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.margin_hold_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_hold_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.trigger_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trigger_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeMarketOrder::~DerivativeMarketOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeMarketOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeMarketOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.margin_.Destroy();
  _impl_.margin_hold_.Destroy();
  _impl_.trigger_price_.Destroy();
  _impl_.order_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_info_;
}

void DerivativeMarketOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeMarketOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeMarketOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.margin_.ClearToEmpty();
  _impl_.margin_hold_.ClearToEmpty();
  _impl_.trigger_price_.ClearToEmpty();
  _impl_.order_hash_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_info_ != nullptr);
    _impl_.order_info_->Clear();
  }
  _impl_.order_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeMarketOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_order_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_order_type(static_cast<::injective::exchange::v1beta1::OrderType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_margin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarketOrder.margin"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string margin_hold = 4 [json_name = "marginHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_margin_hold();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarketOrder.margin_hold"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_trigger_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarketOrder.trigger_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes order_hash = 6 [json_name = "orderHash"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeMarketOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeMarketOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::order_info(this),
        _Internal::order_info(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_order_type(), target);
  }

  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    const std::string& _s = this->_internal_margin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarketOrder.margin");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string margin_hold = 4 [json_name = "marginHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin_hold().empty()) {
    const std::string& _s = this->_internal_margin_hold();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarketOrder.margin_hold");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    const std::string& _s = this->_internal_trigger_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarketOrder.trigger_price");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // bytes order_hash = 6 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeMarketOrder)
  return target;
}

::size_t DerivativeMarketOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeMarketOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_margin());
  }

  // string margin_hold = 4 [json_name = "marginHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin_hold().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_margin_hold());
  }

  // string trigger_price = 5 [json_name = "triggerPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_trigger_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_trigger_price());
  }

  // bytes order_hash = 6 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_order_hash());
  }

  // .injective.exchange.v1beta1.OrderInfo order_info = 1 [json_name = "orderInfo", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_info_);
  }

  // .injective.exchange.v1beta1.OrderType order_type = 2 [json_name = "orderType"];
  if (this->_internal_order_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_order_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeMarketOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeMarketOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeMarketOrder::GetClassData() const { return &_class_data_; }


void DerivativeMarketOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeMarketOrder*>(&to_msg);
  auto& from = static_cast<const DerivativeMarketOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeMarketOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_margin().empty()) {
    _this->_internal_set_margin(from._internal_margin());
  }
  if (!from._internal_margin_hold().empty()) {
    _this->_internal_set_margin_hold(from._internal_margin_hold());
  }
  if (!from._internal_trigger_price().empty()) {
    _this->_internal_set_trigger_price(from._internal_trigger_price());
  }
  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order_info()->::injective::exchange::v1beta1::OrderInfo::MergeFrom(
        from._internal_order_info());
  }
  if (from._internal_order_type() != 0) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeMarketOrder::CopyFrom(const DerivativeMarketOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeMarketOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeMarketOrder::IsInitialized() const {
  return true;
}

void DerivativeMarketOrder::InternalSwap(DerivativeMarketOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.margin_, lhs_arena,
                                       &other->_impl_.margin_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.margin_hold_, lhs_arena,
                                       &other->_impl_.margin_hold_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trigger_price_, lhs_arena,
                                       &other->_impl_.trigger_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DerivativeMarketOrder, _impl_.order_type_)
      + sizeof(DerivativeMarketOrder::_impl_.order_type_)
      - PROTOBUF_FIELD_OFFSET(DerivativeMarketOrder, _impl_.order_info_)>(
          reinterpret_cast<char*>(&_impl_.order_info_),
          reinterpret_cast<char*>(&other->_impl_.order_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeMarketOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[22]);
}
// ===================================================================

class Position::_Internal {
 public:
};

Position::Position(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.Position)
}
Position::Position(const Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Position* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.quantity_) {}

    , decltype(_impl_.entry_price_) {}

    , decltype(_impl_.margin_) {}

    , decltype(_impl_.cumulative_funding_entry_) {}

    , decltype(_impl_.islong_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.entry_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.entry_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_entry_price().empty()) {
    _this->_impl_.entry_price_.Set(from._internal_entry_price(), _this->GetArenaForAllocation());
  }
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_margin().empty()) {
    _this->_impl_.margin_.Set(from._internal_margin(), _this->GetArenaForAllocation());
  }
  _impl_.cumulative_funding_entry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_funding_entry_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cumulative_funding_entry().empty()) {
    _this->_impl_.cumulative_funding_entry_.Set(from._internal_cumulative_funding_entry(), _this->GetArenaForAllocation());
  }
  _this->_impl_.islong_ = from._impl_.islong_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.Position)
}

inline void Position::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.quantity_) {}

    , decltype(_impl_.entry_price_) {}

    , decltype(_impl_.margin_) {}

    , decltype(_impl_.cumulative_funding_entry_) {}

    , decltype(_impl_.islong_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.entry_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.entry_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cumulative_funding_entry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_funding_entry_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.Position)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Position::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.quantity_.Destroy();
  _impl_.entry_price_.Destroy();
  _impl_.margin_.Destroy();
  _impl_.cumulative_funding_entry_.Destroy();
}

void Position::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.Position)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.quantity_.ClearToEmpty();
  _impl_.entry_price_.ClearToEmpty();
  _impl_.margin_.ClearToEmpty();
  _impl_.cumulative_funding_entry_.ClearToEmpty();
  _impl_.islong_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Position::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isLong = 1 [json_name = "isLong"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.islong_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Position.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string entry_price = 3 [json_name = "entryPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_entry_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Position.entry_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_margin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Position.margin"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string cumulative_funding_entry = 5 [json_name = "cumulativeFundingEntry", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_cumulative_funding_entry();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Position.cumulative_funding_entry"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Position::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.Position)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isLong = 1 [json_name = "isLong"];
  if (this->_internal_islong() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_islong(), target);
  }

  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Position.quantity");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string entry_price = 3 [json_name = "entryPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_entry_price().empty()) {
    const std::string& _s = this->_internal_entry_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Position.entry_price");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    const std::string& _s = this->_internal_margin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Position.margin");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string cumulative_funding_entry = 5 [json_name = "cumulativeFundingEntry", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_funding_entry().empty()) {
    const std::string& _s = this->_internal_cumulative_funding_entry();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Position.cumulative_funding_entry");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.Position)
  return target;
}

::size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.Position)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // string entry_price = 3 [json_name = "entryPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_entry_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_entry_price());
  }

  // string margin = 4 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_margin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_margin());
  }

  // string cumulative_funding_entry = 5 [json_name = "cumulativeFundingEntry", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_funding_entry().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_cumulative_funding_entry());
  }

  // bool isLong = 1 [json_name = "isLong"];
  if (this->_internal_islong() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Position::GetClassData() const { return &_class_data_; }


void Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Position*>(&to_msg);
  auto& from = static_cast<const Position&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.Position)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (!from._internal_entry_price().empty()) {
    _this->_internal_set_entry_price(from._internal_entry_price());
  }
  if (!from._internal_margin().empty()) {
    _this->_internal_set_margin(from._internal_margin());
  }
  if (!from._internal_cumulative_funding_entry().empty()) {
    _this->_internal_set_cumulative_funding_entry(from._internal_cumulative_funding_entry());
  }
  if (from._internal_islong() != 0) {
    _this->_internal_set_islong(from._internal_islong());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  return true;
}

void Position::InternalSwap(Position* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entry_price_, lhs_arena,
                                       &other->_impl_.entry_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.margin_, lhs_arena,
                                       &other->_impl_.margin_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.cumulative_funding_entry_, lhs_arena,
                                       &other->_impl_.cumulative_funding_entry_, rhs_arena);

  swap(_impl_.islong_, other->_impl_.islong_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Position::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[23]);
}
// ===================================================================

class MarketOrderIndicator::_Internal {
 public:
};

MarketOrderIndicator::MarketOrderIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.MarketOrderIndicator)
}
MarketOrderIndicator::MarketOrderIndicator(const MarketOrderIndicator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketOrderIndicator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.isbuy_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.isbuy_ = from._impl_.isbuy_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.MarketOrderIndicator)
}

inline void MarketOrderIndicator::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.isbuy_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarketOrderIndicator::~MarketOrderIndicator() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.MarketOrderIndicator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketOrderIndicator::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
}

void MarketOrderIndicator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketOrderIndicator::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.MarketOrderIndicator)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.isbuy_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketOrderIndicator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.MarketOrderIndicator.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isBuy = 2 [json_name = "isBuy"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.isbuy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketOrderIndicator::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.MarketOrderIndicator)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.MarketOrderIndicator.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool isBuy = 2 [json_name = "isBuy"];
  if (this->_internal_isbuy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_isbuy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.MarketOrderIndicator)
  return target;
}

::size_t MarketOrderIndicator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.MarketOrderIndicator)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // bool isBuy = 2 [json_name = "isBuy"];
  if (this->_internal_isbuy() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketOrderIndicator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketOrderIndicator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketOrderIndicator::GetClassData() const { return &_class_data_; }


void MarketOrderIndicator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketOrderIndicator*>(&to_msg);
  auto& from = static_cast<const MarketOrderIndicator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.MarketOrderIndicator)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_isbuy() != 0) {
    _this->_internal_set_isbuy(from._internal_isbuy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketOrderIndicator::CopyFrom(const MarketOrderIndicator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.MarketOrderIndicator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketOrderIndicator::IsInitialized() const {
  return true;
}

void MarketOrderIndicator::InternalSwap(MarketOrderIndicator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);

  swap(_impl_.isbuy_, other->_impl_.isbuy_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketOrderIndicator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[24]);
}
// ===================================================================

class TradeLog::_Internal {
 public:
};

TradeLog::TradeLog(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.TradeLog)
}
TradeLog::TradeLog(const TradeLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeLog* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.quantity_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.fee_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.fee_recipient_address_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee().empty()) {
    _this->_impl_.fee_.Set(from._internal_fee(), _this->GetArenaForAllocation());
  }
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.fee_recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_recipient_address().empty()) {
    _this->_impl_.fee_recipient_address_.Set(from._internal_fee_recipient_address(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.TradeLog)
}

inline void TradeLog::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.quantity_) {}

    , decltype(_impl_.price_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.fee_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.fee_recipient_address_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeLog::~TradeLog() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.TradeLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeLog::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.quantity_.Destroy();
  _impl_.price_.Destroy();
  _impl_.subaccount_id_.Destroy();
  _impl_.fee_.Destroy();
  _impl_.order_hash_.Destroy();
  _impl_.fee_recipient_address_.Destroy();
}

void TradeLog::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeLog::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.TradeLog)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.quantity_.ClearToEmpty();
  _impl_.price_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.fee_.ClearToEmpty();
  _impl_.order_hash_.ClearToEmpty();
  _impl_.fee_recipient_address_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradeLog.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradeLog.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes subaccount_id = 3 [json_name = "subaccountId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradeLog.fee"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes order_hash = 5 [json_name = "orderHash"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_fee_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradeLog::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.TradeLog)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradeLog.quantity");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradeLog.price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // bytes subaccount_id = 3 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fee().empty()) {
    const std::string& _s = this->_internal_fee();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradeLog.fee");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // bytes order_hash = 5 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
  if (!this->_internal_fee_recipient_address().empty()) {
    const std::string& _s = this->_internal_fee_recipient_address();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.TradeLog)
  return target;
}

::size_t TradeLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.TradeLog)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string quantity = 1 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // bytes subaccount_id = 3 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_subaccount_id());
  }

  // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fee().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fee());
  }

  // bytes order_hash = 5 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_order_hash());
  }

  // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
  if (!this->_internal_fee_recipient_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_fee_recipient_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeLog::GetClassData() const { return &_class_data_; }


void TradeLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeLog*>(&to_msg);
  auto& from = static_cast<const TradeLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.TradeLog)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_fee().empty()) {
    _this->_internal_set_fee(from._internal_fee());
  }
  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if (!from._internal_fee_recipient_address().empty()) {
    _this->_internal_set_fee_recipient_address(from._internal_fee_recipient_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeLog::CopyFrom(const TradeLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.TradeLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeLog::IsInitialized() const {
  return true;
}

void TradeLog::InternalSwap(TradeLog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_, lhs_arena,
                                       &other->_impl_.fee_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_recipient_address_, lhs_arena,
                                       &other->_impl_.fee_recipient_address_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeLog::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[25]);
}
// ===================================================================

class PositionDelta::_Internal {
 public:
};

PositionDelta::PositionDelta(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.PositionDelta)
}
PositionDelta::PositionDelta(const PositionDelta& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PositionDelta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.execution_quantity_) {}

    , decltype(_impl_.execution_margin_) {}

    , decltype(_impl_.execution_price_) {}

    , decltype(_impl_.is_long_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.execution_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_quantity().empty()) {
    _this->_impl_.execution_quantity_.Set(from._internal_execution_quantity(), _this->GetArenaForAllocation());
  }
  _impl_.execution_margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_margin().empty()) {
    _this->_impl_.execution_margin_.Set(from._internal_execution_margin(), _this->GetArenaForAllocation());
  }
  _impl_.execution_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_execution_price().empty()) {
    _this->_impl_.execution_price_.Set(from._internal_execution_price(), _this->GetArenaForAllocation());
  }
  _this->_impl_.is_long_ = from._impl_.is_long_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.PositionDelta)
}

inline void PositionDelta::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.execution_quantity_) {}

    , decltype(_impl_.execution_margin_) {}

    , decltype(_impl_.execution_price_) {}

    , decltype(_impl_.is_long_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.execution_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_margin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_margin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.execution_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.execution_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PositionDelta::~PositionDelta() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.PositionDelta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PositionDelta::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.execution_quantity_.Destroy();
  _impl_.execution_margin_.Destroy();
  _impl_.execution_price_.Destroy();
}

void PositionDelta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PositionDelta::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.PositionDelta)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.execution_quantity_.ClearToEmpty();
  _impl_.execution_margin_.ClearToEmpty();
  _impl_.execution_price_.ClearToEmpty();
  _impl_.is_long_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PositionDelta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool is_long = 1 [json_name = "isLong"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.is_long_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_quantity = 2 [json_name = "executionQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_execution_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PositionDelta.execution_quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_margin = 3 [json_name = "executionMargin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_execution_margin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PositionDelta.execution_margin"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string execution_price = 4 [json_name = "executionPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_execution_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PositionDelta.execution_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PositionDelta::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.PositionDelta)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool is_long = 1 [json_name = "isLong"];
  if (this->_internal_is_long() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_is_long(), target);
  }

  // string execution_quantity = 2 [json_name = "executionQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_execution_quantity().empty()) {
    const std::string& _s = this->_internal_execution_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PositionDelta.execution_quantity");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string execution_margin = 3 [json_name = "executionMargin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_execution_margin().empty()) {
    const std::string& _s = this->_internal_execution_margin();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PositionDelta.execution_margin");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string execution_price = 4 [json_name = "executionPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_execution_price().empty()) {
    const std::string& _s = this->_internal_execution_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PositionDelta.execution_price");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.PositionDelta)
  return target;
}

::size_t PositionDelta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.PositionDelta)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string execution_quantity = 2 [json_name = "executionQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_execution_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_quantity());
  }

  // string execution_margin = 3 [json_name = "executionMargin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_execution_margin().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_margin());
  }

  // string execution_price = 4 [json_name = "executionPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_execution_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_execution_price());
  }

  // bool is_long = 1 [json_name = "isLong"];
  if (this->_internal_is_long() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PositionDelta::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PositionDelta::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PositionDelta::GetClassData() const { return &_class_data_; }


void PositionDelta::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PositionDelta*>(&to_msg);
  auto& from = static_cast<const PositionDelta&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.PositionDelta)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_execution_quantity().empty()) {
    _this->_internal_set_execution_quantity(from._internal_execution_quantity());
  }
  if (!from._internal_execution_margin().empty()) {
    _this->_internal_set_execution_margin(from._internal_execution_margin());
  }
  if (!from._internal_execution_price().empty()) {
    _this->_internal_set_execution_price(from._internal_execution_price());
  }
  if (from._internal_is_long() != 0) {
    _this->_internal_set_is_long(from._internal_is_long());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PositionDelta::CopyFrom(const PositionDelta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.PositionDelta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionDelta::IsInitialized() const {
  return true;
}

void PositionDelta::InternalSwap(PositionDelta* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_quantity_, lhs_arena,
                                       &other->_impl_.execution_quantity_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_margin_, lhs_arena,
                                       &other->_impl_.execution_margin_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.execution_price_, lhs_arena,
                                       &other->_impl_.execution_price_, rhs_arena);

  swap(_impl_.is_long_, other->_impl_.is_long_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PositionDelta::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[26]);
}
// ===================================================================

class DerivativeTradeLog::_Internal {
 public:
  using HasBits = decltype(std::declval<DerivativeTradeLog>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DerivativeTradeLog, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::PositionDelta& position_delta(const DerivativeTradeLog* msg);
  static void set_has_position_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::PositionDelta&
DerivativeTradeLog::_Internal::position_delta(const DerivativeTradeLog* msg) {
  return *msg->_impl_.position_delta_;
}
DerivativeTradeLog::DerivativeTradeLog(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeTradeLog)
}
DerivativeTradeLog::DerivativeTradeLog(const DerivativeTradeLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeTradeLog* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.payout_) {}

    , decltype(_impl_.fee_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.fee_recipient_address_) {}

    , decltype(_impl_.position_delta_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.payout_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payout_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payout().empty()) {
    _this->_impl_.payout_.Set(from._internal_payout(), _this->GetArenaForAllocation());
  }
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee().empty()) {
    _this->_impl_.fee_.Set(from._internal_fee(), _this->GetArenaForAllocation());
  }
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.fee_recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fee_recipient_address().empty()) {
    _this->_impl_.fee_recipient_address_.Set(from._internal_fee_recipient_address(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_delta_ = new ::injective::exchange::v1beta1::PositionDelta(*from._impl_.position_delta_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeTradeLog)
}

inline void DerivativeTradeLog::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.payout_) {}

    , decltype(_impl_.fee_) {}

    , decltype(_impl_.order_hash_) {}

    , decltype(_impl_.fee_recipient_address_) {}

    , decltype(_impl_.position_delta_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payout_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.payout_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fee_recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fee_recipient_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeTradeLog::~DerivativeTradeLog() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeTradeLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeTradeLog::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.payout_.Destroy();
  _impl_.fee_.Destroy();
  _impl_.order_hash_.Destroy();
  _impl_.fee_recipient_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_delta_;
}

void DerivativeTradeLog::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeTradeLog::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeTradeLog)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.payout_.ClearToEmpty();
  _impl_.fee_.ClearToEmpty();
  _impl_.order_hash_.ClearToEmpty();
  _impl_.fee_recipient_address_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_delta_ != nullptr);
    _impl_.position_delta_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeTradeLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.PositionDelta position_delta = 2 [json_name = "positionDelta"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position_delta(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string payout = 3 [json_name = "payout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_payout();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeTradeLog.payout"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fee();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeTradeLog.fee"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes order_hash = 5 [json_name = "orderHash"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_fee_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeTradeLog::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeTradeLog)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.PositionDelta position_delta = 2 [json_name = "positionDelta"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position_delta(this),
        _Internal::position_delta(this).GetCachedSize(), target, stream);
  }

  // string payout = 3 [json_name = "payout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_payout().empty()) {
    const std::string& _s = this->_internal_payout();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeTradeLog.payout");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fee().empty()) {
    const std::string& _s = this->_internal_fee();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeTradeLog.fee");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // bytes order_hash = 5 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
  if (!this->_internal_fee_recipient_address().empty()) {
    const std::string& _s = this->_internal_fee_recipient_address();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeTradeLog)
  return target;
}

::size_t DerivativeTradeLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeTradeLog)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_subaccount_id());
  }

  // string payout = 3 [json_name = "payout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_payout().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_payout());
  }

  // string fee = 4 [json_name = "fee", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_fee().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_fee());
  }

  // bytes order_hash = 5 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_order_hash());
  }

  // bytes fee_recipient_address = 6 [json_name = "feeRecipientAddress", (.gogoproto.nullable) = true];
  if (!this->_internal_fee_recipient_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_fee_recipient_address());
  }

  // .injective.exchange.v1beta1.PositionDelta position_delta = 2 [json_name = "positionDelta"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_delta_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeTradeLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeTradeLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeTradeLog::GetClassData() const { return &_class_data_; }


void DerivativeTradeLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeTradeLog*>(&to_msg);
  auto& from = static_cast<const DerivativeTradeLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeTradeLog)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_payout().empty()) {
    _this->_internal_set_payout(from._internal_payout());
  }
  if (!from._internal_fee().empty()) {
    _this->_internal_set_fee(from._internal_fee());
  }
  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if (!from._internal_fee_recipient_address().empty()) {
    _this->_internal_set_fee_recipient_address(from._internal_fee_recipient_address());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position_delta()->::injective::exchange::v1beta1::PositionDelta::MergeFrom(
        from._internal_position_delta());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeTradeLog::CopyFrom(const DerivativeTradeLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeTradeLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeTradeLog::IsInitialized() const {
  return true;
}

void DerivativeTradeLog::InternalSwap(DerivativeTradeLog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payout_, lhs_arena,
                                       &other->_impl_.payout_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_, lhs_arena,
                                       &other->_impl_.fee_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fee_recipient_address_, lhs_arena,
                                       &other->_impl_.fee_recipient_address_, rhs_arena);
  swap(_impl_.position_delta_, other->_impl_.position_delta_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeTradeLog::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[27]);
}
// ===================================================================

class SubaccountPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountPosition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountPosition, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::Position& position(const SubaccountPosition* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::Position&
SubaccountPosition::_Internal::position(const SubaccountPosition* msg) {
  return *msg->_impl_.position_;
}
SubaccountPosition::SubaccountPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountPosition)
}
SubaccountPosition::SubaccountPosition(const SubaccountPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.position_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::injective::exchange::v1beta1::Position(*from._impl_.position_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountPosition)
}

inline void SubaccountPosition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.position_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountPosition::~SubaccountPosition() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountPosition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void SubaccountPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountPosition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.Position position = 1 [json_name = "position"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes subaccount_id = 2 [json_name = "subaccountId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountPosition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountPosition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.Position position = 1 [json_name = "position"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountPosition)
  return target;
}

::size_t SubaccountPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountPosition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_subaccount_id());
  }

  // .injective.exchange.v1beta1.Position position = 1 [json_name = "position"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountPosition::GetClassData() const { return &_class_data_; }


void SubaccountPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountPosition*>(&to_msg);
  auto& from = static_cast<const SubaccountPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountPosition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::injective::exchange::v1beta1::Position::MergeFrom(
        from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountPosition::CopyFrom(const SubaccountPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountPosition::IsInitialized() const {
  return true;
}

void SubaccountPosition::InternalSwap(SubaccountPosition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[28]);
}
// ===================================================================

class SubaccountDeposit::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountDeposit>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountDeposit, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::Deposit& deposit(const SubaccountDeposit* msg);
  static void set_has_deposit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::Deposit&
SubaccountDeposit::_Internal::deposit(const SubaccountDeposit* msg) {
  return *msg->_impl_.deposit_;
}
SubaccountDeposit::SubaccountDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountDeposit)
}
SubaccountDeposit::SubaccountDeposit(const SubaccountDeposit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountDeposit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.deposit_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.deposit_ = new ::injective::exchange::v1beta1::Deposit(*from._impl_.deposit_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountDeposit)
}

inline void SubaccountDeposit::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.deposit_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountDeposit::~SubaccountDeposit() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountDeposit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountDeposit::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.deposit_;
}

void SubaccountDeposit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountDeposit::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountDeposit)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.deposit_ != nullptr);
    _impl_.deposit_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountDeposit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.Deposit deposit = 2 [json_name = "deposit"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_deposit(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountDeposit::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountDeposit)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.Deposit deposit = 2 [json_name = "deposit"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::deposit(this),
        _Internal::deposit(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountDeposit)
  return target;
}

::size_t SubaccountDeposit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountDeposit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_subaccount_id());
  }

  // .injective.exchange.v1beta1.Deposit deposit = 2 [json_name = "deposit"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.deposit_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountDeposit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountDeposit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountDeposit::GetClassData() const { return &_class_data_; }


void SubaccountDeposit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountDeposit*>(&to_msg);
  auto& from = static_cast<const SubaccountDeposit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountDeposit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_deposit()->::injective::exchange::v1beta1::Deposit::MergeFrom(
        from._internal_deposit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountDeposit::CopyFrom(const SubaccountDeposit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountDeposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountDeposit::IsInitialized() const {
  return true;
}

void SubaccountDeposit::InternalSwap(SubaccountDeposit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  swap(_impl_.deposit_, other->_impl_.deposit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountDeposit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[29]);
}
// ===================================================================

class DepositUpdate::_Internal {
 public:
};

DepositUpdate::DepositUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DepositUpdate)
}
DepositUpdate::DepositUpdate(const DepositUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DepositUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.deposits_){from._impl_.deposits_}
    , decltype(_impl_.denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DepositUpdate)
}

inline void DepositUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.deposits_){arena}
    , decltype(_impl_.denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DepositUpdate::~DepositUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DepositUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DepositUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_deposits()->~RepeatedPtrField();
  _impl_.denom_.Destroy();
}

void DepositUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DepositUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DepositUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_deposits()->Clear();
  _impl_.denom_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DepositUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string denom = 1 [json_name = "denom"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DepositUpdate.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SubaccountDeposit deposits = 2 [json_name = "deposits"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_deposits(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DepositUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DepositUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DepositUpdate.denom");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.SubaccountDeposit deposits = 2 [json_name = "deposits"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_deposits_size()); i < n; i++) {
    const auto& repfield = this->_internal_deposits(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DepositUpdate)
  return target;
}

::size_t DepositUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DepositUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.SubaccountDeposit deposits = 2 [json_name = "deposits"];
  total_size += 1UL * this->_internal_deposits_size();
  for (const auto& msg : this->_internal_deposits()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DepositUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DepositUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DepositUpdate::GetClassData() const { return &_class_data_; }


void DepositUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DepositUpdate*>(&to_msg);
  auto& from = static_cast<const DepositUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DepositUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_deposits()->MergeFrom(from._internal_deposits());
  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DepositUpdate::CopyFrom(const DepositUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DepositUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DepositUpdate::IsInitialized() const {
  return true;
}

void DepositUpdate::InternalSwap(DepositUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_deposits()->InternalSwap(other->_internal_mutable_deposits());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata DepositUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[30]);
}
// ===================================================================

class PointsMultiplier::_Internal {
 public:
};

PointsMultiplier::PointsMultiplier(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.PointsMultiplier)
}
PointsMultiplier::PointsMultiplier(const PointsMultiplier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointsMultiplier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.maker_points_multiplier_) {}

    , decltype(_impl_.taker_points_multiplier_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.maker_points_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_points_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maker_points_multiplier().empty()) {
    _this->_impl_.maker_points_multiplier_.Set(from._internal_maker_points_multiplier(), _this->GetArenaForAllocation());
  }
  _impl_.taker_points_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_points_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_taker_points_multiplier().empty()) {
    _this->_impl_.taker_points_multiplier_.Set(from._internal_taker_points_multiplier(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.PointsMultiplier)
}

inline void PointsMultiplier::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.maker_points_multiplier_) {}

    , decltype(_impl_.taker_points_multiplier_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.maker_points_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_points_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taker_points_multiplier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_points_multiplier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PointsMultiplier::~PointsMultiplier() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.PointsMultiplier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointsMultiplier::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.maker_points_multiplier_.Destroy();
  _impl_.taker_points_multiplier_.Destroy();
}

void PointsMultiplier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointsMultiplier::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.PointsMultiplier)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.maker_points_multiplier_.ClearToEmpty();
  _impl_.taker_points_multiplier_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointsMultiplier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string maker_points_multiplier = 1 [json_name = "makerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_maker_points_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PointsMultiplier.maker_points_multiplier"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string taker_points_multiplier = 2 [json_name = "takerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_taker_points_multiplier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.PointsMultiplier.taker_points_multiplier"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointsMultiplier::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.PointsMultiplier)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string maker_points_multiplier = 1 [json_name = "makerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_points_multiplier().empty()) {
    const std::string& _s = this->_internal_maker_points_multiplier();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PointsMultiplier.maker_points_multiplier");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string taker_points_multiplier = 2 [json_name = "takerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_points_multiplier().empty()) {
    const std::string& _s = this->_internal_taker_points_multiplier();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.PointsMultiplier.taker_points_multiplier");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.PointsMultiplier)
  return target;
}

::size_t PointsMultiplier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.PointsMultiplier)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string maker_points_multiplier = 1 [json_name = "makerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_points_multiplier().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maker_points_multiplier());
  }

  // string taker_points_multiplier = 2 [json_name = "takerPointsMultiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_points_multiplier().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_taker_points_multiplier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointsMultiplier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointsMultiplier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointsMultiplier::GetClassData() const { return &_class_data_; }


void PointsMultiplier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointsMultiplier*>(&to_msg);
  auto& from = static_cast<const PointsMultiplier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.PointsMultiplier)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_maker_points_multiplier().empty()) {
    _this->_internal_set_maker_points_multiplier(from._internal_maker_points_multiplier());
  }
  if (!from._internal_taker_points_multiplier().empty()) {
    _this->_internal_set_taker_points_multiplier(from._internal_taker_points_multiplier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointsMultiplier::CopyFrom(const PointsMultiplier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.PointsMultiplier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointsMultiplier::IsInitialized() const {
  return true;
}

void PointsMultiplier::InternalSwap(PointsMultiplier* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maker_points_multiplier_, lhs_arena,
                                       &other->_impl_.maker_points_multiplier_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.taker_points_multiplier_, lhs_arena,
                                       &other->_impl_.taker_points_multiplier_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata PointsMultiplier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[31]);
}
// ===================================================================

class TradingRewardCampaignBoostInfo::_Internal {
 public:
};

TradingRewardCampaignBoostInfo::TradingRewardCampaignBoostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
}
TradingRewardCampaignBoostInfo::TradingRewardCampaignBoostInfo(const TradingRewardCampaignBoostInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradingRewardCampaignBoostInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.boosted_spot_market_ids_){from._impl_.boosted_spot_market_ids_}
    , decltype(_impl_.spot_market_multipliers_){from._impl_.spot_market_multipliers_}
    , decltype(_impl_.boosted_derivative_market_ids_){from._impl_.boosted_derivative_market_ids_}
    , decltype(_impl_.derivative_market_multipliers_){from._impl_.derivative_market_multipliers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
}

inline void TradingRewardCampaignBoostInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.boosted_spot_market_ids_){arena}
    , decltype(_impl_.spot_market_multipliers_){arena}
    , decltype(_impl_.boosted_derivative_market_ids_){arena}
    , decltype(_impl_.derivative_market_multipliers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TradingRewardCampaignBoostInfo::~TradingRewardCampaignBoostInfo() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradingRewardCampaignBoostInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_boosted_spot_market_ids()->~RepeatedPtrField();
  _internal_mutable_spot_market_multipliers()->~RepeatedPtrField();
  _internal_mutable_boosted_derivative_market_ids()->~RepeatedPtrField();
  _internal_mutable_derivative_market_multipliers()->~RepeatedPtrField();
}

void TradingRewardCampaignBoostInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradingRewardCampaignBoostInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_boosted_spot_market_ids()->Clear();
  _internal_mutable_spot_market_multipliers()->Clear();
  _internal_mutable_boosted_derivative_market_ids()->Clear();
  _internal_mutable_derivative_market_multipliers()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradingRewardCampaignBoostInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string boosted_spot_market_ids = 1 [json_name = "boostedSpotMarketIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_boosted_spot_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2 [json_name = "spotMarketMultipliers", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_spot_market_multipliers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string boosted_derivative_market_ids = 3 [json_name = "boostedDerivativeMarketIds"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_boosted_derivative_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4 [json_name = "derivativeMarketMultipliers", (.gogoproto.nullable) = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_derivative_market_multipliers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradingRewardCampaignBoostInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string boosted_spot_market_ids = 1 [json_name = "boostedSpotMarketIds"];
  for (int i = 0, n = this->_internal_boosted_spot_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_boosted_spot_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_spot_market_ids");
    target = stream->WriteString(1, s, target);
  }

  // repeated .injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2 [json_name = "spotMarketMultipliers", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_spot_market_multipliers_size()); i < n; i++) {
    const auto& repfield = this->_internal_spot_market_multipliers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string boosted_derivative_market_ids = 3 [json_name = "boostedDerivativeMarketIds"];
  for (int i = 0, n = this->_internal_boosted_derivative_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_boosted_derivative_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.boosted_derivative_market_ids");
    target = stream->WriteString(3, s, target);
  }

  // repeated .injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4 [json_name = "derivativeMarketMultipliers", (.gogoproto.nullable) = false];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_derivative_market_multipliers_size()); i < n; i++) {
    const auto& repfield = this->_internal_derivative_market_multipliers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
  return target;
}

::size_t TradingRewardCampaignBoostInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string boosted_spot_market_ids = 1 [json_name = "boostedSpotMarketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_boosted_spot_market_ids().size());
  for (int i = 0, n = _internal_boosted_spot_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_boosted_spot_market_ids().Get(i));
  }

  // repeated .injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2 [json_name = "spotMarketMultipliers", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_spot_market_multipliers_size();
  for (const auto& msg : this->_internal_spot_market_multipliers()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string boosted_derivative_market_ids = 3 [json_name = "boostedDerivativeMarketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_boosted_derivative_market_ids().size());
  for (int i = 0, n = _internal_boosted_derivative_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_boosted_derivative_market_ids().Get(i));
  }

  // repeated .injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4 [json_name = "derivativeMarketMultipliers", (.gogoproto.nullable) = false];
  total_size += 1UL * this->_internal_derivative_market_multipliers_size();
  for (const auto& msg : this->_internal_derivative_market_multipliers()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradingRewardCampaignBoostInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradingRewardCampaignBoostInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradingRewardCampaignBoostInfo::GetClassData() const { return &_class_data_; }


void TradingRewardCampaignBoostInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradingRewardCampaignBoostInfo*>(&to_msg);
  auto& from = static_cast<const TradingRewardCampaignBoostInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_boosted_spot_market_ids()->MergeFrom(from._internal_boosted_spot_market_ids());
  _this->_internal_mutable_spot_market_multipliers()->MergeFrom(from._internal_spot_market_multipliers());
  _this->_internal_mutable_boosted_derivative_market_ids()->MergeFrom(from._internal_boosted_derivative_market_ids());
  _this->_internal_mutable_derivative_market_multipliers()->MergeFrom(from._internal_derivative_market_multipliers());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradingRewardCampaignBoostInfo::CopyFrom(const TradingRewardCampaignBoostInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.TradingRewardCampaignBoostInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradingRewardCampaignBoostInfo::IsInitialized() const {
  return true;
}

void TradingRewardCampaignBoostInfo::InternalSwap(TradingRewardCampaignBoostInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_boosted_spot_market_ids()->InternalSwap(
      other->_internal_mutable_boosted_spot_market_ids());
  _internal_mutable_spot_market_multipliers()->InternalSwap(other->_internal_mutable_spot_market_multipliers());
  _internal_mutable_boosted_derivative_market_ids()->InternalSwap(
      other->_internal_mutable_boosted_derivative_market_ids());
  _internal_mutable_derivative_market_multipliers()->InternalSwap(other->_internal_mutable_derivative_market_multipliers());
}

::PROTOBUF_NAMESPACE_ID::Metadata TradingRewardCampaignBoostInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[32]);
}
// ===================================================================

class CampaignRewardPool::_Internal {
 public:
};

void CampaignRewardPool::clear_max_campaign_rewards() {
  _internal_mutable_max_campaign_rewards()->Clear();
}
CampaignRewardPool::CampaignRewardPool(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.CampaignRewardPool)
}
CampaignRewardPool::CampaignRewardPool(const CampaignRewardPool& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CampaignRewardPool* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.max_campaign_rewards_){from._impl_.max_campaign_rewards_}
    , decltype(_impl_.start_timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.start_timestamp_ = from._impl_.start_timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.CampaignRewardPool)
}

inline void CampaignRewardPool::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.max_campaign_rewards_){arena}
    , decltype(_impl_.start_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CampaignRewardPool::~CampaignRewardPool() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.CampaignRewardPool)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CampaignRewardPool::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_max_campaign_rewards()->~RepeatedPtrField();
}

void CampaignRewardPool::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CampaignRewardPool::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.CampaignRewardPool)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_max_campaign_rewards()->Clear();
  _impl_.start_timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CampaignRewardPool::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 start_timestamp = 1 [json_name = "startTimestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .cosmos.base.v1beta1.Coin max_campaign_rewards = 2 [json_name = "maxCampaignRewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_max_campaign_rewards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CampaignRewardPool::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.CampaignRewardPool)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 start_timestamp = 1 [json_name = "startTimestamp"];
  if (this->_internal_start_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_start_timestamp(), target);
  }

  // repeated .cosmos.base.v1beta1.Coin max_campaign_rewards = 2 [json_name = "maxCampaignRewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_max_campaign_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_max_campaign_rewards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.CampaignRewardPool)
  return target;
}

::size_t CampaignRewardPool::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.CampaignRewardPool)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin max_campaign_rewards = 2 [json_name = "maxCampaignRewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  total_size += 1UL * this->_internal_max_campaign_rewards_size();
  for (const auto& msg : this->_internal_max_campaign_rewards()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 start_timestamp = 1 [json_name = "startTimestamp"];
  if (this->_internal_start_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_start_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CampaignRewardPool::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CampaignRewardPool::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CampaignRewardPool::GetClassData() const { return &_class_data_; }


void CampaignRewardPool::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CampaignRewardPool*>(&to_msg);
  auto& from = static_cast<const CampaignRewardPool&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.CampaignRewardPool)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_max_campaign_rewards()->MergeFrom(from._internal_max_campaign_rewards());
  if (from._internal_start_timestamp() != 0) {
    _this->_internal_set_start_timestamp(from._internal_start_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CampaignRewardPool::CopyFrom(const CampaignRewardPool& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.CampaignRewardPool)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CampaignRewardPool::IsInitialized() const {
  return true;
}

void CampaignRewardPool::InternalSwap(CampaignRewardPool* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_max_campaign_rewards()->InternalSwap(other->_internal_mutable_max_campaign_rewards());

  swap(_impl_.start_timestamp_, other->_impl_.start_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CampaignRewardPool::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[33]);
}
// ===================================================================

class TradingRewardCampaignInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TradingRewardCampaignInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TradingRewardCampaignInfo, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo& trading_reward_boost_info(const TradingRewardCampaignInfo* msg);
  static void set_has_trading_reward_boost_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo&
TradingRewardCampaignInfo::_Internal::trading_reward_boost_info(const TradingRewardCampaignInfo* msg) {
  return *msg->_impl_.trading_reward_boost_info_;
}
TradingRewardCampaignInfo::TradingRewardCampaignInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.TradingRewardCampaignInfo)
}
TradingRewardCampaignInfo::TradingRewardCampaignInfo(const TradingRewardCampaignInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradingRewardCampaignInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quote_denoms_){from._impl_.quote_denoms_}
    , decltype(_impl_.disqualified_market_ids_){from._impl_.disqualified_market_ids_}
    , decltype(_impl_.trading_reward_boost_info_){nullptr}
    , decltype(_impl_.campaign_duration_seconds_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.trading_reward_boost_info_ = new ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo(*from._impl_.trading_reward_boost_info_);
  }
  _this->_impl_.campaign_duration_seconds_ = from._impl_.campaign_duration_seconds_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.TradingRewardCampaignInfo)
}

inline void TradingRewardCampaignInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quote_denoms_){arena}
    , decltype(_impl_.disqualified_market_ids_){arena}
    , decltype(_impl_.trading_reward_boost_info_){nullptr}
    , decltype(_impl_.campaign_duration_seconds_) { ::int64_t{0} }

  };
}

TradingRewardCampaignInfo::~TradingRewardCampaignInfo() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.TradingRewardCampaignInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradingRewardCampaignInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_quote_denoms()->~RepeatedPtrField();
  _internal_mutable_disqualified_market_ids()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.trading_reward_boost_info_;
}

void TradingRewardCampaignInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradingRewardCampaignInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.TradingRewardCampaignInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_quote_denoms()->Clear();
  _internal_mutable_disqualified_market_ids()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.trading_reward_boost_info_ != nullptr);
    _impl_.trading_reward_boost_info_->Clear();
  }
  _impl_.campaign_duration_seconds_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradingRewardCampaignInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 campaign_duration_seconds = 1 [json_name = "campaignDurationSeconds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.campaign_duration_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string quote_denoms = 2 [json_name = "quoteDenoms"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_quote_denoms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3 [json_name = "tradingRewardBoostInfo"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_trading_reward_boost_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string disqualified_market_ids = 4 [json_name = "disqualifiedMarketIds"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_disqualified_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradingRewardCampaignInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.TradingRewardCampaignInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 campaign_duration_seconds = 1 [json_name = "campaignDurationSeconds"];
  if (this->_internal_campaign_duration_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_campaign_duration_seconds(), target);
  }

  // repeated string quote_denoms = 2 [json_name = "quoteDenoms"];
  for (int i = 0, n = this->_internal_quote_denoms_size(); i < n; ++i) {
    const auto& s = this->_internal_quote_denoms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradingRewardCampaignInfo.quote_denoms");
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3 [json_name = "tradingRewardBoostInfo"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::trading_reward_boost_info(this),
        _Internal::trading_reward_boost_info(this).GetCachedSize(), target, stream);
  }

  // repeated string disqualified_market_ids = 4 [json_name = "disqualifiedMarketIds"];
  for (int i = 0, n = this->_internal_disqualified_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_disqualified_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradingRewardCampaignInfo.disqualified_market_ids");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.TradingRewardCampaignInfo)
  return target;
}

::size_t TradingRewardCampaignInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.TradingRewardCampaignInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string quote_denoms = 2 [json_name = "quoteDenoms"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_quote_denoms().size());
  for (int i = 0, n = _internal_quote_denoms().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_quote_denoms().Get(i));
  }

  // repeated string disqualified_market_ids = 4 [json_name = "disqualifiedMarketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_disqualified_market_ids().size());
  for (int i = 0, n = _internal_disqualified_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_disqualified_market_ids().Get(i));
  }

  // .injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3 [json_name = "tradingRewardBoostInfo"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.trading_reward_boost_info_);
  }

  // int64 campaign_duration_seconds = 1 [json_name = "campaignDurationSeconds"];
  if (this->_internal_campaign_duration_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_campaign_duration_seconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradingRewardCampaignInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradingRewardCampaignInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradingRewardCampaignInfo::GetClassData() const { return &_class_data_; }


void TradingRewardCampaignInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradingRewardCampaignInfo*>(&to_msg);
  auto& from = static_cast<const TradingRewardCampaignInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.TradingRewardCampaignInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_quote_denoms()->MergeFrom(from._internal_quote_denoms());
  _this->_internal_mutable_disqualified_market_ids()->MergeFrom(from._internal_disqualified_market_ids());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_trading_reward_boost_info()->::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo::MergeFrom(
        from._internal_trading_reward_boost_info());
  }
  if (from._internal_campaign_duration_seconds() != 0) {
    _this->_internal_set_campaign_duration_seconds(from._internal_campaign_duration_seconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradingRewardCampaignInfo::CopyFrom(const TradingRewardCampaignInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.TradingRewardCampaignInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradingRewardCampaignInfo::IsInitialized() const {
  return true;
}

void TradingRewardCampaignInfo::InternalSwap(TradingRewardCampaignInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_quote_denoms()->InternalSwap(
      other->_internal_mutable_quote_denoms());
  _internal_mutable_disqualified_market_ids()->InternalSwap(
      other->_internal_mutable_disqualified_market_ids());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradingRewardCampaignInfo, _impl_.campaign_duration_seconds_)
      + sizeof(TradingRewardCampaignInfo::_impl_.campaign_duration_seconds_)
      - PROTOBUF_FIELD_OFFSET(TradingRewardCampaignInfo, _impl_.trading_reward_boost_info_)>(
          reinterpret_cast<char*>(&_impl_.trading_reward_boost_info_),
          reinterpret_cast<char*>(&other->_impl_.trading_reward_boost_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TradingRewardCampaignInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[34]);
}
// ===================================================================

class FeeDiscountTierInfo::_Internal {
 public:
};

FeeDiscountTierInfo::FeeDiscountTierInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.FeeDiscountTierInfo)
}
FeeDiscountTierInfo::FeeDiscountTierInfo(const FeeDiscountTierInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeeDiscountTierInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.maker_discount_rate_) {}

    , decltype(_impl_.taker_discount_rate_) {}

    , decltype(_impl_.staked_amount_) {}

    , decltype(_impl_.volume_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.maker_discount_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_discount_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maker_discount_rate().empty()) {
    _this->_impl_.maker_discount_rate_.Set(from._internal_maker_discount_rate(), _this->GetArenaForAllocation());
  }
  _impl_.taker_discount_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_discount_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_taker_discount_rate().empty()) {
    _this->_impl_.taker_discount_rate_.Set(from._internal_taker_discount_rate(), _this->GetArenaForAllocation());
  }
  _impl_.staked_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.staked_amount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_staked_amount().empty()) {
    _this->_impl_.staked_amount_.Set(from._internal_staked_amount(), _this->GetArenaForAllocation());
  }
  _impl_.volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_volume().empty()) {
    _this->_impl_.volume_.Set(from._internal_volume(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.FeeDiscountTierInfo)
}

inline void FeeDiscountTierInfo::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.maker_discount_rate_) {}

    , decltype(_impl_.taker_discount_rate_) {}

    , decltype(_impl_.staked_amount_) {}

    , decltype(_impl_.volume_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.maker_discount_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_discount_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taker_discount_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_discount_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.staked_amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.staked_amount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FeeDiscountTierInfo::~FeeDiscountTierInfo() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.FeeDiscountTierInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeDiscountTierInfo::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.maker_discount_rate_.Destroy();
  _impl_.taker_discount_rate_.Destroy();
  _impl_.staked_amount_.Destroy();
  _impl_.volume_.Destroy();
}

void FeeDiscountTierInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeDiscountTierInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.FeeDiscountTierInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.maker_discount_rate_.ClearToEmpty();
  _impl_.taker_discount_rate_.ClearToEmpty();
  _impl_.staked_amount_.ClearToEmpty();
  _impl_.volume_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeDiscountTierInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string maker_discount_rate = 1 [json_name = "makerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_maker_discount_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.FeeDiscountTierInfo.maker_discount_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string taker_discount_rate = 2 [json_name = "takerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_taker_discount_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.FeeDiscountTierInfo.taker_discount_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string staked_amount = 3 [json_name = "stakedAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_staked_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.FeeDiscountTierInfo.staked_amount"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string volume = 4 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_volume();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.FeeDiscountTierInfo.volume"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeeDiscountTierInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.FeeDiscountTierInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string maker_discount_rate = 1 [json_name = "makerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_discount_rate().empty()) {
    const std::string& _s = this->_internal_maker_discount_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.FeeDiscountTierInfo.maker_discount_rate");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string taker_discount_rate = 2 [json_name = "takerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_discount_rate().empty()) {
    const std::string& _s = this->_internal_taker_discount_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.FeeDiscountTierInfo.taker_discount_rate");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string staked_amount = 3 [json_name = "stakedAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_staked_amount().empty()) {
    const std::string& _s = this->_internal_staked_amount();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.FeeDiscountTierInfo.staked_amount");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string volume = 4 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_volume().empty()) {
    const std::string& _s = this->_internal_volume();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.FeeDiscountTierInfo.volume");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.FeeDiscountTierInfo)
  return target;
}

::size_t FeeDiscountTierInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.FeeDiscountTierInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string maker_discount_rate = 1 [json_name = "makerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_discount_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maker_discount_rate());
  }

  // string taker_discount_rate = 2 [json_name = "takerDiscountRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_discount_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_taker_discount_rate());
  }

  // string staked_amount = 3 [json_name = "stakedAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int"];
  if (!this->_internal_staked_amount().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_staked_amount());
  }

  // string volume = 4 [json_name = "volume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_volume().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_volume());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeDiscountTierInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeDiscountTierInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeDiscountTierInfo::GetClassData() const { return &_class_data_; }


void FeeDiscountTierInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeDiscountTierInfo*>(&to_msg);
  auto& from = static_cast<const FeeDiscountTierInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.FeeDiscountTierInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_maker_discount_rate().empty()) {
    _this->_internal_set_maker_discount_rate(from._internal_maker_discount_rate());
  }
  if (!from._internal_taker_discount_rate().empty()) {
    _this->_internal_set_taker_discount_rate(from._internal_taker_discount_rate());
  }
  if (!from._internal_staked_amount().empty()) {
    _this->_internal_set_staked_amount(from._internal_staked_amount());
  }
  if (!from._internal_volume().empty()) {
    _this->_internal_set_volume(from._internal_volume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeDiscountTierInfo::CopyFrom(const FeeDiscountTierInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.FeeDiscountTierInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeDiscountTierInfo::IsInitialized() const {
  return true;
}

void FeeDiscountTierInfo::InternalSwap(FeeDiscountTierInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maker_discount_rate_, lhs_arena,
                                       &other->_impl_.maker_discount_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.taker_discount_rate_, lhs_arena,
                                       &other->_impl_.taker_discount_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.staked_amount_, lhs_arena,
                                       &other->_impl_.staked_amount_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.volume_, lhs_arena,
                                       &other->_impl_.volume_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeDiscountTierInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[35]);
}
// ===================================================================

class FeeDiscountSchedule::_Internal {
 public:
};

FeeDiscountSchedule::FeeDiscountSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.FeeDiscountSchedule)
}
FeeDiscountSchedule::FeeDiscountSchedule(const FeeDiscountSchedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeeDiscountSchedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.quote_denoms_){from._impl_.quote_denoms_}
    , decltype(_impl_.tier_infos_){from._impl_.tier_infos_}
    , decltype(_impl_.disqualified_market_ids_){from._impl_.disqualified_market_ids_}
    , decltype(_impl_.bucket_count_) {}

    , decltype(_impl_.bucket_duration_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.bucket_count_, &from._impl_.bucket_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.bucket_duration_) -
    reinterpret_cast<char*>(&_impl_.bucket_count_)) + sizeof(_impl_.bucket_duration_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.FeeDiscountSchedule)
}

inline void FeeDiscountSchedule::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.quote_denoms_){arena}
    , decltype(_impl_.tier_infos_){arena}
    , decltype(_impl_.disqualified_market_ids_){arena}
    , decltype(_impl_.bucket_count_) { ::uint64_t{0u} }

    , decltype(_impl_.bucket_duration_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeeDiscountSchedule::~FeeDiscountSchedule() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.FeeDiscountSchedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeDiscountSchedule::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_quote_denoms()->~RepeatedPtrField();
  _internal_mutable_tier_infos()->~RepeatedPtrField();
  _internal_mutable_disqualified_market_ids()->~RepeatedPtrField();
}

void FeeDiscountSchedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeDiscountSchedule::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.FeeDiscountSchedule)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_quote_denoms()->Clear();
  _internal_mutable_tier_infos()->Clear();
  _internal_mutable_disqualified_market_ids()->Clear();
  ::memset(&_impl_.bucket_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.bucket_duration_) -
      reinterpret_cast<char*>(&_impl_.bucket_count_)) + sizeof(_impl_.bucket_duration_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeDiscountSchedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 bucket_count = 1 [json_name = "bucketCount"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.bucket_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 bucket_duration = 2 [json_name = "bucketDuration"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.bucket_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string quote_denoms = 3 [json_name = "quoteDenoms"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_quote_denoms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4 [json_name = "tierInfos"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tier_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string disqualified_market_ids = 5 [json_name = "disqualifiedMarketIds"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_disqualified_market_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeeDiscountSchedule::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.FeeDiscountSchedule)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 bucket_count = 1 [json_name = "bucketCount"];
  if (this->_internal_bucket_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_bucket_count(), target);
  }

  // int64 bucket_duration = 2 [json_name = "bucketDuration"];
  if (this->_internal_bucket_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_bucket_duration(), target);
  }

  // repeated string quote_denoms = 3 [json_name = "quoteDenoms"];
  for (int i = 0, n = this->_internal_quote_denoms_size(); i < n; ++i) {
    const auto& s = this->_internal_quote_denoms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.FeeDiscountSchedule.quote_denoms");
    target = stream->WriteString(3, s, target);
  }

  // repeated .injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4 [json_name = "tierInfos"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tier_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_tier_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string disqualified_market_ids = 5 [json_name = "disqualifiedMarketIds"];
  for (int i = 0, n = this->_internal_disqualified_market_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_disqualified_market_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.FeeDiscountSchedule.disqualified_market_ids");
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.FeeDiscountSchedule)
  return target;
}

::size_t FeeDiscountSchedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.FeeDiscountSchedule)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string quote_denoms = 3 [json_name = "quoteDenoms"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_quote_denoms().size());
  for (int i = 0, n = _internal_quote_denoms().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_quote_denoms().Get(i));
  }

  // repeated .injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4 [json_name = "tierInfos"];
  total_size += 1UL * this->_internal_tier_infos_size();
  for (const auto& msg : this->_internal_tier_infos()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string disqualified_market_ids = 5 [json_name = "disqualifiedMarketIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_disqualified_market_ids().size());
  for (int i = 0, n = _internal_disqualified_market_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_disqualified_market_ids().Get(i));
  }

  // uint64 bucket_count = 1 [json_name = "bucketCount"];
  if (this->_internal_bucket_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_bucket_count());
  }

  // int64 bucket_duration = 2 [json_name = "bucketDuration"];
  if (this->_internal_bucket_duration() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_bucket_duration());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeDiscountSchedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeDiscountSchedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeDiscountSchedule::GetClassData() const { return &_class_data_; }


void FeeDiscountSchedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeDiscountSchedule*>(&to_msg);
  auto& from = static_cast<const FeeDiscountSchedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.FeeDiscountSchedule)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_quote_denoms()->MergeFrom(from._internal_quote_denoms());
  _this->_internal_mutable_tier_infos()->MergeFrom(from._internal_tier_infos());
  _this->_internal_mutable_disqualified_market_ids()->MergeFrom(from._internal_disqualified_market_ids());
  if (from._internal_bucket_count() != 0) {
    _this->_internal_set_bucket_count(from._internal_bucket_count());
  }
  if (from._internal_bucket_duration() != 0) {
    _this->_internal_set_bucket_duration(from._internal_bucket_duration());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeDiscountSchedule::CopyFrom(const FeeDiscountSchedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.FeeDiscountSchedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeDiscountSchedule::IsInitialized() const {
  return true;
}

void FeeDiscountSchedule::InternalSwap(FeeDiscountSchedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_quote_denoms()->InternalSwap(
      other->_internal_mutable_quote_denoms());
  _internal_mutable_tier_infos()->InternalSwap(other->_internal_mutable_tier_infos());
  _internal_mutable_disqualified_market_ids()->InternalSwap(
      other->_internal_mutable_disqualified_market_ids());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeeDiscountSchedule, _impl_.bucket_duration_)
      + sizeof(FeeDiscountSchedule::_impl_.bucket_duration_)
      - PROTOBUF_FIELD_OFFSET(FeeDiscountSchedule, _impl_.bucket_count_)>(
          reinterpret_cast<char*>(&_impl_.bucket_count_),
          reinterpret_cast<char*>(&other->_impl_.bucket_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeDiscountSchedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[36]);
}
// ===================================================================

class FeeDiscountTierTTL::_Internal {
 public:
};

FeeDiscountTierTTL::FeeDiscountTierTTL(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.FeeDiscountTierTTL)
}
FeeDiscountTierTTL::FeeDiscountTierTTL(const FeeDiscountTierTTL& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.FeeDiscountTierTTL)
}

inline void FeeDiscountTierTTL::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.tier_) { ::uint64_t{0u} }

    , decltype(_impl_.ttl_timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeeDiscountTierTTL::~FeeDiscountTierTTL() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.FeeDiscountTierTTL)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeeDiscountTierTTL::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeeDiscountTierTTL::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeeDiscountTierTTL::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.FeeDiscountTierTTL)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.tier_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ttl_timestamp_) -
      reinterpret_cast<char*>(&_impl_.tier_)) + sizeof(_impl_.ttl_timestamp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeeDiscountTierTTL::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 tier = 1 [json_name = "tier"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 ttl_timestamp = 2 [json_name = "ttlTimestamp"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.ttl_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeeDiscountTierTTL::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.FeeDiscountTierTTL)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 tier = 1 [json_name = "tier"];
  if (this->_internal_tier() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_tier(), target);
  }

  // int64 ttl_timestamp = 2 [json_name = "ttlTimestamp"];
  if (this->_internal_ttl_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_ttl_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.FeeDiscountTierTTL)
  return target;
}

::size_t FeeDiscountTierTTL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.FeeDiscountTierTTL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 tier = 1 [json_name = "tier"];
  if (this->_internal_tier() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_tier());
  }

  // int64 ttl_timestamp = 2 [json_name = "ttlTimestamp"];
  if (this->_internal_ttl_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_ttl_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeeDiscountTierTTL::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeeDiscountTierTTL::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeeDiscountTierTTL::GetClassData() const { return &_class_data_; }


void FeeDiscountTierTTL::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeeDiscountTierTTL*>(&to_msg);
  auto& from = static_cast<const FeeDiscountTierTTL&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.FeeDiscountTierTTL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_tier() != 0) {
    _this->_internal_set_tier(from._internal_tier());
  }
  if (from._internal_ttl_timestamp() != 0) {
    _this->_internal_set_ttl_timestamp(from._internal_ttl_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeeDiscountTierTTL::CopyFrom(const FeeDiscountTierTTL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.FeeDiscountTierTTL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeeDiscountTierTTL::IsInitialized() const {
  return true;
}

void FeeDiscountTierTTL::InternalSwap(FeeDiscountTierTTL* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeeDiscountTierTTL, _impl_.ttl_timestamp_)
      + sizeof(FeeDiscountTierTTL::_impl_.ttl_timestamp_)
      - PROTOBUF_FIELD_OFFSET(FeeDiscountTierTTL, _impl_.tier_)>(
          reinterpret_cast<char*>(&_impl_.tier_),
          reinterpret_cast<char*>(&other->_impl_.tier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeeDiscountTierTTL::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[37]);
}
// ===================================================================

class VolumeRecord::_Internal {
 public:
};

VolumeRecord::VolumeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.VolumeRecord)
}
VolumeRecord::VolumeRecord(const VolumeRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VolumeRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.maker_volume_) {}

    , decltype(_impl_.taker_volume_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.maker_volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_maker_volume().empty()) {
    _this->_impl_.maker_volume_.Set(from._internal_maker_volume(), _this->GetArenaForAllocation());
  }
  _impl_.taker_volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_taker_volume().empty()) {
    _this->_impl_.taker_volume_.Set(from._internal_taker_volume(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.VolumeRecord)
}

inline void VolumeRecord::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.maker_volume_) {}

    , decltype(_impl_.taker_volume_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.maker_volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.maker_volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taker_volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.taker_volume_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VolumeRecord::~VolumeRecord() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.VolumeRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VolumeRecord::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.maker_volume_.Destroy();
  _impl_.taker_volume_.Destroy();
}

void VolumeRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.VolumeRecord)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.maker_volume_.ClearToEmpty();
  _impl_.taker_volume_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VolumeRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string maker_volume = 1 [json_name = "makerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_maker_volume();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.VolumeRecord.maker_volume"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string taker_volume = 2 [json_name = "takerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_taker_volume();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.VolumeRecord.taker_volume"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VolumeRecord::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.VolumeRecord)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string maker_volume = 1 [json_name = "makerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_volume().empty()) {
    const std::string& _s = this->_internal_maker_volume();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.VolumeRecord.maker_volume");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string taker_volume = 2 [json_name = "takerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_volume().empty()) {
    const std::string& _s = this->_internal_taker_volume();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.VolumeRecord.taker_volume");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.VolumeRecord)
  return target;
}

::size_t VolumeRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.VolumeRecord)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string maker_volume = 1 [json_name = "makerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_maker_volume().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_maker_volume());
  }

  // string taker_volume = 2 [json_name = "takerVolume", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_taker_volume().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_taker_volume());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VolumeRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VolumeRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VolumeRecord::GetClassData() const { return &_class_data_; }


void VolumeRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VolumeRecord*>(&to_msg);
  auto& from = static_cast<const VolumeRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.VolumeRecord)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_maker_volume().empty()) {
    _this->_internal_set_maker_volume(from._internal_maker_volume());
  }
  if (!from._internal_taker_volume().empty()) {
    _this->_internal_set_taker_volume(from._internal_taker_volume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VolumeRecord::CopyFrom(const VolumeRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.VolumeRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeRecord::IsInitialized() const {
  return true;
}

void VolumeRecord::InternalSwap(VolumeRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.maker_volume_, lhs_arena,
                                       &other->_impl_.maker_volume_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.taker_volume_, lhs_arena,
                                       &other->_impl_.taker_volume_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata VolumeRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[38]);
}
// ===================================================================

class AccountRewards::_Internal {
 public:
};

void AccountRewards::clear_rewards() {
  _internal_mutable_rewards()->Clear();
}
AccountRewards::AccountRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.AccountRewards)
}
AccountRewards::AccountRewards(const AccountRewards& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountRewards* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rewards_){from._impl_.rewards_}
    , decltype(_impl_.account_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account().empty()) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.AccountRewards)
}

inline void AccountRewards::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.rewards_){arena}
    , decltype(_impl_.account_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountRewards::~AccountRewards() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.AccountRewards)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountRewards::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_rewards()->~RepeatedPtrField();
  _impl_.account_.Destroy();
}

void AccountRewards::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountRewards::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.AccountRewards)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_rewards()->Clear();
  _impl_.account_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountRewards::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account = 1 [json_name = "account"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.AccountRewards.account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .cosmos.base.v1beta1.Coin rewards = 2 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rewards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountRewards::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.AccountRewards)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    const std::string& _s = this->_internal_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.AccountRewards.account");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .cosmos.base.v1beta1.Coin rewards = 2 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_rewards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.AccountRewards)
  return target;
}

::size_t AccountRewards::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.AccountRewards)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cosmos.base.v1beta1.Coin rewards = 2 [json_name = "rewards", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  total_size += 1UL * this->_internal_rewards_size();
  for (const auto& msg : this->_internal_rewards()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountRewards::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountRewards::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountRewards::GetClassData() const { return &_class_data_; }


void AccountRewards::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountRewards*>(&to_msg);
  auto& from = static_cast<const AccountRewards&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.AccountRewards)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_rewards()->MergeFrom(from._internal_rewards());
  if (!from._internal_account().empty()) {
    _this->_internal_set_account(from._internal_account());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountRewards::CopyFrom(const AccountRewards& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.AccountRewards)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountRewards::IsInitialized() const {
  return true;
}

void AccountRewards::InternalSwap(AccountRewards* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_rewards()->InternalSwap(other->_internal_mutable_rewards());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountRewards::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[39]);
}
// ===================================================================

class TradeRecords::_Internal {
 public:
};

TradeRecords::TradeRecords(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.TradeRecords)
}
TradeRecords::TradeRecords(const TradeRecords& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeRecords* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_trade_records_){from._impl_.latest_trade_records_}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.TradeRecords)
}

inline void TradeRecords::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_trade_records_){arena}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeRecords::~TradeRecords() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.TradeRecords)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeRecords::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_latest_trade_records()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void TradeRecords::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeRecords::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.TradeRecords)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_latest_trade_records()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeRecords::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradeRecords.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.TradeRecord latest_trade_records = 2 [json_name = "latestTradeRecords"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_latest_trade_records(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradeRecords::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.TradeRecords)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradeRecords.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.TradeRecord latest_trade_records = 2 [json_name = "latestTradeRecords"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_latest_trade_records_size()); i < n; i++) {
    const auto& repfield = this->_internal_latest_trade_records(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.TradeRecords)
  return target;
}

::size_t TradeRecords::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.TradeRecords)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.TradeRecord latest_trade_records = 2 [json_name = "latestTradeRecords"];
  total_size += 1UL * this->_internal_latest_trade_records_size();
  for (const auto& msg : this->_internal_latest_trade_records()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeRecords::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeRecords::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeRecords::GetClassData() const { return &_class_data_; }


void TradeRecords::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeRecords*>(&to_msg);
  auto& from = static_cast<const TradeRecords&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.TradeRecords)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_latest_trade_records()->MergeFrom(from._internal_latest_trade_records());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeRecords::CopyFrom(const TradeRecords& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.TradeRecords)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeRecords::IsInitialized() const {
  return true;
}

void TradeRecords::InternalSwap(TradeRecords* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_latest_trade_records()->InternalSwap(other->_internal_mutable_latest_trade_records());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeRecords::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[40]);
}
// ===================================================================

class SubaccountIDs::_Internal {
 public:
};

SubaccountIDs::SubaccountIDs(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.SubaccountIDs)
}
SubaccountIDs::SubaccountIDs(const SubaccountIDs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountIDs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_ids_){from._impl_.subaccount_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.SubaccountIDs)
}

inline void SubaccountIDs::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SubaccountIDs::~SubaccountIDs() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.SubaccountIDs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountIDs::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_subaccount_ids()->~RepeatedPtrField();
}

void SubaccountIDs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountIDs::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.SubaccountIDs)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_subaccount_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountIDs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes subaccount_ids = 1 [json_name = "subaccountIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_subaccount_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountIDs::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.SubaccountIDs)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes subaccount_ids = 1 [json_name = "subaccountIds"];
  for (int i = 0, n = this->_internal_subaccount_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_subaccount_ids(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.SubaccountIDs)
  return target;
}

::size_t SubaccountIDs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.SubaccountIDs)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes subaccount_ids = 1 [json_name = "subaccountIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_subaccount_ids().size());
  for (int i = 0, n = _internal_subaccount_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        _internal_subaccount_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountIDs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountIDs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountIDs::GetClassData() const { return &_class_data_; }


void SubaccountIDs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountIDs*>(&to_msg);
  auto& from = static_cast<const SubaccountIDs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.SubaccountIDs)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_subaccount_ids()->MergeFrom(from._internal_subaccount_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountIDs::CopyFrom(const SubaccountIDs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.SubaccountIDs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountIDs::IsInitialized() const {
  return true;
}

void SubaccountIDs::InternalSwap(SubaccountIDs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_subaccount_ids()->InternalSwap(
      other->_internal_mutable_subaccount_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountIDs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[41]);
}
// ===================================================================

class TradeRecord::_Internal {
 public:
};

TradeRecord::TradeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.TradeRecord)
}
TradeRecord::TradeRecord(const TradeRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TradeRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.timestamp_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_price().empty()) {
    _this->_impl_.price_.Set(from._internal_price(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), _this->GetArenaForAllocation());
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.TradeRecord)
}

inline void TradeRecord::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.price_) {}

    , decltype(_impl_.quantity_) {}

    , decltype(_impl_.timestamp_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TradeRecord::~TradeRecord() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.TradeRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TradeRecord::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.price_.Destroy();
  _impl_.quantity_.Destroy();
}

void TradeRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TradeRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.TradeRecord)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.price_.ClearToEmpty();
  _impl_.quantity_.ClearToEmpty();
  _impl_.timestamp_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TradeRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 timestamp = 1 [json_name = "timestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradeRecord.price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity = 3 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.TradeRecord.quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TradeRecord::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.TradeRecord)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 timestamp = 1 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_timestamp(), target);
  }

  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    const std::string& _s = this->_internal_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradeRecord.price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string quantity = 3 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    const std::string& _s = this->_internal_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.TradeRecord.quantity");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.TradeRecord)
  return target;
}

::size_t TradeRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.TradeRecord)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string price = 2 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_price());
  }

  // string quantity = 3 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity());
  }

  // int64 timestamp = 1 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TradeRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TradeRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TradeRecord::GetClassData() const { return &_class_data_; }


void TradeRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TradeRecord*>(&to_msg);
  auto& from = static_cast<const TradeRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.TradeRecord)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_price().empty()) {
    _this->_internal_set_price(from._internal_price());
  }
  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TradeRecord::CopyFrom(const TradeRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.TradeRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TradeRecord::IsInitialized() const {
  return true;
}

void TradeRecord::InternalSwap(TradeRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.price_, lhs_arena,
                                       &other->_impl_.price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_, lhs_arena,
                                       &other->_impl_.quantity_, rhs_arena);

  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TradeRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[42]);
}
// ===================================================================

class Level::_Internal {
 public:
};

Level::Level(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.Level)
}
Level::Level(const Level& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Level* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.p_) {}

    , decltype(_impl_.q_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.p_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_p().empty()) {
    _this->_impl_.p_.Set(from._internal_p(), _this->GetArenaForAllocation());
  }
  _impl_.q_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.q_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_q().empty()) {
    _this->_impl_.q_.Set(from._internal_q(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.Level)
}

inline void Level::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.p_) {}

    , decltype(_impl_.q_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.p_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.p_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.q_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.q_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Level::~Level() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.Level)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Level::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.p_.Destroy();
  _impl_.q_.Destroy();
}

void Level::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Level::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.Level)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.p_.ClearToEmpty();
  _impl_.q_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Level::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string p = 1 [json_name = "p", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_p();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Level.p"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string q = 2 [json_name = "q", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_q();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.Level.q"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Level::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.Level)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string p = 1 [json_name = "p", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_p().empty()) {
    const std::string& _s = this->_internal_p();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Level.p");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string q = 2 [json_name = "q", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_q().empty()) {
    const std::string& _s = this->_internal_q();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.Level.q");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.Level)
  return target;
}

::size_t Level::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.Level)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string p = 1 [json_name = "p", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_p().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_p());
  }

  // string q = 2 [json_name = "q", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_q().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_q());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Level::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Level::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Level::GetClassData() const { return &_class_data_; }


void Level::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Level*>(&to_msg);
  auto& from = static_cast<const Level&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.Level)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_p().empty()) {
    _this->_internal_set_p(from._internal_p());
  }
  if (!from._internal_q().empty()) {
    _this->_internal_set_q(from._internal_q());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Level::CopyFrom(const Level& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.Level)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Level::IsInitialized() const {
  return true;
}

void Level::InternalSwap(Level* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.p_, lhs_arena,
                                       &other->_impl_.p_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.q_, lhs_arena,
                                       &other->_impl_.q_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Level::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[43]);
}
// ===================================================================

class AggregateSubaccountVolumeRecord::_Internal {
 public:
};

AggregateSubaccountVolumeRecord::AggregateSubaccountVolumeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
}
AggregateSubaccountVolumeRecord::AggregateSubaccountVolumeRecord(const AggregateSubaccountVolumeRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AggregateSubaccountVolumeRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_volumes_){from._impl_.market_volumes_}
    , decltype(_impl_.subaccount_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
}

inline void AggregateSubaccountVolumeRecord::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_volumes_){arena}
    , decltype(_impl_.subaccount_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AggregateSubaccountVolumeRecord::~AggregateSubaccountVolumeRecord() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AggregateSubaccountVolumeRecord::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_volumes()->~RepeatedPtrField();
  _impl_.subaccount_id_.Destroy();
}

void AggregateSubaccountVolumeRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AggregateSubaccountVolumeRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_volumes()->Clear();
  _impl_.subaccount_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AggregateSubaccountVolumeRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_market_volumes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AggregateSubaccountVolumeRecord::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_market_volumes_size()); i < n; i++) {
    const auto& repfield = this->_internal_market_volumes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
  return target;
}

::size_t AggregateSubaccountVolumeRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
  total_size += 1UL * this->_internal_market_volumes_size();
  for (const auto& msg : this->_internal_market_volumes()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AggregateSubaccountVolumeRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AggregateSubaccountVolumeRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AggregateSubaccountVolumeRecord::GetClassData() const { return &_class_data_; }


void AggregateSubaccountVolumeRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AggregateSubaccountVolumeRecord*>(&to_msg);
  auto& from = static_cast<const AggregateSubaccountVolumeRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_volumes()->MergeFrom(from._internal_market_volumes());
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AggregateSubaccountVolumeRecord::CopyFrom(const AggregateSubaccountVolumeRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.AggregateSubaccountVolumeRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AggregateSubaccountVolumeRecord::IsInitialized() const {
  return true;
}

void AggregateSubaccountVolumeRecord::InternalSwap(AggregateSubaccountVolumeRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_volumes()->InternalSwap(other->_internal_mutable_market_volumes());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AggregateSubaccountVolumeRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[44]);
}
// ===================================================================

class AggregateAccountVolumeRecord::_Internal {
 public:
};

AggregateAccountVolumeRecord::AggregateAccountVolumeRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
}
AggregateAccountVolumeRecord::AggregateAccountVolumeRecord(const AggregateAccountVolumeRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AggregateAccountVolumeRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_volumes_){from._impl_.market_volumes_}
    , decltype(_impl_.account_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account().empty()) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
}

inline void AggregateAccountVolumeRecord::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_volumes_){arena}
    , decltype(_impl_.account_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AggregateAccountVolumeRecord::~AggregateAccountVolumeRecord() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AggregateAccountVolumeRecord::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_volumes()->~RepeatedPtrField();
  _impl_.account_.Destroy();
}

void AggregateAccountVolumeRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AggregateAccountVolumeRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_volumes()->Clear();
  _impl_.account_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AggregateAccountVolumeRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account = 1 [json_name = "account"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.AggregateAccountVolumeRecord.account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_market_volumes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AggregateAccountVolumeRecord::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    const std::string& _s = this->_internal_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.AggregateAccountVolumeRecord.account");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_market_volumes_size()); i < n; i++) {
    const auto& repfield = this->_internal_market_volumes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
  return target;
}

::size_t AggregateAccountVolumeRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2 [json_name = "marketVolumes"];
  total_size += 1UL * this->_internal_market_volumes_size();
  for (const auto& msg : this->_internal_market_volumes()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AggregateAccountVolumeRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AggregateAccountVolumeRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AggregateAccountVolumeRecord::GetClassData() const { return &_class_data_; }


void AggregateAccountVolumeRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AggregateAccountVolumeRecord*>(&to_msg);
  auto& from = static_cast<const AggregateAccountVolumeRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_volumes()->MergeFrom(from._internal_market_volumes());
  if (!from._internal_account().empty()) {
    _this->_internal_set_account(from._internal_account());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AggregateAccountVolumeRecord::CopyFrom(const AggregateAccountVolumeRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.AggregateAccountVolumeRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AggregateAccountVolumeRecord::IsInitialized() const {
  return true;
}

void AggregateAccountVolumeRecord::InternalSwap(AggregateAccountVolumeRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_volumes()->InternalSwap(other->_internal_mutable_market_volumes());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AggregateAccountVolumeRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[45]);
}
// ===================================================================

class MarketVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<MarketVolume>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MarketVolume, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::VolumeRecord& volume(const MarketVolume* msg);
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::VolumeRecord&
MarketVolume::_Internal::volume(const MarketVolume* msg) {
  return *msg->_impl_.volume_;
}
MarketVolume::MarketVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.MarketVolume)
}
MarketVolume::MarketVolume(const MarketVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MarketVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.volume_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.volume_ = new ::injective::exchange::v1beta1::VolumeRecord(*from._impl_.volume_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.MarketVolume)
}

inline void MarketVolume::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.volume_){nullptr}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarketVolume::~MarketVolume() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.MarketVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarketVolume::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.volume_;
}

void MarketVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MarketVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.MarketVolume)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.volume_ != nullptr);
    _impl_.volume_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MarketVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.MarketVolume.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.VolumeRecord volume = 2 [json_name = "volume", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MarketVolume::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.MarketVolume)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.MarketVolume.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.VolumeRecord volume = 2 [json_name = "volume", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::volume(this),
        _Internal::volume(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.MarketVolume)
  return target;
}

::size_t MarketVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.MarketVolume)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective.exchange.v1beta1.VolumeRecord volume = 2 [json_name = "volume", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.volume_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MarketVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MarketVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MarketVolume::GetClassData() const { return &_class_data_; }


void MarketVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MarketVolume*>(&to_msg);
  auto& from = static_cast<const MarketVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.MarketVolume)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_volume()->::injective::exchange::v1beta1::VolumeRecord::MergeFrom(
        from._internal_volume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MarketVolume::CopyFrom(const MarketVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.MarketVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketVolume::IsInitialized() const {
  return true;
}

void MarketVolume::InternalSwap(MarketVolume* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  swap(_impl_.volume_, other->_impl_.volume_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MarketVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[46]);
}
// ===================================================================

class DenomDecimals::_Internal {
 public:
};

DenomDecimals::DenomDecimals(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DenomDecimals)
}
DenomDecimals::DenomDecimals(const DenomDecimals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DenomDecimals* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denom_) {}

    , decltype(_impl_.decimals_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  _this->_impl_.decimals_ = from._impl_.decimals_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DenomDecimals)
}

inline void DenomDecimals::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.denom_) {}

    , decltype(_impl_.decimals_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DenomDecimals::~DenomDecimals() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DenomDecimals)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DenomDecimals::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.denom_.Destroy();
}

void DenomDecimals::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DenomDecimals::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DenomDecimals)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.denom_.ClearToEmpty();
  _impl_.decimals_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DenomDecimals::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string denom = 1 [json_name = "denom"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DenomDecimals.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 decimals = 2 [json_name = "decimals"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.decimals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DenomDecimals::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DenomDecimals)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DenomDecimals.denom");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint64 decimals = 2 [json_name = "decimals"];
  if (this->_internal_decimals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_decimals(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DenomDecimals)
  return target;
}

::size_t DenomDecimals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DenomDecimals)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  // uint64 decimals = 2 [json_name = "decimals"];
  if (this->_internal_decimals() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_decimals());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DenomDecimals::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DenomDecimals::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DenomDecimals::GetClassData() const { return &_class_data_; }


void DenomDecimals::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DenomDecimals*>(&to_msg);
  auto& from = static_cast<const DenomDecimals&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DenomDecimals)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  if (from._internal_decimals() != 0) {
    _this->_internal_set_decimals(from._internal_decimals());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DenomDecimals::CopyFrom(const DenomDecimals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DenomDecimals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenomDecimals::IsInitialized() const {
  return true;
}

void DenomDecimals::InternalSwap(DenomDecimals* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);

  swap(_impl_.decimals_, other->_impl_.decimals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DenomDecimals::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fexchange_2eproto[47]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::Params*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::Params >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::MarketFeeMultiplier*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::MarketFeeMultiplier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::MarketFeeMultiplier >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeMarket*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeMarket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeMarket >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::BinaryOptionsMarket*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::BinaryOptionsMarket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::BinaryOptionsMarket >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::PerpetualMarketInfo*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::PerpetualMarketInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::PerpetualMarketInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::PerpetualMarketFunding*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::PerpetualMarketFunding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::PerpetualMarketFunding >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeMarketSettlementInfo*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeMarketSettlementInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeMarketSettlementInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::NextFundingTimestamp*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::NextFundingTimestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::NextFundingTimestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::MidPriceAndTOB*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::MidPriceAndTOB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::MidPriceAndTOB >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SpotMarket*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SpotMarket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SpotMarket >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::Deposit*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::Deposit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::Deposit >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountTradeNonce*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountTradeNonce >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountTradeNonce >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::OrderInfo*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::OrderInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::OrderInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SpotOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SpotOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SpotOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SpotLimitOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SpotLimitOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SpotLimitOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SpotMarketOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SpotMarketOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SpotMarketOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountOrderbookMetadata*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountOrderbookMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountOrderbookMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountOrderData*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountOrderData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountOrderData >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeLimitOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeLimitOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeLimitOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeMarketOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeMarketOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeMarketOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::Position*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::Position >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::MarketOrderIndicator*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::MarketOrderIndicator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::MarketOrderIndicator >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::TradeLog*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::TradeLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::TradeLog >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::PositionDelta*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::PositionDelta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::PositionDelta >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeTradeLog*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeTradeLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeTradeLog >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountPosition*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountDeposit*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountDeposit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountDeposit >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DepositUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DepositUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DepositUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::PointsMultiplier*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::PointsMultiplier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::PointsMultiplier >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::TradingRewardCampaignBoostInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::CampaignRewardPool*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::CampaignRewardPool >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::CampaignRewardPool >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::TradingRewardCampaignInfo*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::TradingRewardCampaignInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::TradingRewardCampaignInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::FeeDiscountTierInfo*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::FeeDiscountTierInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::FeeDiscountTierInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::FeeDiscountSchedule*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::FeeDiscountSchedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::FeeDiscountSchedule >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::FeeDiscountTierTTL*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::FeeDiscountTierTTL >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::FeeDiscountTierTTL >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::VolumeRecord*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::VolumeRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::VolumeRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::AccountRewards*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::AccountRewards >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::AccountRewards >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::TradeRecords*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::TradeRecords >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::TradeRecords >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::SubaccountIDs*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::SubaccountIDs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::SubaccountIDs >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::TradeRecord*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::TradeRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::TradeRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::Level*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::Level >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::Level >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::AggregateSubaccountVolumeRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::AggregateAccountVolumeRecord*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::AggregateAccountVolumeRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::AggregateAccountVolumeRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::MarketVolume*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::MarketVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::MarketVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DenomDecimals*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DenomDecimals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DenomDecimals >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
