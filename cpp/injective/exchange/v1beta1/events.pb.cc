// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/exchange/v1beta1/events.proto

#include "injective/exchange/v1beta1/events.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace injective {
namespace exchange {
namespace v1beta1 {
template <typename>
PROTOBUF_CONSTEXPR EventBatchSpotExecution::EventBatchSpotExecution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.trades_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.is_buy_)*/ false

  , /*decltype(_impl_.executiontype_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventBatchSpotExecutionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventBatchSpotExecutionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventBatchSpotExecutionDefaultTypeInternal() {}
  union {
    EventBatchSpotExecution _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventBatchSpotExecutionDefaultTypeInternal _EventBatchSpotExecution_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventBatchDerivativeExecution::EventBatchDerivativeExecution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.trades_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.cumulative_funding_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.is_buy_)*/ false

  , /*decltype(_impl_.is_liquidation_)*/ false

  , /*decltype(_impl_.executiontype_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventBatchDerivativeExecutionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventBatchDerivativeExecutionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventBatchDerivativeExecutionDefaultTypeInternal() {}
  union {
    EventBatchDerivativeExecution _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventBatchDerivativeExecutionDefaultTypeInternal _EventBatchDerivativeExecution_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventLostFundsFromLiquidation::EventLostFundsFromLiquidation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.lost_funds_from_available_during_payout_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.lost_funds_from_order_cancels_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventLostFundsFromLiquidationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventLostFundsFromLiquidationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventLostFundsFromLiquidationDefaultTypeInternal() {}
  union {
    EventLostFundsFromLiquidation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventLostFundsFromLiquidationDefaultTypeInternal _EventLostFundsFromLiquidation_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventBatchDerivativePosition::EventBatchDerivativePosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.positions_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventBatchDerivativePositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventBatchDerivativePositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventBatchDerivativePositionDefaultTypeInternal() {}
  union {
    EventBatchDerivativePosition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventBatchDerivativePositionDefaultTypeInternal _EventBatchDerivativePosition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventDerivativeMarketPaused::EventDerivativeMarketPaused(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.settle_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.total_missing_funds_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.missing_funds_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventDerivativeMarketPausedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventDerivativeMarketPausedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventDerivativeMarketPausedDefaultTypeInternal() {}
  union {
    EventDerivativeMarketPaused _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDerivativeMarketPausedDefaultTypeInternal _EventDerivativeMarketPaused_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventMarketBeyondBankruptcy::EventMarketBeyondBankruptcy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.settle_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.missing_market_funds_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventMarketBeyondBankruptcyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventMarketBeyondBankruptcyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventMarketBeyondBankruptcyDefaultTypeInternal() {}
  union {
    EventMarketBeyondBankruptcy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventMarketBeyondBankruptcyDefaultTypeInternal _EventMarketBeyondBankruptcy_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventAllPositionsHaircut::EventAllPositionsHaircut(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.settle_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.missing_funds_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventAllPositionsHaircutDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventAllPositionsHaircutDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventAllPositionsHaircutDefaultTypeInternal() {}
  union {
    EventAllPositionsHaircut _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventAllPositionsHaircutDefaultTypeInternal _EventAllPositionsHaircut_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventBinaryOptionsMarketUpdate::EventBinaryOptionsMarketUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_)*/nullptr} {}
struct EventBinaryOptionsMarketUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventBinaryOptionsMarketUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventBinaryOptionsMarketUpdateDefaultTypeInternal() {}
  union {
    EventBinaryOptionsMarketUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventBinaryOptionsMarketUpdateDefaultTypeInternal _EventBinaryOptionsMarketUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventNewSpotOrders::EventNewSpotOrders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buy_orders_)*/{}
  , /*decltype(_impl_.sell_orders_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventNewSpotOrdersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventNewSpotOrdersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventNewSpotOrdersDefaultTypeInternal() {}
  union {
    EventNewSpotOrders _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventNewSpotOrdersDefaultTypeInternal _EventNewSpotOrders_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventNewDerivativeOrders::EventNewDerivativeOrders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buy_orders_)*/{}
  , /*decltype(_impl_.sell_orders_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventNewDerivativeOrdersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventNewDerivativeOrdersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventNewDerivativeOrdersDefaultTypeInternal() {}
  union {
    EventNewDerivativeOrders _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventNewDerivativeOrdersDefaultTypeInternal _EventNewDerivativeOrders_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventCancelSpotOrder::EventCancelSpotOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_)*/nullptr} {}
struct EventCancelSpotOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventCancelSpotOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventCancelSpotOrderDefaultTypeInternal() {}
  union {
    EventCancelSpotOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventCancelSpotOrderDefaultTypeInternal _EventCancelSpotOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventSpotMarketUpdate::EventSpotMarketUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_)*/nullptr} {}
struct EventSpotMarketUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventSpotMarketUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventSpotMarketUpdateDefaultTypeInternal() {}
  union {
    EventSpotMarketUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventSpotMarketUpdateDefaultTypeInternal _EventSpotMarketUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventPerpetualMarketUpdate::EventPerpetualMarketUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_)*/nullptr
  , /*decltype(_impl_.perpetual_market_info_)*/nullptr
  , /*decltype(_impl_.funding_)*/nullptr} {}
struct EventPerpetualMarketUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventPerpetualMarketUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventPerpetualMarketUpdateDefaultTypeInternal() {}
  union {
    EventPerpetualMarketUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventPerpetualMarketUpdateDefaultTypeInternal _EventPerpetualMarketUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventExpiryFuturesMarketUpdate::EventExpiryFuturesMarketUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_)*/nullptr
  , /*decltype(_impl_.expiry_futures_market_info_)*/nullptr} {}
struct EventExpiryFuturesMarketUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventExpiryFuturesMarketUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventExpiryFuturesMarketUpdateDefaultTypeInternal() {}
  union {
    EventExpiryFuturesMarketUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventExpiryFuturesMarketUpdateDefaultTypeInternal _EventExpiryFuturesMarketUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventPerpetualMarketFundingUpdate::EventPerpetualMarketFundingUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.funding_rate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.mark_price_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.funding_)*/nullptr
  , /*decltype(_impl_.is_hourly_funding_)*/ false
} {}
struct EventPerpetualMarketFundingUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventPerpetualMarketFundingUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventPerpetualMarketFundingUpdateDefaultTypeInternal() {}
  union {
    EventPerpetualMarketFundingUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventPerpetualMarketFundingUpdateDefaultTypeInternal _EventPerpetualMarketFundingUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventSubaccountDeposit::EventSubaccountDeposit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.src_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.amount_)*/nullptr} {}
struct EventSubaccountDepositDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventSubaccountDepositDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventSubaccountDepositDefaultTypeInternal() {}
  union {
    EventSubaccountDeposit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventSubaccountDepositDefaultTypeInternal _EventSubaccountDeposit_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventSubaccountWithdraw::EventSubaccountWithdraw(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dst_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.amount_)*/nullptr} {}
struct EventSubaccountWithdrawDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventSubaccountWithdrawDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventSubaccountWithdrawDefaultTypeInternal() {}
  union {
    EventSubaccountWithdraw _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventSubaccountWithdrawDefaultTypeInternal _EventSubaccountWithdraw_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventSubaccountBalanceTransfer::EventSubaccountBalanceTransfer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.src_subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dst_subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.amount_)*/nullptr} {}
struct EventSubaccountBalanceTransferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventSubaccountBalanceTransferDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventSubaccountBalanceTransferDefaultTypeInternal() {}
  union {
    EventSubaccountBalanceTransfer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventSubaccountBalanceTransferDefaultTypeInternal _EventSubaccountBalanceTransfer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventBatchDepositUpdate::EventBatchDepositUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.deposit_updates_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventBatchDepositUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventBatchDepositUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventBatchDepositUpdateDefaultTypeInternal() {}
  union {
    EventBatchDepositUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventBatchDepositUpdateDefaultTypeInternal _EventBatchDepositUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DerivativeMarketOrderCancel::DerivativeMarketOrderCancel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cancel_quantity_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_order_)*/nullptr} {}
struct DerivativeMarketOrderCancelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DerivativeMarketOrderCancelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DerivativeMarketOrderCancelDefaultTypeInternal() {}
  union {
    DerivativeMarketOrderCancel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DerivativeMarketOrderCancelDefaultTypeInternal _DerivativeMarketOrderCancel_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventCancelDerivativeOrder::EventCancelDerivativeOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.limit_order_)*/nullptr
  , /*decltype(_impl_.market_order_cancel_)*/nullptr
  , /*decltype(_impl_.islimitcancel_)*/ false
} {}
struct EventCancelDerivativeOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventCancelDerivativeOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventCancelDerivativeOrderDefaultTypeInternal() {}
  union {
    EventCancelDerivativeOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventCancelDerivativeOrderDefaultTypeInternal _EventCancelDerivativeOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventFeeDiscountSchedule::EventFeeDiscountSchedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.schedule_)*/nullptr} {}
struct EventFeeDiscountScheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventFeeDiscountScheduleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventFeeDiscountScheduleDefaultTypeInternal() {}
  union {
    EventFeeDiscountSchedule _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventFeeDiscountScheduleDefaultTypeInternal _EventFeeDiscountSchedule_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventTradingRewardCampaignUpdate::EventTradingRewardCampaignUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.campaign_reward_pools_)*/{}
  , /*decltype(_impl_.campaign_info_)*/nullptr} {}
struct EventTradingRewardCampaignUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventTradingRewardCampaignUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventTradingRewardCampaignUpdateDefaultTypeInternal() {}
  union {
    EventTradingRewardCampaignUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventTradingRewardCampaignUpdateDefaultTypeInternal _EventTradingRewardCampaignUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventTradingRewardDistribution::EventTradingRewardDistribution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_rewards_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventTradingRewardDistributionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventTradingRewardDistributionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventTradingRewardDistributionDefaultTypeInternal() {}
  union {
    EventTradingRewardDistribution _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventTradingRewardDistributionDefaultTypeInternal _EventTradingRewardDistribution_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventNewConditionalDerivativeOrder::EventNewConditionalDerivativeOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_)*/nullptr
  , /*decltype(_impl_.is_market_)*/ false
} {}
struct EventNewConditionalDerivativeOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventNewConditionalDerivativeOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventNewConditionalDerivativeOrderDefaultTypeInternal() {}
  union {
    EventNewConditionalDerivativeOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventNewConditionalDerivativeOrderDefaultTypeInternal _EventNewConditionalDerivativeOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventCancelConditionalDerivativeOrder::EventCancelConditionalDerivativeOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.limit_order_)*/nullptr
  , /*decltype(_impl_.market_order_)*/nullptr
  , /*decltype(_impl_.islimitcancel_)*/ false
} {}
struct EventCancelConditionalDerivativeOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventCancelConditionalDerivativeOrderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventCancelConditionalDerivativeOrderDefaultTypeInternal() {}
  union {
    EventCancelConditionalDerivativeOrder _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventCancelConditionalDerivativeOrderDefaultTypeInternal _EventCancelConditionalDerivativeOrder_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventConditionalDerivativeOrderTrigger::EventConditionalDerivativeOrderTrigger(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.triggered_order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.placed_order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.islimittrigger_)*/ false

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventConditionalDerivativeOrderTriggerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventConditionalDerivativeOrderTriggerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventConditionalDerivativeOrderTriggerDefaultTypeInternal() {}
  union {
    EventConditionalDerivativeOrderTrigger _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventConditionalDerivativeOrderTriggerDefaultTypeInternal _EventConditionalDerivativeOrderTrigger_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventOrderFail::EventOrderFail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hashes_)*/{}
  , /*decltype(_impl_.flags_)*/ {}
  ,/* _impl_._flags_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventOrderFailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventOrderFailDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventOrderFailDefaultTypeInternal() {}
  union {
    EventOrderFail _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventOrderFailDefaultTypeInternal _EventOrderFail_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventAtomicMarketOrderFeeMultipliersUpdated::EventAtomicMarketOrderFeeMultipliersUpdated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.market_fee_multipliers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventAtomicMarketOrderFeeMultipliersUpdatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventAtomicMarketOrderFeeMultipliersUpdatedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventAtomicMarketOrderFeeMultipliersUpdatedDefaultTypeInternal() {}
  union {
    EventAtomicMarketOrderFeeMultipliersUpdated _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventAtomicMarketOrderFeeMultipliersUpdatedDefaultTypeInternal _EventAtomicMarketOrderFeeMultipliersUpdated_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EventOrderbookUpdate::EventOrderbookUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.spot_updates_)*/{}
  , /*decltype(_impl_.derivative_updates_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventOrderbookUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventOrderbookUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventOrderbookUpdateDefaultTypeInternal() {}
  union {
    EventOrderbookUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventOrderbookUpdateDefaultTypeInternal _EventOrderbookUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderbookUpdate::OrderbookUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.orderbook_)*/nullptr
  , /*decltype(_impl_.seq_)*/ ::uint64_t{0u}
} {}
struct OrderbookUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookUpdateDefaultTypeInternal() {}
  union {
    OrderbookUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookUpdateDefaultTypeInternal _OrderbookUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Orderbook::Orderbook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buy_levels_)*/{}
  , /*decltype(_impl_.sell_levels_)*/{}
  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderbookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderbookDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderbookDefaultTypeInternal() {}
  union {
    Orderbook _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderbookDefaultTypeInternal _Orderbook_default_instance_;
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
static ::_pb::Metadata file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[32];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fevents_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_injective_2fexchange_2fv1beta1_2fevents_2eproto = nullptr;
const ::uint32_t TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchSpotExecution, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchSpotExecution, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchSpotExecution, _impl_.is_buy_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchSpotExecution, _impl_.executiontype_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchSpotExecution, _impl_.trades_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativeExecution, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativeExecution, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativeExecution, _impl_.is_buy_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativeExecution, _impl_.is_liquidation_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativeExecution, _impl_.cumulative_funding_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativeExecution, _impl_.executiontype_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativeExecution, _impl_.trades_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventLostFundsFromLiquidation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventLostFundsFromLiquidation, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventLostFundsFromLiquidation, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventLostFundsFromLiquidation, _impl_.lost_funds_from_available_during_payout_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventLostFundsFromLiquidation, _impl_.lost_funds_from_order_cancels_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativePosition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativePosition, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDerivativePosition, _impl_.positions_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventDerivativeMarketPaused, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventDerivativeMarketPaused, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventDerivativeMarketPaused, _impl_.settle_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventDerivativeMarketPaused, _impl_.total_missing_funds_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventDerivativeMarketPaused, _impl_.missing_funds_rate_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventMarketBeyondBankruptcy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventMarketBeyondBankruptcy, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventMarketBeyondBankruptcy, _impl_.settle_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventMarketBeyondBankruptcy, _impl_.missing_market_funds_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventAllPositionsHaircut, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventAllPositionsHaircut, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventAllPositionsHaircut, _impl_.settle_price_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventAllPositionsHaircut, _impl_.missing_funds_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate, _impl_.market_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewSpotOrders, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewSpotOrders, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewSpotOrders, _impl_.buy_orders_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewSpotOrders, _impl_.sell_orders_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewDerivativeOrders, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewDerivativeOrders, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewDerivativeOrders, _impl_.buy_orders_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewDerivativeOrders, _impl_.sell_orders_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelSpotOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelSpotOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelSpotOrder, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelSpotOrder, _impl_.order_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSpotMarketUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSpotMarketUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSpotMarketUpdate, _impl_.market_),
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketUpdate, _impl_.market_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketUpdate, _impl_.perpetual_market_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketUpdate, _impl_.funding_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate, _impl_.market_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate, _impl_.expiry_futures_market_info_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate, _impl_.funding_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate, _impl_.is_hourly_funding_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate, _impl_.funding_rate_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate, _impl_.mark_price_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountDeposit, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountDeposit, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountDeposit, _impl_.src_address_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountDeposit, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountDeposit, _impl_.amount_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountWithdraw, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountWithdraw, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountWithdraw, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountWithdraw, _impl_.dst_address_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountWithdraw, _impl_.amount_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountBalanceTransfer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountBalanceTransfer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountBalanceTransfer, _impl_.src_subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountBalanceTransfer, _impl_.dst_subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventSubaccountBalanceTransfer, _impl_.amount_),
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDepositUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventBatchDepositUpdate, _impl_.deposit_updates_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrderCancel, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrderCancel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrderCancel, _impl_.market_order_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::DerivativeMarketOrderCancel, _impl_.cancel_quantity_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelDerivativeOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelDerivativeOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelDerivativeOrder, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelDerivativeOrder, _impl_.islimitcancel_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelDerivativeOrder, _impl_.limit_order_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelDerivativeOrder, _impl_.market_order_cancel_),
    ~0u,
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventFeeDiscountSchedule, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventFeeDiscountSchedule, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventFeeDiscountSchedule, _impl_.schedule_),
    0,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate, _impl_.campaign_info_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate, _impl_.campaign_reward_pools_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventTradingRewardDistribution, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventTradingRewardDistribution, _impl_.account_rewards_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder, _impl_.hash_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder, _impl_.is_market_),
    ~0u,
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder, _impl_.islimitcancel_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder, _impl_.limit_order_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder, _impl_.market_order_),
    ~0u,
    ~0u,
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger, _impl_.islimittrigger_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger, _impl_.triggered_order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger, _impl_.placed_order_hash_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventOrderFail, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventOrderFail, _impl_.account_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventOrderFail, _impl_.hashes_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventOrderFail, _impl_.flags_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated, _impl_.market_fee_multipliers_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventOrderbookUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventOrderbookUpdate, _impl_.spot_updates_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::EventOrderbookUpdate, _impl_.derivative_updates_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderbookUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderbookUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderbookUpdate, _impl_.seq_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::OrderbookUpdate, _impl_.orderbook_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Orderbook, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Orderbook, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Orderbook, _impl_.buy_levels_),
    PROTOBUF_FIELD_OFFSET(::injective::exchange::v1beta1::Orderbook, _impl_.sell_levels_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::injective::exchange::v1beta1::EventBatchSpotExecution)},
        { 12, -1, -1, sizeof(::injective::exchange::v1beta1::EventBatchDerivativeExecution)},
        { 26, -1, -1, sizeof(::injective::exchange::v1beta1::EventLostFundsFromLiquidation)},
        { 38, -1, -1, sizeof(::injective::exchange::v1beta1::EventBatchDerivativePosition)},
        { 48, -1, -1, sizeof(::injective::exchange::v1beta1::EventDerivativeMarketPaused)},
        { 60, -1, -1, sizeof(::injective::exchange::v1beta1::EventMarketBeyondBankruptcy)},
        { 71, -1, -1, sizeof(::injective::exchange::v1beta1::EventAllPositionsHaircut)},
        { 82, 91, -1, sizeof(::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate)},
        { 92, -1, -1, sizeof(::injective::exchange::v1beta1::EventNewSpotOrders)},
        { 103, -1, -1, sizeof(::injective::exchange::v1beta1::EventNewDerivativeOrders)},
        { 114, 124, -1, sizeof(::injective::exchange::v1beta1::EventCancelSpotOrder)},
        { 126, 135, -1, sizeof(::injective::exchange::v1beta1::EventSpotMarketUpdate)},
        { 136, 147, -1, sizeof(::injective::exchange::v1beta1::EventPerpetualMarketUpdate)},
        { 150, 160, -1, sizeof(::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate)},
        { 162, 175, -1, sizeof(::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate)},
        { 180, 191, -1, sizeof(::injective::exchange::v1beta1::EventSubaccountDeposit)},
        { 194, 205, -1, sizeof(::injective::exchange::v1beta1::EventSubaccountWithdraw)},
        { 208, 219, -1, sizeof(::injective::exchange::v1beta1::EventSubaccountBalanceTransfer)},
        { 222, -1, -1, sizeof(::injective::exchange::v1beta1::EventBatchDepositUpdate)},
        { 231, 241, -1, sizeof(::injective::exchange::v1beta1::DerivativeMarketOrderCancel)},
        { 243, 255, -1, sizeof(::injective::exchange::v1beta1::EventCancelDerivativeOrder)},
        { 259, 268, -1, sizeof(::injective::exchange::v1beta1::EventFeeDiscountSchedule)},
        { 269, 279, -1, sizeof(::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate)},
        { 281, -1, -1, sizeof(::injective::exchange::v1beta1::EventTradingRewardDistribution)},
        { 290, 302, -1, sizeof(::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder)},
        { 306, 318, -1, sizeof(::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder)},
        { 322, -1, -1, sizeof(::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger)},
        { 334, -1, -1, sizeof(::injective::exchange::v1beta1::EventOrderFail)},
        { 345, -1, -1, sizeof(::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated)},
        { 354, -1, -1, sizeof(::injective::exchange::v1beta1::EventOrderbookUpdate)},
        { 364, 374, -1, sizeof(::injective::exchange::v1beta1::OrderbookUpdate)},
        { 376, -1, -1, sizeof(::injective::exchange::v1beta1::Orderbook)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::injective::exchange::v1beta1::_EventBatchSpotExecution_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventBatchDerivativeExecution_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventLostFundsFromLiquidation_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventBatchDerivativePosition_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventDerivativeMarketPaused_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventMarketBeyondBankruptcy_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventAllPositionsHaircut_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventBinaryOptionsMarketUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventNewSpotOrders_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventNewDerivativeOrders_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventCancelSpotOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventSpotMarketUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventPerpetualMarketUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventExpiryFuturesMarketUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventPerpetualMarketFundingUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventSubaccountDeposit_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventSubaccountWithdraw_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventSubaccountBalanceTransfer_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventBatchDepositUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_DerivativeMarketOrderCancel_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventCancelDerivativeOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventFeeDiscountSchedule_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventTradingRewardCampaignUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventTradingRewardDistribution_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventNewConditionalDerivativeOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventCancelConditionalDerivativeOrder_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventConditionalDerivativeOrderTrigger_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventOrderFail_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventAtomicMarketOrderFeeMultipliersUpdated_default_instance_._instance,
    &::injective::exchange::v1beta1::_EventOrderbookUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_OrderbookUpdate_default_instance_._instance,
    &::injective::exchange::v1beta1::_Orderbook_default_instance_._instance,
};
const char descriptor_table_protodef_injective_2fexchange_2fv1beta1_2fevents_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\'injective/exchange/v1beta1/events.prot"
    "o\022\032injective.exchange.v1beta1\032\024gogoproto"
    "/gogo.proto\032\036cosmos/base/v1beta1/coin.pr"
    "oto\032%injective/oracle/v1beta1/oracle.pro"
    "to\032)injective/exchange/v1beta1/exchange."
    "proto\"\334\001\n\027EventBatchSpotExecution\022\033\n\tmar"
    "ket_id\030\001 \001(\tR\010marketId\022\025\n\006is_buy\030\002 \001(\010R\005"
    "isBuy\022O\n\rexecutionType\030\003 \001(\0162).injective"
    ".exchange.v1beta1.ExecutionTypeR\rexecuti"
    "onType\022<\n\006trades\030\004 \003(\0132$.injective.excha"
    "nge.v1beta1.TradeLogR\006trades\"\362\002\n\035EventBa"
    "tchDerivativeExecution\022\033\n\tmarket_id\030\001 \001("
    "\tR\010marketId\022\025\n\006is_buy\030\002 \001(\010R\005isBuy\022%\n\016is"
    "_liquidation\030\003 \001(\010R\risLiquidation\022]\n\022cum"
    "ulative_funding\030\004 \001(\tB.\310\336\037\001\332\336\037&github.co"
    "m/cosmos/cosmos-sdk/types.DecR\021cumulativ"
    "eFunding\022O\n\rexecutionType\030\005 \001(\0162).inject"
    "ive.exchange.v1beta1.ExecutionTypeR\rexec"
    "utionType\022F\n\006trades\030\006 \003(\0132..injective.ex"
    "change.v1beta1.DerivativeTradeLogR\006trade"
    "s\"\331\002\n\035EventLostFundsFromLiquidation\022\033\n\tm"
    "arket_id\030\001 \001(\tR\010marketId\022#\n\rsubaccount_i"
    "d\030\002 \001(\014R\014subaccountId\022\203\001\n\'lost_funds_fro"
    "m_available_during_payout\030\003 \001(\tB.\310\336\037\000\332\336\037"
    "&github.com/cosmos/cosmos-sdk/types.DecR"
    "\"lostFundsFromAvailableDuringPayout\022p\n\035l"
    "ost_funds_from_order_cancels\030\004 \001(\tB.\310\336\037\000"
    "\332\336\037&github.com/cosmos/cosmos-sdk/types.D"
    "ecR\031lostFundsFromOrderCancels\"\211\001\n\034EventB"
    "atchDerivativePosition\022\033\n\tmarket_id\030\001 \001("
    "\tR\010marketId\022L\n\tpositions\030\002 \003(\0132..injecti"
    "ve.exchange.v1beta1.SubaccountPositionR\t"
    "positions\"\273\001\n\033EventDerivativeMarketPause"
    "d\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\022!\n\014settle"
    "_price\030\002 \001(\tR\013settlePrice\022.\n\023total_missi"
    "ng_funds\030\003 \001(\tR\021totalMissingFunds\022,\n\022mis"
    "sing_funds_rate\030\004 \001(\tR\020missingFundsRate\""
    "\217\001\n\033EventMarketBeyondBankruptcy\022\033\n\tmarke"
    "t_id\030\001 \001(\tR\010marketId\022!\n\014settle_price\030\002 \001"
    "(\tR\013settlePrice\0220\n\024missing_market_funds\030"
    "\003 \001(\tR\022missingMarketFunds\"\210\001\n\030EventAllPo"
    "sitionsHaircut\022\033\n\tmarket_id\030\001 \001(\tR\010marke"
    "tId\022!\n\014settle_price\030\002 \001(\tR\013settlePrice\022,"
    "\n\022missing_funds_rate\030\003 \001(\tR\020missingFunds"
    "Rate\"o\n\036EventBinaryOptionsMarketUpdate\022M"
    "\n\006market\030\001 \001(\0132/.injective.exchange.v1be"
    "ta1.BinaryOptionsMarketB\004\310\336\037\000R\006market\"\311\001"
    "\n\022EventNewSpotOrders\022\033\n\tmarket_id\030\001 \001(\tR"
    "\010marketId\022I\n\nbuy_orders\030\002 \003(\0132*.injectiv"
    "e.exchange.v1beta1.SpotLimitOrderR\tbuyOr"
    "ders\022K\n\013sell_orders\030\003 \003(\0132*.injective.ex"
    "change.v1beta1.SpotLimitOrderR\nsellOrder"
    "s\"\333\001\n\030EventNewDerivativeOrders\022\033\n\tmarket"
    "_id\030\001 \001(\tR\010marketId\022O\n\nbuy_orders\030\002 \003(\0132"
    "0.injective.exchange.v1beta1.DerivativeL"
    "imitOrderR\tbuyOrders\022Q\n\013sell_orders\030\003 \003("
    "\01320.injective.exchange.v1beta1.Derivativ"
    "eLimitOrderR\nsellOrders\"{\n\024EventCancelSp"
    "otOrder\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\022F\n\005"
    "order\030\002 \001(\0132*.injective.exchange.v1beta1"
    ".SpotLimitOrderB\004\310\336\037\000R\005order\"]\n\025EventSpo"
    "tMarketUpdate\022D\n\006market\030\001 \001(\0132&.injectiv"
    "e.exchange.v1beta1.SpotMarketB\004\310\336\037\000R\006mar"
    "ket\"\247\002\n\032EventPerpetualMarketUpdate\022J\n\006ma"
    "rket\030\001 \001(\0132,.injective.exchange.v1beta1."
    "DerivativeMarketB\004\310\336\037\000R\006market\022i\n\025perpet"
    "ual_market_info\030\002 \001(\0132/.injective.exchan"
    "ge.v1beta1.PerpetualMarketInfoB\004\310\336\037\001R\023pe"
    "rpetualMarketInfo\022R\n\007funding\030\003 \001(\01322.inj"
    "ective.exchange.v1beta1.PerpetualMarketF"
    "undingB\004\310\336\037\001R\007funding\"\344\001\n\036EventExpiryFut"
    "uresMarketUpdate\022J\n\006market\030\001 \001(\0132,.injec"
    "tive.exchange.v1beta1.DerivativeMarketB\004"
    "\310\336\037\000R\006market\022v\n\032expiry_futures_market_in"
    "fo\030\003 \001(\01323.injective.exchange.v1beta1.Ex"
    "piryFuturesMarketInfoB\004\310\336\037\001R\027expiryFutur"
    "esMarketInfo\"\342\002\n!EventPerpetualMarketFun"
    "dingUpdate\022\033\n\tmarket_id\030\001 \001(\tR\010marketId\022"
    "R\n\007funding\030\002 \001(\01322.injective.exchange.v1"
    "beta1.PerpetualMarketFundingB\004\310\336\037\000R\007fund"
    "ing\022*\n\021is_hourly_funding\030\003 \001(\010R\017isHourly"
    "Funding\022Q\n\014funding_rate\030\004 \001(\tB.\310\336\037\001\332\336\037&g"
    "ithub.com/cosmos/cosmos-sdk/types.DecR\013f"
    "undingRate\022M\n\nmark_price\030\005 \001(\tB.\310\336\037\001\332\336\037&"
    "github.com/cosmos/cosmos-sdk/types.DecR\t"
    "markPrice\"\227\001\n\026EventSubaccountDeposit\022\037\n\013"
    "src_address\030\001 \001(\tR\nsrcAddress\022#\n\rsubacco"
    "unt_id\030\002 \001(\014R\014subaccountId\0227\n\006amount\030\003 \001"
    "(\0132\031.cosmos.base.v1beta1.CoinB\004\310\336\037\000R\006amo"
    "unt\"\230\001\n\027EventSubaccountWithdraw\022#\n\rsubac"
    "count_id\030\001 \001(\014R\014subaccountId\022\037\n\013dst_addr"
    "ess\030\002 \001(\tR\ndstAddress\0227\n\006amount\030\003 \001(\0132\031."
    "cosmos.base.v1beta1.CoinB\004\310\336\037\000R\006amount\"\261"
    "\001\n\036EventSubaccountBalanceTransfer\022*\n\021src"
    "_subaccount_id\030\001 \001(\tR\017srcSubaccountId\022*\n"
    "\021dst_subaccount_id\030\002 \001(\tR\017dstSubaccountI"
    "d\0227\n\006amount\030\003 \001(\0132\031.cosmos.base.v1beta1."
    "CoinB\004\310\336\037\000R\006amount\"m\n\027EventBatchDepositU"
    "pdate\022R\n\017deposit_updates\030\001 \003(\0132).injecti"
    "ve.exchange.v1beta1.DepositUpdateR\016depos"
    "itUpdates\"\322\001\n\033DerivativeMarketOrderCance"
    "l\022Z\n\014market_order\030\001 \001(\01321.injective.exch"
    "ange.v1beta1.DerivativeMarketOrderB\004\310\336\037\001"
    "R\013marketOrder\022W\n\017cancel_quantity\030\002 \001(\tB."
    "\310\336\037\000\332\336\037&github.com/cosmos/cosmos-sdk/typ"
    "es.DecR\016cancelQuantity\"\247\002\n\032EventCancelDe"
    "rivativeOrder\022\033\n\tmarket_id\030\001 \001(\tR\010market"
    "Id\022$\n\risLimitCancel\030\002 \001(\010R\risLimitCancel"
    "\022W\n\013limit_order\030\003 \001(\01320.injective.exchan"
    "ge.v1beta1.DerivativeLimitOrderB\004\310\336\037\001R\nl"
    "imitOrder\022m\n\023market_order_cancel\030\004 \001(\01327"
    ".injective.exchange.v1beta1.DerivativeMa"
    "rketOrderCancelB\004\310\336\037\001R\021marketOrderCancel"
    "\"g\n\030EventFeeDiscountSchedule\022K\n\010schedule"
    "\030\001 \001(\0132/.injective.exchange.v1beta1.FeeD"
    "iscountScheduleR\010schedule\"\342\001\n EventTradi"
    "ngRewardCampaignUpdate\022Z\n\rcampaign_info\030"
    "\001 \001(\01325.injective.exchange.v1beta1.Tradi"
    "ngRewardCampaignInfoR\014campaignInfo\022b\n\025ca"
    "mpaign_reward_pools\030\002 \003(\0132..injective.ex"
    "change.v1beta1.CampaignRewardPoolR\023campa"
    "ignRewardPools\"u\n\036EventTradingRewardDist"
    "ribution\022S\n\017account_rewards\030\001 \003(\0132*.inje"
    "ctive.exchange.v1beta1.AccountRewardsR\016a"
    "ccountRewards\"\265\001\n\"EventNewConditionalDer"
    "ivativeOrder\022\033\n\tmarket_id\030\001 \001(\tR\010marketI"
    "d\022A\n\005order\030\002 \001(\0132+.injective.exchange.v1"
    "beta1.DerivativeOrderR\005order\022\022\n\004hash\030\003 \001"
    "(\014R\004hash\022\033\n\tis_market\030\004 \001(\010R\010isMarket\"\237\002"
    "\n%EventCancelConditionalDerivativeOrder\022"
    "\033\n\tmarket_id\030\001 \001(\tR\010marketId\022$\n\risLimitC"
    "ancel\030\002 \001(\010R\risLimitCancel\022W\n\013limit_orde"
    "r\030\003 \001(\01320.injective.exchange.v1beta1.Der"
    "ivativeLimitOrderB\004\310\336\037\001R\nlimitOrder\022Z\n\014m"
    "arket_order\030\004 \001(\01321.injective.exchange.v"
    "1beta1.DerivativeMarketOrderB\004\310\336\037\001R\013mark"
    "etOrder\"\313\001\n&EventConditionalDerivativeOr"
    "derTrigger\022\033\n\tmarket_id\030\001 \001(\014R\010marketId\022"
    "&\n\016isLimitTrigger\030\002 \001(\010R\016isLimitTrigger\022"
    "0\n\024triggered_order_hash\030\003 \001(\014R\022triggered"
    "OrderHash\022*\n\021placed_order_hash\030\004 \001(\014R\017pl"
    "acedOrderHash\"X\n\016EventOrderFail\022\030\n\007accou"
    "nt\030\001 \001(\014R\007account\022\026\n\006hashes\030\002 \003(\014R\006hashe"
    "s\022\024\n\005flags\030\003 \003(\rR\005flags\"\224\001\n+EventAtomicM"
    "arketOrderFeeMultipliersUpdated\022e\n\026marke"
    "t_fee_multipliers\030\001 \003(\0132/.injective.exch"
    "ange.v1beta1.MarketFeeMultiplierR\024market"
    "FeeMultipliers\"\302\001\n\024EventOrderbookUpdate\022"
    "N\n\014spot_updates\030\001 \003(\0132+.injective.exchan"
    "ge.v1beta1.OrderbookUpdateR\013spotUpdates\022"
    "Z\n\022derivative_updates\030\002 \003(\0132+.injective."
    "exchange.v1beta1.OrderbookUpdateR\021deriva"
    "tiveUpdates\"h\n\017OrderbookUpdate\022\020\n\003seq\030\001 "
    "\001(\004R\003seq\022C\n\torderbook\030\002 \001(\0132%.injective."
    "exchange.v1beta1.OrderbookR\torderbook\"\256\001"
    "\n\tOrderbook\022\033\n\tmarket_id\030\001 \001(\014R\010marketId"
    "\022@\n\nbuy_levels\030\002 \003(\0132!.injective.exchang"
    "e.v1beta1.LevelR\tbuyLevels\022B\n\013sell_level"
    "s\030\003 \003(\0132!.injective.exchange.v1beta1.Lev"
    "elR\nsellLevelsB\207\002\n\036com.injective.exchang"
    "e.v1beta1B\013EventsProtoP\001ZNgithub.com/Inj"
    "ectiveLabs/injective-core/injective-chai"
    "n/modules/exchange/types\242\002\003IEX\252\002\032Injecti"
    "ve.Exchange.V1beta1\312\002\032Injective\\Exchange"
    "\\V1beta1\342\002&Injective\\Exchange\\V1beta1\\GP"
    "BMetadata\352\002\034Injective::Exchange::V1beta1"
    "b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_deps[4] =
    {
        &::descriptor_table_cosmos_2fbase_2fv1beta1_2fcoin_2eproto,
        &::descriptor_table_gogoproto_2fgogo_2eproto,
        &::descriptor_table_injective_2fexchange_2fv1beta1_2fexchange_2eproto,
        &::descriptor_table_injective_2foracle_2fv1beta1_2foracle_2eproto,
};
static ::absl::once_flag descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto = {
    false,
    false,
    6648,
    descriptor_table_protodef_injective_2fexchange_2fv1beta1_2fevents_2eproto,
    "injective/exchange/v1beta1/events.proto",
    &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
    descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_deps,
    4,
    32,
    schemas,
    file_default_instances,
    TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto::offsets,
    file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto,
    file_level_enum_descriptors_injective_2fexchange_2fv1beta1_2fevents_2eproto,
    file_level_service_descriptors_injective_2fexchange_2fv1beta1_2fevents_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter() {
  return &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_injective_2fexchange_2fv1beta1_2fevents_2eproto(&descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto);
namespace injective {
namespace exchange {
namespace v1beta1 {
// ===================================================================

class EventBatchSpotExecution::_Internal {
 public:
};

void EventBatchSpotExecution::clear_trades() {
  _internal_mutable_trades()->Clear();
}
EventBatchSpotExecution::EventBatchSpotExecution(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventBatchSpotExecution)
}
EventBatchSpotExecution::EventBatchSpotExecution(const EventBatchSpotExecution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventBatchSpotExecution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.trades_){from._impl_.trades_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.is_buy_) {}

    , decltype(_impl_.executiontype_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_buy_, &from._impl_.is_buy_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.executiontype_) -
    reinterpret_cast<char*>(&_impl_.is_buy_)) + sizeof(_impl_.executiontype_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventBatchSpotExecution)
}

inline void EventBatchSpotExecution::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.trades_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.is_buy_) { false }

    , decltype(_impl_.executiontype_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventBatchSpotExecution::~EventBatchSpotExecution() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventBatchSpotExecution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventBatchSpotExecution::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_trades()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void EventBatchSpotExecution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventBatchSpotExecution::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventBatchSpotExecution)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_trades()->Clear();
  _impl_.market_id_.ClearToEmpty();
  ::memset(&_impl_.is_buy_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.executiontype_) -
      reinterpret_cast<char*>(&_impl_.is_buy_)) + sizeof(_impl_.executiontype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventBatchSpotExecution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventBatchSpotExecution.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_buy = 2 [json_name = "isBuy"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.is_buy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.ExecutionType executionType = 3 [json_name = "executionType"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_executiontype(static_cast<::injective::exchange::v1beta1::ExecutionType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.TradeLog trades = 4 [json_name = "trades"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trades(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventBatchSpotExecution::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventBatchSpotExecution)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventBatchSpotExecution.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool is_buy = 2 [json_name = "isBuy"];
  if (this->_internal_is_buy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_is_buy(), target);
  }

  // .injective.exchange.v1beta1.ExecutionType executionType = 3 [json_name = "executionType"];
  if (this->_internal_executiontype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_executiontype(), target);
  }

  // repeated .injective.exchange.v1beta1.TradeLog trades = 4 [json_name = "trades"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trades_size()); i < n; i++) {
    const auto& repfield = this->_internal_trades(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventBatchSpotExecution)
  return target;
}

::size_t EventBatchSpotExecution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventBatchSpotExecution)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.TradeLog trades = 4 [json_name = "trades"];
  total_size += 1UL * this->_internal_trades_size();
  for (const auto& msg : this->_internal_trades()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // bool is_buy = 2 [json_name = "isBuy"];
  if (this->_internal_is_buy() != 0) {
    total_size += 2;
  }

  // .injective.exchange.v1beta1.ExecutionType executionType = 3 [json_name = "executionType"];
  if (this->_internal_executiontype() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_executiontype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventBatchSpotExecution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventBatchSpotExecution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventBatchSpotExecution::GetClassData() const { return &_class_data_; }


void EventBatchSpotExecution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventBatchSpotExecution*>(&to_msg);
  auto& from = static_cast<const EventBatchSpotExecution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventBatchSpotExecution)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_trades()->MergeFrom(from._internal_trades());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (from._internal_is_buy() != 0) {
    _this->_internal_set_is_buy(from._internal_is_buy());
  }
  if (from._internal_executiontype() != 0) {
    _this->_internal_set_executiontype(from._internal_executiontype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventBatchSpotExecution::CopyFrom(const EventBatchSpotExecution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventBatchSpotExecution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventBatchSpotExecution::IsInitialized() const {
  return true;
}

void EventBatchSpotExecution::InternalSwap(EventBatchSpotExecution* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_trades()->InternalSwap(other->_internal_mutable_trades());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventBatchSpotExecution, _impl_.executiontype_)
      + sizeof(EventBatchSpotExecution::_impl_.executiontype_)
      - PROTOBUF_FIELD_OFFSET(EventBatchSpotExecution, _impl_.is_buy_)>(
          reinterpret_cast<char*>(&_impl_.is_buy_),
          reinterpret_cast<char*>(&other->_impl_.is_buy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventBatchSpotExecution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[0]);
}
// ===================================================================

class EventBatchDerivativeExecution::_Internal {
 public:
};

void EventBatchDerivativeExecution::clear_trades() {
  _internal_mutable_trades()->Clear();
}
EventBatchDerivativeExecution::EventBatchDerivativeExecution(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventBatchDerivativeExecution)
}
EventBatchDerivativeExecution::EventBatchDerivativeExecution(const EventBatchDerivativeExecution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventBatchDerivativeExecution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.trades_){from._impl_.trades_}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.cumulative_funding_) {}

    , decltype(_impl_.is_buy_) {}

    , decltype(_impl_.is_liquidation_) {}

    , decltype(_impl_.executiontype_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.cumulative_funding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_funding_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cumulative_funding().empty()) {
    _this->_impl_.cumulative_funding_.Set(from._internal_cumulative_funding(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_buy_, &from._impl_.is_buy_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.executiontype_) -
    reinterpret_cast<char*>(&_impl_.is_buy_)) + sizeof(_impl_.executiontype_));
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventBatchDerivativeExecution)
}

inline void EventBatchDerivativeExecution::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.trades_){arena}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.cumulative_funding_) {}

    , decltype(_impl_.is_buy_) { false }

    , decltype(_impl_.is_liquidation_) { false }

    , decltype(_impl_.executiontype_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cumulative_funding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cumulative_funding_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventBatchDerivativeExecution::~EventBatchDerivativeExecution() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventBatchDerivativeExecution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventBatchDerivativeExecution::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_trades()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
  _impl_.cumulative_funding_.Destroy();
}

void EventBatchDerivativeExecution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventBatchDerivativeExecution::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventBatchDerivativeExecution)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_trades()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _impl_.cumulative_funding_.ClearToEmpty();
  ::memset(&_impl_.is_buy_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.executiontype_) -
      reinterpret_cast<char*>(&_impl_.is_buy_)) + sizeof(_impl_.executiontype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventBatchDerivativeExecution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventBatchDerivativeExecution.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_buy = 2 [json_name = "isBuy"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.is_buy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_liquidation = 3 [json_name = "isLiquidation"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.is_liquidation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string cumulative_funding = 4 [json_name = "cumulativeFunding", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_cumulative_funding();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventBatchDerivativeExecution.cumulative_funding"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.ExecutionType executionType = 5 [json_name = "executionType"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_executiontype(static_cast<::injective::exchange::v1beta1::ExecutionType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeTradeLog trades = 6 [json_name = "trades"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trades(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventBatchDerivativeExecution::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventBatchDerivativeExecution)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventBatchDerivativeExecution.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool is_buy = 2 [json_name = "isBuy"];
  if (this->_internal_is_buy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_is_buy(), target);
  }

  // bool is_liquidation = 3 [json_name = "isLiquidation"];
  if (this->_internal_is_liquidation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_is_liquidation(), target);
  }

  // string cumulative_funding = 4 [json_name = "cumulativeFunding", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_funding().empty()) {
    const std::string& _s = this->_internal_cumulative_funding();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventBatchDerivativeExecution.cumulative_funding");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // .injective.exchange.v1beta1.ExecutionType executionType = 5 [json_name = "executionType"];
  if (this->_internal_executiontype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_executiontype(), target);
  }

  // repeated .injective.exchange.v1beta1.DerivativeTradeLog trades = 6 [json_name = "trades"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trades_size()); i < n; i++) {
    const auto& repfield = this->_internal_trades(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventBatchDerivativeExecution)
  return target;
}

::size_t EventBatchDerivativeExecution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventBatchDerivativeExecution)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.DerivativeTradeLog trades = 6 [json_name = "trades"];
  total_size += 1UL * this->_internal_trades_size();
  for (const auto& msg : this->_internal_trades()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string cumulative_funding = 4 [json_name = "cumulativeFunding", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cumulative_funding().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_cumulative_funding());
  }

  // bool is_buy = 2 [json_name = "isBuy"];
  if (this->_internal_is_buy() != 0) {
    total_size += 2;
  }

  // bool is_liquidation = 3 [json_name = "isLiquidation"];
  if (this->_internal_is_liquidation() != 0) {
    total_size += 2;
  }

  // .injective.exchange.v1beta1.ExecutionType executionType = 5 [json_name = "executionType"];
  if (this->_internal_executiontype() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_executiontype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventBatchDerivativeExecution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventBatchDerivativeExecution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventBatchDerivativeExecution::GetClassData() const { return &_class_data_; }


void EventBatchDerivativeExecution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventBatchDerivativeExecution*>(&to_msg);
  auto& from = static_cast<const EventBatchDerivativeExecution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventBatchDerivativeExecution)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_trades()->MergeFrom(from._internal_trades());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_cumulative_funding().empty()) {
    _this->_internal_set_cumulative_funding(from._internal_cumulative_funding());
  }
  if (from._internal_is_buy() != 0) {
    _this->_internal_set_is_buy(from._internal_is_buy());
  }
  if (from._internal_is_liquidation() != 0) {
    _this->_internal_set_is_liquidation(from._internal_is_liquidation());
  }
  if (from._internal_executiontype() != 0) {
    _this->_internal_set_executiontype(from._internal_executiontype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventBatchDerivativeExecution::CopyFrom(const EventBatchDerivativeExecution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventBatchDerivativeExecution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventBatchDerivativeExecution::IsInitialized() const {
  return true;
}

void EventBatchDerivativeExecution::InternalSwap(EventBatchDerivativeExecution* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_trades()->InternalSwap(other->_internal_mutable_trades());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.cumulative_funding_, lhs_arena,
                                       &other->_impl_.cumulative_funding_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventBatchDerivativeExecution, _impl_.executiontype_)
      + sizeof(EventBatchDerivativeExecution::_impl_.executiontype_)
      - PROTOBUF_FIELD_OFFSET(EventBatchDerivativeExecution, _impl_.is_buy_)>(
          reinterpret_cast<char*>(&_impl_.is_buy_),
          reinterpret_cast<char*>(&other->_impl_.is_buy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventBatchDerivativeExecution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[1]);
}
// ===================================================================

class EventLostFundsFromLiquidation::_Internal {
 public:
};

EventLostFundsFromLiquidation::EventLostFundsFromLiquidation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
}
EventLostFundsFromLiquidation::EventLostFundsFromLiquidation(const EventLostFundsFromLiquidation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventLostFundsFromLiquidation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.lost_funds_from_available_during_payout_) {}

    , decltype(_impl_.lost_funds_from_order_cancels_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.lost_funds_from_available_during_payout_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.lost_funds_from_available_during_payout_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_lost_funds_from_available_during_payout().empty()) {
    _this->_impl_.lost_funds_from_available_during_payout_.Set(from._internal_lost_funds_from_available_during_payout(), _this->GetArenaForAllocation());
  }
  _impl_.lost_funds_from_order_cancels_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.lost_funds_from_order_cancels_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_lost_funds_from_order_cancels().empty()) {
    _this->_impl_.lost_funds_from_order_cancels_.Set(from._internal_lost_funds_from_order_cancels(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
}

inline void EventLostFundsFromLiquidation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.lost_funds_from_available_during_payout_) {}

    , decltype(_impl_.lost_funds_from_order_cancels_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lost_funds_from_available_during_payout_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.lost_funds_from_available_during_payout_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lost_funds_from_order_cancels_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.lost_funds_from_order_cancels_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventLostFundsFromLiquidation::~EventLostFundsFromLiquidation() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventLostFundsFromLiquidation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.subaccount_id_.Destroy();
  _impl_.lost_funds_from_available_during_payout_.Destroy();
  _impl_.lost_funds_from_order_cancels_.Destroy();
}

void EventLostFundsFromLiquidation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventLostFundsFromLiquidation::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.lost_funds_from_available_during_payout_.ClearToEmpty();
  _impl_.lost_funds_from_order_cancels_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventLostFundsFromLiquidation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventLostFundsFromLiquidation.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes subaccount_id = 2 [json_name = "subaccountId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string lost_funds_from_available_during_payout = 3 [json_name = "lostFundsFromAvailableDuringPayout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_lost_funds_from_available_during_payout();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_available_during_payout"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string lost_funds_from_order_cancels = 4 [json_name = "lostFundsFromOrderCancels", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_lost_funds_from_order_cancels();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_order_cancels"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventLostFundsFromLiquidation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventLostFundsFromLiquidation.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // string lost_funds_from_available_during_payout = 3 [json_name = "lostFundsFromAvailableDuringPayout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_lost_funds_from_available_during_payout().empty()) {
    const std::string& _s = this->_internal_lost_funds_from_available_during_payout();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_available_during_payout");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string lost_funds_from_order_cancels = 4 [json_name = "lostFundsFromOrderCancels", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_lost_funds_from_order_cancels().empty()) {
    const std::string& _s = this->_internal_lost_funds_from_order_cancels();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_order_cancels");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
  return target;
}

::size_t EventLostFundsFromLiquidation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_subaccount_id());
  }

  // string lost_funds_from_available_during_payout = 3 [json_name = "lostFundsFromAvailableDuringPayout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_lost_funds_from_available_during_payout().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_lost_funds_from_available_during_payout());
  }

  // string lost_funds_from_order_cancels = 4 [json_name = "lostFundsFromOrderCancels", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_lost_funds_from_order_cancels().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_lost_funds_from_order_cancels());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventLostFundsFromLiquidation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventLostFundsFromLiquidation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventLostFundsFromLiquidation::GetClassData() const { return &_class_data_; }


void EventLostFundsFromLiquidation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventLostFundsFromLiquidation*>(&to_msg);
  auto& from = static_cast<const EventLostFundsFromLiquidation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_lost_funds_from_available_during_payout().empty()) {
    _this->_internal_set_lost_funds_from_available_during_payout(from._internal_lost_funds_from_available_during_payout());
  }
  if (!from._internal_lost_funds_from_order_cancels().empty()) {
    _this->_internal_set_lost_funds_from_order_cancels(from._internal_lost_funds_from_order_cancels());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventLostFundsFromLiquidation::CopyFrom(const EventLostFundsFromLiquidation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventLostFundsFromLiquidation::IsInitialized() const {
  return true;
}

void EventLostFundsFromLiquidation::InternalSwap(EventLostFundsFromLiquidation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.lost_funds_from_available_during_payout_, lhs_arena,
                                       &other->_impl_.lost_funds_from_available_during_payout_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.lost_funds_from_order_cancels_, lhs_arena,
                                       &other->_impl_.lost_funds_from_order_cancels_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventLostFundsFromLiquidation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[2]);
}
// ===================================================================

class EventBatchDerivativePosition::_Internal {
 public:
};

void EventBatchDerivativePosition::clear_positions() {
  _internal_mutable_positions()->Clear();
}
EventBatchDerivativePosition::EventBatchDerivativePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventBatchDerivativePosition)
}
EventBatchDerivativePosition::EventBatchDerivativePosition(const EventBatchDerivativePosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventBatchDerivativePosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.positions_){from._impl_.positions_}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventBatchDerivativePosition)
}

inline void EventBatchDerivativePosition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.positions_){arena}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventBatchDerivativePosition::~EventBatchDerivativePosition() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventBatchDerivativePosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventBatchDerivativePosition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_positions()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void EventBatchDerivativePosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventBatchDerivativePosition::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventBatchDerivativePosition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_positions()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventBatchDerivativePosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventBatchDerivativePosition.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SubaccountPosition positions = 2 [json_name = "positions"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_positions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventBatchDerivativePosition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventBatchDerivativePosition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventBatchDerivativePosition.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.SubaccountPosition positions = 2 [json_name = "positions"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_positions_size()); i < n; i++) {
    const auto& repfield = this->_internal_positions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventBatchDerivativePosition)
  return target;
}

::size_t EventBatchDerivativePosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventBatchDerivativePosition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.SubaccountPosition positions = 2 [json_name = "positions"];
  total_size += 1UL * this->_internal_positions_size();
  for (const auto& msg : this->_internal_positions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventBatchDerivativePosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventBatchDerivativePosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventBatchDerivativePosition::GetClassData() const { return &_class_data_; }


void EventBatchDerivativePosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventBatchDerivativePosition*>(&to_msg);
  auto& from = static_cast<const EventBatchDerivativePosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventBatchDerivativePosition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_positions()->MergeFrom(from._internal_positions());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventBatchDerivativePosition::CopyFrom(const EventBatchDerivativePosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventBatchDerivativePosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventBatchDerivativePosition::IsInitialized() const {
  return true;
}

void EventBatchDerivativePosition::InternalSwap(EventBatchDerivativePosition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_positions()->InternalSwap(other->_internal_mutable_positions());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventBatchDerivativePosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[3]);
}
// ===================================================================

class EventDerivativeMarketPaused::_Internal {
 public:
};

EventDerivativeMarketPaused::EventDerivativeMarketPaused(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventDerivativeMarketPaused)
}
EventDerivativeMarketPaused::EventDerivativeMarketPaused(const EventDerivativeMarketPaused& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventDerivativeMarketPaused* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settle_price_) {}

    , decltype(_impl_.total_missing_funds_) {}

    , decltype(_impl_.missing_funds_rate_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.settle_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settle_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_settle_price().empty()) {
    _this->_impl_.settle_price_.Set(from._internal_settle_price(), _this->GetArenaForAllocation());
  }
  _impl_.total_missing_funds_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.total_missing_funds_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_total_missing_funds().empty()) {
    _this->_impl_.total_missing_funds_.Set(from._internal_total_missing_funds(), _this->GetArenaForAllocation());
  }
  _impl_.missing_funds_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.missing_funds_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_missing_funds_rate().empty()) {
    _this->_impl_.missing_funds_rate_.Set(from._internal_missing_funds_rate(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventDerivativeMarketPaused)
}

inline void EventDerivativeMarketPaused::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settle_price_) {}

    , decltype(_impl_.total_missing_funds_) {}

    , decltype(_impl_.missing_funds_rate_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settle_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settle_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.total_missing_funds_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.total_missing_funds_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.missing_funds_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.missing_funds_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventDerivativeMarketPaused::~EventDerivativeMarketPaused() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventDerivativeMarketPaused)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventDerivativeMarketPaused::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.settle_price_.Destroy();
  _impl_.total_missing_funds_.Destroy();
  _impl_.missing_funds_rate_.Destroy();
}

void EventDerivativeMarketPaused::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventDerivativeMarketPaused::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventDerivativeMarketPaused)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.settle_price_.ClearToEmpty();
  _impl_.total_missing_funds_.ClearToEmpty();
  _impl_.missing_funds_rate_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventDerivativeMarketPaused::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventDerivativeMarketPaused.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string settle_price = 2 [json_name = "settlePrice"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_settle_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventDerivativeMarketPaused.settle_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string total_missing_funds = 3 [json_name = "totalMissingFunds"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_total_missing_funds();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventDerivativeMarketPaused.total_missing_funds"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string missing_funds_rate = 4 [json_name = "missingFundsRate"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_missing_funds_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventDerivativeMarketPaused.missing_funds_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventDerivativeMarketPaused::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventDerivativeMarketPaused)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventDerivativeMarketPaused.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string settle_price = 2 [json_name = "settlePrice"];
  if (!this->_internal_settle_price().empty()) {
    const std::string& _s = this->_internal_settle_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventDerivativeMarketPaused.settle_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string total_missing_funds = 3 [json_name = "totalMissingFunds"];
  if (!this->_internal_total_missing_funds().empty()) {
    const std::string& _s = this->_internal_total_missing_funds();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventDerivativeMarketPaused.total_missing_funds");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string missing_funds_rate = 4 [json_name = "missingFundsRate"];
  if (!this->_internal_missing_funds_rate().empty()) {
    const std::string& _s = this->_internal_missing_funds_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventDerivativeMarketPaused.missing_funds_rate");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventDerivativeMarketPaused)
  return target;
}

::size_t EventDerivativeMarketPaused::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventDerivativeMarketPaused)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string settle_price = 2 [json_name = "settlePrice"];
  if (!this->_internal_settle_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_settle_price());
  }

  // string total_missing_funds = 3 [json_name = "totalMissingFunds"];
  if (!this->_internal_total_missing_funds().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_total_missing_funds());
  }

  // string missing_funds_rate = 4 [json_name = "missingFundsRate"];
  if (!this->_internal_missing_funds_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_missing_funds_rate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventDerivativeMarketPaused::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventDerivativeMarketPaused::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventDerivativeMarketPaused::GetClassData() const { return &_class_data_; }


void EventDerivativeMarketPaused::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventDerivativeMarketPaused*>(&to_msg);
  auto& from = static_cast<const EventDerivativeMarketPaused&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventDerivativeMarketPaused)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_settle_price().empty()) {
    _this->_internal_set_settle_price(from._internal_settle_price());
  }
  if (!from._internal_total_missing_funds().empty()) {
    _this->_internal_set_total_missing_funds(from._internal_total_missing_funds());
  }
  if (!from._internal_missing_funds_rate().empty()) {
    _this->_internal_set_missing_funds_rate(from._internal_missing_funds_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventDerivativeMarketPaused::CopyFrom(const EventDerivativeMarketPaused& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventDerivativeMarketPaused)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventDerivativeMarketPaused::IsInitialized() const {
  return true;
}

void EventDerivativeMarketPaused::InternalSwap(EventDerivativeMarketPaused* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.settle_price_, lhs_arena,
                                       &other->_impl_.settle_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.total_missing_funds_, lhs_arena,
                                       &other->_impl_.total_missing_funds_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.missing_funds_rate_, lhs_arena,
                                       &other->_impl_.missing_funds_rate_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventDerivativeMarketPaused::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[4]);
}
// ===================================================================

class EventMarketBeyondBankruptcy::_Internal {
 public:
};

EventMarketBeyondBankruptcy::EventMarketBeyondBankruptcy(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
}
EventMarketBeyondBankruptcy::EventMarketBeyondBankruptcy(const EventMarketBeyondBankruptcy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventMarketBeyondBankruptcy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settle_price_) {}

    , decltype(_impl_.missing_market_funds_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.settle_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settle_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_settle_price().empty()) {
    _this->_impl_.settle_price_.Set(from._internal_settle_price(), _this->GetArenaForAllocation());
  }
  _impl_.missing_market_funds_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.missing_market_funds_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_missing_market_funds().empty()) {
    _this->_impl_.missing_market_funds_.Set(from._internal_missing_market_funds(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
}

inline void EventMarketBeyondBankruptcy::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settle_price_) {}

    , decltype(_impl_.missing_market_funds_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settle_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settle_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.missing_market_funds_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.missing_market_funds_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventMarketBeyondBankruptcy::~EventMarketBeyondBankruptcy() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventMarketBeyondBankruptcy::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.settle_price_.Destroy();
  _impl_.missing_market_funds_.Destroy();
}

void EventMarketBeyondBankruptcy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventMarketBeyondBankruptcy::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.settle_price_.ClearToEmpty();
  _impl_.missing_market_funds_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventMarketBeyondBankruptcy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventMarketBeyondBankruptcy.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string settle_price = 2 [json_name = "settlePrice"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_settle_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventMarketBeyondBankruptcy.settle_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string missing_market_funds = 3 [json_name = "missingMarketFunds"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_missing_market_funds();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventMarketBeyondBankruptcy.missing_market_funds"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventMarketBeyondBankruptcy::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventMarketBeyondBankruptcy.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string settle_price = 2 [json_name = "settlePrice"];
  if (!this->_internal_settle_price().empty()) {
    const std::string& _s = this->_internal_settle_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventMarketBeyondBankruptcy.settle_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string missing_market_funds = 3 [json_name = "missingMarketFunds"];
  if (!this->_internal_missing_market_funds().empty()) {
    const std::string& _s = this->_internal_missing_market_funds();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventMarketBeyondBankruptcy.missing_market_funds");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
  return target;
}

::size_t EventMarketBeyondBankruptcy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string settle_price = 2 [json_name = "settlePrice"];
  if (!this->_internal_settle_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_settle_price());
  }

  // string missing_market_funds = 3 [json_name = "missingMarketFunds"];
  if (!this->_internal_missing_market_funds().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_missing_market_funds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventMarketBeyondBankruptcy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventMarketBeyondBankruptcy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventMarketBeyondBankruptcy::GetClassData() const { return &_class_data_; }


void EventMarketBeyondBankruptcy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventMarketBeyondBankruptcy*>(&to_msg);
  auto& from = static_cast<const EventMarketBeyondBankruptcy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_settle_price().empty()) {
    _this->_internal_set_settle_price(from._internal_settle_price());
  }
  if (!from._internal_missing_market_funds().empty()) {
    _this->_internal_set_missing_market_funds(from._internal_missing_market_funds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventMarketBeyondBankruptcy::CopyFrom(const EventMarketBeyondBankruptcy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventMarketBeyondBankruptcy::IsInitialized() const {
  return true;
}

void EventMarketBeyondBankruptcy::InternalSwap(EventMarketBeyondBankruptcy* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.settle_price_, lhs_arena,
                                       &other->_impl_.settle_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.missing_market_funds_, lhs_arena,
                                       &other->_impl_.missing_market_funds_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventMarketBeyondBankruptcy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[5]);
}
// ===================================================================

class EventAllPositionsHaircut::_Internal {
 public:
};

EventAllPositionsHaircut::EventAllPositionsHaircut(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventAllPositionsHaircut)
}
EventAllPositionsHaircut::EventAllPositionsHaircut(const EventAllPositionsHaircut& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventAllPositionsHaircut* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settle_price_) {}

    , decltype(_impl_.missing_funds_rate_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.settle_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settle_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_settle_price().empty()) {
    _this->_impl_.settle_price_.Set(from._internal_settle_price(), _this->GetArenaForAllocation());
  }
  _impl_.missing_funds_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.missing_funds_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_missing_funds_rate().empty()) {
    _this->_impl_.missing_funds_rate_.Set(from._internal_missing_funds_rate(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventAllPositionsHaircut)
}

inline void EventAllPositionsHaircut::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.settle_price_) {}

    , decltype(_impl_.missing_funds_rate_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settle_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.settle_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.missing_funds_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.missing_funds_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventAllPositionsHaircut::~EventAllPositionsHaircut() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventAllPositionsHaircut)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventAllPositionsHaircut::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.settle_price_.Destroy();
  _impl_.missing_funds_rate_.Destroy();
}

void EventAllPositionsHaircut::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventAllPositionsHaircut::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventAllPositionsHaircut)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.settle_price_.ClearToEmpty();
  _impl_.missing_funds_rate_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventAllPositionsHaircut::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventAllPositionsHaircut.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string settle_price = 2 [json_name = "settlePrice"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_settle_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventAllPositionsHaircut.settle_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string missing_funds_rate = 3 [json_name = "missingFundsRate"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_missing_funds_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventAllPositionsHaircut.missing_funds_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventAllPositionsHaircut::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventAllPositionsHaircut)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventAllPositionsHaircut.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string settle_price = 2 [json_name = "settlePrice"];
  if (!this->_internal_settle_price().empty()) {
    const std::string& _s = this->_internal_settle_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventAllPositionsHaircut.settle_price");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string missing_funds_rate = 3 [json_name = "missingFundsRate"];
  if (!this->_internal_missing_funds_rate().empty()) {
    const std::string& _s = this->_internal_missing_funds_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventAllPositionsHaircut.missing_funds_rate");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventAllPositionsHaircut)
  return target;
}

::size_t EventAllPositionsHaircut::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventAllPositionsHaircut)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string settle_price = 2 [json_name = "settlePrice"];
  if (!this->_internal_settle_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_settle_price());
  }

  // string missing_funds_rate = 3 [json_name = "missingFundsRate"];
  if (!this->_internal_missing_funds_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_missing_funds_rate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventAllPositionsHaircut::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventAllPositionsHaircut::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventAllPositionsHaircut::GetClassData() const { return &_class_data_; }


void EventAllPositionsHaircut::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventAllPositionsHaircut*>(&to_msg);
  auto& from = static_cast<const EventAllPositionsHaircut&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventAllPositionsHaircut)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_settle_price().empty()) {
    _this->_internal_set_settle_price(from._internal_settle_price());
  }
  if (!from._internal_missing_funds_rate().empty()) {
    _this->_internal_set_missing_funds_rate(from._internal_missing_funds_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventAllPositionsHaircut::CopyFrom(const EventAllPositionsHaircut& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventAllPositionsHaircut)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventAllPositionsHaircut::IsInitialized() const {
  return true;
}

void EventAllPositionsHaircut::InternalSwap(EventAllPositionsHaircut* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.settle_price_, lhs_arena,
                                       &other->_impl_.settle_price_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.missing_funds_rate_, lhs_arena,
                                       &other->_impl_.missing_funds_rate_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventAllPositionsHaircut::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[6]);
}
// ===================================================================

class EventBinaryOptionsMarketUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<EventBinaryOptionsMarketUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventBinaryOptionsMarketUpdate, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::BinaryOptionsMarket& market(const EventBinaryOptionsMarketUpdate* msg);
  static void set_has_market(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::BinaryOptionsMarket&
EventBinaryOptionsMarketUpdate::_Internal::market(const EventBinaryOptionsMarketUpdate* msg) {
  return *msg->_impl_.market_;
}
void EventBinaryOptionsMarketUpdate::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventBinaryOptionsMarketUpdate::EventBinaryOptionsMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
}
EventBinaryOptionsMarketUpdate::EventBinaryOptionsMarketUpdate(const EventBinaryOptionsMarketUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventBinaryOptionsMarketUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_ = new ::injective::exchange::v1beta1::BinaryOptionsMarket(*from._impl_.market_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
}

inline void EventBinaryOptionsMarketUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}
  };
}

EventBinaryOptionsMarketUpdate::~EventBinaryOptionsMarketUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventBinaryOptionsMarketUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.market_;
}

void EventBinaryOptionsMarketUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventBinaryOptionsMarketUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.market_ != nullptr);
    _impl_.market_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventBinaryOptionsMarketUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.BinaryOptionsMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventBinaryOptionsMarketUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.BinaryOptionsMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::market(this),
        _Internal::market(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
  return target;
}

::size_t EventBinaryOptionsMarketUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective.exchange.v1beta1.BinaryOptionsMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.market_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventBinaryOptionsMarketUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventBinaryOptionsMarketUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventBinaryOptionsMarketUpdate::GetClassData() const { return &_class_data_; }


void EventBinaryOptionsMarketUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventBinaryOptionsMarketUpdate*>(&to_msg);
  auto& from = static_cast<const EventBinaryOptionsMarketUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_market()->::injective::exchange::v1beta1::BinaryOptionsMarket::MergeFrom(
        from._internal_market());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventBinaryOptionsMarketUpdate::CopyFrom(const EventBinaryOptionsMarketUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventBinaryOptionsMarketUpdate::IsInitialized() const {
  return true;
}

void EventBinaryOptionsMarketUpdate::InternalSwap(EventBinaryOptionsMarketUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.market_, other->_impl_.market_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventBinaryOptionsMarketUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[7]);
}
// ===================================================================

class EventNewSpotOrders::_Internal {
 public:
};

void EventNewSpotOrders::clear_buy_orders() {
  _internal_mutable_buy_orders()->Clear();
}
void EventNewSpotOrders::clear_sell_orders() {
  _internal_mutable_sell_orders()->Clear();
}
EventNewSpotOrders::EventNewSpotOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventNewSpotOrders)
}
EventNewSpotOrders::EventNewSpotOrders(const EventNewSpotOrders& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventNewSpotOrders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buy_orders_){from._impl_.buy_orders_}
    , decltype(_impl_.sell_orders_){from._impl_.sell_orders_}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventNewSpotOrders)
}

inline void EventNewSpotOrders::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.buy_orders_){arena}
    , decltype(_impl_.sell_orders_){arena}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventNewSpotOrders::~EventNewSpotOrders() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventNewSpotOrders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventNewSpotOrders::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_buy_orders()->~RepeatedPtrField();
  _internal_mutable_sell_orders()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void EventNewSpotOrders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventNewSpotOrders::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventNewSpotOrders)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_buy_orders()->Clear();
  _internal_mutable_sell_orders()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventNewSpotOrders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventNewSpotOrders.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2 [json_name = "buyOrders"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buy_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3 [json_name = "sellOrders"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sell_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventNewSpotOrders::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventNewSpotOrders)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventNewSpotOrders.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2 [json_name = "buyOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buy_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_buy_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3 [json_name = "sellOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sell_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_sell_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventNewSpotOrders)
  return target;
}

::size_t EventNewSpotOrders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventNewSpotOrders)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2 [json_name = "buyOrders"];
  total_size += 1UL * this->_internal_buy_orders_size();
  for (const auto& msg : this->_internal_buy_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3 [json_name = "sellOrders"];
  total_size += 1UL * this->_internal_sell_orders_size();
  for (const auto& msg : this->_internal_sell_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventNewSpotOrders::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventNewSpotOrders::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventNewSpotOrders::GetClassData() const { return &_class_data_; }


void EventNewSpotOrders::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventNewSpotOrders*>(&to_msg);
  auto& from = static_cast<const EventNewSpotOrders&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventNewSpotOrders)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_buy_orders()->MergeFrom(from._internal_buy_orders());
  _this->_internal_mutable_sell_orders()->MergeFrom(from._internal_sell_orders());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventNewSpotOrders::CopyFrom(const EventNewSpotOrders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventNewSpotOrders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventNewSpotOrders::IsInitialized() const {
  return true;
}

void EventNewSpotOrders::InternalSwap(EventNewSpotOrders* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_buy_orders()->InternalSwap(other->_internal_mutable_buy_orders());
  _internal_mutable_sell_orders()->InternalSwap(other->_internal_mutable_sell_orders());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventNewSpotOrders::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[8]);
}
// ===================================================================

class EventNewDerivativeOrders::_Internal {
 public:
};

void EventNewDerivativeOrders::clear_buy_orders() {
  _internal_mutable_buy_orders()->Clear();
}
void EventNewDerivativeOrders::clear_sell_orders() {
  _internal_mutable_sell_orders()->Clear();
}
EventNewDerivativeOrders::EventNewDerivativeOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventNewDerivativeOrders)
}
EventNewDerivativeOrders::EventNewDerivativeOrders(const EventNewDerivativeOrders& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventNewDerivativeOrders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buy_orders_){from._impl_.buy_orders_}
    , decltype(_impl_.sell_orders_){from._impl_.sell_orders_}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventNewDerivativeOrders)
}

inline void EventNewDerivativeOrders::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.buy_orders_){arena}
    , decltype(_impl_.sell_orders_){arena}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventNewDerivativeOrders::~EventNewDerivativeOrders() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventNewDerivativeOrders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventNewDerivativeOrders::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_buy_orders()->~RepeatedPtrField();
  _internal_mutable_sell_orders()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void EventNewDerivativeOrders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventNewDerivativeOrders::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventNewDerivativeOrders)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_buy_orders()->Clear();
  _internal_mutable_sell_orders()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventNewDerivativeOrders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventNewDerivativeOrders.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2 [json_name = "buyOrders"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buy_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3 [json_name = "sellOrders"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sell_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventNewDerivativeOrders::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventNewDerivativeOrders)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventNewDerivativeOrders.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2 [json_name = "buyOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buy_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_buy_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3 [json_name = "sellOrders"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sell_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_sell_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventNewDerivativeOrders)
  return target;
}

::size_t EventNewDerivativeOrders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventNewDerivativeOrders)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2 [json_name = "buyOrders"];
  total_size += 1UL * this->_internal_buy_orders_size();
  for (const auto& msg : this->_internal_buy_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3 [json_name = "sellOrders"];
  total_size += 1UL * this->_internal_sell_orders_size();
  for (const auto& msg : this->_internal_sell_orders()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventNewDerivativeOrders::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventNewDerivativeOrders::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventNewDerivativeOrders::GetClassData() const { return &_class_data_; }


void EventNewDerivativeOrders::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventNewDerivativeOrders*>(&to_msg);
  auto& from = static_cast<const EventNewDerivativeOrders&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventNewDerivativeOrders)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_buy_orders()->MergeFrom(from._internal_buy_orders());
  _this->_internal_mutable_sell_orders()->MergeFrom(from._internal_sell_orders());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventNewDerivativeOrders::CopyFrom(const EventNewDerivativeOrders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventNewDerivativeOrders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventNewDerivativeOrders::IsInitialized() const {
  return true;
}

void EventNewDerivativeOrders::InternalSwap(EventNewDerivativeOrders* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_buy_orders()->InternalSwap(other->_internal_mutable_buy_orders());
  _internal_mutable_sell_orders()->InternalSwap(other->_internal_mutable_sell_orders());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventNewDerivativeOrders::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[9]);
}
// ===================================================================

class EventCancelSpotOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<EventCancelSpotOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventCancelSpotOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::SpotLimitOrder& order(const EventCancelSpotOrder* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::SpotLimitOrder&
EventCancelSpotOrder::_Internal::order(const EventCancelSpotOrder* msg) {
  return *msg->_impl_.order_;
}
void EventCancelSpotOrder::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventCancelSpotOrder::EventCancelSpotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventCancelSpotOrder)
}
EventCancelSpotOrder::EventCancelSpotOrder(const EventCancelSpotOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventCancelSpotOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::injective::exchange::v1beta1::SpotLimitOrder(*from._impl_.order_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventCancelSpotOrder)
}

inline void EventCancelSpotOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_){nullptr}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventCancelSpotOrder::~EventCancelSpotOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventCancelSpotOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventCancelSpotOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_;
}

void EventCancelSpotOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventCancelSpotOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventCancelSpotOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventCancelSpotOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventCancelSpotOrder.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.SpotLimitOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventCancelSpotOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventCancelSpotOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventCancelSpotOrder.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.SpotLimitOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventCancelSpotOrder)
  return target;
}

::size_t EventCancelSpotOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventCancelSpotOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // .injective.exchange.v1beta1.SpotLimitOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventCancelSpotOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventCancelSpotOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventCancelSpotOrder::GetClassData() const { return &_class_data_; }


void EventCancelSpotOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventCancelSpotOrder*>(&to_msg);
  auto& from = static_cast<const EventCancelSpotOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventCancelSpotOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::injective::exchange::v1beta1::SpotLimitOrder::MergeFrom(
        from._internal_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventCancelSpotOrder::CopyFrom(const EventCancelSpotOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventCancelSpotOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventCancelSpotOrder::IsInitialized() const {
  return true;
}

void EventCancelSpotOrder::InternalSwap(EventCancelSpotOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  swap(_impl_.order_, other->_impl_.order_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventCancelSpotOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[10]);
}
// ===================================================================

class EventSpotMarketUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<EventSpotMarketUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventSpotMarketUpdate, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::SpotMarket& market(const EventSpotMarketUpdate* msg);
  static void set_has_market(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::SpotMarket&
EventSpotMarketUpdate::_Internal::market(const EventSpotMarketUpdate* msg) {
  return *msg->_impl_.market_;
}
void EventSpotMarketUpdate::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventSpotMarketUpdate::EventSpotMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventSpotMarketUpdate)
}
EventSpotMarketUpdate::EventSpotMarketUpdate(const EventSpotMarketUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventSpotMarketUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_ = new ::injective::exchange::v1beta1::SpotMarket(*from._impl_.market_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventSpotMarketUpdate)
}

inline void EventSpotMarketUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}
  };
}

EventSpotMarketUpdate::~EventSpotMarketUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventSpotMarketUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventSpotMarketUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.market_;
}

void EventSpotMarketUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventSpotMarketUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventSpotMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.market_ != nullptr);
    _impl_.market_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventSpotMarketUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventSpotMarketUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventSpotMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::market(this),
        _Internal::market(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventSpotMarketUpdate)
  return target;
}

::size_t EventSpotMarketUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventSpotMarketUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.market_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventSpotMarketUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventSpotMarketUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventSpotMarketUpdate::GetClassData() const { return &_class_data_; }


void EventSpotMarketUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventSpotMarketUpdate*>(&to_msg);
  auto& from = static_cast<const EventSpotMarketUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventSpotMarketUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_market()->::injective::exchange::v1beta1::SpotMarket::MergeFrom(
        from._internal_market());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventSpotMarketUpdate::CopyFrom(const EventSpotMarketUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventSpotMarketUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventSpotMarketUpdate::IsInitialized() const {
  return true;
}

void EventSpotMarketUpdate::InternalSwap(EventSpotMarketUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.market_, other->_impl_.market_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventSpotMarketUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[11]);
}
// ===================================================================

class EventPerpetualMarketUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<EventPerpetualMarketUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventPerpetualMarketUpdate, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::DerivativeMarket& market(const EventPerpetualMarketUpdate* msg);
  static void set_has_market(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::injective::exchange::v1beta1::PerpetualMarketInfo& perpetual_market_info(const EventPerpetualMarketUpdate* msg);
  static void set_has_perpetual_market_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::injective::exchange::v1beta1::PerpetualMarketFunding& funding(const EventPerpetualMarketUpdate* msg);
  static void set_has_funding(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::injective::exchange::v1beta1::DerivativeMarket&
EventPerpetualMarketUpdate::_Internal::market(const EventPerpetualMarketUpdate* msg) {
  return *msg->_impl_.market_;
}
const ::injective::exchange::v1beta1::PerpetualMarketInfo&
EventPerpetualMarketUpdate::_Internal::perpetual_market_info(const EventPerpetualMarketUpdate* msg) {
  return *msg->_impl_.perpetual_market_info_;
}
const ::injective::exchange::v1beta1::PerpetualMarketFunding&
EventPerpetualMarketUpdate::_Internal::funding(const EventPerpetualMarketUpdate* msg) {
  return *msg->_impl_.funding_;
}
void EventPerpetualMarketUpdate::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EventPerpetualMarketUpdate::clear_perpetual_market_info() {
  if (_impl_.perpetual_market_info_ != nullptr) _impl_.perpetual_market_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void EventPerpetualMarketUpdate::clear_funding() {
  if (_impl_.funding_ != nullptr) _impl_.funding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
EventPerpetualMarketUpdate::EventPerpetualMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
}
EventPerpetualMarketUpdate::EventPerpetualMarketUpdate(const EventPerpetualMarketUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventPerpetualMarketUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}
    , decltype(_impl_.perpetual_market_info_){nullptr}
    , decltype(_impl_.funding_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_ = new ::injective::exchange::v1beta1::DerivativeMarket(*from._impl_.market_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.perpetual_market_info_ = new ::injective::exchange::v1beta1::PerpetualMarketInfo(*from._impl_.perpetual_market_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.funding_ = new ::injective::exchange::v1beta1::PerpetualMarketFunding(*from._impl_.funding_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
}

inline void EventPerpetualMarketUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}
    , decltype(_impl_.perpetual_market_info_){nullptr}
    , decltype(_impl_.funding_){nullptr}
  };
}

EventPerpetualMarketUpdate::~EventPerpetualMarketUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventPerpetualMarketUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.market_;
  if (this != internal_default_instance()) delete _impl_.perpetual_market_info_;
  if (this != internal_default_instance()) delete _impl_.funding_;
}

void EventPerpetualMarketUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventPerpetualMarketUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.market_ != nullptr);
      _impl_.market_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.perpetual_market_info_ != nullptr);
      _impl_.perpetual_market_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.funding_ != nullptr);
      _impl_.funding_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventPerpetualMarketUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_perpetual_market_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 3 [json_name = "funding", (.gogoproto.nullable) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_funding(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventPerpetualMarketUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::market(this),
        _Internal::market(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::perpetual_market_info(this),
        _Internal::perpetual_market_info(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 3 [json_name = "funding", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::funding(this),
        _Internal::funding(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
  return target;
}

::size_t EventPerpetualMarketUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.market_);
    }

    // .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.perpetual_market_info_);
    }

    // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 3 [json_name = "funding", (.gogoproto.nullable) = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.funding_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventPerpetualMarketUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventPerpetualMarketUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventPerpetualMarketUpdate::GetClassData() const { return &_class_data_; }


void EventPerpetualMarketUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventPerpetualMarketUpdate*>(&to_msg);
  auto& from = static_cast<const EventPerpetualMarketUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_market()->::injective::exchange::v1beta1::DerivativeMarket::MergeFrom(
          from._internal_market());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_perpetual_market_info()->::injective::exchange::v1beta1::PerpetualMarketInfo::MergeFrom(
          from._internal_perpetual_market_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_funding()->::injective::exchange::v1beta1::PerpetualMarketFunding::MergeFrom(
          from._internal_funding());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventPerpetualMarketUpdate::CopyFrom(const EventPerpetualMarketUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventPerpetualMarketUpdate::IsInitialized() const {
  return true;
}

void EventPerpetualMarketUpdate::InternalSwap(EventPerpetualMarketUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventPerpetualMarketUpdate, _impl_.funding_)
      + sizeof(EventPerpetualMarketUpdate::_impl_.funding_)
      - PROTOBUF_FIELD_OFFSET(EventPerpetualMarketUpdate, _impl_.market_)>(
          reinterpret_cast<char*>(&_impl_.market_),
          reinterpret_cast<char*>(&other->_impl_.market_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventPerpetualMarketUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[12]);
}
// ===================================================================

class EventExpiryFuturesMarketUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<EventExpiryFuturesMarketUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventExpiryFuturesMarketUpdate, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::DerivativeMarket& market(const EventExpiryFuturesMarketUpdate* msg);
  static void set_has_market(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& expiry_futures_market_info(const EventExpiryFuturesMarketUpdate* msg);
  static void set_has_expiry_futures_market_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::injective::exchange::v1beta1::DerivativeMarket&
EventExpiryFuturesMarketUpdate::_Internal::market(const EventExpiryFuturesMarketUpdate* msg) {
  return *msg->_impl_.market_;
}
const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo&
EventExpiryFuturesMarketUpdate::_Internal::expiry_futures_market_info(const EventExpiryFuturesMarketUpdate* msg) {
  return *msg->_impl_.expiry_futures_market_info_;
}
void EventExpiryFuturesMarketUpdate::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EventExpiryFuturesMarketUpdate::clear_expiry_futures_market_info() {
  if (_impl_.expiry_futures_market_info_ != nullptr) _impl_.expiry_futures_market_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
EventExpiryFuturesMarketUpdate::EventExpiryFuturesMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
}
EventExpiryFuturesMarketUpdate::EventExpiryFuturesMarketUpdate(const EventExpiryFuturesMarketUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventExpiryFuturesMarketUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}
    , decltype(_impl_.expiry_futures_market_info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_ = new ::injective::exchange::v1beta1::DerivativeMarket(*from._impl_.market_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.expiry_futures_market_info_ = new ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo(*from._impl_.expiry_futures_market_info_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
}

inline void EventExpiryFuturesMarketUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_){nullptr}
    , decltype(_impl_.expiry_futures_market_info_){nullptr}
  };
}

EventExpiryFuturesMarketUpdate::~EventExpiryFuturesMarketUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventExpiryFuturesMarketUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.market_;
  if (this != internal_default_instance()) delete _impl_.expiry_futures_market_info_;
}

void EventExpiryFuturesMarketUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventExpiryFuturesMarketUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.market_ != nullptr);
      _impl_.market_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.expiry_futures_market_info_ != nullptr);
      _impl_.expiry_futures_market_info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventExpiryFuturesMarketUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3 [json_name = "expiryFuturesMarketInfo", (.gogoproto.nullable) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_expiry_futures_market_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventExpiryFuturesMarketUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::market(this),
        _Internal::market(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3 [json_name = "expiryFuturesMarketInfo", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::expiry_futures_market_info(this),
        _Internal::expiry_futures_market_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
  return target;
}

::size_t EventExpiryFuturesMarketUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.market_);
    }

    // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3 [json_name = "expiryFuturesMarketInfo", (.gogoproto.nullable) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.expiry_futures_market_info_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventExpiryFuturesMarketUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventExpiryFuturesMarketUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventExpiryFuturesMarketUpdate::GetClassData() const { return &_class_data_; }


void EventExpiryFuturesMarketUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventExpiryFuturesMarketUpdate*>(&to_msg);
  auto& from = static_cast<const EventExpiryFuturesMarketUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_market()->::injective::exchange::v1beta1::DerivativeMarket::MergeFrom(
          from._internal_market());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_expiry_futures_market_info()->::injective::exchange::v1beta1::ExpiryFuturesMarketInfo::MergeFrom(
          from._internal_expiry_futures_market_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventExpiryFuturesMarketUpdate::CopyFrom(const EventExpiryFuturesMarketUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventExpiryFuturesMarketUpdate::IsInitialized() const {
  return true;
}

void EventExpiryFuturesMarketUpdate::InternalSwap(EventExpiryFuturesMarketUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventExpiryFuturesMarketUpdate, _impl_.expiry_futures_market_info_)
      + sizeof(EventExpiryFuturesMarketUpdate::_impl_.expiry_futures_market_info_)
      - PROTOBUF_FIELD_OFFSET(EventExpiryFuturesMarketUpdate, _impl_.market_)>(
          reinterpret_cast<char*>(&_impl_.market_),
          reinterpret_cast<char*>(&other->_impl_.market_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventExpiryFuturesMarketUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[13]);
}
// ===================================================================

class EventPerpetualMarketFundingUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<EventPerpetualMarketFundingUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventPerpetualMarketFundingUpdate, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::PerpetualMarketFunding& funding(const EventPerpetualMarketFundingUpdate* msg);
  static void set_has_funding(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::PerpetualMarketFunding&
EventPerpetualMarketFundingUpdate::_Internal::funding(const EventPerpetualMarketFundingUpdate* msg) {
  return *msg->_impl_.funding_;
}
void EventPerpetualMarketFundingUpdate::clear_funding() {
  if (_impl_.funding_ != nullptr) _impl_.funding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventPerpetualMarketFundingUpdate::EventPerpetualMarketFundingUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
}
EventPerpetualMarketFundingUpdate::EventPerpetualMarketFundingUpdate(const EventPerpetualMarketFundingUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventPerpetualMarketFundingUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.funding_rate_) {}

    , decltype(_impl_.mark_price_) {}

    , decltype(_impl_.funding_){nullptr}
    , decltype(_impl_.is_hourly_funding_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.funding_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.funding_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_funding_rate().empty()) {
    _this->_impl_.funding_rate_.Set(from._internal_funding_rate(), _this->GetArenaForAllocation());
  }
  _impl_.mark_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mark_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mark_price().empty()) {
    _this->_impl_.mark_price_.Set(from._internal_mark_price(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.funding_ = new ::injective::exchange::v1beta1::PerpetualMarketFunding(*from._impl_.funding_);
  }
  _this->_impl_.is_hourly_funding_ = from._impl_.is_hourly_funding_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
}

inline void EventPerpetualMarketFundingUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.funding_rate_) {}

    , decltype(_impl_.mark_price_) {}

    , decltype(_impl_.funding_){nullptr}
    , decltype(_impl_.is_hourly_funding_) { false }

  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.funding_rate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.funding_rate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mark_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.mark_price_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventPerpetualMarketFundingUpdate::~EventPerpetualMarketFundingUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventPerpetualMarketFundingUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.funding_rate_.Destroy();
  _impl_.mark_price_.Destroy();
  if (this != internal_default_instance()) delete _impl_.funding_;
}

void EventPerpetualMarketFundingUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventPerpetualMarketFundingUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.funding_rate_.ClearToEmpty();
  _impl_.mark_price_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.funding_ != nullptr);
    _impl_.funding_->Clear();
  }
  _impl_.is_hourly_funding_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventPerpetualMarketFundingUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding", (.gogoproto.nullable) = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_funding(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_hourly_funding = 3 [json_name = "isHourlyFunding"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.is_hourly_funding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string funding_rate = 4 [json_name = "fundingRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_funding_rate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding_rate"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string mark_price = 5 [json_name = "markPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mark_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.mark_price"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventPerpetualMarketFundingUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::funding(this),
        _Internal::funding(this).GetCachedSize(), target, stream);
  }

  // bool is_hourly_funding = 3 [json_name = "isHourlyFunding"];
  if (this->_internal_is_hourly_funding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_is_hourly_funding(), target);
  }

  // string funding_rate = 4 [json_name = "fundingRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_funding_rate().empty()) {
    const std::string& _s = this->_internal_funding_rate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding_rate");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string mark_price = 5 [json_name = "markPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_mark_price().empty()) {
    const std::string& _s = this->_internal_mark_price();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.mark_price");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
  return target;
}

::size_t EventPerpetualMarketFundingUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string funding_rate = 4 [json_name = "fundingRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_funding_rate().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_funding_rate());
  }

  // string mark_price = 5 [json_name = "markPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_mark_price().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_mark_price());
  }

  // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.funding_);
  }

  // bool is_hourly_funding = 3 [json_name = "isHourlyFunding"];
  if (this->_internal_is_hourly_funding() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventPerpetualMarketFundingUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventPerpetualMarketFundingUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventPerpetualMarketFundingUpdate::GetClassData() const { return &_class_data_; }


void EventPerpetualMarketFundingUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventPerpetualMarketFundingUpdate*>(&to_msg);
  auto& from = static_cast<const EventPerpetualMarketFundingUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_funding_rate().empty()) {
    _this->_internal_set_funding_rate(from._internal_funding_rate());
  }
  if (!from._internal_mark_price().empty()) {
    _this->_internal_set_mark_price(from._internal_mark_price());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_funding()->::injective::exchange::v1beta1::PerpetualMarketFunding::MergeFrom(
        from._internal_funding());
  }
  if (from._internal_is_hourly_funding() != 0) {
    _this->_internal_set_is_hourly_funding(from._internal_is_hourly_funding());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventPerpetualMarketFundingUpdate::CopyFrom(const EventPerpetualMarketFundingUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventPerpetualMarketFundingUpdate::IsInitialized() const {
  return true;
}

void EventPerpetualMarketFundingUpdate::InternalSwap(EventPerpetualMarketFundingUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.funding_rate_, lhs_arena,
                                       &other->_impl_.funding_rate_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mark_price_, lhs_arena,
                                       &other->_impl_.mark_price_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventPerpetualMarketFundingUpdate, _impl_.is_hourly_funding_)
      + sizeof(EventPerpetualMarketFundingUpdate::_impl_.is_hourly_funding_)
      - PROTOBUF_FIELD_OFFSET(EventPerpetualMarketFundingUpdate, _impl_.funding_)>(
          reinterpret_cast<char*>(&_impl_.funding_),
          reinterpret_cast<char*>(&other->_impl_.funding_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventPerpetualMarketFundingUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[14]);
}
// ===================================================================

class EventSubaccountDeposit::_Internal {
 public:
  using HasBits = decltype(std::declval<EventSubaccountDeposit>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventSubaccountDeposit, _impl_._has_bits_);
  static const ::cosmos::base::v1beta1::Coin& amount(const EventSubaccountDeposit* msg);
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::base::v1beta1::Coin&
EventSubaccountDeposit::_Internal::amount(const EventSubaccountDeposit* msg) {
  return *msg->_impl_.amount_;
}
void EventSubaccountDeposit::clear_amount() {
  if (_impl_.amount_ != nullptr) _impl_.amount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventSubaccountDeposit::EventSubaccountDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventSubaccountDeposit)
}
EventSubaccountDeposit::EventSubaccountDeposit(const EventSubaccountDeposit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventSubaccountDeposit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_address_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.amount_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.src_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src_address().empty()) {
    _this->_impl_.src_address_.Set(from._internal_src_address(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.amount_ = new ::cosmos::base::v1beta1::Coin(*from._impl_.amount_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventSubaccountDeposit)
}

inline void EventSubaccountDeposit::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_address_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.amount_){nullptr}
  };
  _impl_.src_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventSubaccountDeposit::~EventSubaccountDeposit() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventSubaccountDeposit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventSubaccountDeposit::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.src_address_.Destroy();
  _impl_.subaccount_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.amount_;
}

void EventSubaccountDeposit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventSubaccountDeposit::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventSubaccountDeposit)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.src_address_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.amount_ != nullptr);
    _impl_.amount_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventSubaccountDeposit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string src_address = 1 [json_name = "srcAddress"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_src_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventSubaccountDeposit.src_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes subaccount_id = 2 [json_name = "subaccountId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_amount(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventSubaccountDeposit::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventSubaccountDeposit)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string src_address = 1 [json_name = "srcAddress"];
  if (!this->_internal_src_address().empty()) {
    const std::string& _s = this->_internal_src_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventSubaccountDeposit.src_address");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::amount(this),
        _Internal::amount(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventSubaccountDeposit)
  return target;
}

::size_t EventSubaccountDeposit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventSubaccountDeposit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string src_address = 1 [json_name = "srcAddress"];
  if (!this->_internal_src_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_src_address());
  }

  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_subaccount_id());
  }

  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amount_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventSubaccountDeposit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventSubaccountDeposit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventSubaccountDeposit::GetClassData() const { return &_class_data_; }


void EventSubaccountDeposit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventSubaccountDeposit*>(&to_msg);
  auto& from = static_cast<const EventSubaccountDeposit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventSubaccountDeposit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_src_address().empty()) {
    _this->_internal_set_src_address(from._internal_src_address());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_amount()->::cosmos::base::v1beta1::Coin::MergeFrom(
        from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventSubaccountDeposit::CopyFrom(const EventSubaccountDeposit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventSubaccountDeposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventSubaccountDeposit::IsInitialized() const {
  return true;
}

void EventSubaccountDeposit::InternalSwap(EventSubaccountDeposit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.src_address_, lhs_arena,
                                       &other->_impl_.src_address_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventSubaccountDeposit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[15]);
}
// ===================================================================

class EventSubaccountWithdraw::_Internal {
 public:
  using HasBits = decltype(std::declval<EventSubaccountWithdraw>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventSubaccountWithdraw, _impl_._has_bits_);
  static const ::cosmos::base::v1beta1::Coin& amount(const EventSubaccountWithdraw* msg);
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::base::v1beta1::Coin&
EventSubaccountWithdraw::_Internal::amount(const EventSubaccountWithdraw* msg) {
  return *msg->_impl_.amount_;
}
void EventSubaccountWithdraw::clear_amount() {
  if (_impl_.amount_ != nullptr) _impl_.amount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventSubaccountWithdraw::EventSubaccountWithdraw(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventSubaccountWithdraw)
}
EventSubaccountWithdraw::EventSubaccountWithdraw(const EventSubaccountWithdraw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventSubaccountWithdraw* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.dst_address_) {}

    , decltype(_impl_.amount_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.dst_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dst_address().empty()) {
    _this->_impl_.dst_address_.Set(from._internal_dst_address(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.amount_ = new ::cosmos::base::v1beta1::Coin(*from._impl_.amount_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventSubaccountWithdraw)
}

inline void EventSubaccountWithdraw::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.dst_address_) {}

    , decltype(_impl_.amount_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventSubaccountWithdraw::~EventSubaccountWithdraw() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventSubaccountWithdraw)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventSubaccountWithdraw::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.dst_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.amount_;
}

void EventSubaccountWithdraw::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventSubaccountWithdraw::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventSubaccountWithdraw)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.dst_address_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.amount_ != nullptr);
    _impl_.amount_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventSubaccountWithdraw::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string dst_address = 2 [json_name = "dstAddress"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dst_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventSubaccountWithdraw.dst_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_amount(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventSubaccountWithdraw::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventSubaccountWithdraw)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // string dst_address = 2 [json_name = "dstAddress"];
  if (!this->_internal_dst_address().empty()) {
    const std::string& _s = this->_internal_dst_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventSubaccountWithdraw.dst_address");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::amount(this),
        _Internal::amount(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventSubaccountWithdraw)
  return target;
}

::size_t EventSubaccountWithdraw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventSubaccountWithdraw)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_subaccount_id());
  }

  // string dst_address = 2 [json_name = "dstAddress"];
  if (!this->_internal_dst_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_dst_address());
  }

  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amount_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventSubaccountWithdraw::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventSubaccountWithdraw::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventSubaccountWithdraw::GetClassData() const { return &_class_data_; }


void EventSubaccountWithdraw::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventSubaccountWithdraw*>(&to_msg);
  auto& from = static_cast<const EventSubaccountWithdraw&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventSubaccountWithdraw)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_dst_address().empty()) {
    _this->_internal_set_dst_address(from._internal_dst_address());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_amount()->::cosmos::base::v1beta1::Coin::MergeFrom(
        from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventSubaccountWithdraw::CopyFrom(const EventSubaccountWithdraw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventSubaccountWithdraw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventSubaccountWithdraw::IsInitialized() const {
  return true;
}

void EventSubaccountWithdraw::InternalSwap(EventSubaccountWithdraw* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dst_address_, lhs_arena,
                                       &other->_impl_.dst_address_, rhs_arena);
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventSubaccountWithdraw::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[16]);
}
// ===================================================================

class EventSubaccountBalanceTransfer::_Internal {
 public:
  using HasBits = decltype(std::declval<EventSubaccountBalanceTransfer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventSubaccountBalanceTransfer, _impl_._has_bits_);
  static const ::cosmos::base::v1beta1::Coin& amount(const EventSubaccountBalanceTransfer* msg);
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cosmos::base::v1beta1::Coin&
EventSubaccountBalanceTransfer::_Internal::amount(const EventSubaccountBalanceTransfer* msg) {
  return *msg->_impl_.amount_;
}
void EventSubaccountBalanceTransfer::clear_amount() {
  if (_impl_.amount_ != nullptr) _impl_.amount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventSubaccountBalanceTransfer::EventSubaccountBalanceTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
}
EventSubaccountBalanceTransfer::EventSubaccountBalanceTransfer(const EventSubaccountBalanceTransfer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventSubaccountBalanceTransfer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_subaccount_id_) {}

    , decltype(_impl_.dst_subaccount_id_) {}

    , decltype(_impl_.amount_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.src_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src_subaccount_id().empty()) {
    _this->_impl_.src_subaccount_id_.Set(from._internal_src_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.dst_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dst_subaccount_id().empty()) {
    _this->_impl_.dst_subaccount_id_.Set(from._internal_dst_subaccount_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.amount_ = new ::cosmos::base::v1beta1::Coin(*from._impl_.amount_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
}

inline void EventSubaccountBalanceTransfer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_subaccount_id_) {}

    , decltype(_impl_.dst_subaccount_id_) {}

    , decltype(_impl_.amount_){nullptr}
  };
  _impl_.src_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventSubaccountBalanceTransfer::~EventSubaccountBalanceTransfer() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventSubaccountBalanceTransfer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.src_subaccount_id_.Destroy();
  _impl_.dst_subaccount_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.amount_;
}

void EventSubaccountBalanceTransfer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventSubaccountBalanceTransfer::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.src_subaccount_id_.ClearToEmpty();
  _impl_.dst_subaccount_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.amount_ != nullptr);
    _impl_.amount_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventSubaccountBalanceTransfer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string src_subaccount_id = 1 [json_name = "srcSubaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_src_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventSubaccountBalanceTransfer.src_subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string dst_subaccount_id = 2 [json_name = "dstSubaccountId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dst_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventSubaccountBalanceTransfer.dst_subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_amount(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventSubaccountBalanceTransfer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string src_subaccount_id = 1 [json_name = "srcSubaccountId"];
  if (!this->_internal_src_subaccount_id().empty()) {
    const std::string& _s = this->_internal_src_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventSubaccountBalanceTransfer.src_subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string dst_subaccount_id = 2 [json_name = "dstSubaccountId"];
  if (!this->_internal_dst_subaccount_id().empty()) {
    const std::string& _s = this->_internal_dst_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventSubaccountBalanceTransfer.dst_subaccount_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::amount(this),
        _Internal::amount(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
  return target;
}

::size_t EventSubaccountBalanceTransfer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string src_subaccount_id = 1 [json_name = "srcSubaccountId"];
  if (!this->_internal_src_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_src_subaccount_id());
  }

  // string dst_subaccount_id = 2 [json_name = "dstSubaccountId"];
  if (!this->_internal_dst_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_dst_subaccount_id());
  }

  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amount_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventSubaccountBalanceTransfer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventSubaccountBalanceTransfer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventSubaccountBalanceTransfer::GetClassData() const { return &_class_data_; }


void EventSubaccountBalanceTransfer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventSubaccountBalanceTransfer*>(&to_msg);
  auto& from = static_cast<const EventSubaccountBalanceTransfer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_src_subaccount_id().empty()) {
    _this->_internal_set_src_subaccount_id(from._internal_src_subaccount_id());
  }
  if (!from._internal_dst_subaccount_id().empty()) {
    _this->_internal_set_dst_subaccount_id(from._internal_dst_subaccount_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_amount()->::cosmos::base::v1beta1::Coin::MergeFrom(
        from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventSubaccountBalanceTransfer::CopyFrom(const EventSubaccountBalanceTransfer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventSubaccountBalanceTransfer::IsInitialized() const {
  return true;
}

void EventSubaccountBalanceTransfer::InternalSwap(EventSubaccountBalanceTransfer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.src_subaccount_id_, lhs_arena,
                                       &other->_impl_.src_subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dst_subaccount_id_, lhs_arena,
                                       &other->_impl_.dst_subaccount_id_, rhs_arena);
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventSubaccountBalanceTransfer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[17]);
}
// ===================================================================

class EventBatchDepositUpdate::_Internal {
 public:
};

void EventBatchDepositUpdate::clear_deposit_updates() {
  _internal_mutable_deposit_updates()->Clear();
}
EventBatchDepositUpdate::EventBatchDepositUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventBatchDepositUpdate)
}
EventBatchDepositUpdate::EventBatchDepositUpdate(const EventBatchDepositUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventBatchDepositUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.deposit_updates_){from._impl_.deposit_updates_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventBatchDepositUpdate)
}

inline void EventBatchDepositUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.deposit_updates_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventBatchDepositUpdate::~EventBatchDepositUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventBatchDepositUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventBatchDepositUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_deposit_updates()->~RepeatedPtrField();
}

void EventBatchDepositUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventBatchDepositUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventBatchDepositUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_deposit_updates()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventBatchDepositUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective.exchange.v1beta1.DepositUpdate deposit_updates = 1 [json_name = "depositUpdates"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_deposit_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventBatchDepositUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventBatchDepositUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.DepositUpdate deposit_updates = 1 [json_name = "depositUpdates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_deposit_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_deposit_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventBatchDepositUpdate)
  return target;
}

::size_t EventBatchDepositUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventBatchDepositUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.DepositUpdate deposit_updates = 1 [json_name = "depositUpdates"];
  total_size += 1UL * this->_internal_deposit_updates_size();
  for (const auto& msg : this->_internal_deposit_updates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventBatchDepositUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventBatchDepositUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventBatchDepositUpdate::GetClassData() const { return &_class_data_; }


void EventBatchDepositUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventBatchDepositUpdate*>(&to_msg);
  auto& from = static_cast<const EventBatchDepositUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventBatchDepositUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_deposit_updates()->MergeFrom(from._internal_deposit_updates());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventBatchDepositUpdate::CopyFrom(const EventBatchDepositUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventBatchDepositUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventBatchDepositUpdate::IsInitialized() const {
  return true;
}

void EventBatchDepositUpdate::InternalSwap(EventBatchDepositUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_deposit_updates()->InternalSwap(other->_internal_mutable_deposit_updates());
}

::PROTOBUF_NAMESPACE_ID::Metadata EventBatchDepositUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[18]);
}
// ===================================================================

class DerivativeMarketOrderCancel::_Internal {
 public:
  using HasBits = decltype(std::declval<DerivativeMarketOrderCancel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DerivativeMarketOrderCancel, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::DerivativeMarketOrder& market_order(const DerivativeMarketOrderCancel* msg);
  static void set_has_market_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::DerivativeMarketOrder&
DerivativeMarketOrderCancel::_Internal::market_order(const DerivativeMarketOrderCancel* msg) {
  return *msg->_impl_.market_order_;
}
void DerivativeMarketOrderCancel::clear_market_order() {
  if (_impl_.market_order_ != nullptr) _impl_.market_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
DerivativeMarketOrderCancel::DerivativeMarketOrderCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
}
DerivativeMarketOrderCancel::DerivativeMarketOrderCancel(const DerivativeMarketOrderCancel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DerivativeMarketOrderCancel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cancel_quantity_) {}

    , decltype(_impl_.market_order_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cancel_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cancel_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cancel_quantity().empty()) {
    _this->_impl_.cancel_quantity_.Set(from._internal_cancel_quantity(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.market_order_ = new ::injective::exchange::v1beta1::DerivativeMarketOrder(*from._impl_.market_order_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
}

inline void DerivativeMarketOrderCancel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cancel_quantity_) {}

    , decltype(_impl_.market_order_){nullptr}
  };
  _impl_.cancel_quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.cancel_quantity_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DerivativeMarketOrderCancel::~DerivativeMarketOrderCancel() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DerivativeMarketOrderCancel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cancel_quantity_.Destroy();
  if (this != internal_default_instance()) delete _impl_.market_order_;
}

void DerivativeMarketOrderCancel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DerivativeMarketOrderCancel::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cancel_quantity_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.market_order_ != nullptr);
    _impl_.market_order_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivativeMarketOrderCancel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1 [json_name = "marketOrder", (.gogoproto.nullable) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string cancel_quantity = 2 [json_name = "cancelQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cancel_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.DerivativeMarketOrderCancel.cancel_quantity"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DerivativeMarketOrderCancel::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1 [json_name = "marketOrder", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::market_order(this),
        _Internal::market_order(this).GetCachedSize(), target, stream);
  }

  // string cancel_quantity = 2 [json_name = "cancelQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cancel_quantity().empty()) {
    const std::string& _s = this->_internal_cancel_quantity();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.DerivativeMarketOrderCancel.cancel_quantity");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
  return target;
}

::size_t DerivativeMarketOrderCancel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string cancel_quantity = 2 [json_name = "cancelQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  if (!this->_internal_cancel_quantity().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_cancel_quantity());
  }

  // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1 [json_name = "marketOrder", (.gogoproto.nullable) = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.market_order_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivativeMarketOrderCancel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DerivativeMarketOrderCancel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivativeMarketOrderCancel::GetClassData() const { return &_class_data_; }


void DerivativeMarketOrderCancel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DerivativeMarketOrderCancel*>(&to_msg);
  auto& from = static_cast<const DerivativeMarketOrderCancel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_cancel_quantity().empty()) {
    _this->_internal_set_cancel_quantity(from._internal_cancel_quantity());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_market_order()->::injective::exchange::v1beta1::DerivativeMarketOrder::MergeFrom(
        from._internal_market_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivativeMarketOrderCancel::CopyFrom(const DerivativeMarketOrderCancel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivativeMarketOrderCancel::IsInitialized() const {
  return true;
}

void DerivativeMarketOrderCancel::InternalSwap(DerivativeMarketOrderCancel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.cancel_quantity_, lhs_arena,
                                       &other->_impl_.cancel_quantity_, rhs_arena);
  swap(_impl_.market_order_, other->_impl_.market_order_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivativeMarketOrderCancel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[19]);
}
// ===================================================================

class EventCancelDerivativeOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<EventCancelDerivativeOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventCancelDerivativeOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::DerivativeLimitOrder& limit_order(const EventCancelDerivativeOrder* msg);
  static void set_has_limit_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel& market_order_cancel(const EventCancelDerivativeOrder* msg);
  static void set_has_market_order_cancel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::injective::exchange::v1beta1::DerivativeLimitOrder&
EventCancelDerivativeOrder::_Internal::limit_order(const EventCancelDerivativeOrder* msg) {
  return *msg->_impl_.limit_order_;
}
const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel&
EventCancelDerivativeOrder::_Internal::market_order_cancel(const EventCancelDerivativeOrder* msg) {
  return *msg->_impl_.market_order_cancel_;
}
void EventCancelDerivativeOrder::clear_limit_order() {
  if (_impl_.limit_order_ != nullptr) _impl_.limit_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventCancelDerivativeOrder::EventCancelDerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventCancelDerivativeOrder)
}
EventCancelDerivativeOrder::EventCancelDerivativeOrder(const EventCancelDerivativeOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventCancelDerivativeOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.limit_order_){nullptr}
    , decltype(_impl_.market_order_cancel_){nullptr}
    , decltype(_impl_.islimitcancel_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.limit_order_ = new ::injective::exchange::v1beta1::DerivativeLimitOrder(*from._impl_.limit_order_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.market_order_cancel_ = new ::injective::exchange::v1beta1::DerivativeMarketOrderCancel(*from._impl_.market_order_cancel_);
  }
  _this->_impl_.islimitcancel_ = from._impl_.islimitcancel_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventCancelDerivativeOrder)
}

inline void EventCancelDerivativeOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.limit_order_){nullptr}
    , decltype(_impl_.market_order_cancel_){nullptr}
    , decltype(_impl_.islimitcancel_) { false }

  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventCancelDerivativeOrder::~EventCancelDerivativeOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventCancelDerivativeOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventCancelDerivativeOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.limit_order_;
  if (this != internal_default_instance()) delete _impl_.market_order_cancel_;
}

void EventCancelDerivativeOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventCancelDerivativeOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventCancelDerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.limit_order_ != nullptr);
      _impl_.limit_order_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.market_order_cancel_ != nullptr);
      _impl_.market_order_cancel_->Clear();
    }
  }
  _impl_.islimitcancel_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventCancelDerivativeOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventCancelDerivativeOrder.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.islimitcancel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4 [json_name = "marketOrderCancel", (.gogoproto.nullable) = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_order_cancel(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventCancelDerivativeOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventCancelDerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventCancelDerivativeOrder.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
  if (this->_internal_islimitcancel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_islimitcancel(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::limit_order(this),
        _Internal::limit_order(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4 [json_name = "marketOrderCancel", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::market_order_cancel(this),
        _Internal::market_order_cancel(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventCancelDerivativeOrder)
  return target;
}

::size_t EventCancelDerivativeOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventCancelDerivativeOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.limit_order_);
    }

    // .injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4 [json_name = "marketOrderCancel", (.gogoproto.nullable) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.market_order_cancel_);
    }

  }
  // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
  if (this->_internal_islimitcancel() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventCancelDerivativeOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventCancelDerivativeOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventCancelDerivativeOrder::GetClassData() const { return &_class_data_; }


void EventCancelDerivativeOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventCancelDerivativeOrder*>(&to_msg);
  auto& from = static_cast<const EventCancelDerivativeOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventCancelDerivativeOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_limit_order()->::injective::exchange::v1beta1::DerivativeLimitOrder::MergeFrom(
          from._internal_limit_order());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_market_order_cancel()->::injective::exchange::v1beta1::DerivativeMarketOrderCancel::MergeFrom(
          from._internal_market_order_cancel());
    }
  }
  if (from._internal_islimitcancel() != 0) {
    _this->_internal_set_islimitcancel(from._internal_islimitcancel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventCancelDerivativeOrder::CopyFrom(const EventCancelDerivativeOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventCancelDerivativeOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventCancelDerivativeOrder::IsInitialized() const {
  return true;
}

void EventCancelDerivativeOrder::InternalSwap(EventCancelDerivativeOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventCancelDerivativeOrder, _impl_.islimitcancel_)
      + sizeof(EventCancelDerivativeOrder::_impl_.islimitcancel_)
      - PROTOBUF_FIELD_OFFSET(EventCancelDerivativeOrder, _impl_.limit_order_)>(
          reinterpret_cast<char*>(&_impl_.limit_order_),
          reinterpret_cast<char*>(&other->_impl_.limit_order_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventCancelDerivativeOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[20]);
}
// ===================================================================

class EventFeeDiscountSchedule::_Internal {
 public:
  using HasBits = decltype(std::declval<EventFeeDiscountSchedule>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventFeeDiscountSchedule, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::FeeDiscountSchedule& schedule(const EventFeeDiscountSchedule* msg);
  static void set_has_schedule(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::FeeDiscountSchedule&
EventFeeDiscountSchedule::_Internal::schedule(const EventFeeDiscountSchedule* msg) {
  return *msg->_impl_.schedule_;
}
void EventFeeDiscountSchedule::clear_schedule() {
  if (_impl_.schedule_ != nullptr) _impl_.schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventFeeDiscountSchedule::EventFeeDiscountSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventFeeDiscountSchedule)
}
EventFeeDiscountSchedule::EventFeeDiscountSchedule(const EventFeeDiscountSchedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventFeeDiscountSchedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.schedule_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.schedule_ = new ::injective::exchange::v1beta1::FeeDiscountSchedule(*from._impl_.schedule_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventFeeDiscountSchedule)
}

inline void EventFeeDiscountSchedule::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.schedule_){nullptr}
  };
}

EventFeeDiscountSchedule::~EventFeeDiscountSchedule() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventFeeDiscountSchedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventFeeDiscountSchedule::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.schedule_;
}

void EventFeeDiscountSchedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventFeeDiscountSchedule::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventFeeDiscountSchedule)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.schedule_ != nullptr);
    _impl_.schedule_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventFeeDiscountSchedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1 [json_name = "schedule"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_schedule(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventFeeDiscountSchedule::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventFeeDiscountSchedule)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1 [json_name = "schedule"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::schedule(this),
        _Internal::schedule(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventFeeDiscountSchedule)
  return target;
}

::size_t EventFeeDiscountSchedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventFeeDiscountSchedule)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1 [json_name = "schedule"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.schedule_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventFeeDiscountSchedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventFeeDiscountSchedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventFeeDiscountSchedule::GetClassData() const { return &_class_data_; }


void EventFeeDiscountSchedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventFeeDiscountSchedule*>(&to_msg);
  auto& from = static_cast<const EventFeeDiscountSchedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventFeeDiscountSchedule)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_schedule()->::injective::exchange::v1beta1::FeeDiscountSchedule::MergeFrom(
        from._internal_schedule());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventFeeDiscountSchedule::CopyFrom(const EventFeeDiscountSchedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventFeeDiscountSchedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventFeeDiscountSchedule::IsInitialized() const {
  return true;
}

void EventFeeDiscountSchedule::InternalSwap(EventFeeDiscountSchedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.schedule_, other->_impl_.schedule_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventFeeDiscountSchedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[21]);
}
// ===================================================================

class EventTradingRewardCampaignUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<EventTradingRewardCampaignUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventTradingRewardCampaignUpdate, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& campaign_info(const EventTradingRewardCampaignUpdate* msg);
  static void set_has_campaign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::TradingRewardCampaignInfo&
EventTradingRewardCampaignUpdate::_Internal::campaign_info(const EventTradingRewardCampaignUpdate* msg) {
  return *msg->_impl_.campaign_info_;
}
void EventTradingRewardCampaignUpdate::clear_campaign_info() {
  if (_impl_.campaign_info_ != nullptr) _impl_.campaign_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EventTradingRewardCampaignUpdate::clear_campaign_reward_pools() {
  _internal_mutable_campaign_reward_pools()->Clear();
}
EventTradingRewardCampaignUpdate::EventTradingRewardCampaignUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
}
EventTradingRewardCampaignUpdate::EventTradingRewardCampaignUpdate(const EventTradingRewardCampaignUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventTradingRewardCampaignUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.campaign_reward_pools_){from._impl_.campaign_reward_pools_}
    , decltype(_impl_.campaign_info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.campaign_info_ = new ::injective::exchange::v1beta1::TradingRewardCampaignInfo(*from._impl_.campaign_info_);
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
}

inline void EventTradingRewardCampaignUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.campaign_reward_pools_){arena}
    , decltype(_impl_.campaign_info_){nullptr}
  };
}

EventTradingRewardCampaignUpdate::~EventTradingRewardCampaignUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventTradingRewardCampaignUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_campaign_reward_pools()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.campaign_info_;
}

void EventTradingRewardCampaignUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventTradingRewardCampaignUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_campaign_reward_pools()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.campaign_info_ != nullptr);
    _impl_.campaign_info_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventTradingRewardCampaignUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1 [json_name = "campaignInfo"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_campaign_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2 [json_name = "campaignRewardPools"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_campaign_reward_pools(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventTradingRewardCampaignUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1 [json_name = "campaignInfo"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::campaign_info(this),
        _Internal::campaign_info(this).GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2 [json_name = "campaignRewardPools"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_campaign_reward_pools_size()); i < n; i++) {
    const auto& repfield = this->_internal_campaign_reward_pools(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
  return target;
}

::size_t EventTradingRewardCampaignUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2 [json_name = "campaignRewardPools"];
  total_size += 1UL * this->_internal_campaign_reward_pools_size();
  for (const auto& msg : this->_internal_campaign_reward_pools()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1 [json_name = "campaignInfo"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.campaign_info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventTradingRewardCampaignUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventTradingRewardCampaignUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventTradingRewardCampaignUpdate::GetClassData() const { return &_class_data_; }


void EventTradingRewardCampaignUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventTradingRewardCampaignUpdate*>(&to_msg);
  auto& from = static_cast<const EventTradingRewardCampaignUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_campaign_reward_pools()->MergeFrom(from._internal_campaign_reward_pools());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_campaign_info()->::injective::exchange::v1beta1::TradingRewardCampaignInfo::MergeFrom(
        from._internal_campaign_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventTradingRewardCampaignUpdate::CopyFrom(const EventTradingRewardCampaignUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventTradingRewardCampaignUpdate::IsInitialized() const {
  return true;
}

void EventTradingRewardCampaignUpdate::InternalSwap(EventTradingRewardCampaignUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_campaign_reward_pools()->InternalSwap(other->_internal_mutable_campaign_reward_pools());
  swap(_impl_.campaign_info_, other->_impl_.campaign_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventTradingRewardCampaignUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[22]);
}
// ===================================================================

class EventTradingRewardDistribution::_Internal {
 public:
};

void EventTradingRewardDistribution::clear_account_rewards() {
  _internal_mutable_account_rewards()->Clear();
}
EventTradingRewardDistribution::EventTradingRewardDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventTradingRewardDistribution)
}
EventTradingRewardDistribution::EventTradingRewardDistribution(const EventTradingRewardDistribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventTradingRewardDistribution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_rewards_){from._impl_.account_rewards_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventTradingRewardDistribution)
}

inline void EventTradingRewardDistribution::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_rewards_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventTradingRewardDistribution::~EventTradingRewardDistribution() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventTradingRewardDistribution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventTradingRewardDistribution::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_account_rewards()->~RepeatedPtrField();
}

void EventTradingRewardDistribution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventTradingRewardDistribution::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventTradingRewardDistribution)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_account_rewards()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventTradingRewardDistribution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective.exchange.v1beta1.AccountRewards account_rewards = 1 [json_name = "accountRewards"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_account_rewards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventTradingRewardDistribution::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventTradingRewardDistribution)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.AccountRewards account_rewards = 1 [json_name = "accountRewards"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_account_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_account_rewards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventTradingRewardDistribution)
  return target;
}

::size_t EventTradingRewardDistribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventTradingRewardDistribution)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.AccountRewards account_rewards = 1 [json_name = "accountRewards"];
  total_size += 1UL * this->_internal_account_rewards_size();
  for (const auto& msg : this->_internal_account_rewards()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventTradingRewardDistribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventTradingRewardDistribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventTradingRewardDistribution::GetClassData() const { return &_class_data_; }


void EventTradingRewardDistribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventTradingRewardDistribution*>(&to_msg);
  auto& from = static_cast<const EventTradingRewardDistribution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventTradingRewardDistribution)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_account_rewards()->MergeFrom(from._internal_account_rewards());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventTradingRewardDistribution::CopyFrom(const EventTradingRewardDistribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventTradingRewardDistribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventTradingRewardDistribution::IsInitialized() const {
  return true;
}

void EventTradingRewardDistribution::InternalSwap(EventTradingRewardDistribution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_account_rewards()->InternalSwap(other->_internal_mutable_account_rewards());
}

::PROTOBUF_NAMESPACE_ID::Metadata EventTradingRewardDistribution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[23]);
}
// ===================================================================

class EventNewConditionalDerivativeOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<EventNewConditionalDerivativeOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventNewConditionalDerivativeOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::DerivativeOrder& order(const EventNewConditionalDerivativeOrder* msg);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::DerivativeOrder&
EventNewConditionalDerivativeOrder::_Internal::order(const EventNewConditionalDerivativeOrder* msg) {
  return *msg->_impl_.order_;
}
void EventNewConditionalDerivativeOrder::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventNewConditionalDerivativeOrder::EventNewConditionalDerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
}
EventNewConditionalDerivativeOrder::EventNewConditionalDerivativeOrder(const EventNewConditionalDerivativeOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventNewConditionalDerivativeOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.hash_) {}

    , decltype(_impl_.order_){nullptr}
    , decltype(_impl_.is_market_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash().empty()) {
    _this->_impl_.hash_.Set(from._internal_hash(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.order_ = new ::injective::exchange::v1beta1::DerivativeOrder(*from._impl_.order_);
  }
  _this->_impl_.is_market_ = from._impl_.is_market_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
}

inline void EventNewConditionalDerivativeOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.hash_) {}

    , decltype(_impl_.order_){nullptr}
    , decltype(_impl_.is_market_) { false }

  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventNewConditionalDerivativeOrder::~EventNewConditionalDerivativeOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventNewConditionalDerivativeOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.order_;
}

void EventNewConditionalDerivativeOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventNewConditionalDerivativeOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.hash_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.order_ != nullptr);
    _impl_.order_->Clear();
  }
  _impl_.is_market_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventNewConditionalDerivativeOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes hash = 3 [json_name = "hash"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_market = 4 [json_name = "isMarket"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.is_market_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventNewConditionalDerivativeOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::order(this),
        _Internal::order(this).GetCachedSize(), target, stream);
  }

  // bytes hash = 3 [json_name = "hash"];
  if (!this->_internal_hash().empty()) {
    const std::string& _s = this->_internal_hash();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // bool is_market = 4 [json_name = "isMarket"];
  if (this->_internal_is_market() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_is_market(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
  return target;
}

::size_t EventNewConditionalDerivativeOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // bytes hash = 3 [json_name = "hash"];
  if (!this->_internal_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_hash());
  }

  // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.order_);
  }

  // bool is_market = 4 [json_name = "isMarket"];
  if (this->_internal_is_market() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventNewConditionalDerivativeOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventNewConditionalDerivativeOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventNewConditionalDerivativeOrder::GetClassData() const { return &_class_data_; }


void EventNewConditionalDerivativeOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventNewConditionalDerivativeOrder*>(&to_msg);
  auto& from = static_cast<const EventNewConditionalDerivativeOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_hash().empty()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_order()->::injective::exchange::v1beta1::DerivativeOrder::MergeFrom(
        from._internal_order());
  }
  if (from._internal_is_market() != 0) {
    _this->_internal_set_is_market(from._internal_is_market());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventNewConditionalDerivativeOrder::CopyFrom(const EventNewConditionalDerivativeOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventNewConditionalDerivativeOrder::IsInitialized() const {
  return true;
}

void EventNewConditionalDerivativeOrder::InternalSwap(EventNewConditionalDerivativeOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_, lhs_arena,
                                       &other->_impl_.hash_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventNewConditionalDerivativeOrder, _impl_.is_market_)
      + sizeof(EventNewConditionalDerivativeOrder::_impl_.is_market_)
      - PROTOBUF_FIELD_OFFSET(EventNewConditionalDerivativeOrder, _impl_.order_)>(
          reinterpret_cast<char*>(&_impl_.order_),
          reinterpret_cast<char*>(&other->_impl_.order_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventNewConditionalDerivativeOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[24]);
}
// ===================================================================

class EventCancelConditionalDerivativeOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<EventCancelConditionalDerivativeOrder>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EventCancelConditionalDerivativeOrder, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::DerivativeLimitOrder& limit_order(const EventCancelConditionalDerivativeOrder* msg);
  static void set_has_limit_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::injective::exchange::v1beta1::DerivativeMarketOrder& market_order(const EventCancelConditionalDerivativeOrder* msg);
  static void set_has_market_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::injective::exchange::v1beta1::DerivativeLimitOrder&
EventCancelConditionalDerivativeOrder::_Internal::limit_order(const EventCancelConditionalDerivativeOrder* msg) {
  return *msg->_impl_.limit_order_;
}
const ::injective::exchange::v1beta1::DerivativeMarketOrder&
EventCancelConditionalDerivativeOrder::_Internal::market_order(const EventCancelConditionalDerivativeOrder* msg) {
  return *msg->_impl_.market_order_;
}
void EventCancelConditionalDerivativeOrder::clear_limit_order() {
  if (_impl_.limit_order_ != nullptr) _impl_.limit_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EventCancelConditionalDerivativeOrder::clear_market_order() {
  if (_impl_.market_order_ != nullptr) _impl_.market_order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
EventCancelConditionalDerivativeOrder::EventCancelConditionalDerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
}
EventCancelConditionalDerivativeOrder::EventCancelConditionalDerivativeOrder(const EventCancelConditionalDerivativeOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventCancelConditionalDerivativeOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.limit_order_){nullptr}
    , decltype(_impl_.market_order_){nullptr}
    , decltype(_impl_.islimitcancel_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.limit_order_ = new ::injective::exchange::v1beta1::DerivativeLimitOrder(*from._impl_.limit_order_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.market_order_ = new ::injective::exchange::v1beta1::DerivativeMarketOrder(*from._impl_.market_order_);
  }
  _this->_impl_.islimitcancel_ = from._impl_.islimitcancel_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
}

inline void EventCancelConditionalDerivativeOrder::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.limit_order_){nullptr}
    , decltype(_impl_.market_order_){nullptr}
    , decltype(_impl_.islimitcancel_) { false }

  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventCancelConditionalDerivativeOrder::~EventCancelConditionalDerivativeOrder() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventCancelConditionalDerivativeOrder::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.limit_order_;
  if (this != internal_default_instance()) delete _impl_.market_order_;
}

void EventCancelConditionalDerivativeOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventCancelConditionalDerivativeOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.limit_order_ != nullptr);
      _impl_.limit_order_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.market_order_ != nullptr);
      _impl_.market_order_->Clear();
    }
  }
  _impl_.islimitcancel_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventCancelConditionalDerivativeOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.islimitcancel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4 [json_name = "marketOrder", (.gogoproto.nullable) = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_market_order(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventCancelConditionalDerivativeOrder::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
  if (this->_internal_islimitcancel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_islimitcancel(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::limit_order(this),
        _Internal::limit_order(this).GetCachedSize(), target, stream);
  }

  // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4 [json_name = "marketOrder", (.gogoproto.nullable) = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::market_order(this),
        _Internal::market_order(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
  return target;
}

::size_t EventCancelConditionalDerivativeOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.limit_order_);
    }

    // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4 [json_name = "marketOrder", (.gogoproto.nullable) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.market_order_);
    }

  }
  // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
  if (this->_internal_islimitcancel() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventCancelConditionalDerivativeOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventCancelConditionalDerivativeOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventCancelConditionalDerivativeOrder::GetClassData() const { return &_class_data_; }


void EventCancelConditionalDerivativeOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventCancelConditionalDerivativeOrder*>(&to_msg);
  auto& from = static_cast<const EventCancelConditionalDerivativeOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_limit_order()->::injective::exchange::v1beta1::DerivativeLimitOrder::MergeFrom(
          from._internal_limit_order());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_market_order()->::injective::exchange::v1beta1::DerivativeMarketOrder::MergeFrom(
          from._internal_market_order());
    }
  }
  if (from._internal_islimitcancel() != 0) {
    _this->_internal_set_islimitcancel(from._internal_islimitcancel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventCancelConditionalDerivativeOrder::CopyFrom(const EventCancelConditionalDerivativeOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventCancelConditionalDerivativeOrder::IsInitialized() const {
  return true;
}

void EventCancelConditionalDerivativeOrder::InternalSwap(EventCancelConditionalDerivativeOrder* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventCancelConditionalDerivativeOrder, _impl_.islimitcancel_)
      + sizeof(EventCancelConditionalDerivativeOrder::_impl_.islimitcancel_)
      - PROTOBUF_FIELD_OFFSET(EventCancelConditionalDerivativeOrder, _impl_.limit_order_)>(
          reinterpret_cast<char*>(&_impl_.limit_order_),
          reinterpret_cast<char*>(&other->_impl_.limit_order_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventCancelConditionalDerivativeOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[25]);
}
// ===================================================================

class EventConditionalDerivativeOrderTrigger::_Internal {
 public:
};

EventConditionalDerivativeOrderTrigger::EventConditionalDerivativeOrderTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
}
EventConditionalDerivativeOrderTrigger::EventConditionalDerivativeOrderTrigger(const EventConditionalDerivativeOrderTrigger& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventConditionalDerivativeOrderTrigger* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.triggered_order_hash_) {}

    , decltype(_impl_.placed_order_hash_) {}

    , decltype(_impl_.islimittrigger_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.triggered_order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.triggered_order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_triggered_order_hash().empty()) {
    _this->_impl_.triggered_order_hash_.Set(from._internal_triggered_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.placed_order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.placed_order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_placed_order_hash().empty()) {
    _this->_impl_.placed_order_hash_.Set(from._internal_placed_order_hash(), _this->GetArenaForAllocation());
  }
  _this->_impl_.islimittrigger_ = from._impl_.islimittrigger_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
}

inline void EventConditionalDerivativeOrderTrigger::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_id_) {}

    , decltype(_impl_.triggered_order_hash_) {}

    , decltype(_impl_.placed_order_hash_) {}

    , decltype(_impl_.islimittrigger_) { false }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.triggered_order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.triggered_order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.placed_order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.placed_order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventConditionalDerivativeOrderTrigger::~EventConditionalDerivativeOrderTrigger() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventConditionalDerivativeOrderTrigger::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.market_id_.Destroy();
  _impl_.triggered_order_hash_.Destroy();
  _impl_.placed_order_hash_.Destroy();
}

void EventConditionalDerivativeOrderTrigger::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventConditionalDerivativeOrderTrigger::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.market_id_.ClearToEmpty();
  _impl_.triggered_order_hash_.ClearToEmpty();
  _impl_.placed_order_hash_.ClearToEmpty();
  _impl_.islimittrigger_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventConditionalDerivativeOrderTrigger::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool isLimitTrigger = 2 [json_name = "isLimitTrigger"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.islimittrigger_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes triggered_order_hash = 3 [json_name = "triggeredOrderHash"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_triggered_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes placed_order_hash = 4 [json_name = "placedOrderHash"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_placed_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventConditionalDerivativeOrderTrigger::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // bool isLimitTrigger = 2 [json_name = "isLimitTrigger"];
  if (this->_internal_islimittrigger() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_islimittrigger(), target);
  }

  // bytes triggered_order_hash = 3 [json_name = "triggeredOrderHash"];
  if (!this->_internal_triggered_order_hash().empty()) {
    const std::string& _s = this->_internal_triggered_order_hash();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // bytes placed_order_hash = 4 [json_name = "placedOrderHash"];
  if (!this->_internal_placed_order_hash().empty()) {
    const std::string& _s = this->_internal_placed_order_hash();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
  return target;
}

::size_t EventConditionalDerivativeOrderTrigger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_market_id());
  }

  // bytes triggered_order_hash = 3 [json_name = "triggeredOrderHash"];
  if (!this->_internal_triggered_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_triggered_order_hash());
  }

  // bytes placed_order_hash = 4 [json_name = "placedOrderHash"];
  if (!this->_internal_placed_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_placed_order_hash());
  }

  // bool isLimitTrigger = 2 [json_name = "isLimitTrigger"];
  if (this->_internal_islimittrigger() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventConditionalDerivativeOrderTrigger::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventConditionalDerivativeOrderTrigger::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventConditionalDerivativeOrderTrigger::GetClassData() const { return &_class_data_; }


void EventConditionalDerivativeOrderTrigger::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventConditionalDerivativeOrderTrigger*>(&to_msg);
  auto& from = static_cast<const EventConditionalDerivativeOrderTrigger&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_triggered_order_hash().empty()) {
    _this->_internal_set_triggered_order_hash(from._internal_triggered_order_hash());
  }
  if (!from._internal_placed_order_hash().empty()) {
    _this->_internal_set_placed_order_hash(from._internal_placed_order_hash());
  }
  if (from._internal_islimittrigger() != 0) {
    _this->_internal_set_islimittrigger(from._internal_islimittrigger());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventConditionalDerivativeOrderTrigger::CopyFrom(const EventConditionalDerivativeOrderTrigger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventConditionalDerivativeOrderTrigger::IsInitialized() const {
  return true;
}

void EventConditionalDerivativeOrderTrigger::InternalSwap(EventConditionalDerivativeOrderTrigger* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.triggered_order_hash_, lhs_arena,
                                       &other->_impl_.triggered_order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.placed_order_hash_, lhs_arena,
                                       &other->_impl_.placed_order_hash_, rhs_arena);

  swap(_impl_.islimittrigger_, other->_impl_.islimittrigger_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventConditionalDerivativeOrderTrigger::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[26]);
}
// ===================================================================

class EventOrderFail::_Internal {
 public:
};

EventOrderFail::EventOrderFail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventOrderFail)
}
EventOrderFail::EventOrderFail(const EventOrderFail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventOrderFail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){from._impl_.hashes_}
    , decltype(_impl_.flags_) { from._impl_.flags_ }
    ,/* _impl_._flags_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.account_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account().empty()) {
    _this->_impl_.account_.Set(from._internal_account(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventOrderFail)
}

inline void EventOrderFail::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){arena}
    , decltype(_impl_.flags_) { arena }
    ,/* _impl_._flags_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.account_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventOrderFail::~EventOrderFail() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventOrderFail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventOrderFail::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_hashes()->~RepeatedPtrField();
  _impl_.flags_.~RepeatedField();
  _impl_.account_.Destroy();
}

void EventOrderFail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventOrderFail::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventOrderFail)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_hashes()->Clear();
  _internal_mutable_flags()->Clear();
  _impl_.account_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventOrderFail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes account = 1 [json_name = "account"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated bytes hashes = 2 [json_name = "hashes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hashes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated uint32 flags = 3 [json_name = "flags"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_flags(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 24) {
          _internal_add_flags(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventOrderFail::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventOrderFail)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    const std::string& _s = this->_internal_account();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // repeated bytes hashes = 2 [json_name = "hashes"];
  for (int i = 0, n = this->_internal_hashes_size(); i < n; ++i) {
    const auto& s = this->_internal_hashes(i);
    target = stream->WriteBytes(2, s, target);
  }

  // repeated uint32 flags = 3 [json_name = "flags"];
  {
    int byte_size = _impl_._flags_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(3, _internal_flags(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventOrderFail)
  return target;
}

::size_t EventOrderFail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventOrderFail)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hashes = 2 [json_name = "hashes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_hashes().size());
  for (int i = 0, n = _internal_hashes().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        _internal_hashes().Get(i));
  }

  // repeated uint32 flags = 3 [json_name = "flags"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_flags())
    ;
    _impl_._flags_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // bytes account = 1 [json_name = "account"];
  if (!this->_internal_account().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_account());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventOrderFail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventOrderFail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventOrderFail::GetClassData() const { return &_class_data_; }


void EventOrderFail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventOrderFail*>(&to_msg);
  auto& from = static_cast<const EventOrderFail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventOrderFail)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_hashes()->MergeFrom(from._internal_hashes());
  _this->_impl_.flags_.MergeFrom(from._impl_.flags_);
  if (!from._internal_account().empty()) {
    _this->_internal_set_account(from._internal_account());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventOrderFail::CopyFrom(const EventOrderFail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventOrderFail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventOrderFail::IsInitialized() const {
  return true;
}

void EventOrderFail::InternalSwap(EventOrderFail* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_hashes()->InternalSwap(
      other->_internal_mutable_hashes());
  _impl_.flags_.InternalSwap(&other->_impl_.flags_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_, lhs_arena,
                                       &other->_impl_.account_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventOrderFail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[27]);
}
// ===================================================================

class EventAtomicMarketOrderFeeMultipliersUpdated::_Internal {
 public:
};

void EventAtomicMarketOrderFeeMultipliersUpdated::clear_market_fee_multipliers() {
  _internal_mutable_market_fee_multipliers()->Clear();
}
EventAtomicMarketOrderFeeMultipliersUpdated::EventAtomicMarketOrderFeeMultipliersUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
}
EventAtomicMarketOrderFeeMultipliersUpdated::EventAtomicMarketOrderFeeMultipliersUpdated(const EventAtomicMarketOrderFeeMultipliersUpdated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventAtomicMarketOrderFeeMultipliersUpdated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.market_fee_multipliers_){from._impl_.market_fee_multipliers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
}

inline void EventAtomicMarketOrderFeeMultipliersUpdated::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.market_fee_multipliers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventAtomicMarketOrderFeeMultipliersUpdated::~EventAtomicMarketOrderFeeMultipliersUpdated() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventAtomicMarketOrderFeeMultipliersUpdated::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_market_fee_multipliers()->~RepeatedPtrField();
}

void EventAtomicMarketOrderFeeMultipliersUpdated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventAtomicMarketOrderFeeMultipliersUpdated::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_market_fee_multipliers()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventAtomicMarketOrderFeeMultipliersUpdated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1 [json_name = "marketFeeMultipliers"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_market_fee_multipliers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventAtomicMarketOrderFeeMultipliersUpdated::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1 [json_name = "marketFeeMultipliers"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_market_fee_multipliers_size()); i < n; i++) {
    const auto& repfield = this->_internal_market_fee_multipliers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
  return target;
}

::size_t EventAtomicMarketOrderFeeMultipliersUpdated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1 [json_name = "marketFeeMultipliers"];
  total_size += 1UL * this->_internal_market_fee_multipliers_size();
  for (const auto& msg : this->_internal_market_fee_multipliers()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventAtomicMarketOrderFeeMultipliersUpdated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventAtomicMarketOrderFeeMultipliersUpdated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventAtomicMarketOrderFeeMultipliersUpdated::GetClassData() const { return &_class_data_; }


void EventAtomicMarketOrderFeeMultipliersUpdated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventAtomicMarketOrderFeeMultipliersUpdated*>(&to_msg);
  auto& from = static_cast<const EventAtomicMarketOrderFeeMultipliersUpdated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_market_fee_multipliers()->MergeFrom(from._internal_market_fee_multipliers());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventAtomicMarketOrderFeeMultipliersUpdated::CopyFrom(const EventAtomicMarketOrderFeeMultipliersUpdated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventAtomicMarketOrderFeeMultipliersUpdated::IsInitialized() const {
  return true;
}

void EventAtomicMarketOrderFeeMultipliersUpdated::InternalSwap(EventAtomicMarketOrderFeeMultipliersUpdated* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_market_fee_multipliers()->InternalSwap(other->_internal_mutable_market_fee_multipliers());
}

::PROTOBUF_NAMESPACE_ID::Metadata EventAtomicMarketOrderFeeMultipliersUpdated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[28]);
}
// ===================================================================

class EventOrderbookUpdate::_Internal {
 public:
};

EventOrderbookUpdate::EventOrderbookUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.EventOrderbookUpdate)
}
EventOrderbookUpdate::EventOrderbookUpdate(const EventOrderbookUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventOrderbookUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.spot_updates_){from._impl_.spot_updates_}
    , decltype(_impl_.derivative_updates_){from._impl_.derivative_updates_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.EventOrderbookUpdate)
}

inline void EventOrderbookUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.spot_updates_){arena}
    , decltype(_impl_.derivative_updates_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EventOrderbookUpdate::~EventOrderbookUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.EventOrderbookUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventOrderbookUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_spot_updates()->~RepeatedPtrField();
  _internal_mutable_derivative_updates()->~RepeatedPtrField();
}

void EventOrderbookUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventOrderbookUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.EventOrderbookUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_spot_updates()->Clear();
  _internal_mutable_derivative_updates()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventOrderbookUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1 [json_name = "spotUpdates"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_spot_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2 [json_name = "derivativeUpdates"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_derivative_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EventOrderbookUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.EventOrderbookUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1 [json_name = "spotUpdates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_spot_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_spot_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2 [json_name = "derivativeUpdates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_derivative_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_derivative_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.EventOrderbookUpdate)
  return target;
}

::size_t EventOrderbookUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.EventOrderbookUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1 [json_name = "spotUpdates"];
  total_size += 1UL * this->_internal_spot_updates_size();
  for (const auto& msg : this->_internal_spot_updates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2 [json_name = "derivativeUpdates"];
  total_size += 1UL * this->_internal_derivative_updates_size();
  for (const auto& msg : this->_internal_derivative_updates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventOrderbookUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventOrderbookUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventOrderbookUpdate::GetClassData() const { return &_class_data_; }


void EventOrderbookUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventOrderbookUpdate*>(&to_msg);
  auto& from = static_cast<const EventOrderbookUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.EventOrderbookUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_spot_updates()->MergeFrom(from._internal_spot_updates());
  _this->_internal_mutable_derivative_updates()->MergeFrom(from._internal_derivative_updates());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventOrderbookUpdate::CopyFrom(const EventOrderbookUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.EventOrderbookUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventOrderbookUpdate::IsInitialized() const {
  return true;
}

void EventOrderbookUpdate::InternalSwap(EventOrderbookUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_spot_updates()->InternalSwap(other->_internal_mutable_spot_updates());
  _internal_mutable_derivative_updates()->InternalSwap(other->_internal_mutable_derivative_updates());
}

::PROTOBUF_NAMESPACE_ID::Metadata EventOrderbookUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[29]);
}
// ===================================================================

class OrderbookUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<OrderbookUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OrderbookUpdate, _impl_._has_bits_);
  static const ::injective::exchange::v1beta1::Orderbook& orderbook(const OrderbookUpdate* msg);
  static void set_has_orderbook(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective::exchange::v1beta1::Orderbook&
OrderbookUpdate::_Internal::orderbook(const OrderbookUpdate* msg) {
  return *msg->_impl_.orderbook_;
}
OrderbookUpdate::OrderbookUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.OrderbookUpdate)
}
OrderbookUpdate::OrderbookUpdate(const OrderbookUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderbookUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orderbook_){nullptr}
    , decltype(_impl_.seq_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.orderbook_ = new ::injective::exchange::v1beta1::Orderbook(*from._impl_.orderbook_);
  }
  _this->_impl_.seq_ = from._impl_.seq_;
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.OrderbookUpdate)
}

inline void OrderbookUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.orderbook_){nullptr}
    , decltype(_impl_.seq_) { ::uint64_t{0u} }

  };
}

OrderbookUpdate::~OrderbookUpdate() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.OrderbookUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderbookUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.orderbook_;
}

void OrderbookUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderbookUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.OrderbookUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.orderbook_ != nullptr);
    _impl_.orderbook_->Clear();
  }
  _impl_.seq_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderbookUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 seq = 1 [json_name = "seq"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective.exchange.v1beta1.Orderbook orderbook = 2 [json_name = "orderbook"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orderbook(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderbookUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.OrderbookUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 seq = 1 [json_name = "seq"];
  if (this->_internal_seq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_seq(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective.exchange.v1beta1.Orderbook orderbook = 2 [json_name = "orderbook"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::orderbook(this),
        _Internal::orderbook(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.OrderbookUpdate)
  return target;
}

::size_t OrderbookUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.OrderbookUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective.exchange.v1beta1.Orderbook orderbook = 2 [json_name = "orderbook"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orderbook_);
  }

  // uint64 seq = 1 [json_name = "seq"];
  if (this->_internal_seq() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_seq());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderbookUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderbookUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderbookUpdate::GetClassData() const { return &_class_data_; }


void OrderbookUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderbookUpdate*>(&to_msg);
  auto& from = static_cast<const OrderbookUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.OrderbookUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_orderbook()->::injective::exchange::v1beta1::Orderbook::MergeFrom(
        from._internal_orderbook());
  }
  if (from._internal_seq() != 0) {
    _this->_internal_set_seq(from._internal_seq());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderbookUpdate::CopyFrom(const OrderbookUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.OrderbookUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderbookUpdate::IsInitialized() const {
  return true;
}

void OrderbookUpdate::InternalSwap(OrderbookUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OrderbookUpdate, _impl_.seq_)
      + sizeof(OrderbookUpdate::_impl_.seq_)
      - PROTOBUF_FIELD_OFFSET(OrderbookUpdate, _impl_.orderbook_)>(
          reinterpret_cast<char*>(&_impl_.orderbook_),
          reinterpret_cast<char*>(&other->_impl_.orderbook_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderbookUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[30]);
}
// ===================================================================

class Orderbook::_Internal {
 public:
};

void Orderbook::clear_buy_levels() {
  _internal_mutable_buy_levels()->Clear();
}
void Orderbook::clear_sell_levels() {
  _internal_mutable_sell_levels()->Clear();
}
Orderbook::Orderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective.exchange.v1beta1.Orderbook)
}
Orderbook::Orderbook(const Orderbook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Orderbook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buy_levels_){from._impl_.buy_levels_}
    , decltype(_impl_.sell_levels_){from._impl_.sell_levels_}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective.exchange.v1beta1.Orderbook)
}

inline void Orderbook::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.buy_levels_){arena}
    , decltype(_impl_.sell_levels_){arena}
    , decltype(_impl_.market_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Orderbook::~Orderbook() {
  // @@protoc_insertion_point(destructor:injective.exchange.v1beta1.Orderbook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Orderbook::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_buy_levels()->~RepeatedPtrField();
  _internal_mutable_sell_levels()->~RepeatedPtrField();
  _impl_.market_id_.Destroy();
}

void Orderbook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Orderbook::Clear() {
// @@protoc_insertion_point(message_clear_start:injective.exchange.v1beta1.Orderbook)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_buy_levels()->Clear();
  _internal_mutable_sell_levels()->Clear();
  _impl_.market_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Orderbook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes market_id = 1 [json_name = "marketId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.Level buy_levels = 2 [json_name = "buyLevels"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buy_levels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective.exchange.v1beta1.Level sell_levels = 3 [json_name = "sellLevels"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sell_levels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Orderbook::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective.exchange.v1beta1.Orderbook)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // repeated .injective.exchange.v1beta1.Level buy_levels = 2 [json_name = "buyLevels"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buy_levels_size()); i < n; i++) {
    const auto& repfield = this->_internal_buy_levels(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective.exchange.v1beta1.Level sell_levels = 3 [json_name = "sellLevels"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sell_levels_size()); i < n; i++) {
    const auto& repfield = this->_internal_sell_levels(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective.exchange.v1beta1.Orderbook)
  return target;
}

::size_t Orderbook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective.exchange.v1beta1.Orderbook)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective.exchange.v1beta1.Level buy_levels = 2 [json_name = "buyLevels"];
  total_size += 1UL * this->_internal_buy_levels_size();
  for (const auto& msg : this->_internal_buy_levels()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective.exchange.v1beta1.Level sell_levels = 3 [json_name = "sellLevels"];
  total_size += 1UL * this->_internal_sell_levels_size();
  for (const auto& msg : this->_internal_sell_levels()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes market_id = 1 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_market_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Orderbook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Orderbook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Orderbook::GetClassData() const { return &_class_data_; }


void Orderbook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Orderbook*>(&to_msg);
  auto& from = static_cast<const Orderbook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective.exchange.v1beta1.Orderbook)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_buy_levels()->MergeFrom(from._internal_buy_levels());
  _this->_internal_mutable_sell_levels()->MergeFrom(from._internal_sell_levels());
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Orderbook::CopyFrom(const Orderbook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective.exchange.v1beta1.Orderbook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Orderbook::IsInitialized() const {
  return true;
}

void Orderbook::InternalSwap(Orderbook* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_buy_levels()->InternalSwap(other->_internal_mutable_buy_levels());
  _internal_mutable_sell_levels()->InternalSwap(other->_internal_mutable_sell_levels());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Orderbook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_getter, &descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto_once,
      file_level_metadata_injective_2fexchange_2fv1beta1_2fevents_2eproto[31]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventBatchSpotExecution*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventBatchSpotExecution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventBatchSpotExecution >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventBatchDerivativeExecution*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventBatchDerivativeExecution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventBatchDerivativeExecution >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventLostFundsFromLiquidation*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventLostFundsFromLiquidation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventLostFundsFromLiquidation >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventBatchDerivativePosition*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventBatchDerivativePosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventBatchDerivativePosition >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventDerivativeMarketPaused*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventDerivativeMarketPaused >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventDerivativeMarketPaused >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventMarketBeyondBankruptcy*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventMarketBeyondBankruptcy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventMarketBeyondBankruptcy >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventAllPositionsHaircut*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventAllPositionsHaircut >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventAllPositionsHaircut >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventNewSpotOrders*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventNewSpotOrders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventNewSpotOrders >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventNewDerivativeOrders*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventNewDerivativeOrders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventNewDerivativeOrders >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventCancelSpotOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventCancelSpotOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventCancelSpotOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventSpotMarketUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventSpotMarketUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventSpotMarketUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventPerpetualMarketUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventPerpetualMarketUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventPerpetualMarketUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventSubaccountDeposit*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventSubaccountDeposit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventSubaccountDeposit >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventSubaccountWithdraw*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventSubaccountWithdraw >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventSubaccountWithdraw >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventSubaccountBalanceTransfer*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventSubaccountBalanceTransfer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventSubaccountBalanceTransfer >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventBatchDepositUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventBatchDepositUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventBatchDepositUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::DerivativeMarketOrderCancel*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::DerivativeMarketOrderCancel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::DerivativeMarketOrderCancel >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventCancelDerivativeOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventCancelDerivativeOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventCancelDerivativeOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventFeeDiscountSchedule*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventFeeDiscountSchedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventFeeDiscountSchedule >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventTradingRewardDistribution*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventTradingRewardDistribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventTradingRewardDistribution >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventOrderFail*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventOrderFail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventOrderFail >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::EventOrderbookUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::EventOrderbookUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::EventOrderbookUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::OrderbookUpdate*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::OrderbookUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::OrderbookUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::injective::exchange::v1beta1::Orderbook*
Arena::CreateMaybeMessage< ::injective::exchange::v1beta1::Orderbook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective::exchange::v1beta1::Orderbook >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
