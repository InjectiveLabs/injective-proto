// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/exchange/v1beta1/events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fevents_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fevents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "injective/oracle/v1beta1/oracle.pb.h"
#include "injective/exchange/v1beta1/exchange.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2fexchange_2fv1beta1_2fevents_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2fexchange_2fv1beta1_2fevents_2eproto;
namespace injective {
namespace exchange {
namespace v1beta1 {
class DerivativeMarketOrderCancel;
struct DerivativeMarketOrderCancelDefaultTypeInternal;
extern DerivativeMarketOrderCancelDefaultTypeInternal _DerivativeMarketOrderCancel_default_instance_;
class EventAllPositionsHaircut;
struct EventAllPositionsHaircutDefaultTypeInternal;
extern EventAllPositionsHaircutDefaultTypeInternal _EventAllPositionsHaircut_default_instance_;
class EventAtomicMarketOrderFeeMultipliersUpdated;
struct EventAtomicMarketOrderFeeMultipliersUpdatedDefaultTypeInternal;
extern EventAtomicMarketOrderFeeMultipliersUpdatedDefaultTypeInternal _EventAtomicMarketOrderFeeMultipliersUpdated_default_instance_;
class EventBatchDepositUpdate;
struct EventBatchDepositUpdateDefaultTypeInternal;
extern EventBatchDepositUpdateDefaultTypeInternal _EventBatchDepositUpdate_default_instance_;
class EventBatchDerivativeExecution;
struct EventBatchDerivativeExecutionDefaultTypeInternal;
extern EventBatchDerivativeExecutionDefaultTypeInternal _EventBatchDerivativeExecution_default_instance_;
class EventBatchDerivativePosition;
struct EventBatchDerivativePositionDefaultTypeInternal;
extern EventBatchDerivativePositionDefaultTypeInternal _EventBatchDerivativePosition_default_instance_;
class EventBatchSpotExecution;
struct EventBatchSpotExecutionDefaultTypeInternal;
extern EventBatchSpotExecutionDefaultTypeInternal _EventBatchSpotExecution_default_instance_;
class EventBinaryOptionsMarketUpdate;
struct EventBinaryOptionsMarketUpdateDefaultTypeInternal;
extern EventBinaryOptionsMarketUpdateDefaultTypeInternal _EventBinaryOptionsMarketUpdate_default_instance_;
class EventCancelConditionalDerivativeOrder;
struct EventCancelConditionalDerivativeOrderDefaultTypeInternal;
extern EventCancelConditionalDerivativeOrderDefaultTypeInternal _EventCancelConditionalDerivativeOrder_default_instance_;
class EventCancelDerivativeOrder;
struct EventCancelDerivativeOrderDefaultTypeInternal;
extern EventCancelDerivativeOrderDefaultTypeInternal _EventCancelDerivativeOrder_default_instance_;
class EventCancelSpotOrder;
struct EventCancelSpotOrderDefaultTypeInternal;
extern EventCancelSpotOrderDefaultTypeInternal _EventCancelSpotOrder_default_instance_;
class EventConditionalDerivativeOrderTrigger;
struct EventConditionalDerivativeOrderTriggerDefaultTypeInternal;
extern EventConditionalDerivativeOrderTriggerDefaultTypeInternal _EventConditionalDerivativeOrderTrigger_default_instance_;
class EventDerivativeMarketPaused;
struct EventDerivativeMarketPausedDefaultTypeInternal;
extern EventDerivativeMarketPausedDefaultTypeInternal _EventDerivativeMarketPaused_default_instance_;
class EventExpiryFuturesMarketUpdate;
struct EventExpiryFuturesMarketUpdateDefaultTypeInternal;
extern EventExpiryFuturesMarketUpdateDefaultTypeInternal _EventExpiryFuturesMarketUpdate_default_instance_;
class EventFeeDiscountSchedule;
struct EventFeeDiscountScheduleDefaultTypeInternal;
extern EventFeeDiscountScheduleDefaultTypeInternal _EventFeeDiscountSchedule_default_instance_;
class EventLostFundsFromLiquidation;
struct EventLostFundsFromLiquidationDefaultTypeInternal;
extern EventLostFundsFromLiquidationDefaultTypeInternal _EventLostFundsFromLiquidation_default_instance_;
class EventMarketBeyondBankruptcy;
struct EventMarketBeyondBankruptcyDefaultTypeInternal;
extern EventMarketBeyondBankruptcyDefaultTypeInternal _EventMarketBeyondBankruptcy_default_instance_;
class EventNewConditionalDerivativeOrder;
struct EventNewConditionalDerivativeOrderDefaultTypeInternal;
extern EventNewConditionalDerivativeOrderDefaultTypeInternal _EventNewConditionalDerivativeOrder_default_instance_;
class EventNewDerivativeOrders;
struct EventNewDerivativeOrdersDefaultTypeInternal;
extern EventNewDerivativeOrdersDefaultTypeInternal _EventNewDerivativeOrders_default_instance_;
class EventNewSpotOrders;
struct EventNewSpotOrdersDefaultTypeInternal;
extern EventNewSpotOrdersDefaultTypeInternal _EventNewSpotOrders_default_instance_;
class EventOrderFail;
struct EventOrderFailDefaultTypeInternal;
extern EventOrderFailDefaultTypeInternal _EventOrderFail_default_instance_;
class EventOrderbookUpdate;
struct EventOrderbookUpdateDefaultTypeInternal;
extern EventOrderbookUpdateDefaultTypeInternal _EventOrderbookUpdate_default_instance_;
class EventPerpetualMarketFundingUpdate;
struct EventPerpetualMarketFundingUpdateDefaultTypeInternal;
extern EventPerpetualMarketFundingUpdateDefaultTypeInternal _EventPerpetualMarketFundingUpdate_default_instance_;
class EventPerpetualMarketUpdate;
struct EventPerpetualMarketUpdateDefaultTypeInternal;
extern EventPerpetualMarketUpdateDefaultTypeInternal _EventPerpetualMarketUpdate_default_instance_;
class EventSpotMarketUpdate;
struct EventSpotMarketUpdateDefaultTypeInternal;
extern EventSpotMarketUpdateDefaultTypeInternal _EventSpotMarketUpdate_default_instance_;
class EventSubaccountBalanceTransfer;
struct EventSubaccountBalanceTransferDefaultTypeInternal;
extern EventSubaccountBalanceTransferDefaultTypeInternal _EventSubaccountBalanceTransfer_default_instance_;
class EventSubaccountDeposit;
struct EventSubaccountDepositDefaultTypeInternal;
extern EventSubaccountDepositDefaultTypeInternal _EventSubaccountDeposit_default_instance_;
class EventSubaccountWithdraw;
struct EventSubaccountWithdrawDefaultTypeInternal;
extern EventSubaccountWithdrawDefaultTypeInternal _EventSubaccountWithdraw_default_instance_;
class EventTradingRewardCampaignUpdate;
struct EventTradingRewardCampaignUpdateDefaultTypeInternal;
extern EventTradingRewardCampaignUpdateDefaultTypeInternal _EventTradingRewardCampaignUpdate_default_instance_;
class EventTradingRewardDistribution;
struct EventTradingRewardDistributionDefaultTypeInternal;
extern EventTradingRewardDistributionDefaultTypeInternal _EventTradingRewardDistribution_default_instance_;
class Orderbook;
struct OrderbookDefaultTypeInternal;
extern OrderbookDefaultTypeInternal _Orderbook_default_instance_;
class OrderbookUpdate;
struct OrderbookUpdateDefaultTypeInternal;
extern OrderbookUpdateDefaultTypeInternal _OrderbookUpdate_default_instance_;
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::exchange::v1beta1::DerivativeMarketOrderCancel* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrderCancel>(Arena*);
template <>
::injective::exchange::v1beta1::EventAllPositionsHaircut* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventAllPositionsHaircut>(Arena*);
template <>
::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventAtomicMarketOrderFeeMultipliersUpdated>(Arena*);
template <>
::injective::exchange::v1beta1::EventBatchDepositUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventBatchDepositUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventBatchDerivativeExecution* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventBatchDerivativeExecution>(Arena*);
template <>
::injective::exchange::v1beta1::EventBatchDerivativePosition* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventBatchDerivativePosition>(Arena*);
template <>
::injective::exchange::v1beta1::EventBatchSpotExecution* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventBatchSpotExecution>(Arena*);
template <>
::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventBinaryOptionsMarketUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventCancelConditionalDerivativeOrder>(Arena*);
template <>
::injective::exchange::v1beta1::EventCancelDerivativeOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventCancelDerivativeOrder>(Arena*);
template <>
::injective::exchange::v1beta1::EventCancelSpotOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventCancelSpotOrder>(Arena*);
template <>
::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventConditionalDerivativeOrderTrigger>(Arena*);
template <>
::injective::exchange::v1beta1::EventDerivativeMarketPaused* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventDerivativeMarketPaused>(Arena*);
template <>
::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventExpiryFuturesMarketUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventFeeDiscountSchedule* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventFeeDiscountSchedule>(Arena*);
template <>
::injective::exchange::v1beta1::EventLostFundsFromLiquidation* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventLostFundsFromLiquidation>(Arena*);
template <>
::injective::exchange::v1beta1::EventMarketBeyondBankruptcy* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventMarketBeyondBankruptcy>(Arena*);
template <>
::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventNewConditionalDerivativeOrder>(Arena*);
template <>
::injective::exchange::v1beta1::EventNewDerivativeOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventNewDerivativeOrders>(Arena*);
template <>
::injective::exchange::v1beta1::EventNewSpotOrders* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventNewSpotOrders>(Arena*);
template <>
::injective::exchange::v1beta1::EventOrderFail* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventOrderFail>(Arena*);
template <>
::injective::exchange::v1beta1::EventOrderbookUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventOrderbookUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventPerpetualMarketFundingUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventPerpetualMarketUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventPerpetualMarketUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventSpotMarketUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventSpotMarketUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventSubaccountBalanceTransfer* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventSubaccountBalanceTransfer>(Arena*);
template <>
::injective::exchange::v1beta1::EventSubaccountDeposit* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventSubaccountDeposit>(Arena*);
template <>
::injective::exchange::v1beta1::EventSubaccountWithdraw* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventSubaccountWithdraw>(Arena*);
template <>
::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventTradingRewardCampaignUpdate>(Arena*);
template <>
::injective::exchange::v1beta1::EventTradingRewardDistribution* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EventTradingRewardDistribution>(Arena*);
template <>
::injective::exchange::v1beta1::Orderbook* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::Orderbook>(Arena*);
template <>
::injective::exchange::v1beta1::OrderbookUpdate* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::OrderbookUpdate>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace exchange {
namespace v1beta1 {

// ===================================================================


// -------------------------------------------------------------------

class EventBatchSpotExecution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventBatchSpotExecution) */ {
 public:
  inline EventBatchSpotExecution() : EventBatchSpotExecution(nullptr) {}
  ~EventBatchSpotExecution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventBatchSpotExecution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventBatchSpotExecution(const EventBatchSpotExecution& from);
  EventBatchSpotExecution(EventBatchSpotExecution&& from) noexcept
    : EventBatchSpotExecution() {
    *this = ::std::move(from);
  }

  inline EventBatchSpotExecution& operator=(const EventBatchSpotExecution& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventBatchSpotExecution& operator=(EventBatchSpotExecution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventBatchSpotExecution& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventBatchSpotExecution* internal_default_instance() {
    return reinterpret_cast<const EventBatchSpotExecution*>(
               &_EventBatchSpotExecution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EventBatchSpotExecution& a, EventBatchSpotExecution& b) {
    a.Swap(&b);
  }
  inline void Swap(EventBatchSpotExecution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventBatchSpotExecution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventBatchSpotExecution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventBatchSpotExecution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventBatchSpotExecution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventBatchSpotExecution& from) {
    EventBatchSpotExecution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBatchSpotExecution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventBatchSpotExecution";
  }
  protected:
  explicit EventBatchSpotExecution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradesFieldNumber = 4,
    kMarketIdFieldNumber = 1,
    kIsBuyFieldNumber = 2,
    kExecutionTypeFieldNumber = 3,
  };
  // repeated .injective.exchange.v1beta1.TradeLog trades = 4 [json_name = "trades"];
  int trades_size() const;
  private:
  int _internal_trades_size() const;

  public:
  void clear_trades() ;
  ::injective::exchange::v1beta1::TradeLog* mutable_trades(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeLog >*
      mutable_trades();
  private:
  const ::injective::exchange::v1beta1::TradeLog& _internal_trades(int index) const;
  ::injective::exchange::v1beta1::TradeLog* _internal_add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeLog>& _internal_trades() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeLog>* _internal_mutable_trades();
  public:
  const ::injective::exchange::v1beta1::TradeLog& trades(int index) const;
  ::injective::exchange::v1beta1::TradeLog* add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeLog >&
      trades() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // bool is_buy = 2 [json_name = "isBuy"];
  void clear_is_buy() ;
  bool is_buy() const;
  void set_is_buy(bool value);

  private:
  bool _internal_is_buy() const;
  void _internal_set_is_buy(bool value);

  public:
  // .injective.exchange.v1beta1.ExecutionType executionType = 3 [json_name = "executionType"];
  void clear_executiontype() ;
  ::injective::exchange::v1beta1::ExecutionType executiontype() const;
  void set_executiontype(::injective::exchange::v1beta1::ExecutionType value);

  private:
  ::injective::exchange::v1beta1::ExecutionType _internal_executiontype() const;
  void _internal_set_executiontype(::injective::exchange::v1beta1::ExecutionType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventBatchSpotExecution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeLog > trades_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    bool is_buy_;
    int executiontype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventBatchDerivativeExecution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventBatchDerivativeExecution) */ {
 public:
  inline EventBatchDerivativeExecution() : EventBatchDerivativeExecution(nullptr) {}
  ~EventBatchDerivativeExecution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventBatchDerivativeExecution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventBatchDerivativeExecution(const EventBatchDerivativeExecution& from);
  EventBatchDerivativeExecution(EventBatchDerivativeExecution&& from) noexcept
    : EventBatchDerivativeExecution() {
    *this = ::std::move(from);
  }

  inline EventBatchDerivativeExecution& operator=(const EventBatchDerivativeExecution& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventBatchDerivativeExecution& operator=(EventBatchDerivativeExecution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventBatchDerivativeExecution& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventBatchDerivativeExecution* internal_default_instance() {
    return reinterpret_cast<const EventBatchDerivativeExecution*>(
               &_EventBatchDerivativeExecution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EventBatchDerivativeExecution& a, EventBatchDerivativeExecution& b) {
    a.Swap(&b);
  }
  inline void Swap(EventBatchDerivativeExecution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventBatchDerivativeExecution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventBatchDerivativeExecution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventBatchDerivativeExecution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventBatchDerivativeExecution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventBatchDerivativeExecution& from) {
    EventBatchDerivativeExecution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBatchDerivativeExecution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventBatchDerivativeExecution";
  }
  protected:
  explicit EventBatchDerivativeExecution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradesFieldNumber = 6,
    kMarketIdFieldNumber = 1,
    kCumulativeFundingFieldNumber = 4,
    kIsBuyFieldNumber = 2,
    kIsLiquidationFieldNumber = 3,
    kExecutionTypeFieldNumber = 5,
  };
  // repeated .injective.exchange.v1beta1.DerivativeTradeLog trades = 6 [json_name = "trades"];
  int trades_size() const;
  private:
  int _internal_trades_size() const;

  public:
  void clear_trades() ;
  ::injective::exchange::v1beta1::DerivativeTradeLog* mutable_trades(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeTradeLog >*
      mutable_trades();
  private:
  const ::injective::exchange::v1beta1::DerivativeTradeLog& _internal_trades(int index) const;
  ::injective::exchange::v1beta1::DerivativeTradeLog* _internal_add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeTradeLog>& _internal_trades() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeTradeLog>* _internal_mutable_trades();
  public:
  const ::injective::exchange::v1beta1::DerivativeTradeLog& trades(int index) const;
  ::injective::exchange::v1beta1::DerivativeTradeLog* add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeTradeLog >&
      trades() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string cumulative_funding = 4 [json_name = "cumulativeFunding", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_cumulative_funding() ;
  const std::string& cumulative_funding() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cumulative_funding(Arg_&& arg, Args_... args);
  std::string* mutable_cumulative_funding();
  PROTOBUF_NODISCARD std::string* release_cumulative_funding();
  void set_allocated_cumulative_funding(std::string* ptr);

  private:
  const std::string& _internal_cumulative_funding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cumulative_funding(
      const std::string& value);
  std::string* _internal_mutable_cumulative_funding();

  public:
  // bool is_buy = 2 [json_name = "isBuy"];
  void clear_is_buy() ;
  bool is_buy() const;
  void set_is_buy(bool value);

  private:
  bool _internal_is_buy() const;
  void _internal_set_is_buy(bool value);

  public:
  // bool is_liquidation = 3 [json_name = "isLiquidation"];
  void clear_is_liquidation() ;
  bool is_liquidation() const;
  void set_is_liquidation(bool value);

  private:
  bool _internal_is_liquidation() const;
  void _internal_set_is_liquidation(bool value);

  public:
  // .injective.exchange.v1beta1.ExecutionType executionType = 5 [json_name = "executionType"];
  void clear_executiontype() ;
  ::injective::exchange::v1beta1::ExecutionType executiontype() const;
  void set_executiontype(::injective::exchange::v1beta1::ExecutionType value);

  private:
  ::injective::exchange::v1beta1::ExecutionType _internal_executiontype() const;
  void _internal_set_executiontype(::injective::exchange::v1beta1::ExecutionType value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventBatchDerivativeExecution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeTradeLog > trades_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cumulative_funding_;
    bool is_buy_;
    bool is_liquidation_;
    int executiontype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventLostFundsFromLiquidation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventLostFundsFromLiquidation) */ {
 public:
  inline EventLostFundsFromLiquidation() : EventLostFundsFromLiquidation(nullptr) {}
  ~EventLostFundsFromLiquidation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventLostFundsFromLiquidation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventLostFundsFromLiquidation(const EventLostFundsFromLiquidation& from);
  EventLostFundsFromLiquidation(EventLostFundsFromLiquidation&& from) noexcept
    : EventLostFundsFromLiquidation() {
    *this = ::std::move(from);
  }

  inline EventLostFundsFromLiquidation& operator=(const EventLostFundsFromLiquidation& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventLostFundsFromLiquidation& operator=(EventLostFundsFromLiquidation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventLostFundsFromLiquidation& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventLostFundsFromLiquidation* internal_default_instance() {
    return reinterpret_cast<const EventLostFundsFromLiquidation*>(
               &_EventLostFundsFromLiquidation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EventLostFundsFromLiquidation& a, EventLostFundsFromLiquidation& b) {
    a.Swap(&b);
  }
  inline void Swap(EventLostFundsFromLiquidation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventLostFundsFromLiquidation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventLostFundsFromLiquidation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventLostFundsFromLiquidation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventLostFundsFromLiquidation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventLostFundsFromLiquidation& from) {
    EventLostFundsFromLiquidation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventLostFundsFromLiquidation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventLostFundsFromLiquidation";
  }
  protected:
  explicit EventLostFundsFromLiquidation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kLostFundsFromAvailableDuringPayoutFieldNumber = 3,
    kLostFundsFromOrderCancelsFieldNumber = 4,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string lost_funds_from_available_during_payout = 3 [json_name = "lostFundsFromAvailableDuringPayout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_lost_funds_from_available_during_payout() ;
  const std::string& lost_funds_from_available_during_payout() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lost_funds_from_available_during_payout(Arg_&& arg, Args_... args);
  std::string* mutable_lost_funds_from_available_during_payout();
  PROTOBUF_NODISCARD std::string* release_lost_funds_from_available_during_payout();
  void set_allocated_lost_funds_from_available_during_payout(std::string* ptr);

  private:
  const std::string& _internal_lost_funds_from_available_during_payout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lost_funds_from_available_during_payout(
      const std::string& value);
  std::string* _internal_mutable_lost_funds_from_available_during_payout();

  public:
  // string lost_funds_from_order_cancels = 4 [json_name = "lostFundsFromOrderCancels", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_lost_funds_from_order_cancels() ;
  const std::string& lost_funds_from_order_cancels() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lost_funds_from_order_cancels(Arg_&& arg, Args_... args);
  std::string* mutable_lost_funds_from_order_cancels();
  PROTOBUF_NODISCARD std::string* release_lost_funds_from_order_cancels();
  void set_allocated_lost_funds_from_order_cancels(std::string* ptr);

  private:
  const std::string& _internal_lost_funds_from_order_cancels() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lost_funds_from_order_cancels(
      const std::string& value);
  std::string* _internal_mutable_lost_funds_from_order_cancels();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventLostFundsFromLiquidation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lost_funds_from_available_during_payout_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lost_funds_from_order_cancels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventBatchDerivativePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventBatchDerivativePosition) */ {
 public:
  inline EventBatchDerivativePosition() : EventBatchDerivativePosition(nullptr) {}
  ~EventBatchDerivativePosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventBatchDerivativePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventBatchDerivativePosition(const EventBatchDerivativePosition& from);
  EventBatchDerivativePosition(EventBatchDerivativePosition&& from) noexcept
    : EventBatchDerivativePosition() {
    *this = ::std::move(from);
  }

  inline EventBatchDerivativePosition& operator=(const EventBatchDerivativePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventBatchDerivativePosition& operator=(EventBatchDerivativePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventBatchDerivativePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventBatchDerivativePosition* internal_default_instance() {
    return reinterpret_cast<const EventBatchDerivativePosition*>(
               &_EventBatchDerivativePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EventBatchDerivativePosition& a, EventBatchDerivativePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(EventBatchDerivativePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventBatchDerivativePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventBatchDerivativePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventBatchDerivativePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventBatchDerivativePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventBatchDerivativePosition& from) {
    EventBatchDerivativePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBatchDerivativePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventBatchDerivativePosition";
  }
  protected:
  explicit EventBatchDerivativePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 2,
    kMarketIdFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.SubaccountPosition positions = 2 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::injective::exchange::v1beta1::SubaccountPosition* mutable_positions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountPosition >*
      mutable_positions();
  private:
  const ::injective::exchange::v1beta1::SubaccountPosition& _internal_positions(int index) const;
  ::injective::exchange::v1beta1::SubaccountPosition* _internal_add_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountPosition>& _internal_positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountPosition>* _internal_mutable_positions();
  public:
  const ::injective::exchange::v1beta1::SubaccountPosition& positions(int index) const;
  ::injective::exchange::v1beta1::SubaccountPosition* add_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountPosition >&
      positions() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventBatchDerivativePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountPosition > positions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventDerivativeMarketPaused final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventDerivativeMarketPaused) */ {
 public:
  inline EventDerivativeMarketPaused() : EventDerivativeMarketPaused(nullptr) {}
  ~EventDerivativeMarketPaused() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventDerivativeMarketPaused(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventDerivativeMarketPaused(const EventDerivativeMarketPaused& from);
  EventDerivativeMarketPaused(EventDerivativeMarketPaused&& from) noexcept
    : EventDerivativeMarketPaused() {
    *this = ::std::move(from);
  }

  inline EventDerivativeMarketPaused& operator=(const EventDerivativeMarketPaused& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventDerivativeMarketPaused& operator=(EventDerivativeMarketPaused&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventDerivativeMarketPaused& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventDerivativeMarketPaused* internal_default_instance() {
    return reinterpret_cast<const EventDerivativeMarketPaused*>(
               &_EventDerivativeMarketPaused_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EventDerivativeMarketPaused& a, EventDerivativeMarketPaused& b) {
    a.Swap(&b);
  }
  inline void Swap(EventDerivativeMarketPaused* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventDerivativeMarketPaused* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventDerivativeMarketPaused* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventDerivativeMarketPaused>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventDerivativeMarketPaused& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventDerivativeMarketPaused& from) {
    EventDerivativeMarketPaused::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventDerivativeMarketPaused* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventDerivativeMarketPaused";
  }
  protected:
  explicit EventDerivativeMarketPaused(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSettlePriceFieldNumber = 2,
    kTotalMissingFundsFieldNumber = 3,
    kMissingFundsRateFieldNumber = 4,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string settle_price = 2 [json_name = "settlePrice"];
  void clear_settle_price() ;
  const std::string& settle_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settle_price(Arg_&& arg, Args_... args);
  std::string* mutable_settle_price();
  PROTOBUF_NODISCARD std::string* release_settle_price();
  void set_allocated_settle_price(std::string* ptr);

  private:
  const std::string& _internal_settle_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settle_price(
      const std::string& value);
  std::string* _internal_mutable_settle_price();

  public:
  // string total_missing_funds = 3 [json_name = "totalMissingFunds"];
  void clear_total_missing_funds() ;
  const std::string& total_missing_funds() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_missing_funds(Arg_&& arg, Args_... args);
  std::string* mutable_total_missing_funds();
  PROTOBUF_NODISCARD std::string* release_total_missing_funds();
  void set_allocated_total_missing_funds(std::string* ptr);

  private:
  const std::string& _internal_total_missing_funds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_missing_funds(
      const std::string& value);
  std::string* _internal_mutable_total_missing_funds();

  public:
  // string missing_funds_rate = 4 [json_name = "missingFundsRate"];
  void clear_missing_funds_rate() ;
  const std::string& missing_funds_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_missing_funds_rate(Arg_&& arg, Args_... args);
  std::string* mutable_missing_funds_rate();
  PROTOBUF_NODISCARD std::string* release_missing_funds_rate();
  void set_allocated_missing_funds_rate(std::string* ptr);

  private:
  const std::string& _internal_missing_funds_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_missing_funds_rate(
      const std::string& value);
  std::string* _internal_mutable_missing_funds_rate();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventDerivativeMarketPaused)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settle_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_missing_funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr missing_funds_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventMarketBeyondBankruptcy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventMarketBeyondBankruptcy) */ {
 public:
  inline EventMarketBeyondBankruptcy() : EventMarketBeyondBankruptcy(nullptr) {}
  ~EventMarketBeyondBankruptcy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventMarketBeyondBankruptcy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventMarketBeyondBankruptcy(const EventMarketBeyondBankruptcy& from);
  EventMarketBeyondBankruptcy(EventMarketBeyondBankruptcy&& from) noexcept
    : EventMarketBeyondBankruptcy() {
    *this = ::std::move(from);
  }

  inline EventMarketBeyondBankruptcy& operator=(const EventMarketBeyondBankruptcy& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventMarketBeyondBankruptcy& operator=(EventMarketBeyondBankruptcy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventMarketBeyondBankruptcy& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventMarketBeyondBankruptcy* internal_default_instance() {
    return reinterpret_cast<const EventMarketBeyondBankruptcy*>(
               &_EventMarketBeyondBankruptcy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EventMarketBeyondBankruptcy& a, EventMarketBeyondBankruptcy& b) {
    a.Swap(&b);
  }
  inline void Swap(EventMarketBeyondBankruptcy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventMarketBeyondBankruptcy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventMarketBeyondBankruptcy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventMarketBeyondBankruptcy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventMarketBeyondBankruptcy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventMarketBeyondBankruptcy& from) {
    EventMarketBeyondBankruptcy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventMarketBeyondBankruptcy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventMarketBeyondBankruptcy";
  }
  protected:
  explicit EventMarketBeyondBankruptcy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSettlePriceFieldNumber = 2,
    kMissingMarketFundsFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string settle_price = 2 [json_name = "settlePrice"];
  void clear_settle_price() ;
  const std::string& settle_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settle_price(Arg_&& arg, Args_... args);
  std::string* mutable_settle_price();
  PROTOBUF_NODISCARD std::string* release_settle_price();
  void set_allocated_settle_price(std::string* ptr);

  private:
  const std::string& _internal_settle_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settle_price(
      const std::string& value);
  std::string* _internal_mutable_settle_price();

  public:
  // string missing_market_funds = 3 [json_name = "missingMarketFunds"];
  void clear_missing_market_funds() ;
  const std::string& missing_market_funds() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_missing_market_funds(Arg_&& arg, Args_... args);
  std::string* mutable_missing_market_funds();
  PROTOBUF_NODISCARD std::string* release_missing_market_funds();
  void set_allocated_missing_market_funds(std::string* ptr);

  private:
  const std::string& _internal_missing_market_funds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_missing_market_funds(
      const std::string& value);
  std::string* _internal_mutable_missing_market_funds();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventMarketBeyondBankruptcy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settle_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr missing_market_funds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventAllPositionsHaircut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventAllPositionsHaircut) */ {
 public:
  inline EventAllPositionsHaircut() : EventAllPositionsHaircut(nullptr) {}
  ~EventAllPositionsHaircut() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventAllPositionsHaircut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAllPositionsHaircut(const EventAllPositionsHaircut& from);
  EventAllPositionsHaircut(EventAllPositionsHaircut&& from) noexcept
    : EventAllPositionsHaircut() {
    *this = ::std::move(from);
  }

  inline EventAllPositionsHaircut& operator=(const EventAllPositionsHaircut& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAllPositionsHaircut& operator=(EventAllPositionsHaircut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAllPositionsHaircut& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAllPositionsHaircut* internal_default_instance() {
    return reinterpret_cast<const EventAllPositionsHaircut*>(
               &_EventAllPositionsHaircut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EventAllPositionsHaircut& a, EventAllPositionsHaircut& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAllPositionsHaircut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAllPositionsHaircut* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAllPositionsHaircut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAllPositionsHaircut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAllPositionsHaircut& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventAllPositionsHaircut& from) {
    EventAllPositionsHaircut::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAllPositionsHaircut* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventAllPositionsHaircut";
  }
  protected:
  explicit EventAllPositionsHaircut(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSettlePriceFieldNumber = 2,
    kMissingFundsRateFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string settle_price = 2 [json_name = "settlePrice"];
  void clear_settle_price() ;
  const std::string& settle_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settle_price(Arg_&& arg, Args_... args);
  std::string* mutable_settle_price();
  PROTOBUF_NODISCARD std::string* release_settle_price();
  void set_allocated_settle_price(std::string* ptr);

  private:
  const std::string& _internal_settle_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settle_price(
      const std::string& value);
  std::string* _internal_mutable_settle_price();

  public:
  // string missing_funds_rate = 3 [json_name = "missingFundsRate"];
  void clear_missing_funds_rate() ;
  const std::string& missing_funds_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_missing_funds_rate(Arg_&& arg, Args_... args);
  std::string* mutable_missing_funds_rate();
  PROTOBUF_NODISCARD std::string* release_missing_funds_rate();
  void set_allocated_missing_funds_rate(std::string* ptr);

  private:
  const std::string& _internal_missing_funds_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_missing_funds_rate(
      const std::string& value);
  std::string* _internal_mutable_missing_funds_rate();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventAllPositionsHaircut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settle_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr missing_funds_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventBinaryOptionsMarketUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate) */ {
 public:
  inline EventBinaryOptionsMarketUpdate() : EventBinaryOptionsMarketUpdate(nullptr) {}
  ~EventBinaryOptionsMarketUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventBinaryOptionsMarketUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventBinaryOptionsMarketUpdate(const EventBinaryOptionsMarketUpdate& from);
  EventBinaryOptionsMarketUpdate(EventBinaryOptionsMarketUpdate&& from) noexcept
    : EventBinaryOptionsMarketUpdate() {
    *this = ::std::move(from);
  }

  inline EventBinaryOptionsMarketUpdate& operator=(const EventBinaryOptionsMarketUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventBinaryOptionsMarketUpdate& operator=(EventBinaryOptionsMarketUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventBinaryOptionsMarketUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventBinaryOptionsMarketUpdate* internal_default_instance() {
    return reinterpret_cast<const EventBinaryOptionsMarketUpdate*>(
               &_EventBinaryOptionsMarketUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EventBinaryOptionsMarketUpdate& a, EventBinaryOptionsMarketUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventBinaryOptionsMarketUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventBinaryOptionsMarketUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventBinaryOptionsMarketUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventBinaryOptionsMarketUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventBinaryOptionsMarketUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventBinaryOptionsMarketUpdate& from) {
    EventBinaryOptionsMarketUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBinaryOptionsMarketUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate";
  }
  protected:
  explicit EventBinaryOptionsMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.BinaryOptionsMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::BinaryOptionsMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::BinaryOptionsMarket* release_market();
  ::injective::exchange::v1beta1::BinaryOptionsMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::BinaryOptionsMarket* market);
  private:
  const ::injective::exchange::v1beta1::BinaryOptionsMarket& _internal_market() const;
  ::injective::exchange::v1beta1::BinaryOptionsMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::BinaryOptionsMarket* market);
  ::injective::exchange::v1beta1::BinaryOptionsMarket* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::BinaryOptionsMarket* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventNewSpotOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventNewSpotOrders) */ {
 public:
  inline EventNewSpotOrders() : EventNewSpotOrders(nullptr) {}
  ~EventNewSpotOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventNewSpotOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventNewSpotOrders(const EventNewSpotOrders& from);
  EventNewSpotOrders(EventNewSpotOrders&& from) noexcept
    : EventNewSpotOrders() {
    *this = ::std::move(from);
  }

  inline EventNewSpotOrders& operator=(const EventNewSpotOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventNewSpotOrders& operator=(EventNewSpotOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventNewSpotOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventNewSpotOrders* internal_default_instance() {
    return reinterpret_cast<const EventNewSpotOrders*>(
               &_EventNewSpotOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EventNewSpotOrders& a, EventNewSpotOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(EventNewSpotOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventNewSpotOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventNewSpotOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventNewSpotOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventNewSpotOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventNewSpotOrders& from) {
    EventNewSpotOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventNewSpotOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventNewSpotOrders";
  }
  protected:
  explicit EventNewSpotOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuyOrdersFieldNumber = 2,
    kSellOrdersFieldNumber = 3,
    kMarketIdFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2 [json_name = "buyOrders"];
  int buy_orders_size() const;
  private:
  int _internal_buy_orders_size() const;

  public:
  void clear_buy_orders() ;
  ::injective::exchange::v1beta1::SpotLimitOrder* mutable_buy_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >*
      mutable_buy_orders();
  private:
  const ::injective::exchange::v1beta1::SpotLimitOrder& _internal_buy_orders(int index) const;
  ::injective::exchange::v1beta1::SpotLimitOrder* _internal_add_buy_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>& _internal_buy_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>* _internal_mutable_buy_orders();
  public:
  const ::injective::exchange::v1beta1::SpotLimitOrder& buy_orders(int index) const;
  ::injective::exchange::v1beta1::SpotLimitOrder* add_buy_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >&
      buy_orders() const;
  // repeated .injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3 [json_name = "sellOrders"];
  int sell_orders_size() const;
  private:
  int _internal_sell_orders_size() const;

  public:
  void clear_sell_orders() ;
  ::injective::exchange::v1beta1::SpotLimitOrder* mutable_sell_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >*
      mutable_sell_orders();
  private:
  const ::injective::exchange::v1beta1::SpotLimitOrder& _internal_sell_orders(int index) const;
  ::injective::exchange::v1beta1::SpotLimitOrder* _internal_add_sell_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>& _internal_sell_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>* _internal_mutable_sell_orders();
  public:
  const ::injective::exchange::v1beta1::SpotLimitOrder& sell_orders(int index) const;
  ::injective::exchange::v1beta1::SpotLimitOrder* add_sell_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >&
      sell_orders() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventNewSpotOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder > buy_orders_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder > sell_orders_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventNewDerivativeOrders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventNewDerivativeOrders) */ {
 public:
  inline EventNewDerivativeOrders() : EventNewDerivativeOrders(nullptr) {}
  ~EventNewDerivativeOrders() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventNewDerivativeOrders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventNewDerivativeOrders(const EventNewDerivativeOrders& from);
  EventNewDerivativeOrders(EventNewDerivativeOrders&& from) noexcept
    : EventNewDerivativeOrders() {
    *this = ::std::move(from);
  }

  inline EventNewDerivativeOrders& operator=(const EventNewDerivativeOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventNewDerivativeOrders& operator=(EventNewDerivativeOrders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventNewDerivativeOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventNewDerivativeOrders* internal_default_instance() {
    return reinterpret_cast<const EventNewDerivativeOrders*>(
               &_EventNewDerivativeOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EventNewDerivativeOrders& a, EventNewDerivativeOrders& b) {
    a.Swap(&b);
  }
  inline void Swap(EventNewDerivativeOrders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventNewDerivativeOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventNewDerivativeOrders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventNewDerivativeOrders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventNewDerivativeOrders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventNewDerivativeOrders& from) {
    EventNewDerivativeOrders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventNewDerivativeOrders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventNewDerivativeOrders";
  }
  protected:
  explicit EventNewDerivativeOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuyOrdersFieldNumber = 2,
    kSellOrdersFieldNumber = 3,
    kMarketIdFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2 [json_name = "buyOrders"];
  int buy_orders_size() const;
  private:
  int _internal_buy_orders_size() const;

  public:
  void clear_buy_orders() ;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* mutable_buy_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >*
      mutable_buy_orders();
  private:
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& _internal_buy_orders(int index) const;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _internal_add_buy_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>& _internal_buy_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>* _internal_mutable_buy_orders();
  public:
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& buy_orders(int index) const;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* add_buy_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >&
      buy_orders() const;
  // repeated .injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3 [json_name = "sellOrders"];
  int sell_orders_size() const;
  private:
  int _internal_sell_orders_size() const;

  public:
  void clear_sell_orders() ;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* mutable_sell_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >*
      mutable_sell_orders();
  private:
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& _internal_sell_orders(int index) const;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _internal_add_sell_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>& _internal_sell_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>* _internal_mutable_sell_orders();
  public:
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& sell_orders(int index) const;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* add_sell_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >&
      sell_orders() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventNewDerivativeOrders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder > buy_orders_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder > sell_orders_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventCancelSpotOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventCancelSpotOrder) */ {
 public:
  inline EventCancelSpotOrder() : EventCancelSpotOrder(nullptr) {}
  ~EventCancelSpotOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventCancelSpotOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventCancelSpotOrder(const EventCancelSpotOrder& from);
  EventCancelSpotOrder(EventCancelSpotOrder&& from) noexcept
    : EventCancelSpotOrder() {
    *this = ::std::move(from);
  }

  inline EventCancelSpotOrder& operator=(const EventCancelSpotOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventCancelSpotOrder& operator=(EventCancelSpotOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventCancelSpotOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventCancelSpotOrder* internal_default_instance() {
    return reinterpret_cast<const EventCancelSpotOrder*>(
               &_EventCancelSpotOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EventCancelSpotOrder& a, EventCancelSpotOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(EventCancelSpotOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventCancelSpotOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventCancelSpotOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventCancelSpotOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventCancelSpotOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventCancelSpotOrder& from) {
    EventCancelSpotOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventCancelSpotOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventCancelSpotOrder";
  }
  protected:
  explicit EventCancelSpotOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective.exchange.v1beta1.SpotLimitOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::SpotLimitOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SpotLimitOrder* release_order();
  ::injective::exchange::v1beta1::SpotLimitOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::SpotLimitOrder* order);
  private:
  const ::injective::exchange::v1beta1::SpotLimitOrder& _internal_order() const;
  ::injective::exchange::v1beta1::SpotLimitOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::SpotLimitOrder* order);
  ::injective::exchange::v1beta1::SpotLimitOrder* unsafe_arena_release_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventCancelSpotOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective::exchange::v1beta1::SpotLimitOrder* order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventSpotMarketUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventSpotMarketUpdate) */ {
 public:
  inline EventSpotMarketUpdate() : EventSpotMarketUpdate(nullptr) {}
  ~EventSpotMarketUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventSpotMarketUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSpotMarketUpdate(const EventSpotMarketUpdate& from);
  EventSpotMarketUpdate(EventSpotMarketUpdate&& from) noexcept
    : EventSpotMarketUpdate() {
    *this = ::std::move(from);
  }

  inline EventSpotMarketUpdate& operator=(const EventSpotMarketUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSpotMarketUpdate& operator=(EventSpotMarketUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSpotMarketUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSpotMarketUpdate* internal_default_instance() {
    return reinterpret_cast<const EventSpotMarketUpdate*>(
               &_EventSpotMarketUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EventSpotMarketUpdate& a, EventSpotMarketUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSpotMarketUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSpotMarketUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSpotMarketUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSpotMarketUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSpotMarketUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSpotMarketUpdate& from) {
    EventSpotMarketUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSpotMarketUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventSpotMarketUpdate";
  }
  protected:
  explicit EventSpotMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::SpotMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SpotMarket* release_market();
  ::injective::exchange::v1beta1::SpotMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::SpotMarket* market);
  private:
  const ::injective::exchange::v1beta1::SpotMarket& _internal_market() const;
  ::injective::exchange::v1beta1::SpotMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::SpotMarket* market);
  ::injective::exchange::v1beta1::SpotMarket* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventSpotMarketUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::SpotMarket* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventPerpetualMarketUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventPerpetualMarketUpdate) */ {
 public:
  inline EventPerpetualMarketUpdate() : EventPerpetualMarketUpdate(nullptr) {}
  ~EventPerpetualMarketUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventPerpetualMarketUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventPerpetualMarketUpdate(const EventPerpetualMarketUpdate& from);
  EventPerpetualMarketUpdate(EventPerpetualMarketUpdate&& from) noexcept
    : EventPerpetualMarketUpdate() {
    *this = ::std::move(from);
  }

  inline EventPerpetualMarketUpdate& operator=(const EventPerpetualMarketUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventPerpetualMarketUpdate& operator=(EventPerpetualMarketUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventPerpetualMarketUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventPerpetualMarketUpdate* internal_default_instance() {
    return reinterpret_cast<const EventPerpetualMarketUpdate*>(
               &_EventPerpetualMarketUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EventPerpetualMarketUpdate& a, EventPerpetualMarketUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventPerpetualMarketUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventPerpetualMarketUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventPerpetualMarketUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventPerpetualMarketUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventPerpetualMarketUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventPerpetualMarketUpdate& from) {
    EventPerpetualMarketUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventPerpetualMarketUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventPerpetualMarketUpdate";
  }
  protected:
  explicit EventPerpetualMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
    kPerpetualMarketInfoFieldNumber = 2,
    kFundingFieldNumber = 3,
  };
  // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::DerivativeMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarket* release_market();
  ::injective::exchange::v1beta1::DerivativeMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::DerivativeMarket* market);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarket& _internal_market() const;
  ::injective::exchange::v1beta1::DerivativeMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::DerivativeMarket* market);
  ::injective::exchange::v1beta1::DerivativeMarket* unsafe_arena_release_market();
  // .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = true];
  bool has_perpetual_market_info() const;
  void clear_perpetual_market_info() ;
  const ::injective::exchange::v1beta1::PerpetualMarketInfo& perpetual_market_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketInfo* release_perpetual_market_info();
  ::injective::exchange::v1beta1::PerpetualMarketInfo* mutable_perpetual_market_info();
  void set_allocated_perpetual_market_info(::injective::exchange::v1beta1::PerpetualMarketInfo* perpetual_market_info);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketInfo& _internal_perpetual_market_info() const;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* _internal_mutable_perpetual_market_info();
  public:
  void unsafe_arena_set_allocated_perpetual_market_info(
      ::injective::exchange::v1beta1::PerpetualMarketInfo* perpetual_market_info);
  ::injective::exchange::v1beta1::PerpetualMarketInfo* unsafe_arena_release_perpetual_market_info();
  // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 3 [json_name = "funding", (.gogoproto.nullable) = true];
  bool has_funding() const;
  void clear_funding() ;
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& funding() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketFunding* release_funding();
  ::injective::exchange::v1beta1::PerpetualMarketFunding* mutable_funding();
  void set_allocated_funding(::injective::exchange::v1beta1::PerpetualMarketFunding* funding);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& _internal_funding() const;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _internal_mutable_funding();
  public:
  void unsafe_arena_set_allocated_funding(
      ::injective::exchange::v1beta1::PerpetualMarketFunding* funding);
  ::injective::exchange::v1beta1::PerpetualMarketFunding* unsafe_arena_release_funding();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventPerpetualMarketUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::DerivativeMarket* market_;
    ::injective::exchange::v1beta1::PerpetualMarketInfo* perpetual_market_info_;
    ::injective::exchange::v1beta1::PerpetualMarketFunding* funding_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventExpiryFuturesMarketUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate) */ {
 public:
  inline EventExpiryFuturesMarketUpdate() : EventExpiryFuturesMarketUpdate(nullptr) {}
  ~EventExpiryFuturesMarketUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventExpiryFuturesMarketUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventExpiryFuturesMarketUpdate(const EventExpiryFuturesMarketUpdate& from);
  EventExpiryFuturesMarketUpdate(EventExpiryFuturesMarketUpdate&& from) noexcept
    : EventExpiryFuturesMarketUpdate() {
    *this = ::std::move(from);
  }

  inline EventExpiryFuturesMarketUpdate& operator=(const EventExpiryFuturesMarketUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventExpiryFuturesMarketUpdate& operator=(EventExpiryFuturesMarketUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventExpiryFuturesMarketUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventExpiryFuturesMarketUpdate* internal_default_instance() {
    return reinterpret_cast<const EventExpiryFuturesMarketUpdate*>(
               &_EventExpiryFuturesMarketUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EventExpiryFuturesMarketUpdate& a, EventExpiryFuturesMarketUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventExpiryFuturesMarketUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventExpiryFuturesMarketUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventExpiryFuturesMarketUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventExpiryFuturesMarketUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventExpiryFuturesMarketUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventExpiryFuturesMarketUpdate& from) {
    EventExpiryFuturesMarketUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventExpiryFuturesMarketUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate";
  }
  protected:
  explicit EventExpiryFuturesMarketUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
    kExpiryFuturesMarketInfoFieldNumber = 3,
  };
  // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::DerivativeMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarket* release_market();
  ::injective::exchange::v1beta1::DerivativeMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::DerivativeMarket* market);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarket& _internal_market() const;
  ::injective::exchange::v1beta1::DerivativeMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::DerivativeMarket* market);
  ::injective::exchange::v1beta1::DerivativeMarket* unsafe_arena_release_market();
  // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3 [json_name = "expiryFuturesMarketInfo", (.gogoproto.nullable) = true];
  bool has_expiry_futures_market_info() const;
  void clear_expiry_futures_market_info() ;
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& expiry_futures_market_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* release_expiry_futures_market_info();
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* mutable_expiry_futures_market_info();
  void set_allocated_expiry_futures_market_info(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* expiry_futures_market_info);
  private:
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& _internal_expiry_futures_market_info() const;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* _internal_mutable_expiry_futures_market_info();
  public:
  void unsafe_arena_set_allocated_expiry_futures_market_info(
      ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* expiry_futures_market_info);
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* unsafe_arena_release_expiry_futures_market_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::DerivativeMarket* market_;
    ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* expiry_futures_market_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventPerpetualMarketFundingUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate) */ {
 public:
  inline EventPerpetualMarketFundingUpdate() : EventPerpetualMarketFundingUpdate(nullptr) {}
  ~EventPerpetualMarketFundingUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventPerpetualMarketFundingUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventPerpetualMarketFundingUpdate(const EventPerpetualMarketFundingUpdate& from);
  EventPerpetualMarketFundingUpdate(EventPerpetualMarketFundingUpdate&& from) noexcept
    : EventPerpetualMarketFundingUpdate() {
    *this = ::std::move(from);
  }

  inline EventPerpetualMarketFundingUpdate& operator=(const EventPerpetualMarketFundingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventPerpetualMarketFundingUpdate& operator=(EventPerpetualMarketFundingUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventPerpetualMarketFundingUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventPerpetualMarketFundingUpdate* internal_default_instance() {
    return reinterpret_cast<const EventPerpetualMarketFundingUpdate*>(
               &_EventPerpetualMarketFundingUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EventPerpetualMarketFundingUpdate& a, EventPerpetualMarketFundingUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventPerpetualMarketFundingUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventPerpetualMarketFundingUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventPerpetualMarketFundingUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventPerpetualMarketFundingUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventPerpetualMarketFundingUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventPerpetualMarketFundingUpdate& from) {
    EventPerpetualMarketFundingUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventPerpetualMarketFundingUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate";
  }
  protected:
  explicit EventPerpetualMarketFundingUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kFundingRateFieldNumber = 4,
    kMarkPriceFieldNumber = 5,
    kFundingFieldNumber = 2,
    kIsHourlyFundingFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string funding_rate = 4 [json_name = "fundingRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_funding_rate() ;
  const std::string& funding_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_funding_rate(Arg_&& arg, Args_... args);
  std::string* mutable_funding_rate();
  PROTOBUF_NODISCARD std::string* release_funding_rate();
  void set_allocated_funding_rate(std::string* ptr);

  private:
  const std::string& _internal_funding_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funding_rate(
      const std::string& value);
  std::string* _internal_mutable_funding_rate();

  public:
  // string mark_price = 5 [json_name = "markPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_mark_price() ;
  const std::string& mark_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mark_price(Arg_&& arg, Args_... args);
  std::string* mutable_mark_price();
  PROTOBUF_NODISCARD std::string* release_mark_price();
  void set_allocated_mark_price(std::string* ptr);

  private:
  const std::string& _internal_mark_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_price(
      const std::string& value);
  std::string* _internal_mutable_mark_price();

  public:
  // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding", (.gogoproto.nullable) = false];
  bool has_funding() const;
  void clear_funding() ;
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& funding() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketFunding* release_funding();
  ::injective::exchange::v1beta1::PerpetualMarketFunding* mutable_funding();
  void set_allocated_funding(::injective::exchange::v1beta1::PerpetualMarketFunding* funding);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& _internal_funding() const;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _internal_mutable_funding();
  public:
  void unsafe_arena_set_allocated_funding(
      ::injective::exchange::v1beta1::PerpetualMarketFunding* funding);
  ::injective::exchange::v1beta1::PerpetualMarketFunding* unsafe_arena_release_funding();
  // bool is_hourly_funding = 3 [json_name = "isHourlyFunding"];
  void clear_is_hourly_funding() ;
  bool is_hourly_funding() const;
  void set_is_hourly_funding(bool value);

  private:
  bool _internal_is_hourly_funding() const;
  void _internal_set_is_hourly_funding(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funding_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_price_;
    ::injective::exchange::v1beta1::PerpetualMarketFunding* funding_;
    bool is_hourly_funding_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventSubaccountDeposit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventSubaccountDeposit) */ {
 public:
  inline EventSubaccountDeposit() : EventSubaccountDeposit(nullptr) {}
  ~EventSubaccountDeposit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventSubaccountDeposit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSubaccountDeposit(const EventSubaccountDeposit& from);
  EventSubaccountDeposit(EventSubaccountDeposit&& from) noexcept
    : EventSubaccountDeposit() {
    *this = ::std::move(from);
  }

  inline EventSubaccountDeposit& operator=(const EventSubaccountDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSubaccountDeposit& operator=(EventSubaccountDeposit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSubaccountDeposit& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSubaccountDeposit* internal_default_instance() {
    return reinterpret_cast<const EventSubaccountDeposit*>(
               &_EventSubaccountDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EventSubaccountDeposit& a, EventSubaccountDeposit& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSubaccountDeposit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSubaccountDeposit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSubaccountDeposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSubaccountDeposit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSubaccountDeposit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSubaccountDeposit& from) {
    EventSubaccountDeposit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSubaccountDeposit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventSubaccountDeposit";
  }
  protected:
  explicit EventSubaccountDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcAddressFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string src_address = 1 [json_name = "srcAddress"];
  void clear_src_address() ;
  const std::string& src_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_address(Arg_&& arg, Args_... args);
  std::string* mutable_src_address();
  PROTOBUF_NODISCARD std::string* release_src_address();
  void set_allocated_src_address(std::string* ptr);

  private:
  const std::string& _internal_src_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_address(
      const std::string& value);
  std::string* _internal_mutable_src_address();

  public:
  // bytes subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventSubaccountDeposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventSubaccountWithdraw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventSubaccountWithdraw) */ {
 public:
  inline EventSubaccountWithdraw() : EventSubaccountWithdraw(nullptr) {}
  ~EventSubaccountWithdraw() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventSubaccountWithdraw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSubaccountWithdraw(const EventSubaccountWithdraw& from);
  EventSubaccountWithdraw(EventSubaccountWithdraw&& from) noexcept
    : EventSubaccountWithdraw() {
    *this = ::std::move(from);
  }

  inline EventSubaccountWithdraw& operator=(const EventSubaccountWithdraw& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSubaccountWithdraw& operator=(EventSubaccountWithdraw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSubaccountWithdraw& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSubaccountWithdraw* internal_default_instance() {
    return reinterpret_cast<const EventSubaccountWithdraw*>(
               &_EventSubaccountWithdraw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EventSubaccountWithdraw& a, EventSubaccountWithdraw& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSubaccountWithdraw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSubaccountWithdraw* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSubaccountWithdraw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSubaccountWithdraw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSubaccountWithdraw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSubaccountWithdraw& from) {
    EventSubaccountWithdraw::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSubaccountWithdraw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventSubaccountWithdraw";
  }
  protected:
  explicit EventSubaccountWithdraw(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kDstAddressFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // bytes subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string dst_address = 2 [json_name = "dstAddress"];
  void clear_dst_address() ;
  const std::string& dst_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_address(Arg_&& arg, Args_... args);
  std::string* mutable_dst_address();
  PROTOBUF_NODISCARD std::string* release_dst_address();
  void set_allocated_dst_address(std::string* ptr);

  private:
  const std::string& _internal_dst_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_address(
      const std::string& value);
  std::string* _internal_mutable_dst_address();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventSubaccountWithdraw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_address_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventSubaccountBalanceTransfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventSubaccountBalanceTransfer) */ {
 public:
  inline EventSubaccountBalanceTransfer() : EventSubaccountBalanceTransfer(nullptr) {}
  ~EventSubaccountBalanceTransfer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventSubaccountBalanceTransfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSubaccountBalanceTransfer(const EventSubaccountBalanceTransfer& from);
  EventSubaccountBalanceTransfer(EventSubaccountBalanceTransfer&& from) noexcept
    : EventSubaccountBalanceTransfer() {
    *this = ::std::move(from);
  }

  inline EventSubaccountBalanceTransfer& operator=(const EventSubaccountBalanceTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSubaccountBalanceTransfer& operator=(EventSubaccountBalanceTransfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSubaccountBalanceTransfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSubaccountBalanceTransfer* internal_default_instance() {
    return reinterpret_cast<const EventSubaccountBalanceTransfer*>(
               &_EventSubaccountBalanceTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EventSubaccountBalanceTransfer& a, EventSubaccountBalanceTransfer& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSubaccountBalanceTransfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSubaccountBalanceTransfer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSubaccountBalanceTransfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSubaccountBalanceTransfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSubaccountBalanceTransfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSubaccountBalanceTransfer& from) {
    EventSubaccountBalanceTransfer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSubaccountBalanceTransfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventSubaccountBalanceTransfer";
  }
  protected:
  explicit EventSubaccountBalanceTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcSubaccountIdFieldNumber = 1,
    kDstSubaccountIdFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string src_subaccount_id = 1 [json_name = "srcSubaccountId"];
  void clear_src_subaccount_id() ;
  const std::string& src_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_src_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_src_subaccount_id();
  void set_allocated_src_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_src_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_src_subaccount_id();

  public:
  // string dst_subaccount_id = 2 [json_name = "dstSubaccountId"];
  void clear_dst_subaccount_id() ;
  const std::string& dst_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_dst_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_dst_subaccount_id();
  void set_allocated_dst_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_dst_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_dst_subaccount_id();

  public:
  // .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
  bool has_amount() const;
  void clear_amount() ;
  const ::cosmos::base::v1beta1::Coin& amount() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_amount();
  ::cosmos::base::v1beta1::Coin* mutable_amount();
  void set_allocated_amount(::cosmos::base::v1beta1::Coin* amount);
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amount() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::cosmos::base::v1beta1::Coin* amount);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_amount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventSubaccountBalanceTransfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_subaccount_id_;
    ::cosmos::base::v1beta1::Coin* amount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventBatchDepositUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventBatchDepositUpdate) */ {
 public:
  inline EventBatchDepositUpdate() : EventBatchDepositUpdate(nullptr) {}
  ~EventBatchDepositUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventBatchDepositUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventBatchDepositUpdate(const EventBatchDepositUpdate& from);
  EventBatchDepositUpdate(EventBatchDepositUpdate&& from) noexcept
    : EventBatchDepositUpdate() {
    *this = ::std::move(from);
  }

  inline EventBatchDepositUpdate& operator=(const EventBatchDepositUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventBatchDepositUpdate& operator=(EventBatchDepositUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventBatchDepositUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventBatchDepositUpdate* internal_default_instance() {
    return reinterpret_cast<const EventBatchDepositUpdate*>(
               &_EventBatchDepositUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EventBatchDepositUpdate& a, EventBatchDepositUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventBatchDepositUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventBatchDepositUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventBatchDepositUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventBatchDepositUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventBatchDepositUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventBatchDepositUpdate& from) {
    EventBatchDepositUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBatchDepositUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventBatchDepositUpdate";
  }
  protected:
  explicit EventBatchDepositUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepositUpdatesFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.DepositUpdate deposit_updates = 1 [json_name = "depositUpdates"];
  int deposit_updates_size() const;
  private:
  int _internal_deposit_updates_size() const;

  public:
  void clear_deposit_updates() ;
  ::injective::exchange::v1beta1::DepositUpdate* mutable_deposit_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DepositUpdate >*
      mutable_deposit_updates();
  private:
  const ::injective::exchange::v1beta1::DepositUpdate& _internal_deposit_updates(int index) const;
  ::injective::exchange::v1beta1::DepositUpdate* _internal_add_deposit_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DepositUpdate>& _internal_deposit_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DepositUpdate>* _internal_mutable_deposit_updates();
  public:
  const ::injective::exchange::v1beta1::DepositUpdate& deposit_updates(int index) const;
  ::injective::exchange::v1beta1::DepositUpdate* add_deposit_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DepositUpdate >&
      deposit_updates() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventBatchDepositUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DepositUpdate > deposit_updates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class DerivativeMarketOrderCancel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.DerivativeMarketOrderCancel) */ {
 public:
  inline DerivativeMarketOrderCancel() : DerivativeMarketOrderCancel(nullptr) {}
  ~DerivativeMarketOrderCancel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeMarketOrderCancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeMarketOrderCancel(const DerivativeMarketOrderCancel& from);
  DerivativeMarketOrderCancel(DerivativeMarketOrderCancel&& from) noexcept
    : DerivativeMarketOrderCancel() {
    *this = ::std::move(from);
  }

  inline DerivativeMarketOrderCancel& operator=(const DerivativeMarketOrderCancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeMarketOrderCancel& operator=(DerivativeMarketOrderCancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeMarketOrderCancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeMarketOrderCancel* internal_default_instance() {
    return reinterpret_cast<const DerivativeMarketOrderCancel*>(
               &_DerivativeMarketOrderCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DerivativeMarketOrderCancel& a, DerivativeMarketOrderCancel& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeMarketOrderCancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeMarketOrderCancel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeMarketOrderCancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeMarketOrderCancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeMarketOrderCancel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeMarketOrderCancel& from) {
    DerivativeMarketOrderCancel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeMarketOrderCancel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.DerivativeMarketOrderCancel";
  }
  protected:
  explicit DerivativeMarketOrderCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCancelQuantityFieldNumber = 2,
    kMarketOrderFieldNumber = 1,
  };
  // string cancel_quantity = 2 [json_name = "cancelQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_cancel_quantity() ;
  const std::string& cancel_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cancel_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_cancel_quantity();
  PROTOBUF_NODISCARD std::string* release_cancel_quantity();
  void set_allocated_cancel_quantity(std::string* ptr);

  private:
  const std::string& _internal_cancel_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cancel_quantity(
      const std::string& value);
  std::string* _internal_mutable_cancel_quantity();

  public:
  // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1 [json_name = "marketOrder", (.gogoproto.nullable) = true];
  bool has_market_order() const;
  void clear_market_order() ;
  const ::injective::exchange::v1beta1::DerivativeMarketOrder& market_order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarketOrder* release_market_order();
  ::injective::exchange::v1beta1::DerivativeMarketOrder* mutable_market_order();
  void set_allocated_market_order(::injective::exchange::v1beta1::DerivativeMarketOrder* market_order);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarketOrder& _internal_market_order() const;
  ::injective::exchange::v1beta1::DerivativeMarketOrder* _internal_mutable_market_order();
  public:
  void unsafe_arena_set_allocated_market_order(
      ::injective::exchange::v1beta1::DerivativeMarketOrder* market_order);
  ::injective::exchange::v1beta1::DerivativeMarketOrder* unsafe_arena_release_market_order();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.DerivativeMarketOrderCancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cancel_quantity_;
    ::injective::exchange::v1beta1::DerivativeMarketOrder* market_order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventCancelDerivativeOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventCancelDerivativeOrder) */ {
 public:
  inline EventCancelDerivativeOrder() : EventCancelDerivativeOrder(nullptr) {}
  ~EventCancelDerivativeOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventCancelDerivativeOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventCancelDerivativeOrder(const EventCancelDerivativeOrder& from);
  EventCancelDerivativeOrder(EventCancelDerivativeOrder&& from) noexcept
    : EventCancelDerivativeOrder() {
    *this = ::std::move(from);
  }

  inline EventCancelDerivativeOrder& operator=(const EventCancelDerivativeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventCancelDerivativeOrder& operator=(EventCancelDerivativeOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventCancelDerivativeOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventCancelDerivativeOrder* internal_default_instance() {
    return reinterpret_cast<const EventCancelDerivativeOrder*>(
               &_EventCancelDerivativeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EventCancelDerivativeOrder& a, EventCancelDerivativeOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(EventCancelDerivativeOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventCancelDerivativeOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventCancelDerivativeOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventCancelDerivativeOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventCancelDerivativeOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventCancelDerivativeOrder& from) {
    EventCancelDerivativeOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventCancelDerivativeOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventCancelDerivativeOrder";
  }
  protected:
  explicit EventCancelDerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kLimitOrderFieldNumber = 3,
    kMarketOrderCancelFieldNumber = 4,
    kIsLimitCancelFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
  bool has_limit_order() const;
  void clear_limit_order() ;
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& limit_order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeLimitOrder* release_limit_order();
  ::injective::exchange::v1beta1::DerivativeLimitOrder* mutable_limit_order();
  void set_allocated_limit_order(::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order);
  private:
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& _internal_limit_order() const;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _internal_mutable_limit_order();
  public:
  void unsafe_arena_set_allocated_limit_order(
      ::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order);
  ::injective::exchange::v1beta1::DerivativeLimitOrder* unsafe_arena_release_limit_order();
  // .injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4 [json_name = "marketOrderCancel", (.gogoproto.nullable) = true];
  bool has_market_order_cancel() const;
  void clear_market_order_cancel() ;
  const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel& market_order_cancel() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* release_market_order_cancel();
  ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* mutable_market_order_cancel();
  void set_allocated_market_order_cancel(::injective::exchange::v1beta1::DerivativeMarketOrderCancel* market_order_cancel);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel& _internal_market_order_cancel() const;
  ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* _internal_mutable_market_order_cancel();
  public:
  void unsafe_arena_set_allocated_market_order_cancel(
      ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* market_order_cancel);
  ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* unsafe_arena_release_market_order_cancel();
  // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
  void clear_islimitcancel() ;
  bool islimitcancel() const;
  void set_islimitcancel(bool value);

  private:
  bool _internal_islimitcancel() const;
  void _internal_set_islimitcancel(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventCancelDerivativeOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order_;
    ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* market_order_cancel_;
    bool islimitcancel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventFeeDiscountSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventFeeDiscountSchedule) */ {
 public:
  inline EventFeeDiscountSchedule() : EventFeeDiscountSchedule(nullptr) {}
  ~EventFeeDiscountSchedule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventFeeDiscountSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventFeeDiscountSchedule(const EventFeeDiscountSchedule& from);
  EventFeeDiscountSchedule(EventFeeDiscountSchedule&& from) noexcept
    : EventFeeDiscountSchedule() {
    *this = ::std::move(from);
  }

  inline EventFeeDiscountSchedule& operator=(const EventFeeDiscountSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventFeeDiscountSchedule& operator=(EventFeeDiscountSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventFeeDiscountSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventFeeDiscountSchedule* internal_default_instance() {
    return reinterpret_cast<const EventFeeDiscountSchedule*>(
               &_EventFeeDiscountSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(EventFeeDiscountSchedule& a, EventFeeDiscountSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(EventFeeDiscountSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventFeeDiscountSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventFeeDiscountSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventFeeDiscountSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventFeeDiscountSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventFeeDiscountSchedule& from) {
    EventFeeDiscountSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventFeeDiscountSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventFeeDiscountSchedule";
  }
  protected:
  explicit EventFeeDiscountSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1 [json_name = "schedule"];
  bool has_schedule() const;
  void clear_schedule() ;
  const ::injective::exchange::v1beta1::FeeDiscountSchedule& schedule() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::FeeDiscountSchedule* release_schedule();
  ::injective::exchange::v1beta1::FeeDiscountSchedule* mutable_schedule();
  void set_allocated_schedule(::injective::exchange::v1beta1::FeeDiscountSchedule* schedule);
  private:
  const ::injective::exchange::v1beta1::FeeDiscountSchedule& _internal_schedule() const;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* _internal_mutable_schedule();
  public:
  void unsafe_arena_set_allocated_schedule(
      ::injective::exchange::v1beta1::FeeDiscountSchedule* schedule);
  ::injective::exchange::v1beta1::FeeDiscountSchedule* unsafe_arena_release_schedule();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventFeeDiscountSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::FeeDiscountSchedule* schedule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventTradingRewardCampaignUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate) */ {
 public:
  inline EventTradingRewardCampaignUpdate() : EventTradingRewardCampaignUpdate(nullptr) {}
  ~EventTradingRewardCampaignUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventTradingRewardCampaignUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventTradingRewardCampaignUpdate(const EventTradingRewardCampaignUpdate& from);
  EventTradingRewardCampaignUpdate(EventTradingRewardCampaignUpdate&& from) noexcept
    : EventTradingRewardCampaignUpdate() {
    *this = ::std::move(from);
  }

  inline EventTradingRewardCampaignUpdate& operator=(const EventTradingRewardCampaignUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventTradingRewardCampaignUpdate& operator=(EventTradingRewardCampaignUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventTradingRewardCampaignUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventTradingRewardCampaignUpdate* internal_default_instance() {
    return reinterpret_cast<const EventTradingRewardCampaignUpdate*>(
               &_EventTradingRewardCampaignUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EventTradingRewardCampaignUpdate& a, EventTradingRewardCampaignUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventTradingRewardCampaignUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventTradingRewardCampaignUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventTradingRewardCampaignUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventTradingRewardCampaignUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventTradingRewardCampaignUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventTradingRewardCampaignUpdate& from) {
    EventTradingRewardCampaignUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventTradingRewardCampaignUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventTradingRewardCampaignUpdate";
  }
  protected:
  explicit EventTradingRewardCampaignUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCampaignRewardPoolsFieldNumber = 2,
    kCampaignInfoFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2 [json_name = "campaignRewardPools"];
  int campaign_reward_pools_size() const;
  private:
  int _internal_campaign_reward_pools_size() const;

  public:
  void clear_campaign_reward_pools() ;
  ::injective::exchange::v1beta1::CampaignRewardPool* mutable_campaign_reward_pools(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
      mutable_campaign_reward_pools();
  private:
  const ::injective::exchange::v1beta1::CampaignRewardPool& _internal_campaign_reward_pools(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* _internal_add_campaign_reward_pools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>& _internal_campaign_reward_pools() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>* _internal_mutable_campaign_reward_pools();
  public:
  const ::injective::exchange::v1beta1::CampaignRewardPool& campaign_reward_pools(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* add_campaign_reward_pools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
      campaign_reward_pools() const;
  // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1 [json_name = "campaignInfo"];
  bool has_campaign_info() const;
  void clear_campaign_info() ;
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& campaign_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::TradingRewardCampaignInfo* release_campaign_info();
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* mutable_campaign_info();
  void set_allocated_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info);
  private:
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& _internal_campaign_info() const;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _internal_mutable_campaign_info();
  public:
  void unsafe_arena_set_allocated_campaign_info(
      ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info);
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* unsafe_arena_release_campaign_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool > campaign_reward_pools_;
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventTradingRewardDistribution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventTradingRewardDistribution) */ {
 public:
  inline EventTradingRewardDistribution() : EventTradingRewardDistribution(nullptr) {}
  ~EventTradingRewardDistribution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventTradingRewardDistribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventTradingRewardDistribution(const EventTradingRewardDistribution& from);
  EventTradingRewardDistribution(EventTradingRewardDistribution&& from) noexcept
    : EventTradingRewardDistribution() {
    *this = ::std::move(from);
  }

  inline EventTradingRewardDistribution& operator=(const EventTradingRewardDistribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventTradingRewardDistribution& operator=(EventTradingRewardDistribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventTradingRewardDistribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventTradingRewardDistribution* internal_default_instance() {
    return reinterpret_cast<const EventTradingRewardDistribution*>(
               &_EventTradingRewardDistribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(EventTradingRewardDistribution& a, EventTradingRewardDistribution& b) {
    a.Swap(&b);
  }
  inline void Swap(EventTradingRewardDistribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventTradingRewardDistribution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventTradingRewardDistribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventTradingRewardDistribution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventTradingRewardDistribution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventTradingRewardDistribution& from) {
    EventTradingRewardDistribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventTradingRewardDistribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventTradingRewardDistribution";
  }
  protected:
  explicit EventTradingRewardDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountRewardsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.AccountRewards account_rewards = 1 [json_name = "accountRewards"];
  int account_rewards_size() const;
  private:
  int _internal_account_rewards_size() const;

  public:
  void clear_account_rewards() ;
  ::injective::exchange::v1beta1::AccountRewards* mutable_account_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AccountRewards >*
      mutable_account_rewards();
  private:
  const ::injective::exchange::v1beta1::AccountRewards& _internal_account_rewards(int index) const;
  ::injective::exchange::v1beta1::AccountRewards* _internal_add_account_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AccountRewards>& _internal_account_rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AccountRewards>* _internal_mutable_account_rewards();
  public:
  const ::injective::exchange::v1beta1::AccountRewards& account_rewards(int index) const;
  ::injective::exchange::v1beta1::AccountRewards* add_account_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AccountRewards >&
      account_rewards() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventTradingRewardDistribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AccountRewards > account_rewards_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventNewConditionalDerivativeOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder) */ {
 public:
  inline EventNewConditionalDerivativeOrder() : EventNewConditionalDerivativeOrder(nullptr) {}
  ~EventNewConditionalDerivativeOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventNewConditionalDerivativeOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventNewConditionalDerivativeOrder(const EventNewConditionalDerivativeOrder& from);
  EventNewConditionalDerivativeOrder(EventNewConditionalDerivativeOrder&& from) noexcept
    : EventNewConditionalDerivativeOrder() {
    *this = ::std::move(from);
  }

  inline EventNewConditionalDerivativeOrder& operator=(const EventNewConditionalDerivativeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventNewConditionalDerivativeOrder& operator=(EventNewConditionalDerivativeOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventNewConditionalDerivativeOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventNewConditionalDerivativeOrder* internal_default_instance() {
    return reinterpret_cast<const EventNewConditionalDerivativeOrder*>(
               &_EventNewConditionalDerivativeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(EventNewConditionalDerivativeOrder& a, EventNewConditionalDerivativeOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(EventNewConditionalDerivativeOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventNewConditionalDerivativeOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventNewConditionalDerivativeOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventNewConditionalDerivativeOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventNewConditionalDerivativeOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventNewConditionalDerivativeOrder& from) {
    EventNewConditionalDerivativeOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventNewConditionalDerivativeOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventNewConditionalDerivativeOrder";
  }
  protected:
  explicit EventNewConditionalDerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kHashFieldNumber = 3,
    kOrderFieldNumber = 2,
    kIsMarketFieldNumber = 4,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // bytes hash = 3 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order"];
  bool has_order() const;
  void clear_order() ;
  const ::injective::exchange::v1beta1::DerivativeOrder& order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeOrder* release_order();
  ::injective::exchange::v1beta1::DerivativeOrder* mutable_order();
  void set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order);
  private:
  const ::injective::exchange::v1beta1::DerivativeOrder& _internal_order() const;
  ::injective::exchange::v1beta1::DerivativeOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective::exchange::v1beta1::DerivativeOrder* order);
  ::injective::exchange::v1beta1::DerivativeOrder* unsafe_arena_release_order();
  // bool is_market = 4 [json_name = "isMarket"];
  void clear_is_market() ;
  bool is_market() const;
  void set_is_market(bool value);

  private:
  bool _internal_is_market() const;
  void _internal_set_is_market(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::injective::exchange::v1beta1::DerivativeOrder* order_;
    bool is_market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventCancelConditionalDerivativeOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder) */ {
 public:
  inline EventCancelConditionalDerivativeOrder() : EventCancelConditionalDerivativeOrder(nullptr) {}
  ~EventCancelConditionalDerivativeOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventCancelConditionalDerivativeOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventCancelConditionalDerivativeOrder(const EventCancelConditionalDerivativeOrder& from);
  EventCancelConditionalDerivativeOrder(EventCancelConditionalDerivativeOrder&& from) noexcept
    : EventCancelConditionalDerivativeOrder() {
    *this = ::std::move(from);
  }

  inline EventCancelConditionalDerivativeOrder& operator=(const EventCancelConditionalDerivativeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventCancelConditionalDerivativeOrder& operator=(EventCancelConditionalDerivativeOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventCancelConditionalDerivativeOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventCancelConditionalDerivativeOrder* internal_default_instance() {
    return reinterpret_cast<const EventCancelConditionalDerivativeOrder*>(
               &_EventCancelConditionalDerivativeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EventCancelConditionalDerivativeOrder& a, EventCancelConditionalDerivativeOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(EventCancelConditionalDerivativeOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventCancelConditionalDerivativeOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventCancelConditionalDerivativeOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventCancelConditionalDerivativeOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventCancelConditionalDerivativeOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventCancelConditionalDerivativeOrder& from) {
    EventCancelConditionalDerivativeOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventCancelConditionalDerivativeOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder";
  }
  protected:
  explicit EventCancelConditionalDerivativeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kLimitOrderFieldNumber = 3,
    kMarketOrderFieldNumber = 4,
    kIsLimitCancelFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
  bool has_limit_order() const;
  void clear_limit_order() ;
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& limit_order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeLimitOrder* release_limit_order();
  ::injective::exchange::v1beta1::DerivativeLimitOrder* mutable_limit_order();
  void set_allocated_limit_order(::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order);
  private:
  const ::injective::exchange::v1beta1::DerivativeLimitOrder& _internal_limit_order() const;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _internal_mutable_limit_order();
  public:
  void unsafe_arena_set_allocated_limit_order(
      ::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order);
  ::injective::exchange::v1beta1::DerivativeLimitOrder* unsafe_arena_release_limit_order();
  // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4 [json_name = "marketOrder", (.gogoproto.nullable) = true];
  bool has_market_order() const;
  void clear_market_order() ;
  const ::injective::exchange::v1beta1::DerivativeMarketOrder& market_order() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarketOrder* release_market_order();
  ::injective::exchange::v1beta1::DerivativeMarketOrder* mutable_market_order();
  void set_allocated_market_order(::injective::exchange::v1beta1::DerivativeMarketOrder* market_order);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarketOrder& _internal_market_order() const;
  ::injective::exchange::v1beta1::DerivativeMarketOrder* _internal_mutable_market_order();
  public:
  void unsafe_arena_set_allocated_market_order(
      ::injective::exchange::v1beta1::DerivativeMarketOrder* market_order);
  ::injective::exchange::v1beta1::DerivativeMarketOrder* unsafe_arena_release_market_order();
  // bool isLimitCancel = 2 [json_name = "isLimitCancel"];
  void clear_islimitcancel() ;
  bool islimitcancel() const;
  void set_islimitcancel(bool value);

  private:
  bool _internal_islimitcancel() const;
  void _internal_set_islimitcancel(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order_;
    ::injective::exchange::v1beta1::DerivativeMarketOrder* market_order_;
    bool islimitcancel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventConditionalDerivativeOrderTrigger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger) */ {
 public:
  inline EventConditionalDerivativeOrderTrigger() : EventConditionalDerivativeOrderTrigger(nullptr) {}
  ~EventConditionalDerivativeOrderTrigger() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventConditionalDerivativeOrderTrigger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventConditionalDerivativeOrderTrigger(const EventConditionalDerivativeOrderTrigger& from);
  EventConditionalDerivativeOrderTrigger(EventConditionalDerivativeOrderTrigger&& from) noexcept
    : EventConditionalDerivativeOrderTrigger() {
    *this = ::std::move(from);
  }

  inline EventConditionalDerivativeOrderTrigger& operator=(const EventConditionalDerivativeOrderTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventConditionalDerivativeOrderTrigger& operator=(EventConditionalDerivativeOrderTrigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventConditionalDerivativeOrderTrigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventConditionalDerivativeOrderTrigger* internal_default_instance() {
    return reinterpret_cast<const EventConditionalDerivativeOrderTrigger*>(
               &_EventConditionalDerivativeOrderTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(EventConditionalDerivativeOrderTrigger& a, EventConditionalDerivativeOrderTrigger& b) {
    a.Swap(&b);
  }
  inline void Swap(EventConditionalDerivativeOrderTrigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventConditionalDerivativeOrderTrigger* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventConditionalDerivativeOrderTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventConditionalDerivativeOrderTrigger>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventConditionalDerivativeOrderTrigger& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventConditionalDerivativeOrderTrigger& from) {
    EventConditionalDerivativeOrderTrigger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventConditionalDerivativeOrderTrigger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger";
  }
  protected:
  explicit EventConditionalDerivativeOrderTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kTriggeredOrderHashFieldNumber = 3,
    kPlacedOrderHashFieldNumber = 4,
    kIsLimitTriggerFieldNumber = 2,
  };
  // bytes market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // bytes triggered_order_hash = 3 [json_name = "triggeredOrderHash"];
  void clear_triggered_order_hash() ;
  const std::string& triggered_order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_triggered_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_triggered_order_hash();
  PROTOBUF_NODISCARD std::string* release_triggered_order_hash();
  void set_allocated_triggered_order_hash(std::string* ptr);

  private:
  const std::string& _internal_triggered_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triggered_order_hash(
      const std::string& value);
  std::string* _internal_mutable_triggered_order_hash();

  public:
  // bytes placed_order_hash = 4 [json_name = "placedOrderHash"];
  void clear_placed_order_hash() ;
  const std::string& placed_order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_placed_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_placed_order_hash();
  PROTOBUF_NODISCARD std::string* release_placed_order_hash();
  void set_allocated_placed_order_hash(std::string* ptr);

  private:
  const std::string& _internal_placed_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placed_order_hash(
      const std::string& value);
  std::string* _internal_mutable_placed_order_hash();

  public:
  // bool isLimitTrigger = 2 [json_name = "isLimitTrigger"];
  void clear_islimittrigger() ;
  bool islimittrigger() const;
  void set_islimittrigger(bool value);

  private:
  bool _internal_islimittrigger() const;
  void _internal_set_islimittrigger(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr triggered_order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placed_order_hash_;
    bool islimittrigger_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventOrderFail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventOrderFail) */ {
 public:
  inline EventOrderFail() : EventOrderFail(nullptr) {}
  ~EventOrderFail() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventOrderFail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventOrderFail(const EventOrderFail& from);
  EventOrderFail(EventOrderFail&& from) noexcept
    : EventOrderFail() {
    *this = ::std::move(from);
  }

  inline EventOrderFail& operator=(const EventOrderFail& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventOrderFail& operator=(EventOrderFail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventOrderFail& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventOrderFail* internal_default_instance() {
    return reinterpret_cast<const EventOrderFail*>(
               &_EventOrderFail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(EventOrderFail& a, EventOrderFail& b) {
    a.Swap(&b);
  }
  inline void Swap(EventOrderFail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventOrderFail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventOrderFail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventOrderFail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventOrderFail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventOrderFail& from) {
    EventOrderFail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventOrderFail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventOrderFail";
  }
  protected:
  explicit EventOrderFail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kAccountFieldNumber = 1,
  };
  // repeated bytes hashes = 2 [json_name = "hashes"];
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;

  public:
  void clear_hashes() ;
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const void* value, std::size_t size);
  void set_hashes(int index, absl::string_view value);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const void* value, std::size_t size);
  void add_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();

  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_hashes();

  public:
  // repeated uint32 flags = 3 [json_name = "flags"];
  int flags_size() const;
  private:
  int _internal_flags_size() const;

  public:
  void clear_flags() ;
  ::uint32_t flags(int index) const;
  void set_flags(int index, ::uint32_t value);
  void add_flags(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& flags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* mutable_flags();

  private:
  ::uint32_t _internal_flags(int index) const;
  void _internal_add_flags(::uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& _internal_flags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* _internal_mutable_flags();

  public:
  // bytes account = 1 [json_name = "account"];
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventOrderFail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t> flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _flags_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventAtomicMarketOrderFeeMultipliersUpdated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated) */ {
 public:
  inline EventAtomicMarketOrderFeeMultipliersUpdated() : EventAtomicMarketOrderFeeMultipliersUpdated(nullptr) {}
  ~EventAtomicMarketOrderFeeMultipliersUpdated() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventAtomicMarketOrderFeeMultipliersUpdated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAtomicMarketOrderFeeMultipliersUpdated(const EventAtomicMarketOrderFeeMultipliersUpdated& from);
  EventAtomicMarketOrderFeeMultipliersUpdated(EventAtomicMarketOrderFeeMultipliersUpdated&& from) noexcept
    : EventAtomicMarketOrderFeeMultipliersUpdated() {
    *this = ::std::move(from);
  }

  inline EventAtomicMarketOrderFeeMultipliersUpdated& operator=(const EventAtomicMarketOrderFeeMultipliersUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAtomicMarketOrderFeeMultipliersUpdated& operator=(EventAtomicMarketOrderFeeMultipliersUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAtomicMarketOrderFeeMultipliersUpdated& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAtomicMarketOrderFeeMultipliersUpdated* internal_default_instance() {
    return reinterpret_cast<const EventAtomicMarketOrderFeeMultipliersUpdated*>(
               &_EventAtomicMarketOrderFeeMultipliersUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(EventAtomicMarketOrderFeeMultipliersUpdated& a, EventAtomicMarketOrderFeeMultipliersUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAtomicMarketOrderFeeMultipliersUpdated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAtomicMarketOrderFeeMultipliersUpdated* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAtomicMarketOrderFeeMultipliersUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAtomicMarketOrderFeeMultipliersUpdated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAtomicMarketOrderFeeMultipliersUpdated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventAtomicMarketOrderFeeMultipliersUpdated& from) {
    EventAtomicMarketOrderFeeMultipliersUpdated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAtomicMarketOrderFeeMultipliersUpdated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated";
  }
  protected:
  explicit EventAtomicMarketOrderFeeMultipliersUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFeeMultipliersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1 [json_name = "marketFeeMultipliers"];
  int market_fee_multipliers_size() const;
  private:
  int _internal_market_fee_multipliers_size() const;

  public:
  void clear_market_fee_multipliers() ;
  ::injective::exchange::v1beta1::MarketFeeMultiplier* mutable_market_fee_multipliers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >*
      mutable_market_fee_multipliers();
  private:
  const ::injective::exchange::v1beta1::MarketFeeMultiplier& _internal_market_fee_multipliers(int index) const;
  ::injective::exchange::v1beta1::MarketFeeMultiplier* _internal_add_market_fee_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>& _internal_market_fee_multipliers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>* _internal_mutable_market_fee_multipliers();
  public:
  const ::injective::exchange::v1beta1::MarketFeeMultiplier& market_fee_multipliers(int index) const;
  ::injective::exchange::v1beta1::MarketFeeMultiplier* add_market_fee_multipliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >&
      market_fee_multipliers() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier > market_fee_multipliers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class EventOrderbookUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EventOrderbookUpdate) */ {
 public:
  inline EventOrderbookUpdate() : EventOrderbookUpdate(nullptr) {}
  ~EventOrderbookUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventOrderbookUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventOrderbookUpdate(const EventOrderbookUpdate& from);
  EventOrderbookUpdate(EventOrderbookUpdate&& from) noexcept
    : EventOrderbookUpdate() {
    *this = ::std::move(from);
  }

  inline EventOrderbookUpdate& operator=(const EventOrderbookUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventOrderbookUpdate& operator=(EventOrderbookUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventOrderbookUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventOrderbookUpdate* internal_default_instance() {
    return reinterpret_cast<const EventOrderbookUpdate*>(
               &_EventOrderbookUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(EventOrderbookUpdate& a, EventOrderbookUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(EventOrderbookUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventOrderbookUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventOrderbookUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventOrderbookUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventOrderbookUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventOrderbookUpdate& from) {
    EventOrderbookUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventOrderbookUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EventOrderbookUpdate";
  }
  protected:
  explicit EventOrderbookUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpotUpdatesFieldNumber = 1,
    kDerivativeUpdatesFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1 [json_name = "spotUpdates"];
  int spot_updates_size() const;
  private:
  int _internal_spot_updates_size() const;

  public:
  void clear_spot_updates() ;
  ::injective::exchange::v1beta1::OrderbookUpdate* mutable_spot_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >*
      mutable_spot_updates();
  private:
  const ::injective::exchange::v1beta1::OrderbookUpdate& _internal_spot_updates(int index) const;
  ::injective::exchange::v1beta1::OrderbookUpdate* _internal_add_spot_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>& _internal_spot_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>* _internal_mutable_spot_updates();
  public:
  const ::injective::exchange::v1beta1::OrderbookUpdate& spot_updates(int index) const;
  ::injective::exchange::v1beta1::OrderbookUpdate* add_spot_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >&
      spot_updates() const;
  // repeated .injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2 [json_name = "derivativeUpdates"];
  int derivative_updates_size() const;
  private:
  int _internal_derivative_updates_size() const;

  public:
  void clear_derivative_updates() ;
  ::injective::exchange::v1beta1::OrderbookUpdate* mutable_derivative_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >*
      mutable_derivative_updates();
  private:
  const ::injective::exchange::v1beta1::OrderbookUpdate& _internal_derivative_updates(int index) const;
  ::injective::exchange::v1beta1::OrderbookUpdate* _internal_add_derivative_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>& _internal_derivative_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>* _internal_mutable_derivative_updates();
  public:
  const ::injective::exchange::v1beta1::OrderbookUpdate& derivative_updates(int index) const;
  ::injective::exchange::v1beta1::OrderbookUpdate* add_derivative_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >&
      derivative_updates() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EventOrderbookUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate > spot_updates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate > derivative_updates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class OrderbookUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.OrderbookUpdate) */ {
 public:
  inline OrderbookUpdate() : OrderbookUpdate(nullptr) {}
  ~OrderbookUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookUpdate(const OrderbookUpdate& from);
  OrderbookUpdate(OrderbookUpdate&& from) noexcept
    : OrderbookUpdate() {
    *this = ::std::move(from);
  }

  inline OrderbookUpdate& operator=(const OrderbookUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookUpdate& operator=(OrderbookUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookUpdate* internal_default_instance() {
    return reinterpret_cast<const OrderbookUpdate*>(
               &_OrderbookUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(OrderbookUpdate& a, OrderbookUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookUpdate& from) {
    OrderbookUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.OrderbookUpdate";
  }
  protected:
  explicit OrderbookUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbookFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.Orderbook orderbook = 2 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective::exchange::v1beta1::Orderbook& orderbook() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Orderbook* release_orderbook();
  ::injective::exchange::v1beta1::Orderbook* mutable_orderbook();
  void set_allocated_orderbook(::injective::exchange::v1beta1::Orderbook* orderbook);
  private:
  const ::injective::exchange::v1beta1::Orderbook& _internal_orderbook() const;
  ::injective::exchange::v1beta1::Orderbook* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective::exchange::v1beta1::Orderbook* orderbook);
  ::injective::exchange::v1beta1::Orderbook* unsafe_arena_release_orderbook();
  // uint64 seq = 1 [json_name = "seq"];
  void clear_seq() ;
  ::uint64_t seq() const;
  void set_seq(::uint64_t value);

  private:
  ::uint64_t _internal_seq() const;
  void _internal_set_seq(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.OrderbookUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::Orderbook* orderbook_;
    ::uint64_t seq_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};// -------------------------------------------------------------------

class Orderbook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.Orderbook) */ {
 public:
  inline Orderbook() : Orderbook(nullptr) {}
  ~Orderbook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Orderbook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orderbook(const Orderbook& from);
  Orderbook(Orderbook&& from) noexcept
    : Orderbook() {
    *this = ::std::move(from);
  }

  inline Orderbook& operator=(const Orderbook& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orderbook& operator=(Orderbook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orderbook& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orderbook* internal_default_instance() {
    return reinterpret_cast<const Orderbook*>(
               &_Orderbook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Orderbook& a, Orderbook& b) {
    a.Swap(&b);
  }
  inline void Swap(Orderbook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orderbook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orderbook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Orderbook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orderbook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Orderbook& from) {
    Orderbook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orderbook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.Orderbook";
  }
  protected:
  explicit Orderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuyLevelsFieldNumber = 2,
    kSellLevelsFieldNumber = 3,
    kMarketIdFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.Level buy_levels = 2 [json_name = "buyLevels"];
  int buy_levels_size() const;
  private:
  int _internal_buy_levels_size() const;

  public:
  void clear_buy_levels() ;
  ::injective::exchange::v1beta1::Level* mutable_buy_levels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
      mutable_buy_levels();
  private:
  const ::injective::exchange::v1beta1::Level& _internal_buy_levels(int index) const;
  ::injective::exchange::v1beta1::Level* _internal_add_buy_levels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>& _internal_buy_levels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>* _internal_mutable_buy_levels();
  public:
  const ::injective::exchange::v1beta1::Level& buy_levels(int index) const;
  ::injective::exchange::v1beta1::Level* add_buy_levels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
      buy_levels() const;
  // repeated .injective.exchange.v1beta1.Level sell_levels = 3 [json_name = "sellLevels"];
  int sell_levels_size() const;
  private:
  int _internal_sell_levels_size() const;

  public:
  void clear_sell_levels() ;
  ::injective::exchange::v1beta1::Level* mutable_sell_levels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
      mutable_sell_levels();
  private:
  const ::injective::exchange::v1beta1::Level& _internal_sell_levels(int index) const;
  ::injective::exchange::v1beta1::Level* _internal_add_sell_levels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>& _internal_sell_levels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>* _internal_mutable_sell_levels();
  public:
  const ::injective::exchange::v1beta1::Level& sell_levels(int index) const;
  ::injective::exchange::v1beta1::Level* add_sell_levels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
      sell_levels() const;
  // bytes market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.Orderbook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level > buy_levels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level > sell_levels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fevents_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EventBatchSpotExecution

// string market_id = 1 [json_name = "marketId"];
inline void EventBatchSpotExecution::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventBatchSpotExecution::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchSpotExecution.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventBatchSpotExecution::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchSpotExecution.market_id)
}
inline std::string* EventBatchSpotExecution::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchSpotExecution.market_id)
  return _s;
}
inline const std::string& EventBatchSpotExecution::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventBatchSpotExecution::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventBatchSpotExecution::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventBatchSpotExecution::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventBatchSpotExecution.market_id)
  return _impl_.market_id_.Release();
}
inline void EventBatchSpotExecution::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventBatchSpotExecution.market_id)
}

// bool is_buy = 2 [json_name = "isBuy"];
inline void EventBatchSpotExecution::clear_is_buy() {
  _impl_.is_buy_ = false;
}
inline bool EventBatchSpotExecution::is_buy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchSpotExecution.is_buy)
  return _internal_is_buy();
}
inline void EventBatchSpotExecution::set_is_buy(bool value) {
  _internal_set_is_buy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchSpotExecution.is_buy)
}
inline bool EventBatchSpotExecution::_internal_is_buy() const {
  return _impl_.is_buy_;
}
inline void EventBatchSpotExecution::_internal_set_is_buy(bool value) {
  ;
  _impl_.is_buy_ = value;
}

// .injective.exchange.v1beta1.ExecutionType executionType = 3 [json_name = "executionType"];
inline void EventBatchSpotExecution::clear_executiontype() {
  _impl_.executiontype_ = 0;
}
inline ::injective::exchange::v1beta1::ExecutionType EventBatchSpotExecution::executiontype() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchSpotExecution.executionType)
  return _internal_executiontype();
}
inline void EventBatchSpotExecution::set_executiontype(::injective::exchange::v1beta1::ExecutionType value) {
   _internal_set_executiontype(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchSpotExecution.executionType)
}
inline ::injective::exchange::v1beta1::ExecutionType EventBatchSpotExecution::_internal_executiontype() const {
  return static_cast<::injective::exchange::v1beta1::ExecutionType>(_impl_.executiontype_);
}
inline void EventBatchSpotExecution::_internal_set_executiontype(::injective::exchange::v1beta1::ExecutionType value) {
  ;
  _impl_.executiontype_ = value;
}

// repeated .injective.exchange.v1beta1.TradeLog trades = 4 [json_name = "trades"];
inline int EventBatchSpotExecution::_internal_trades_size() const {
  return _impl_.trades_.size();
}
inline int EventBatchSpotExecution::trades_size() const {
  return _internal_trades_size();
}
inline ::injective::exchange::v1beta1::TradeLog* EventBatchSpotExecution::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchSpotExecution.trades)
  return _internal_mutable_trades()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeLog >*
EventBatchSpotExecution::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventBatchSpotExecution.trades)
  return _internal_mutable_trades();
}
inline const ::injective::exchange::v1beta1::TradeLog& EventBatchSpotExecution::_internal_trades(int index) const {
  return _internal_trades().Get(index);
}
inline const ::injective::exchange::v1beta1::TradeLog& EventBatchSpotExecution::trades(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchSpotExecution.trades)
  return _internal_trades(index);
}
inline ::injective::exchange::v1beta1::TradeLog* EventBatchSpotExecution::_internal_add_trades() {
  return _internal_mutable_trades()->Add();
}
inline ::injective::exchange::v1beta1::TradeLog* EventBatchSpotExecution::add_trades() {
  ::injective::exchange::v1beta1::TradeLog* _add = _internal_add_trades();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventBatchSpotExecution.trades)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeLog >&
EventBatchSpotExecution::trades() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventBatchSpotExecution.trades)
  return _internal_trades();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeLog>&
EventBatchSpotExecution::_internal_trades() const {
  return _impl_.trades_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeLog>*
EventBatchSpotExecution::_internal_mutable_trades() {
  return &_impl_.trades_;
}

// -------------------------------------------------------------------

// EventBatchDerivativeExecution

// string market_id = 1 [json_name = "marketId"];
inline void EventBatchDerivativeExecution::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventBatchDerivativeExecution::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativeExecution.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventBatchDerivativeExecution::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchDerivativeExecution.market_id)
}
inline std::string* EventBatchDerivativeExecution::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchDerivativeExecution.market_id)
  return _s;
}
inline const std::string& EventBatchDerivativeExecution::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventBatchDerivativeExecution::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventBatchDerivativeExecution::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventBatchDerivativeExecution::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventBatchDerivativeExecution.market_id)
  return _impl_.market_id_.Release();
}
inline void EventBatchDerivativeExecution::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventBatchDerivativeExecution.market_id)
}

// bool is_buy = 2 [json_name = "isBuy"];
inline void EventBatchDerivativeExecution::clear_is_buy() {
  _impl_.is_buy_ = false;
}
inline bool EventBatchDerivativeExecution::is_buy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativeExecution.is_buy)
  return _internal_is_buy();
}
inline void EventBatchDerivativeExecution::set_is_buy(bool value) {
  _internal_set_is_buy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchDerivativeExecution.is_buy)
}
inline bool EventBatchDerivativeExecution::_internal_is_buy() const {
  return _impl_.is_buy_;
}
inline void EventBatchDerivativeExecution::_internal_set_is_buy(bool value) {
  ;
  _impl_.is_buy_ = value;
}

// bool is_liquidation = 3 [json_name = "isLiquidation"];
inline void EventBatchDerivativeExecution::clear_is_liquidation() {
  _impl_.is_liquidation_ = false;
}
inline bool EventBatchDerivativeExecution::is_liquidation() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativeExecution.is_liquidation)
  return _internal_is_liquidation();
}
inline void EventBatchDerivativeExecution::set_is_liquidation(bool value) {
  _internal_set_is_liquidation(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchDerivativeExecution.is_liquidation)
}
inline bool EventBatchDerivativeExecution::_internal_is_liquidation() const {
  return _impl_.is_liquidation_;
}
inline void EventBatchDerivativeExecution::_internal_set_is_liquidation(bool value) {
  ;
  _impl_.is_liquidation_ = value;
}

// string cumulative_funding = 4 [json_name = "cumulativeFunding", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EventBatchDerivativeExecution::clear_cumulative_funding() {
  _impl_.cumulative_funding_.ClearToEmpty();
}
inline const std::string& EventBatchDerivativeExecution::cumulative_funding() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativeExecution.cumulative_funding)
  return _internal_cumulative_funding();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventBatchDerivativeExecution::set_cumulative_funding(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cumulative_funding_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchDerivativeExecution.cumulative_funding)
}
inline std::string* EventBatchDerivativeExecution::mutable_cumulative_funding() {
  std::string* _s = _internal_mutable_cumulative_funding();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchDerivativeExecution.cumulative_funding)
  return _s;
}
inline const std::string& EventBatchDerivativeExecution::_internal_cumulative_funding() const {
  return _impl_.cumulative_funding_.Get();
}
inline void EventBatchDerivativeExecution::_internal_set_cumulative_funding(const std::string& value) {
  ;


  _impl_.cumulative_funding_.Set(value, GetArenaForAllocation());
}
inline std::string* EventBatchDerivativeExecution::_internal_mutable_cumulative_funding() {
  ;
  return _impl_.cumulative_funding_.Mutable( GetArenaForAllocation());
}
inline std::string* EventBatchDerivativeExecution::release_cumulative_funding() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventBatchDerivativeExecution.cumulative_funding)
  return _impl_.cumulative_funding_.Release();
}
inline void EventBatchDerivativeExecution::set_allocated_cumulative_funding(std::string* value) {
  _impl_.cumulative_funding_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cumulative_funding_.IsDefault()) {
          _impl_.cumulative_funding_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventBatchDerivativeExecution.cumulative_funding)
}

// .injective.exchange.v1beta1.ExecutionType executionType = 5 [json_name = "executionType"];
inline void EventBatchDerivativeExecution::clear_executiontype() {
  _impl_.executiontype_ = 0;
}
inline ::injective::exchange::v1beta1::ExecutionType EventBatchDerivativeExecution::executiontype() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativeExecution.executionType)
  return _internal_executiontype();
}
inline void EventBatchDerivativeExecution::set_executiontype(::injective::exchange::v1beta1::ExecutionType value) {
   _internal_set_executiontype(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchDerivativeExecution.executionType)
}
inline ::injective::exchange::v1beta1::ExecutionType EventBatchDerivativeExecution::_internal_executiontype() const {
  return static_cast<::injective::exchange::v1beta1::ExecutionType>(_impl_.executiontype_);
}
inline void EventBatchDerivativeExecution::_internal_set_executiontype(::injective::exchange::v1beta1::ExecutionType value) {
  ;
  _impl_.executiontype_ = value;
}

// repeated .injective.exchange.v1beta1.DerivativeTradeLog trades = 6 [json_name = "trades"];
inline int EventBatchDerivativeExecution::_internal_trades_size() const {
  return _impl_.trades_.size();
}
inline int EventBatchDerivativeExecution::trades_size() const {
  return _internal_trades_size();
}
inline ::injective::exchange::v1beta1::DerivativeTradeLog* EventBatchDerivativeExecution::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchDerivativeExecution.trades)
  return _internal_mutable_trades()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeTradeLog >*
EventBatchDerivativeExecution::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventBatchDerivativeExecution.trades)
  return _internal_mutable_trades();
}
inline const ::injective::exchange::v1beta1::DerivativeTradeLog& EventBatchDerivativeExecution::_internal_trades(int index) const {
  return _internal_trades().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativeTradeLog& EventBatchDerivativeExecution::trades(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativeExecution.trades)
  return _internal_trades(index);
}
inline ::injective::exchange::v1beta1::DerivativeTradeLog* EventBatchDerivativeExecution::_internal_add_trades() {
  return _internal_mutable_trades()->Add();
}
inline ::injective::exchange::v1beta1::DerivativeTradeLog* EventBatchDerivativeExecution::add_trades() {
  ::injective::exchange::v1beta1::DerivativeTradeLog* _add = _internal_add_trades();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventBatchDerivativeExecution.trades)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeTradeLog >&
EventBatchDerivativeExecution::trades() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventBatchDerivativeExecution.trades)
  return _internal_trades();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeTradeLog>&
EventBatchDerivativeExecution::_internal_trades() const {
  return _impl_.trades_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeTradeLog>*
EventBatchDerivativeExecution::_internal_mutable_trades() {
  return &_impl_.trades_;
}

// -------------------------------------------------------------------

// EventLostFundsFromLiquidation

// string market_id = 1 [json_name = "marketId"];
inline void EventLostFundsFromLiquidation::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventLostFundsFromLiquidation::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventLostFundsFromLiquidation.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventLostFundsFromLiquidation::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventLostFundsFromLiquidation.market_id)
}
inline std::string* EventLostFundsFromLiquidation::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventLostFundsFromLiquidation.market_id)
  return _s;
}
inline const std::string& EventLostFundsFromLiquidation::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventLostFundsFromLiquidation::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventLostFundsFromLiquidation.market_id)
  return _impl_.market_id_.Release();
}
inline void EventLostFundsFromLiquidation::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventLostFundsFromLiquidation.market_id)
}

// bytes subaccount_id = 2 [json_name = "subaccountId"];
inline void EventLostFundsFromLiquidation::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& EventLostFundsFromLiquidation::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventLostFundsFromLiquidation.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventLostFundsFromLiquidation::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventLostFundsFromLiquidation.subaccount_id)
}
inline std::string* EventLostFundsFromLiquidation::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventLostFundsFromLiquidation.subaccount_id)
  return _s;
}
inline const std::string& EventLostFundsFromLiquidation::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void EventLostFundsFromLiquidation::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventLostFundsFromLiquidation.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void EventLostFundsFromLiquidation::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventLostFundsFromLiquidation.subaccount_id)
}

// string lost_funds_from_available_during_payout = 3 [json_name = "lostFundsFromAvailableDuringPayout", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EventLostFundsFromLiquidation::clear_lost_funds_from_available_during_payout() {
  _impl_.lost_funds_from_available_during_payout_.ClearToEmpty();
}
inline const std::string& EventLostFundsFromLiquidation::lost_funds_from_available_during_payout() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_available_during_payout)
  return _internal_lost_funds_from_available_during_payout();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventLostFundsFromLiquidation::set_lost_funds_from_available_during_payout(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.lost_funds_from_available_during_payout_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_available_during_payout)
}
inline std::string* EventLostFundsFromLiquidation::mutable_lost_funds_from_available_during_payout() {
  std::string* _s = _internal_mutable_lost_funds_from_available_during_payout();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_available_during_payout)
  return _s;
}
inline const std::string& EventLostFundsFromLiquidation::_internal_lost_funds_from_available_during_payout() const {
  return _impl_.lost_funds_from_available_during_payout_.Get();
}
inline void EventLostFundsFromLiquidation::_internal_set_lost_funds_from_available_during_payout(const std::string& value) {
  ;


  _impl_.lost_funds_from_available_during_payout_.Set(value, GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::_internal_mutable_lost_funds_from_available_during_payout() {
  ;
  return _impl_.lost_funds_from_available_during_payout_.Mutable( GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::release_lost_funds_from_available_during_payout() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_available_during_payout)
  return _impl_.lost_funds_from_available_during_payout_.Release();
}
inline void EventLostFundsFromLiquidation::set_allocated_lost_funds_from_available_during_payout(std::string* value) {
  _impl_.lost_funds_from_available_during_payout_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lost_funds_from_available_during_payout_.IsDefault()) {
          _impl_.lost_funds_from_available_during_payout_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_available_during_payout)
}

// string lost_funds_from_order_cancels = 4 [json_name = "lostFundsFromOrderCancels", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EventLostFundsFromLiquidation::clear_lost_funds_from_order_cancels() {
  _impl_.lost_funds_from_order_cancels_.ClearToEmpty();
}
inline const std::string& EventLostFundsFromLiquidation::lost_funds_from_order_cancels() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_order_cancels)
  return _internal_lost_funds_from_order_cancels();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventLostFundsFromLiquidation::set_lost_funds_from_order_cancels(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.lost_funds_from_order_cancels_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_order_cancels)
}
inline std::string* EventLostFundsFromLiquidation::mutable_lost_funds_from_order_cancels() {
  std::string* _s = _internal_mutable_lost_funds_from_order_cancels();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_order_cancels)
  return _s;
}
inline const std::string& EventLostFundsFromLiquidation::_internal_lost_funds_from_order_cancels() const {
  return _impl_.lost_funds_from_order_cancels_.Get();
}
inline void EventLostFundsFromLiquidation::_internal_set_lost_funds_from_order_cancels(const std::string& value) {
  ;


  _impl_.lost_funds_from_order_cancels_.Set(value, GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::_internal_mutable_lost_funds_from_order_cancels() {
  ;
  return _impl_.lost_funds_from_order_cancels_.Mutable( GetArenaForAllocation());
}
inline std::string* EventLostFundsFromLiquidation::release_lost_funds_from_order_cancels() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_order_cancels)
  return _impl_.lost_funds_from_order_cancels_.Release();
}
inline void EventLostFundsFromLiquidation::set_allocated_lost_funds_from_order_cancels(std::string* value) {
  _impl_.lost_funds_from_order_cancels_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lost_funds_from_order_cancels_.IsDefault()) {
          _impl_.lost_funds_from_order_cancels_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventLostFundsFromLiquidation.lost_funds_from_order_cancels)
}

// -------------------------------------------------------------------

// EventBatchDerivativePosition

// string market_id = 1 [json_name = "marketId"];
inline void EventBatchDerivativePosition::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventBatchDerivativePosition::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativePosition.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventBatchDerivativePosition::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventBatchDerivativePosition.market_id)
}
inline std::string* EventBatchDerivativePosition::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchDerivativePosition.market_id)
  return _s;
}
inline const std::string& EventBatchDerivativePosition::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventBatchDerivativePosition::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventBatchDerivativePosition::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventBatchDerivativePosition::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventBatchDerivativePosition.market_id)
  return _impl_.market_id_.Release();
}
inline void EventBatchDerivativePosition::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventBatchDerivativePosition.market_id)
}

// repeated .injective.exchange.v1beta1.SubaccountPosition positions = 2 [json_name = "positions"];
inline int EventBatchDerivativePosition::_internal_positions_size() const {
  return _impl_.positions_.size();
}
inline int EventBatchDerivativePosition::positions_size() const {
  return _internal_positions_size();
}
inline ::injective::exchange::v1beta1::SubaccountPosition* EventBatchDerivativePosition::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchDerivativePosition.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountPosition >*
EventBatchDerivativePosition::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventBatchDerivativePosition.positions)
  return _internal_mutable_positions();
}
inline const ::injective::exchange::v1beta1::SubaccountPosition& EventBatchDerivativePosition::_internal_positions(int index) const {
  return _internal_positions().Get(index);
}
inline const ::injective::exchange::v1beta1::SubaccountPosition& EventBatchDerivativePosition::positions(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDerivativePosition.positions)
  return _internal_positions(index);
}
inline ::injective::exchange::v1beta1::SubaccountPosition* EventBatchDerivativePosition::_internal_add_positions() {
  return _internal_mutable_positions()->Add();
}
inline ::injective::exchange::v1beta1::SubaccountPosition* EventBatchDerivativePosition::add_positions() {
  ::injective::exchange::v1beta1::SubaccountPosition* _add = _internal_add_positions();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventBatchDerivativePosition.positions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountPosition >&
EventBatchDerivativePosition::positions() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventBatchDerivativePosition.positions)
  return _internal_positions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountPosition>&
EventBatchDerivativePosition::_internal_positions() const {
  return _impl_.positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountPosition>*
EventBatchDerivativePosition::_internal_mutable_positions() {
  return &_impl_.positions_;
}

// -------------------------------------------------------------------

// EventDerivativeMarketPaused

// string market_id = 1 [json_name = "marketId"];
inline void EventDerivativeMarketPaused::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventDerivativeMarketPaused::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventDerivativeMarketPaused.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDerivativeMarketPaused::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventDerivativeMarketPaused.market_id)
}
inline std::string* EventDerivativeMarketPaused::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventDerivativeMarketPaused.market_id)
  return _s;
}
inline const std::string& EventDerivativeMarketPaused::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventDerivativeMarketPaused::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventDerivativeMarketPaused.market_id)
  return _impl_.market_id_.Release();
}
inline void EventDerivativeMarketPaused::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventDerivativeMarketPaused.market_id)
}

// string settle_price = 2 [json_name = "settlePrice"];
inline void EventDerivativeMarketPaused::clear_settle_price() {
  _impl_.settle_price_.ClearToEmpty();
}
inline const std::string& EventDerivativeMarketPaused::settle_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventDerivativeMarketPaused.settle_price)
  return _internal_settle_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDerivativeMarketPaused::set_settle_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settle_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventDerivativeMarketPaused.settle_price)
}
inline std::string* EventDerivativeMarketPaused::mutable_settle_price() {
  std::string* _s = _internal_mutable_settle_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventDerivativeMarketPaused.settle_price)
  return _s;
}
inline const std::string& EventDerivativeMarketPaused::_internal_settle_price() const {
  return _impl_.settle_price_.Get();
}
inline void EventDerivativeMarketPaused::_internal_set_settle_price(const std::string& value) {
  ;


  _impl_.settle_price_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::_internal_mutable_settle_price() {
  ;
  return _impl_.settle_price_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::release_settle_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventDerivativeMarketPaused.settle_price)
  return _impl_.settle_price_.Release();
}
inline void EventDerivativeMarketPaused::set_allocated_settle_price(std::string* value) {
  _impl_.settle_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settle_price_.IsDefault()) {
          _impl_.settle_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventDerivativeMarketPaused.settle_price)
}

// string total_missing_funds = 3 [json_name = "totalMissingFunds"];
inline void EventDerivativeMarketPaused::clear_total_missing_funds() {
  _impl_.total_missing_funds_.ClearToEmpty();
}
inline const std::string& EventDerivativeMarketPaused::total_missing_funds() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventDerivativeMarketPaused.total_missing_funds)
  return _internal_total_missing_funds();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDerivativeMarketPaused::set_total_missing_funds(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_missing_funds_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventDerivativeMarketPaused.total_missing_funds)
}
inline std::string* EventDerivativeMarketPaused::mutable_total_missing_funds() {
  std::string* _s = _internal_mutable_total_missing_funds();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventDerivativeMarketPaused.total_missing_funds)
  return _s;
}
inline const std::string& EventDerivativeMarketPaused::_internal_total_missing_funds() const {
  return _impl_.total_missing_funds_.Get();
}
inline void EventDerivativeMarketPaused::_internal_set_total_missing_funds(const std::string& value) {
  ;


  _impl_.total_missing_funds_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::_internal_mutable_total_missing_funds() {
  ;
  return _impl_.total_missing_funds_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::release_total_missing_funds() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventDerivativeMarketPaused.total_missing_funds)
  return _impl_.total_missing_funds_.Release();
}
inline void EventDerivativeMarketPaused::set_allocated_total_missing_funds(std::string* value) {
  _impl_.total_missing_funds_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_missing_funds_.IsDefault()) {
          _impl_.total_missing_funds_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventDerivativeMarketPaused.total_missing_funds)
}

// string missing_funds_rate = 4 [json_name = "missingFundsRate"];
inline void EventDerivativeMarketPaused::clear_missing_funds_rate() {
  _impl_.missing_funds_rate_.ClearToEmpty();
}
inline const std::string& EventDerivativeMarketPaused::missing_funds_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventDerivativeMarketPaused.missing_funds_rate)
  return _internal_missing_funds_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventDerivativeMarketPaused::set_missing_funds_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.missing_funds_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventDerivativeMarketPaused.missing_funds_rate)
}
inline std::string* EventDerivativeMarketPaused::mutable_missing_funds_rate() {
  std::string* _s = _internal_mutable_missing_funds_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventDerivativeMarketPaused.missing_funds_rate)
  return _s;
}
inline const std::string& EventDerivativeMarketPaused::_internal_missing_funds_rate() const {
  return _impl_.missing_funds_rate_.Get();
}
inline void EventDerivativeMarketPaused::_internal_set_missing_funds_rate(const std::string& value) {
  ;


  _impl_.missing_funds_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::_internal_mutable_missing_funds_rate() {
  ;
  return _impl_.missing_funds_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* EventDerivativeMarketPaused::release_missing_funds_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventDerivativeMarketPaused.missing_funds_rate)
  return _impl_.missing_funds_rate_.Release();
}
inline void EventDerivativeMarketPaused::set_allocated_missing_funds_rate(std::string* value) {
  _impl_.missing_funds_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.missing_funds_rate_.IsDefault()) {
          _impl_.missing_funds_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventDerivativeMarketPaused.missing_funds_rate)
}

// -------------------------------------------------------------------

// EventMarketBeyondBankruptcy

// string market_id = 1 [json_name = "marketId"];
inline void EventMarketBeyondBankruptcy::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventMarketBeyondBankruptcy::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventMarketBeyondBankruptcy::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.market_id)
}
inline std::string* EventMarketBeyondBankruptcy::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.market_id)
  return _s;
}
inline const std::string& EventMarketBeyondBankruptcy::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventMarketBeyondBankruptcy::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventMarketBeyondBankruptcy::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventMarketBeyondBankruptcy::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.market_id)
  return _impl_.market_id_.Release();
}
inline void EventMarketBeyondBankruptcy::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.market_id)
}

// string settle_price = 2 [json_name = "settlePrice"];
inline void EventMarketBeyondBankruptcy::clear_settle_price() {
  _impl_.settle_price_.ClearToEmpty();
}
inline const std::string& EventMarketBeyondBankruptcy::settle_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.settle_price)
  return _internal_settle_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventMarketBeyondBankruptcy::set_settle_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settle_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.settle_price)
}
inline std::string* EventMarketBeyondBankruptcy::mutable_settle_price() {
  std::string* _s = _internal_mutable_settle_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.settle_price)
  return _s;
}
inline const std::string& EventMarketBeyondBankruptcy::_internal_settle_price() const {
  return _impl_.settle_price_.Get();
}
inline void EventMarketBeyondBankruptcy::_internal_set_settle_price(const std::string& value) {
  ;


  _impl_.settle_price_.Set(value, GetArenaForAllocation());
}
inline std::string* EventMarketBeyondBankruptcy::_internal_mutable_settle_price() {
  ;
  return _impl_.settle_price_.Mutable( GetArenaForAllocation());
}
inline std::string* EventMarketBeyondBankruptcy::release_settle_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.settle_price)
  return _impl_.settle_price_.Release();
}
inline void EventMarketBeyondBankruptcy::set_allocated_settle_price(std::string* value) {
  _impl_.settle_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settle_price_.IsDefault()) {
          _impl_.settle_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.settle_price)
}

// string missing_market_funds = 3 [json_name = "missingMarketFunds"];
inline void EventMarketBeyondBankruptcy::clear_missing_market_funds() {
  _impl_.missing_market_funds_.ClearToEmpty();
}
inline const std::string& EventMarketBeyondBankruptcy::missing_market_funds() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.missing_market_funds)
  return _internal_missing_market_funds();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventMarketBeyondBankruptcy::set_missing_market_funds(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.missing_market_funds_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.missing_market_funds)
}
inline std::string* EventMarketBeyondBankruptcy::mutable_missing_market_funds() {
  std::string* _s = _internal_mutable_missing_market_funds();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.missing_market_funds)
  return _s;
}
inline const std::string& EventMarketBeyondBankruptcy::_internal_missing_market_funds() const {
  return _impl_.missing_market_funds_.Get();
}
inline void EventMarketBeyondBankruptcy::_internal_set_missing_market_funds(const std::string& value) {
  ;


  _impl_.missing_market_funds_.Set(value, GetArenaForAllocation());
}
inline std::string* EventMarketBeyondBankruptcy::_internal_mutable_missing_market_funds() {
  ;
  return _impl_.missing_market_funds_.Mutable( GetArenaForAllocation());
}
inline std::string* EventMarketBeyondBankruptcy::release_missing_market_funds() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.missing_market_funds)
  return _impl_.missing_market_funds_.Release();
}
inline void EventMarketBeyondBankruptcy::set_allocated_missing_market_funds(std::string* value) {
  _impl_.missing_market_funds_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.missing_market_funds_.IsDefault()) {
          _impl_.missing_market_funds_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventMarketBeyondBankruptcy.missing_market_funds)
}

// -------------------------------------------------------------------

// EventAllPositionsHaircut

// string market_id = 1 [json_name = "marketId"];
inline void EventAllPositionsHaircut::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventAllPositionsHaircut::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventAllPositionsHaircut.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAllPositionsHaircut::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventAllPositionsHaircut.market_id)
}
inline std::string* EventAllPositionsHaircut::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventAllPositionsHaircut.market_id)
  return _s;
}
inline const std::string& EventAllPositionsHaircut::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventAllPositionsHaircut::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAllPositionsHaircut::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAllPositionsHaircut::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventAllPositionsHaircut.market_id)
  return _impl_.market_id_.Release();
}
inline void EventAllPositionsHaircut::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventAllPositionsHaircut.market_id)
}

// string settle_price = 2 [json_name = "settlePrice"];
inline void EventAllPositionsHaircut::clear_settle_price() {
  _impl_.settle_price_.ClearToEmpty();
}
inline const std::string& EventAllPositionsHaircut::settle_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventAllPositionsHaircut.settle_price)
  return _internal_settle_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAllPositionsHaircut::set_settle_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settle_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventAllPositionsHaircut.settle_price)
}
inline std::string* EventAllPositionsHaircut::mutable_settle_price() {
  std::string* _s = _internal_mutable_settle_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventAllPositionsHaircut.settle_price)
  return _s;
}
inline const std::string& EventAllPositionsHaircut::_internal_settle_price() const {
  return _impl_.settle_price_.Get();
}
inline void EventAllPositionsHaircut::_internal_set_settle_price(const std::string& value) {
  ;


  _impl_.settle_price_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAllPositionsHaircut::_internal_mutable_settle_price() {
  ;
  return _impl_.settle_price_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAllPositionsHaircut::release_settle_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventAllPositionsHaircut.settle_price)
  return _impl_.settle_price_.Release();
}
inline void EventAllPositionsHaircut::set_allocated_settle_price(std::string* value) {
  _impl_.settle_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settle_price_.IsDefault()) {
          _impl_.settle_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventAllPositionsHaircut.settle_price)
}

// string missing_funds_rate = 3 [json_name = "missingFundsRate"];
inline void EventAllPositionsHaircut::clear_missing_funds_rate() {
  _impl_.missing_funds_rate_.ClearToEmpty();
}
inline const std::string& EventAllPositionsHaircut::missing_funds_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventAllPositionsHaircut.missing_funds_rate)
  return _internal_missing_funds_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventAllPositionsHaircut::set_missing_funds_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.missing_funds_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventAllPositionsHaircut.missing_funds_rate)
}
inline std::string* EventAllPositionsHaircut::mutable_missing_funds_rate() {
  std::string* _s = _internal_mutable_missing_funds_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventAllPositionsHaircut.missing_funds_rate)
  return _s;
}
inline const std::string& EventAllPositionsHaircut::_internal_missing_funds_rate() const {
  return _impl_.missing_funds_rate_.Get();
}
inline void EventAllPositionsHaircut::_internal_set_missing_funds_rate(const std::string& value) {
  ;


  _impl_.missing_funds_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* EventAllPositionsHaircut::_internal_mutable_missing_funds_rate() {
  ;
  return _impl_.missing_funds_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* EventAllPositionsHaircut::release_missing_funds_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventAllPositionsHaircut.missing_funds_rate)
  return _impl_.missing_funds_rate_.Release();
}
inline void EventAllPositionsHaircut::set_allocated_missing_funds_rate(std::string* value) {
  _impl_.missing_funds_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.missing_funds_rate_.IsDefault()) {
          _impl_.missing_funds_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventAllPositionsHaircut.missing_funds_rate)
}

// -------------------------------------------------------------------

// EventBinaryOptionsMarketUpdate

// .injective.exchange.v1beta1.BinaryOptionsMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
inline bool EventBinaryOptionsMarketUpdate::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarket& EventBinaryOptionsMarketUpdate::_internal_market() const {
  const ::injective::exchange::v1beta1::BinaryOptionsMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::BinaryOptionsMarket&>(
      ::injective::exchange::v1beta1::_BinaryOptionsMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarket& EventBinaryOptionsMarketUpdate::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.market)
  return _internal_market();
}
inline void EventBinaryOptionsMarketUpdate::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::BinaryOptionsMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.market)
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarket* EventBinaryOptionsMarketUpdate::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::BinaryOptionsMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarket* EventBinaryOptionsMarketUpdate::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::BinaryOptionsMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarket* EventBinaryOptionsMarketUpdate::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::BinaryOptionsMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarket* EventBinaryOptionsMarketUpdate::mutable_market() {
  ::injective::exchange::v1beta1::BinaryOptionsMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.market)
  return _msg;
}
inline void EventBinaryOptionsMarketUpdate::set_allocated_market(::injective::exchange::v1beta1::BinaryOptionsMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.market)
}

// -------------------------------------------------------------------

// EventNewSpotOrders

// string market_id = 1 [json_name = "marketId"];
inline void EventNewSpotOrders::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventNewSpotOrders::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewSpotOrders.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewSpotOrders::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventNewSpotOrders.market_id)
}
inline std::string* EventNewSpotOrders::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewSpotOrders.market_id)
  return _s;
}
inline const std::string& EventNewSpotOrders::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventNewSpotOrders::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewSpotOrders::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewSpotOrders::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventNewSpotOrders.market_id)
  return _impl_.market_id_.Release();
}
inline void EventNewSpotOrders::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventNewSpotOrders.market_id)
}

// repeated .injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2 [json_name = "buyOrders"];
inline int EventNewSpotOrders::_internal_buy_orders_size() const {
  return _impl_.buy_orders_.size();
}
inline int EventNewSpotOrders::buy_orders_size() const {
  return _internal_buy_orders_size();
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventNewSpotOrders::mutable_buy_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewSpotOrders.buy_orders)
  return _internal_mutable_buy_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >*
EventNewSpotOrders::mutable_buy_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventNewSpotOrders.buy_orders)
  return _internal_mutable_buy_orders();
}
inline const ::injective::exchange::v1beta1::SpotLimitOrder& EventNewSpotOrders::_internal_buy_orders(int index) const {
  return _internal_buy_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::SpotLimitOrder& EventNewSpotOrders::buy_orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewSpotOrders.buy_orders)
  return _internal_buy_orders(index);
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventNewSpotOrders::_internal_add_buy_orders() {
  return _internal_mutable_buy_orders()->Add();
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventNewSpotOrders::add_buy_orders() {
  ::injective::exchange::v1beta1::SpotLimitOrder* _add = _internal_add_buy_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventNewSpotOrders.buy_orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >&
EventNewSpotOrders::buy_orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventNewSpotOrders.buy_orders)
  return _internal_buy_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>&
EventNewSpotOrders::_internal_buy_orders() const {
  return _impl_.buy_orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>*
EventNewSpotOrders::_internal_mutable_buy_orders() {
  return &_impl_.buy_orders_;
}

// repeated .injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3 [json_name = "sellOrders"];
inline int EventNewSpotOrders::_internal_sell_orders_size() const {
  return _impl_.sell_orders_.size();
}
inline int EventNewSpotOrders::sell_orders_size() const {
  return _internal_sell_orders_size();
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventNewSpotOrders::mutable_sell_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewSpotOrders.sell_orders)
  return _internal_mutable_sell_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >*
EventNewSpotOrders::mutable_sell_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventNewSpotOrders.sell_orders)
  return _internal_mutable_sell_orders();
}
inline const ::injective::exchange::v1beta1::SpotLimitOrder& EventNewSpotOrders::_internal_sell_orders(int index) const {
  return _internal_sell_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::SpotLimitOrder& EventNewSpotOrders::sell_orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewSpotOrders.sell_orders)
  return _internal_sell_orders(index);
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventNewSpotOrders::_internal_add_sell_orders() {
  return _internal_mutable_sell_orders()->Add();
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventNewSpotOrders::add_sell_orders() {
  ::injective::exchange::v1beta1::SpotLimitOrder* _add = _internal_add_sell_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventNewSpotOrders.sell_orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotLimitOrder >&
EventNewSpotOrders::sell_orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventNewSpotOrders.sell_orders)
  return _internal_sell_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>&
EventNewSpotOrders::_internal_sell_orders() const {
  return _impl_.sell_orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotLimitOrder>*
EventNewSpotOrders::_internal_mutable_sell_orders() {
  return &_impl_.sell_orders_;
}

// -------------------------------------------------------------------

// EventNewDerivativeOrders

// string market_id = 1 [json_name = "marketId"];
inline void EventNewDerivativeOrders::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventNewDerivativeOrders::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewDerivativeOrders.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewDerivativeOrders::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventNewDerivativeOrders.market_id)
}
inline std::string* EventNewDerivativeOrders::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewDerivativeOrders.market_id)
  return _s;
}
inline const std::string& EventNewDerivativeOrders::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventNewDerivativeOrders::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewDerivativeOrders::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewDerivativeOrders::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventNewDerivativeOrders.market_id)
  return _impl_.market_id_.Release();
}
inline void EventNewDerivativeOrders::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventNewDerivativeOrders.market_id)
}

// repeated .injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2 [json_name = "buyOrders"];
inline int EventNewDerivativeOrders::_internal_buy_orders_size() const {
  return _impl_.buy_orders_.size();
}
inline int EventNewDerivativeOrders::buy_orders_size() const {
  return _internal_buy_orders_size();
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventNewDerivativeOrders::mutable_buy_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewDerivativeOrders.buy_orders)
  return _internal_mutable_buy_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >*
EventNewDerivativeOrders::mutable_buy_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventNewDerivativeOrders.buy_orders)
  return _internal_mutable_buy_orders();
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventNewDerivativeOrders::_internal_buy_orders(int index) const {
  return _internal_buy_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventNewDerivativeOrders::buy_orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewDerivativeOrders.buy_orders)
  return _internal_buy_orders(index);
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventNewDerivativeOrders::_internal_add_buy_orders() {
  return _internal_mutable_buy_orders()->Add();
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventNewDerivativeOrders::add_buy_orders() {
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _add = _internal_add_buy_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventNewDerivativeOrders.buy_orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >&
EventNewDerivativeOrders::buy_orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventNewDerivativeOrders.buy_orders)
  return _internal_buy_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>&
EventNewDerivativeOrders::_internal_buy_orders() const {
  return _impl_.buy_orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>*
EventNewDerivativeOrders::_internal_mutable_buy_orders() {
  return &_impl_.buy_orders_;
}

// repeated .injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3 [json_name = "sellOrders"];
inline int EventNewDerivativeOrders::_internal_sell_orders_size() const {
  return _impl_.sell_orders_.size();
}
inline int EventNewDerivativeOrders::sell_orders_size() const {
  return _internal_sell_orders_size();
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventNewDerivativeOrders::mutable_sell_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewDerivativeOrders.sell_orders)
  return _internal_mutable_sell_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >*
EventNewDerivativeOrders::mutable_sell_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventNewDerivativeOrders.sell_orders)
  return _internal_mutable_sell_orders();
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventNewDerivativeOrders::_internal_sell_orders(int index) const {
  return _internal_sell_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventNewDerivativeOrders::sell_orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewDerivativeOrders.sell_orders)
  return _internal_sell_orders(index);
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventNewDerivativeOrders::_internal_add_sell_orders() {
  return _internal_mutable_sell_orders()->Add();
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventNewDerivativeOrders::add_sell_orders() {
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _add = _internal_add_sell_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventNewDerivativeOrders.sell_orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativeLimitOrder >&
EventNewDerivativeOrders::sell_orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventNewDerivativeOrders.sell_orders)
  return _internal_sell_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>&
EventNewDerivativeOrders::_internal_sell_orders() const {
  return _impl_.sell_orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativeLimitOrder>*
EventNewDerivativeOrders::_internal_mutable_sell_orders() {
  return &_impl_.sell_orders_;
}

// -------------------------------------------------------------------

// EventCancelSpotOrder

// string market_id = 1 [json_name = "marketId"];
inline void EventCancelSpotOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventCancelSpotOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelSpotOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventCancelSpotOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventCancelSpotOrder.market_id)
}
inline std::string* EventCancelSpotOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelSpotOrder.market_id)
  return _s;
}
inline const std::string& EventCancelSpotOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventCancelSpotOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventCancelSpotOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventCancelSpotOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelSpotOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void EventCancelSpotOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelSpotOrder.market_id)
}

// .injective.exchange.v1beta1.SpotLimitOrder order = 2 [json_name = "order", (.gogoproto.nullable) = false];
inline bool EventCancelSpotOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::SpotLimitOrder& EventCancelSpotOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::SpotLimitOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SpotLimitOrder&>(
      ::injective::exchange::v1beta1::_SpotLimitOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::SpotLimitOrder& EventCancelSpotOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelSpotOrder.order)
  return _internal_order();
}
inline void EventCancelSpotOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::SpotLimitOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventCancelSpotOrder.order)
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventCancelSpotOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotLimitOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventCancelSpotOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelSpotOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotLimitOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventCancelSpotOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SpotLimitOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::SpotLimitOrder* EventCancelSpotOrder::mutable_order() {
  ::injective::exchange::v1beta1::SpotLimitOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelSpotOrder.order)
  return _msg;
}
inline void EventCancelSpotOrder::set_allocated_order(::injective::exchange::v1beta1::SpotLimitOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelSpotOrder.order)
}

// -------------------------------------------------------------------

// EventSpotMarketUpdate

// .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
inline bool EventSpotMarketUpdate::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::SpotMarket& EventSpotMarketUpdate::_internal_market() const {
  const ::injective::exchange::v1beta1::SpotMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SpotMarket&>(
      ::injective::exchange::v1beta1::_SpotMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::SpotMarket& EventSpotMarketUpdate::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSpotMarketUpdate.market)
  return _internal_market();
}
inline void EventSpotMarketUpdate::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::SpotMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventSpotMarketUpdate.market)
}
inline ::injective::exchange::v1beta1::SpotMarket* EventSpotMarketUpdate::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarket* EventSpotMarketUpdate::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSpotMarketUpdate.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarket* EventSpotMarketUpdate::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::SpotMarket* EventSpotMarketUpdate::mutable_market() {
  ::injective::exchange::v1beta1::SpotMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSpotMarketUpdate.market)
  return _msg;
}
inline void EventSpotMarketUpdate::set_allocated_market(::injective::exchange::v1beta1::SpotMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSpotMarketUpdate.market)
}

// -------------------------------------------------------------------

// EventPerpetualMarketUpdate

// .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
inline bool EventPerpetualMarketUpdate::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeMarket& EventPerpetualMarketUpdate::_internal_market() const {
  const ::injective::exchange::v1beta1::DerivativeMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarket&>(
      ::injective::exchange::v1beta1::_DerivativeMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarket& EventPerpetualMarketUpdate::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketUpdate.market)
  return _internal_market();
}
inline void EventPerpetualMarketUpdate::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::DerivativeMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketUpdate.market)
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventPerpetualMarketUpdate::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventPerpetualMarketUpdate::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventPerpetualMarketUpdate.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventPerpetualMarketUpdate::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventPerpetualMarketUpdate::mutable_market() {
  ::injective::exchange::v1beta1::DerivativeMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventPerpetualMarketUpdate.market)
  return _msg;
}
inline void EventPerpetualMarketUpdate::set_allocated_market(::injective::exchange::v1beta1::DerivativeMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketUpdate.market)
}

// .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2 [json_name = "perpetualMarketInfo", (.gogoproto.nullable) = true];
inline bool EventPerpetualMarketUpdate::has_perpetual_market_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.perpetual_market_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PerpetualMarketInfo& EventPerpetualMarketUpdate::_internal_perpetual_market_info() const {
  const ::injective::exchange::v1beta1::PerpetualMarketInfo* p = _impl_.perpetual_market_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PerpetualMarketInfo&>(
      ::injective::exchange::v1beta1::_PerpetualMarketInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketInfo& EventPerpetualMarketUpdate::perpetual_market_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketUpdate.perpetual_market_info)
  return _internal_perpetual_market_info();
}
inline void EventPerpetualMarketUpdate::unsafe_arena_set_allocated_perpetual_market_info(
    ::injective::exchange::v1beta1::PerpetualMarketInfo* perpetual_market_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.perpetual_market_info_);
  }
  _impl_.perpetual_market_info_ = perpetual_market_info;
  if (perpetual_market_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketUpdate.perpetual_market_info)
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* EventPerpetualMarketUpdate::release_perpetual_market_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* temp = _impl_.perpetual_market_info_;
  _impl_.perpetual_market_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* EventPerpetualMarketUpdate::unsafe_arena_release_perpetual_market_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventPerpetualMarketUpdate.perpetual_market_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* temp = _impl_.perpetual_market_info_;
  _impl_.perpetual_market_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* EventPerpetualMarketUpdate::_internal_mutable_perpetual_market_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.perpetual_market_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketInfo>(GetArenaForAllocation());
    _impl_.perpetual_market_info_ = p;
  }
  return _impl_.perpetual_market_info_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* EventPerpetualMarketUpdate::mutable_perpetual_market_info() {
  ::injective::exchange::v1beta1::PerpetualMarketInfo* _msg = _internal_mutable_perpetual_market_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventPerpetualMarketUpdate.perpetual_market_info)
  return _msg;
}
inline void EventPerpetualMarketUpdate::set_allocated_perpetual_market_info(::injective::exchange::v1beta1::PerpetualMarketInfo* perpetual_market_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.perpetual_market_info_);
  }
  if (perpetual_market_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(perpetual_market_info));
    if (message_arena != submessage_arena) {
      perpetual_market_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, perpetual_market_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.perpetual_market_info_ = perpetual_market_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketUpdate.perpetual_market_info)
}

// .injective.exchange.v1beta1.PerpetualMarketFunding funding = 3 [json_name = "funding", (.gogoproto.nullable) = true];
inline bool EventPerpetualMarketUpdate::has_funding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.funding_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& EventPerpetualMarketUpdate::_internal_funding() const {
  const ::injective::exchange::v1beta1::PerpetualMarketFunding* p = _impl_.funding_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PerpetualMarketFunding&>(
      ::injective::exchange::v1beta1::_PerpetualMarketFunding_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& EventPerpetualMarketUpdate::funding() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketUpdate.funding)
  return _internal_funding();
}
inline void EventPerpetualMarketUpdate::unsafe_arena_set_allocated_funding(
    ::injective::exchange::v1beta1::PerpetualMarketFunding* funding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funding_);
  }
  _impl_.funding_ = funding;
  if (funding) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketUpdate.funding)
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketUpdate::release_funding() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.funding_;
  _impl_.funding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketUpdate::unsafe_arena_release_funding() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventPerpetualMarketUpdate.funding)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.funding_;
  _impl_.funding_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketUpdate::_internal_mutable_funding() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.funding_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketFunding>(GetArenaForAllocation());
    _impl_.funding_ = p;
  }
  return _impl_.funding_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketUpdate::mutable_funding() {
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _msg = _internal_mutable_funding();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventPerpetualMarketUpdate.funding)
  return _msg;
}
inline void EventPerpetualMarketUpdate::set_allocated_funding(::injective::exchange::v1beta1::PerpetualMarketFunding* funding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funding_);
  }
  if (funding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(funding));
    if (message_arena != submessage_arena) {
      funding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, funding, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.funding_ = funding;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketUpdate.funding)
}

// -------------------------------------------------------------------

// EventExpiryFuturesMarketUpdate

// .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market", (.gogoproto.nullable) = false];
inline bool EventExpiryFuturesMarketUpdate::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeMarket& EventExpiryFuturesMarketUpdate::_internal_market() const {
  const ::injective::exchange::v1beta1::DerivativeMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarket&>(
      ::injective::exchange::v1beta1::_DerivativeMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarket& EventExpiryFuturesMarketUpdate::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.market)
  return _internal_market();
}
inline void EventExpiryFuturesMarketUpdate::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::DerivativeMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.market)
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventExpiryFuturesMarketUpdate::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventExpiryFuturesMarketUpdate::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventExpiryFuturesMarketUpdate::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* EventExpiryFuturesMarketUpdate::mutable_market() {
  ::injective::exchange::v1beta1::DerivativeMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.market)
  return _msg;
}
inline void EventExpiryFuturesMarketUpdate::set_allocated_market(::injective::exchange::v1beta1::DerivativeMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.market)
}

// .injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3 [json_name = "expiryFuturesMarketInfo", (.gogoproto.nullable) = true];
inline bool EventExpiryFuturesMarketUpdate::has_expiry_futures_market_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiry_futures_market_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& EventExpiryFuturesMarketUpdate::_internal_expiry_futures_market_info() const {
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* p = _impl_.expiry_futures_market_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo&>(
      ::injective::exchange::v1beta1::_ExpiryFuturesMarketInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& EventExpiryFuturesMarketUpdate::expiry_futures_market_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.expiry_futures_market_info)
  return _internal_expiry_futures_market_info();
}
inline void EventExpiryFuturesMarketUpdate::unsafe_arena_set_allocated_expiry_futures_market_info(
    ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* expiry_futures_market_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiry_futures_market_info_);
  }
  _impl_.expiry_futures_market_info_ = expiry_futures_market_info;
  if (expiry_futures_market_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.expiry_futures_market_info)
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* EventExpiryFuturesMarketUpdate::release_expiry_futures_market_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* temp = _impl_.expiry_futures_market_info_;
  _impl_.expiry_futures_market_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* EventExpiryFuturesMarketUpdate::unsafe_arena_release_expiry_futures_market_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.expiry_futures_market_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* temp = _impl_.expiry_futures_market_info_;
  _impl_.expiry_futures_market_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* EventExpiryFuturesMarketUpdate::_internal_mutable_expiry_futures_market_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.expiry_futures_market_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::ExpiryFuturesMarketInfo>(GetArenaForAllocation());
    _impl_.expiry_futures_market_info_ = p;
  }
  return _impl_.expiry_futures_market_info_;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* EventExpiryFuturesMarketUpdate::mutable_expiry_futures_market_info() {
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* _msg = _internal_mutable_expiry_futures_market_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.expiry_futures_market_info)
  return _msg;
}
inline void EventExpiryFuturesMarketUpdate::set_allocated_expiry_futures_market_info(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* expiry_futures_market_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiry_futures_market_info_);
  }
  if (expiry_futures_market_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_futures_market_info));
    if (message_arena != submessage_arena) {
      expiry_futures_market_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiry_futures_market_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.expiry_futures_market_info_ = expiry_futures_market_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.expiry_futures_market_info)
}

// -------------------------------------------------------------------

// EventPerpetualMarketFundingUpdate

// string market_id = 1 [json_name = "marketId"];
inline void EventPerpetualMarketFundingUpdate::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventPerpetualMarketFundingUpdate::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventPerpetualMarketFundingUpdate::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.market_id)
}
inline std::string* EventPerpetualMarketFundingUpdate::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.market_id)
  return _s;
}
inline const std::string& EventPerpetualMarketFundingUpdate::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventPerpetualMarketFundingUpdate::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventPerpetualMarketFundingUpdate::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventPerpetualMarketFundingUpdate::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.market_id)
  return _impl_.market_id_.Release();
}
inline void EventPerpetualMarketFundingUpdate::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.market_id)
}

// .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2 [json_name = "funding", (.gogoproto.nullable) = false];
inline bool EventPerpetualMarketFundingUpdate::has_funding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.funding_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& EventPerpetualMarketFundingUpdate::_internal_funding() const {
  const ::injective::exchange::v1beta1::PerpetualMarketFunding* p = _impl_.funding_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PerpetualMarketFunding&>(
      ::injective::exchange::v1beta1::_PerpetualMarketFunding_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& EventPerpetualMarketFundingUpdate::funding() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding)
  return _internal_funding();
}
inline void EventPerpetualMarketFundingUpdate::unsafe_arena_set_allocated_funding(
    ::injective::exchange::v1beta1::PerpetualMarketFunding* funding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funding_);
  }
  _impl_.funding_ = funding;
  if (funding) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding)
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketFundingUpdate::release_funding() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.funding_;
  _impl_.funding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketFundingUpdate::unsafe_arena_release_funding() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.funding_;
  _impl_.funding_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketFundingUpdate::_internal_mutable_funding() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.funding_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketFunding>(GetArenaForAllocation());
    _impl_.funding_ = p;
  }
  return _impl_.funding_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* EventPerpetualMarketFundingUpdate::mutable_funding() {
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _msg = _internal_mutable_funding();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding)
  return _msg;
}
inline void EventPerpetualMarketFundingUpdate::set_allocated_funding(::injective::exchange::v1beta1::PerpetualMarketFunding* funding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funding_);
  }
  if (funding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(funding));
    if (message_arena != submessage_arena) {
      funding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, funding, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.funding_ = funding;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding)
}

// bool is_hourly_funding = 3 [json_name = "isHourlyFunding"];
inline void EventPerpetualMarketFundingUpdate::clear_is_hourly_funding() {
  _impl_.is_hourly_funding_ = false;
}
inline bool EventPerpetualMarketFundingUpdate::is_hourly_funding() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.is_hourly_funding)
  return _internal_is_hourly_funding();
}
inline void EventPerpetualMarketFundingUpdate::set_is_hourly_funding(bool value) {
  _internal_set_is_hourly_funding(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.is_hourly_funding)
}
inline bool EventPerpetualMarketFundingUpdate::_internal_is_hourly_funding() const {
  return _impl_.is_hourly_funding_;
}
inline void EventPerpetualMarketFundingUpdate::_internal_set_is_hourly_funding(bool value) {
  ;
  _impl_.is_hourly_funding_ = value;
}

// string funding_rate = 4 [json_name = "fundingRate", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EventPerpetualMarketFundingUpdate::clear_funding_rate() {
  _impl_.funding_rate_.ClearToEmpty();
}
inline const std::string& EventPerpetualMarketFundingUpdate::funding_rate() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding_rate)
  return _internal_funding_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventPerpetualMarketFundingUpdate::set_funding_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.funding_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding_rate)
}
inline std::string* EventPerpetualMarketFundingUpdate::mutable_funding_rate() {
  std::string* _s = _internal_mutable_funding_rate();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding_rate)
  return _s;
}
inline const std::string& EventPerpetualMarketFundingUpdate::_internal_funding_rate() const {
  return _impl_.funding_rate_.Get();
}
inline void EventPerpetualMarketFundingUpdate::_internal_set_funding_rate(const std::string& value) {
  ;


  _impl_.funding_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* EventPerpetualMarketFundingUpdate::_internal_mutable_funding_rate() {
  ;
  return _impl_.funding_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* EventPerpetualMarketFundingUpdate::release_funding_rate() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding_rate)
  return _impl_.funding_rate_.Release();
}
inline void EventPerpetualMarketFundingUpdate::set_allocated_funding_rate(std::string* value) {
  _impl_.funding_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.funding_rate_.IsDefault()) {
          _impl_.funding_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.funding_rate)
}

// string mark_price = 5 [json_name = "markPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EventPerpetualMarketFundingUpdate::clear_mark_price() {
  _impl_.mark_price_.ClearToEmpty();
}
inline const std::string& EventPerpetualMarketFundingUpdate::mark_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.mark_price)
  return _internal_mark_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventPerpetualMarketFundingUpdate::set_mark_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mark_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.mark_price)
}
inline std::string* EventPerpetualMarketFundingUpdate::mutable_mark_price() {
  std::string* _s = _internal_mutable_mark_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.mark_price)
  return _s;
}
inline const std::string& EventPerpetualMarketFundingUpdate::_internal_mark_price() const {
  return _impl_.mark_price_.Get();
}
inline void EventPerpetualMarketFundingUpdate::_internal_set_mark_price(const std::string& value) {
  ;


  _impl_.mark_price_.Set(value, GetArenaForAllocation());
}
inline std::string* EventPerpetualMarketFundingUpdate::_internal_mutable_mark_price() {
  ;
  return _impl_.mark_price_.Mutable( GetArenaForAllocation());
}
inline std::string* EventPerpetualMarketFundingUpdate::release_mark_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.mark_price)
  return _impl_.mark_price_.Release();
}
inline void EventPerpetualMarketFundingUpdate::set_allocated_mark_price(std::string* value) {
  _impl_.mark_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mark_price_.IsDefault()) {
          _impl_.mark_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.mark_price)
}

// -------------------------------------------------------------------

// EventSubaccountDeposit

// string src_address = 1 [json_name = "srcAddress"];
inline void EventSubaccountDeposit::clear_src_address() {
  _impl_.src_address_.ClearToEmpty();
}
inline const std::string& EventSubaccountDeposit::src_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountDeposit.src_address)
  return _internal_src_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubaccountDeposit::set_src_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.src_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventSubaccountDeposit.src_address)
}
inline std::string* EventSubaccountDeposit::mutable_src_address() {
  std::string* _s = _internal_mutable_src_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountDeposit.src_address)
  return _s;
}
inline const std::string& EventSubaccountDeposit::_internal_src_address() const {
  return _impl_.src_address_.Get();
}
inline void EventSubaccountDeposit::_internal_set_src_address(const std::string& value) {
  ;


  _impl_.src_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubaccountDeposit::_internal_mutable_src_address() {
  ;
  return _impl_.src_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubaccountDeposit::release_src_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountDeposit.src_address)
  return _impl_.src_address_.Release();
}
inline void EventSubaccountDeposit::set_allocated_src_address(std::string* value) {
  _impl_.src_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_address_.IsDefault()) {
          _impl_.src_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountDeposit.src_address)
}

// bytes subaccount_id = 2 [json_name = "subaccountId"];
inline void EventSubaccountDeposit::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& EventSubaccountDeposit::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountDeposit.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubaccountDeposit::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventSubaccountDeposit.subaccount_id)
}
inline std::string* EventSubaccountDeposit::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountDeposit.subaccount_id)
  return _s;
}
inline const std::string& EventSubaccountDeposit::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void EventSubaccountDeposit::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubaccountDeposit::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubaccountDeposit::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountDeposit.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void EventSubaccountDeposit::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountDeposit.subaccount_id)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool EventSubaccountDeposit::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& EventSubaccountDeposit::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& EventSubaccountDeposit::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountDeposit.amount)
  return _internal_amount();
}
inline void EventSubaccountDeposit::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventSubaccountDeposit.amount)
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountDeposit::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountDeposit::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountDeposit.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountDeposit::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountDeposit::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountDeposit.amount)
  return _msg;
}
inline void EventSubaccountDeposit::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountDeposit.amount)
}

// -------------------------------------------------------------------

// EventSubaccountWithdraw

// bytes subaccount_id = 1 [json_name = "subaccountId"];
inline void EventSubaccountWithdraw::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& EventSubaccountWithdraw::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountWithdraw.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubaccountWithdraw::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventSubaccountWithdraw.subaccount_id)
}
inline std::string* EventSubaccountWithdraw::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountWithdraw.subaccount_id)
  return _s;
}
inline const std::string& EventSubaccountWithdraw::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void EventSubaccountWithdraw::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubaccountWithdraw::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubaccountWithdraw::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountWithdraw.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void EventSubaccountWithdraw::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountWithdraw.subaccount_id)
}

// string dst_address = 2 [json_name = "dstAddress"];
inline void EventSubaccountWithdraw::clear_dst_address() {
  _impl_.dst_address_.ClearToEmpty();
}
inline const std::string& EventSubaccountWithdraw::dst_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountWithdraw.dst_address)
  return _internal_dst_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubaccountWithdraw::set_dst_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dst_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventSubaccountWithdraw.dst_address)
}
inline std::string* EventSubaccountWithdraw::mutable_dst_address() {
  std::string* _s = _internal_mutable_dst_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountWithdraw.dst_address)
  return _s;
}
inline const std::string& EventSubaccountWithdraw::_internal_dst_address() const {
  return _impl_.dst_address_.Get();
}
inline void EventSubaccountWithdraw::_internal_set_dst_address(const std::string& value) {
  ;


  _impl_.dst_address_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubaccountWithdraw::_internal_mutable_dst_address() {
  ;
  return _impl_.dst_address_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubaccountWithdraw::release_dst_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountWithdraw.dst_address)
  return _impl_.dst_address_.Release();
}
inline void EventSubaccountWithdraw::set_allocated_dst_address(std::string* value) {
  _impl_.dst_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_address_.IsDefault()) {
          _impl_.dst_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountWithdraw.dst_address)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool EventSubaccountWithdraw::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& EventSubaccountWithdraw::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& EventSubaccountWithdraw::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountWithdraw.amount)
  return _internal_amount();
}
inline void EventSubaccountWithdraw::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventSubaccountWithdraw.amount)
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountWithdraw::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountWithdraw::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountWithdraw.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountWithdraw::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountWithdraw::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountWithdraw.amount)
  return _msg;
}
inline void EventSubaccountWithdraw::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountWithdraw.amount)
}

// -------------------------------------------------------------------

// EventSubaccountBalanceTransfer

// string src_subaccount_id = 1 [json_name = "srcSubaccountId"];
inline void EventSubaccountBalanceTransfer::clear_src_subaccount_id() {
  _impl_.src_subaccount_id_.ClearToEmpty();
}
inline const std::string& EventSubaccountBalanceTransfer::src_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.src_subaccount_id)
  return _internal_src_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubaccountBalanceTransfer::set_src_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.src_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.src_subaccount_id)
}
inline std::string* EventSubaccountBalanceTransfer::mutable_src_subaccount_id() {
  std::string* _s = _internal_mutable_src_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.src_subaccount_id)
  return _s;
}
inline const std::string& EventSubaccountBalanceTransfer::_internal_src_subaccount_id() const {
  return _impl_.src_subaccount_id_.Get();
}
inline void EventSubaccountBalanceTransfer::_internal_set_src_subaccount_id(const std::string& value) {
  ;


  _impl_.src_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubaccountBalanceTransfer::_internal_mutable_src_subaccount_id() {
  ;
  return _impl_.src_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubaccountBalanceTransfer::release_src_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.src_subaccount_id)
  return _impl_.src_subaccount_id_.Release();
}
inline void EventSubaccountBalanceTransfer::set_allocated_src_subaccount_id(std::string* value) {
  _impl_.src_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_subaccount_id_.IsDefault()) {
          _impl_.src_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.src_subaccount_id)
}

// string dst_subaccount_id = 2 [json_name = "dstSubaccountId"];
inline void EventSubaccountBalanceTransfer::clear_dst_subaccount_id() {
  _impl_.dst_subaccount_id_.ClearToEmpty();
}
inline const std::string& EventSubaccountBalanceTransfer::dst_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.dst_subaccount_id)
  return _internal_dst_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventSubaccountBalanceTransfer::set_dst_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dst_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.dst_subaccount_id)
}
inline std::string* EventSubaccountBalanceTransfer::mutable_dst_subaccount_id() {
  std::string* _s = _internal_mutable_dst_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.dst_subaccount_id)
  return _s;
}
inline const std::string& EventSubaccountBalanceTransfer::_internal_dst_subaccount_id() const {
  return _impl_.dst_subaccount_id_.Get();
}
inline void EventSubaccountBalanceTransfer::_internal_set_dst_subaccount_id(const std::string& value) {
  ;


  _impl_.dst_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventSubaccountBalanceTransfer::_internal_mutable_dst_subaccount_id() {
  ;
  return _impl_.dst_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventSubaccountBalanceTransfer::release_dst_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.dst_subaccount_id)
  return _impl_.dst_subaccount_id_.Release();
}
inline void EventSubaccountBalanceTransfer::set_allocated_dst_subaccount_id(std::string* value) {
  _impl_.dst_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_subaccount_id_.IsDefault()) {
          _impl_.dst_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.dst_subaccount_id)
}

// .cosmos.base.v1beta1.Coin amount = 3 [json_name = "amount", (.gogoproto.nullable) = false];
inline bool EventSubaccountBalanceTransfer::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& EventSubaccountBalanceTransfer::_internal_amount() const {
  const ::cosmos::base::v1beta1::Coin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(
      ::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& EventSubaccountBalanceTransfer::amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.amount)
  return _internal_amount();
}
inline void EventSubaccountBalanceTransfer::unsafe_arena_set_allocated_amount(
    ::cosmos::base::v1beta1::Coin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.amount)
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountBalanceTransfer::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountBalanceTransfer::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountBalanceTransfer::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmos::base::v1beta1::Coin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::cosmos::base::v1beta1::Coin* EventSubaccountBalanceTransfer::mutable_amount() {
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.amount)
  return _msg;
}
inline void EventSubaccountBalanceTransfer::set_allocated_amount(::cosmos::base::v1beta1::Coin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventSubaccountBalanceTransfer.amount)
}

// -------------------------------------------------------------------

// EventBatchDepositUpdate

// repeated .injective.exchange.v1beta1.DepositUpdate deposit_updates = 1 [json_name = "depositUpdates"];
inline int EventBatchDepositUpdate::_internal_deposit_updates_size() const {
  return _impl_.deposit_updates_.size();
}
inline int EventBatchDepositUpdate::deposit_updates_size() const {
  return _internal_deposit_updates_size();
}
inline ::injective::exchange::v1beta1::DepositUpdate* EventBatchDepositUpdate::mutable_deposit_updates(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventBatchDepositUpdate.deposit_updates)
  return _internal_mutable_deposit_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DepositUpdate >*
EventBatchDepositUpdate::mutable_deposit_updates() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventBatchDepositUpdate.deposit_updates)
  return _internal_mutable_deposit_updates();
}
inline const ::injective::exchange::v1beta1::DepositUpdate& EventBatchDepositUpdate::_internal_deposit_updates(int index) const {
  return _internal_deposit_updates().Get(index);
}
inline const ::injective::exchange::v1beta1::DepositUpdate& EventBatchDepositUpdate::deposit_updates(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventBatchDepositUpdate.deposit_updates)
  return _internal_deposit_updates(index);
}
inline ::injective::exchange::v1beta1::DepositUpdate* EventBatchDepositUpdate::_internal_add_deposit_updates() {
  return _internal_mutable_deposit_updates()->Add();
}
inline ::injective::exchange::v1beta1::DepositUpdate* EventBatchDepositUpdate::add_deposit_updates() {
  ::injective::exchange::v1beta1::DepositUpdate* _add = _internal_add_deposit_updates();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventBatchDepositUpdate.deposit_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DepositUpdate >&
EventBatchDepositUpdate::deposit_updates() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventBatchDepositUpdate.deposit_updates)
  return _internal_deposit_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DepositUpdate>&
EventBatchDepositUpdate::_internal_deposit_updates() const {
  return _impl_.deposit_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DepositUpdate>*
EventBatchDepositUpdate::_internal_mutable_deposit_updates() {
  return &_impl_.deposit_updates_;
}

// -------------------------------------------------------------------

// DerivativeMarketOrderCancel

// .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1 [json_name = "marketOrder", (.gogoproto.nullable) = true];
inline bool DerivativeMarketOrderCancel::has_market_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrder& DerivativeMarketOrderCancel::_internal_market_order() const {
  const ::injective::exchange::v1beta1::DerivativeMarketOrder* p = _impl_.market_order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarketOrder&>(
      ::injective::exchange::v1beta1::_DerivativeMarketOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrder& DerivativeMarketOrderCancel::market_order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrderCancel.market_order)
  return _internal_market_order();
}
inline void DerivativeMarketOrderCancel::unsafe_arena_set_allocated_market_order(
    ::injective::exchange::v1beta1::DerivativeMarketOrder* market_order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_order_);
  }
  _impl_.market_order_ = market_order;
  if (market_order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderCancel.market_order)
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* DerivativeMarketOrderCancel::release_market_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarketOrder* temp = _impl_.market_order_;
  _impl_.market_order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* DerivativeMarketOrderCancel::unsafe_arena_release_market_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrderCancel.market_order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarketOrder* temp = _impl_.market_order_;
  _impl_.market_order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* DerivativeMarketOrderCancel::_internal_mutable_market_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrder>(GetArenaForAllocation());
    _impl_.market_order_ = p;
  }
  return _impl_.market_order_;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* DerivativeMarketOrderCancel::mutable_market_order() {
  ::injective::exchange::v1beta1::DerivativeMarketOrder* _msg = _internal_mutable_market_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrderCancel.market_order)
  return _msg;
}
inline void DerivativeMarketOrderCancel::set_allocated_market_order(::injective::exchange::v1beta1::DerivativeMarketOrder* market_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_order_);
  }
  if (market_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_order));
    if (message_arena != submessage_arena) {
      market_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_order_ = market_order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderCancel.market_order)
}

// string cancel_quantity = 2 [json_name = "cancelQuantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void DerivativeMarketOrderCancel::clear_cancel_quantity() {
  _impl_.cancel_quantity_.ClearToEmpty();
}
inline const std::string& DerivativeMarketOrderCancel::cancel_quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.DerivativeMarketOrderCancel.cancel_quantity)
  return _internal_cancel_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketOrderCancel::set_cancel_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cancel_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.DerivativeMarketOrderCancel.cancel_quantity)
}
inline std::string* DerivativeMarketOrderCancel::mutable_cancel_quantity() {
  std::string* _s = _internal_mutable_cancel_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.DerivativeMarketOrderCancel.cancel_quantity)
  return _s;
}
inline const std::string& DerivativeMarketOrderCancel::_internal_cancel_quantity() const {
  return _impl_.cancel_quantity_.Get();
}
inline void DerivativeMarketOrderCancel::_internal_set_cancel_quantity(const std::string& value) {
  ;


  _impl_.cancel_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderCancel::_internal_mutable_cancel_quantity() {
  ;
  return _impl_.cancel_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketOrderCancel::release_cancel_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.DerivativeMarketOrderCancel.cancel_quantity)
  return _impl_.cancel_quantity_.Release();
}
inline void DerivativeMarketOrderCancel::set_allocated_cancel_quantity(std::string* value) {
  _impl_.cancel_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cancel_quantity_.IsDefault()) {
          _impl_.cancel_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.DerivativeMarketOrderCancel.cancel_quantity)
}

// -------------------------------------------------------------------

// EventCancelDerivativeOrder

// string market_id = 1 [json_name = "marketId"];
inline void EventCancelDerivativeOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventCancelDerivativeOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventCancelDerivativeOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_id)
}
inline std::string* EventCancelDerivativeOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_id)
  return _s;
}
inline const std::string& EventCancelDerivativeOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventCancelDerivativeOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventCancelDerivativeOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventCancelDerivativeOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void EventCancelDerivativeOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_id)
}

// bool isLimitCancel = 2 [json_name = "isLimitCancel"];
inline void EventCancelDerivativeOrder::clear_islimitcancel() {
  _impl_.islimitcancel_ = false;
}
inline bool EventCancelDerivativeOrder::islimitcancel() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelDerivativeOrder.isLimitCancel)
  return _internal_islimitcancel();
}
inline void EventCancelDerivativeOrder::set_islimitcancel(bool value) {
  _internal_set_islimitcancel(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventCancelDerivativeOrder.isLimitCancel)
}
inline bool EventCancelDerivativeOrder::_internal_islimitcancel() const {
  return _impl_.islimitcancel_;
}
inline void EventCancelDerivativeOrder::_internal_set_islimitcancel(bool value) {
  ;
  _impl_.islimitcancel_ = value;
}

// .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
inline bool EventCancelDerivativeOrder::has_limit_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limit_order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventCancelDerivativeOrder::_internal_limit_order() const {
  const ::injective::exchange::v1beta1::DerivativeLimitOrder* p = _impl_.limit_order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeLimitOrder&>(
      ::injective::exchange::v1beta1::_DerivativeLimitOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventCancelDerivativeOrder::limit_order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelDerivativeOrder.limit_order)
  return _internal_limit_order();
}
inline void EventCancelDerivativeOrder::unsafe_arena_set_allocated_limit_order(
    ::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limit_order_);
  }
  _impl_.limit_order_ = limit_order;
  if (limit_order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventCancelDerivativeOrder.limit_order)
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelDerivativeOrder::release_limit_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* temp = _impl_.limit_order_;
  _impl_.limit_order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelDerivativeOrder::unsafe_arena_release_limit_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelDerivativeOrder.limit_order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* temp = _impl_.limit_order_;
  _impl_.limit_order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelDerivativeOrder::_internal_mutable_limit_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.limit_order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeLimitOrder>(GetArenaForAllocation());
    _impl_.limit_order_ = p;
  }
  return _impl_.limit_order_;
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelDerivativeOrder::mutable_limit_order() {
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _msg = _internal_mutable_limit_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelDerivativeOrder.limit_order)
  return _msg;
}
inline void EventCancelDerivativeOrder::set_allocated_limit_order(::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limit_order_);
  }
  if (limit_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limit_order));
    if (message_arena != submessage_arena) {
      limit_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.limit_order_ = limit_order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelDerivativeOrder.limit_order)
}

// .injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4 [json_name = "marketOrderCancel", (.gogoproto.nullable) = true];
inline bool EventCancelDerivativeOrder::has_market_order_cancel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_order_cancel_ != nullptr);
  return value;
}
inline void EventCancelDerivativeOrder::clear_market_order_cancel() {
  if (_impl_.market_order_cancel_ != nullptr) _impl_.market_order_cancel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel& EventCancelDerivativeOrder::_internal_market_order_cancel() const {
  const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* p = _impl_.market_order_cancel_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel&>(
      ::injective::exchange::v1beta1::_DerivativeMarketOrderCancel_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrderCancel& EventCancelDerivativeOrder::market_order_cancel() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_order_cancel)
  return _internal_market_order_cancel();
}
inline void EventCancelDerivativeOrder::unsafe_arena_set_allocated_market_order_cancel(
    ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* market_order_cancel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_order_cancel_);
  }
  _impl_.market_order_cancel_ = market_order_cancel;
  if (market_order_cancel) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_order_cancel)
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* EventCancelDerivativeOrder::release_market_order_cancel() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* temp = _impl_.market_order_cancel_;
  _impl_.market_order_cancel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* EventCancelDerivativeOrder::unsafe_arena_release_market_order_cancel() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_order_cancel)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* temp = _impl_.market_order_cancel_;
  _impl_.market_order_cancel_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* EventCancelDerivativeOrder::_internal_mutable_market_order_cancel() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.market_order_cancel_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrderCancel>(GetArenaForAllocation());
    _impl_.market_order_cancel_ = p;
  }
  return _impl_.market_order_cancel_;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* EventCancelDerivativeOrder::mutable_market_order_cancel() {
  ::injective::exchange::v1beta1::DerivativeMarketOrderCancel* _msg = _internal_mutable_market_order_cancel();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_order_cancel)
  return _msg;
}
inline void EventCancelDerivativeOrder::set_allocated_market_order_cancel(::injective::exchange::v1beta1::DerivativeMarketOrderCancel* market_order_cancel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_order_cancel_;
  }
  if (market_order_cancel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market_order_cancel);
    if (message_arena != submessage_arena) {
      market_order_cancel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_order_cancel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.market_order_cancel_ = market_order_cancel;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelDerivativeOrder.market_order_cancel)
}

// -------------------------------------------------------------------

// EventFeeDiscountSchedule

// .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1 [json_name = "schedule"];
inline bool EventFeeDiscountSchedule::has_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedule_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::FeeDiscountSchedule& EventFeeDiscountSchedule::_internal_schedule() const {
  const ::injective::exchange::v1beta1::FeeDiscountSchedule* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::FeeDiscountSchedule&>(
      ::injective::exchange::v1beta1::_FeeDiscountSchedule_default_instance_);
}
inline const ::injective::exchange::v1beta1::FeeDiscountSchedule& EventFeeDiscountSchedule::schedule() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventFeeDiscountSchedule.schedule)
  return _internal_schedule();
}
inline void EventFeeDiscountSchedule::unsafe_arena_set_allocated_schedule(
    ::injective::exchange::v1beta1::FeeDiscountSchedule* schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = schedule;
  if (schedule) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventFeeDiscountSchedule.schedule)
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* EventFeeDiscountSchedule::release_schedule() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* EventFeeDiscountSchedule::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventFeeDiscountSchedule.schedule)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* EventFeeDiscountSchedule::_internal_mutable_schedule() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountSchedule>(GetArenaForAllocation());
    _impl_.schedule_ = p;
  }
  return _impl_.schedule_;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* EventFeeDiscountSchedule::mutable_schedule() {
  ::injective::exchange::v1beta1::FeeDiscountSchedule* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventFeeDiscountSchedule.schedule)
  return _msg;
}
inline void EventFeeDiscountSchedule::set_allocated_schedule(::injective::exchange::v1beta1::FeeDiscountSchedule* schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  if (schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schedule));
    if (message_arena != submessage_arena) {
      schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventFeeDiscountSchedule.schedule)
}

// -------------------------------------------------------------------

// EventTradingRewardCampaignUpdate

// .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1 [json_name = "campaignInfo"];
inline bool EventTradingRewardCampaignUpdate::has_campaign_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.campaign_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& EventTradingRewardCampaignUpdate::_internal_campaign_info() const {
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo* p = _impl_.campaign_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::TradingRewardCampaignInfo&>(
      ::injective::exchange::v1beta1::_TradingRewardCampaignInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& EventTradingRewardCampaignUpdate::campaign_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_info)
  return _internal_campaign_info();
}
inline void EventTradingRewardCampaignUpdate::unsafe_arena_set_allocated_campaign_info(
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.campaign_info_);
  }
  _impl_.campaign_info_ = campaign_info;
  if (campaign_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_info)
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* EventTradingRewardCampaignUpdate::release_campaign_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.campaign_info_;
  _impl_.campaign_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* EventTradingRewardCampaignUpdate::unsafe_arena_release_campaign_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.campaign_info_;
  _impl_.campaign_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* EventTradingRewardCampaignUpdate::_internal_mutable_campaign_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.campaign_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignInfo>(GetArenaForAllocation());
    _impl_.campaign_info_ = p;
  }
  return _impl_.campaign_info_;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* EventTradingRewardCampaignUpdate::mutable_campaign_info() {
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _msg = _internal_mutable_campaign_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_info)
  return _msg;
}
inline void EventTradingRewardCampaignUpdate::set_allocated_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* campaign_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.campaign_info_);
  }
  if (campaign_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(campaign_info));
    if (message_arena != submessage_arena) {
      campaign_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, campaign_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.campaign_info_ = campaign_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_info)
}

// repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2 [json_name = "campaignRewardPools"];
inline int EventTradingRewardCampaignUpdate::_internal_campaign_reward_pools_size() const {
  return _impl_.campaign_reward_pools_.size();
}
inline int EventTradingRewardCampaignUpdate::campaign_reward_pools_size() const {
  return _internal_campaign_reward_pools_size();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* EventTradingRewardCampaignUpdate::mutable_campaign_reward_pools(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_reward_pools)
  return _internal_mutable_campaign_reward_pools()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
EventTradingRewardCampaignUpdate::mutable_campaign_reward_pools() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_reward_pools)
  return _internal_mutable_campaign_reward_pools();
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& EventTradingRewardCampaignUpdate::_internal_campaign_reward_pools(int index) const {
  return _internal_campaign_reward_pools().Get(index);
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& EventTradingRewardCampaignUpdate::campaign_reward_pools(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_reward_pools)
  return _internal_campaign_reward_pools(index);
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* EventTradingRewardCampaignUpdate::_internal_add_campaign_reward_pools() {
  return _internal_mutable_campaign_reward_pools()->Add();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* EventTradingRewardCampaignUpdate::add_campaign_reward_pools() {
  ::injective::exchange::v1beta1::CampaignRewardPool* _add = _internal_add_campaign_reward_pools();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_reward_pools)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
EventTradingRewardCampaignUpdate::campaign_reward_pools() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.campaign_reward_pools)
  return _internal_campaign_reward_pools();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>&
EventTradingRewardCampaignUpdate::_internal_campaign_reward_pools() const {
  return _impl_.campaign_reward_pools_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>*
EventTradingRewardCampaignUpdate::_internal_mutable_campaign_reward_pools() {
  return &_impl_.campaign_reward_pools_;
}

// -------------------------------------------------------------------

// EventTradingRewardDistribution

// repeated .injective.exchange.v1beta1.AccountRewards account_rewards = 1 [json_name = "accountRewards"];
inline int EventTradingRewardDistribution::_internal_account_rewards_size() const {
  return _impl_.account_rewards_.size();
}
inline int EventTradingRewardDistribution::account_rewards_size() const {
  return _internal_account_rewards_size();
}
inline ::injective::exchange::v1beta1::AccountRewards* EventTradingRewardDistribution::mutable_account_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventTradingRewardDistribution.account_rewards)
  return _internal_mutable_account_rewards()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AccountRewards >*
EventTradingRewardDistribution::mutable_account_rewards() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventTradingRewardDistribution.account_rewards)
  return _internal_mutable_account_rewards();
}
inline const ::injective::exchange::v1beta1::AccountRewards& EventTradingRewardDistribution::_internal_account_rewards(int index) const {
  return _internal_account_rewards().Get(index);
}
inline const ::injective::exchange::v1beta1::AccountRewards& EventTradingRewardDistribution::account_rewards(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventTradingRewardDistribution.account_rewards)
  return _internal_account_rewards(index);
}
inline ::injective::exchange::v1beta1::AccountRewards* EventTradingRewardDistribution::_internal_add_account_rewards() {
  return _internal_mutable_account_rewards()->Add();
}
inline ::injective::exchange::v1beta1::AccountRewards* EventTradingRewardDistribution::add_account_rewards() {
  ::injective::exchange::v1beta1::AccountRewards* _add = _internal_add_account_rewards();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventTradingRewardDistribution.account_rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AccountRewards >&
EventTradingRewardDistribution::account_rewards() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventTradingRewardDistribution.account_rewards)
  return _internal_account_rewards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AccountRewards>&
EventTradingRewardDistribution::_internal_account_rewards() const {
  return _impl_.account_rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AccountRewards>*
EventTradingRewardDistribution::_internal_mutable_account_rewards() {
  return &_impl_.account_rewards_;
}

// -------------------------------------------------------------------

// EventNewConditionalDerivativeOrder

// string market_id = 1 [json_name = "marketId"];
inline void EventNewConditionalDerivativeOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventNewConditionalDerivativeOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewConditionalDerivativeOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.market_id)
}
inline std::string* EventNewConditionalDerivativeOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.market_id)
  return _s;
}
inline const std::string& EventNewConditionalDerivativeOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventNewConditionalDerivativeOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewConditionalDerivativeOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewConditionalDerivativeOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void EventNewConditionalDerivativeOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.market_id)
}

// .injective.exchange.v1beta1.DerivativeOrder order = 2 [json_name = "order"];
inline bool EventNewConditionalDerivativeOrder::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& EventNewConditionalDerivativeOrder::_internal_order() const {
  const ::injective::exchange::v1beta1::DerivativeOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeOrder&>(
      ::injective::exchange::v1beta1::_DerivativeOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeOrder& EventNewConditionalDerivativeOrder::order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.order)
  return _internal_order();
}
inline void EventNewConditionalDerivativeOrder::unsafe_arena_set_allocated_order(
    ::injective::exchange::v1beta1::DerivativeOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.order)
}
inline ::injective::exchange::v1beta1::DerivativeOrder* EventNewConditionalDerivativeOrder::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* EventNewConditionalDerivativeOrder::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* EventNewConditionalDerivativeOrder::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective::exchange::v1beta1::DerivativeOrder* EventNewConditionalDerivativeOrder::mutable_order() {
  ::injective::exchange::v1beta1::DerivativeOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.order)
  return _msg;
}
inline void EventNewConditionalDerivativeOrder::set_allocated_order(::injective::exchange::v1beta1::DerivativeOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order));
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.order)
}

// bytes hash = 3 [json_name = "hash"];
inline void EventNewConditionalDerivativeOrder::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& EventNewConditionalDerivativeOrder::hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventNewConditionalDerivativeOrder::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.hash)
}
inline std::string* EventNewConditionalDerivativeOrder::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.hash)
  return _s;
}
inline const std::string& EventNewConditionalDerivativeOrder::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void EventNewConditionalDerivativeOrder::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* EventNewConditionalDerivativeOrder::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* EventNewConditionalDerivativeOrder::release_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.hash)
  return _impl_.hash_.Release();
}
inline void EventNewConditionalDerivativeOrder::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.hash)
}

// bool is_market = 4 [json_name = "isMarket"];
inline void EventNewConditionalDerivativeOrder::clear_is_market() {
  _impl_.is_market_ = false;
}
inline bool EventNewConditionalDerivativeOrder::is_market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.is_market)
  return _internal_is_market();
}
inline void EventNewConditionalDerivativeOrder::set_is_market(bool value) {
  _internal_set_is_market(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.is_market)
}
inline bool EventNewConditionalDerivativeOrder::_internal_is_market() const {
  return _impl_.is_market_;
}
inline void EventNewConditionalDerivativeOrder::_internal_set_is_market(bool value) {
  ;
  _impl_.is_market_ = value;
}

// -------------------------------------------------------------------

// EventCancelConditionalDerivativeOrder

// string market_id = 1 [json_name = "marketId"];
inline void EventCancelConditionalDerivativeOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventCancelConditionalDerivativeOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventCancelConditionalDerivativeOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_id)
}
inline std::string* EventCancelConditionalDerivativeOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_id)
  return _s;
}
inline const std::string& EventCancelConditionalDerivativeOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventCancelConditionalDerivativeOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventCancelConditionalDerivativeOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventCancelConditionalDerivativeOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void EventCancelConditionalDerivativeOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_id)
}

// bool isLimitCancel = 2 [json_name = "isLimitCancel"];
inline void EventCancelConditionalDerivativeOrder::clear_islimitcancel() {
  _impl_.islimitcancel_ = false;
}
inline bool EventCancelConditionalDerivativeOrder::islimitcancel() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.isLimitCancel)
  return _internal_islimitcancel();
}
inline void EventCancelConditionalDerivativeOrder::set_islimitcancel(bool value) {
  _internal_set_islimitcancel(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.isLimitCancel)
}
inline bool EventCancelConditionalDerivativeOrder::_internal_islimitcancel() const {
  return _impl_.islimitcancel_;
}
inline void EventCancelConditionalDerivativeOrder::_internal_set_islimitcancel(bool value) {
  ;
  _impl_.islimitcancel_ = value;
}

// .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3 [json_name = "limitOrder", (.gogoproto.nullable) = true];
inline bool EventCancelConditionalDerivativeOrder::has_limit_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limit_order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventCancelConditionalDerivativeOrder::_internal_limit_order() const {
  const ::injective::exchange::v1beta1::DerivativeLimitOrder* p = _impl_.limit_order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeLimitOrder&>(
      ::injective::exchange::v1beta1::_DerivativeLimitOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeLimitOrder& EventCancelConditionalDerivativeOrder::limit_order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.limit_order)
  return _internal_limit_order();
}
inline void EventCancelConditionalDerivativeOrder::unsafe_arena_set_allocated_limit_order(
    ::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limit_order_);
  }
  _impl_.limit_order_ = limit_order;
  if (limit_order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.limit_order)
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelConditionalDerivativeOrder::release_limit_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* temp = _impl_.limit_order_;
  _impl_.limit_order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelConditionalDerivativeOrder::unsafe_arena_release_limit_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.limit_order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeLimitOrder* temp = _impl_.limit_order_;
  _impl_.limit_order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelConditionalDerivativeOrder::_internal_mutable_limit_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.limit_order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeLimitOrder>(GetArenaForAllocation());
    _impl_.limit_order_ = p;
  }
  return _impl_.limit_order_;
}
inline ::injective::exchange::v1beta1::DerivativeLimitOrder* EventCancelConditionalDerivativeOrder::mutable_limit_order() {
  ::injective::exchange::v1beta1::DerivativeLimitOrder* _msg = _internal_mutable_limit_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.limit_order)
  return _msg;
}
inline void EventCancelConditionalDerivativeOrder::set_allocated_limit_order(::injective::exchange::v1beta1::DerivativeLimitOrder* limit_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limit_order_);
  }
  if (limit_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limit_order));
    if (message_arena != submessage_arena) {
      limit_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.limit_order_ = limit_order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.limit_order)
}

// .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4 [json_name = "marketOrder", (.gogoproto.nullable) = true];
inline bool EventCancelConditionalDerivativeOrder::has_market_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_order_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrder& EventCancelConditionalDerivativeOrder::_internal_market_order() const {
  const ::injective::exchange::v1beta1::DerivativeMarketOrder* p = _impl_.market_order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarketOrder&>(
      ::injective::exchange::v1beta1::_DerivativeMarketOrder_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarketOrder& EventCancelConditionalDerivativeOrder::market_order() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_order)
  return _internal_market_order();
}
inline void EventCancelConditionalDerivativeOrder::unsafe_arena_set_allocated_market_order(
    ::injective::exchange::v1beta1::DerivativeMarketOrder* market_order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_order_);
  }
  _impl_.market_order_ = market_order;
  if (market_order) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_order)
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* EventCancelConditionalDerivativeOrder::release_market_order() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::DerivativeMarketOrder* temp = _impl_.market_order_;
  _impl_.market_order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* EventCancelConditionalDerivativeOrder::unsafe_arena_release_market_order() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_order)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::DerivativeMarketOrder* temp = _impl_.market_order_;
  _impl_.market_order_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* EventCancelConditionalDerivativeOrder::_internal_mutable_market_order() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.market_order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarketOrder>(GetArenaForAllocation());
    _impl_.market_order_ = p;
  }
  return _impl_.market_order_;
}
inline ::injective::exchange::v1beta1::DerivativeMarketOrder* EventCancelConditionalDerivativeOrder::mutable_market_order() {
  ::injective::exchange::v1beta1::DerivativeMarketOrder* _msg = _internal_mutable_market_order();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_order)
  return _msg;
}
inline void EventCancelConditionalDerivativeOrder::set_allocated_market_order(::injective::exchange::v1beta1::DerivativeMarketOrder* market_order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_order_);
  }
  if (market_order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_order));
    if (message_arena != submessage_arena) {
      market_order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.market_order_ = market_order;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.market_order)
}

// -------------------------------------------------------------------

// EventConditionalDerivativeOrderTrigger

// bytes market_id = 1 [json_name = "marketId"];
inline void EventConditionalDerivativeOrderTrigger::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& EventConditionalDerivativeOrderTrigger::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventConditionalDerivativeOrderTrigger::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.market_id)
}
inline std::string* EventConditionalDerivativeOrderTrigger::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.market_id)
  return _s;
}
inline const std::string& EventConditionalDerivativeOrderTrigger::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void EventConditionalDerivativeOrderTrigger::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventConditionalDerivativeOrderTrigger::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EventConditionalDerivativeOrderTrigger::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.market_id)
  return _impl_.market_id_.Release();
}
inline void EventConditionalDerivativeOrderTrigger::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.market_id)
}

// bool isLimitTrigger = 2 [json_name = "isLimitTrigger"];
inline void EventConditionalDerivativeOrderTrigger::clear_islimittrigger() {
  _impl_.islimittrigger_ = false;
}
inline bool EventConditionalDerivativeOrderTrigger::islimittrigger() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.isLimitTrigger)
  return _internal_islimittrigger();
}
inline void EventConditionalDerivativeOrderTrigger::set_islimittrigger(bool value) {
  _internal_set_islimittrigger(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.isLimitTrigger)
}
inline bool EventConditionalDerivativeOrderTrigger::_internal_islimittrigger() const {
  return _impl_.islimittrigger_;
}
inline void EventConditionalDerivativeOrderTrigger::_internal_set_islimittrigger(bool value) {
  ;
  _impl_.islimittrigger_ = value;
}

// bytes triggered_order_hash = 3 [json_name = "triggeredOrderHash"];
inline void EventConditionalDerivativeOrderTrigger::clear_triggered_order_hash() {
  _impl_.triggered_order_hash_.ClearToEmpty();
}
inline const std::string& EventConditionalDerivativeOrderTrigger::triggered_order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.triggered_order_hash)
  return _internal_triggered_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventConditionalDerivativeOrderTrigger::set_triggered_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.triggered_order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.triggered_order_hash)
}
inline std::string* EventConditionalDerivativeOrderTrigger::mutable_triggered_order_hash() {
  std::string* _s = _internal_mutable_triggered_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.triggered_order_hash)
  return _s;
}
inline const std::string& EventConditionalDerivativeOrderTrigger::_internal_triggered_order_hash() const {
  return _impl_.triggered_order_hash_.Get();
}
inline void EventConditionalDerivativeOrderTrigger::_internal_set_triggered_order_hash(const std::string& value) {
  ;


  _impl_.triggered_order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* EventConditionalDerivativeOrderTrigger::_internal_mutable_triggered_order_hash() {
  ;
  return _impl_.triggered_order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* EventConditionalDerivativeOrderTrigger::release_triggered_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.triggered_order_hash)
  return _impl_.triggered_order_hash_.Release();
}
inline void EventConditionalDerivativeOrderTrigger::set_allocated_triggered_order_hash(std::string* value) {
  _impl_.triggered_order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.triggered_order_hash_.IsDefault()) {
          _impl_.triggered_order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.triggered_order_hash)
}

// bytes placed_order_hash = 4 [json_name = "placedOrderHash"];
inline void EventConditionalDerivativeOrderTrigger::clear_placed_order_hash() {
  _impl_.placed_order_hash_.ClearToEmpty();
}
inline const std::string& EventConditionalDerivativeOrderTrigger::placed_order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.placed_order_hash)
  return _internal_placed_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventConditionalDerivativeOrderTrigger::set_placed_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.placed_order_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.placed_order_hash)
}
inline std::string* EventConditionalDerivativeOrderTrigger::mutable_placed_order_hash() {
  std::string* _s = _internal_mutable_placed_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.placed_order_hash)
  return _s;
}
inline const std::string& EventConditionalDerivativeOrderTrigger::_internal_placed_order_hash() const {
  return _impl_.placed_order_hash_.Get();
}
inline void EventConditionalDerivativeOrderTrigger::_internal_set_placed_order_hash(const std::string& value) {
  ;


  _impl_.placed_order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* EventConditionalDerivativeOrderTrigger::_internal_mutable_placed_order_hash() {
  ;
  return _impl_.placed_order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* EventConditionalDerivativeOrderTrigger::release_placed_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.placed_order_hash)
  return _impl_.placed_order_hash_.Release();
}
inline void EventConditionalDerivativeOrderTrigger::set_allocated_placed_order_hash(std::string* value) {
  _impl_.placed_order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.placed_order_hash_.IsDefault()) {
          _impl_.placed_order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.placed_order_hash)
}

// -------------------------------------------------------------------

// EventOrderFail

// bytes account = 1 [json_name = "account"];
inline void EventOrderFail::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& EventOrderFail::account() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventOrderFail.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventOrderFail::set_account(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventOrderFail.account)
}
inline std::string* EventOrderFail::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventOrderFail.account)
  return _s;
}
inline const std::string& EventOrderFail::_internal_account() const {
  return _impl_.account_.Get();
}
inline void EventOrderFail::_internal_set_account(const std::string& value) {
  ;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* EventOrderFail::_internal_mutable_account() {
  ;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* EventOrderFail::release_account() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EventOrderFail.account)
  return _impl_.account_.Release();
}
inline void EventOrderFail::set_allocated_account(std::string* value) {
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EventOrderFail.account)
}

// repeated bytes hashes = 2 [json_name = "hashes"];
inline int EventOrderFail::_internal_hashes_size() const {
  return _impl_.hashes_.size();
}
inline int EventOrderFail::hashes_size() const {
  return _internal_hashes_size();
}
inline void EventOrderFail::clear_hashes() {
  _internal_mutable_hashes()->Clear();
}
inline std::string* EventOrderFail::add_hashes() {
  std::string* _s = _internal_add_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.EventOrderFail.hashes)
  return _s;
}
inline const std::string& EventOrderFail::hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventOrderFail.hashes)
  return _internal_hashes(index);
}
inline std::string* EventOrderFail::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventOrderFail.hashes)
  return _internal_mutable_hashes()->Mutable(index);
}
inline void EventOrderFail::set_hashes(int index, const std::string& value) {
  _internal_mutable_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::set_hashes(int index, std::string&& value) {
  _internal_mutable_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::set_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::set_hashes(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::set_hashes(int index, absl::string_view value) {
  _internal_mutable_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::add_hashes(const std::string& value) {
  _internal_mutable_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::add_hashes(std::string&& value) {
  _internal_mutable_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::add_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::add_hashes(const void* value, std::size_t size) {
  _internal_mutable_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline void EventOrderFail::add_hashes(absl::string_view value) {
  _internal_mutable_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.EventOrderFail.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventOrderFail::hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventOrderFail.hashes)
  return _internal_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* EventOrderFail::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventOrderFail.hashes)
  return _internal_mutable_hashes();
}
inline const std::string& EventOrderFail::_internal_hashes(int index) const {
  return _internal_hashes().Get(index);
}
inline std::string* EventOrderFail::_internal_add_hashes() {
  return _internal_mutable_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventOrderFail::_internal_hashes() const {
  return _impl_.hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EventOrderFail::_internal_mutable_hashes() {
  return &_impl_.hashes_;
}

// repeated uint32 flags = 3 [json_name = "flags"];
inline int EventOrderFail::_internal_flags_size() const {
  return _impl_.flags_.size();
}
inline int EventOrderFail::flags_size() const {
  return _internal_flags_size();
}
inline void EventOrderFail::clear_flags() {
  _internal_mutable_flags()->Clear();
}
inline ::uint32_t EventOrderFail::flags(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventOrderFail.flags)
  return _internal_flags(index);
}
inline void EventOrderFail::set_flags(int index, ::uint32_t value) {
  _internal_mutable_flags()->Set(index, value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EventOrderFail.flags)
}
inline void EventOrderFail::add_flags(::uint32_t value) {
  _internal_add_flags(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventOrderFail.flags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& EventOrderFail::flags() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventOrderFail.flags)
  return _internal_flags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* EventOrderFail::mutable_flags() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventOrderFail.flags)
  return _internal_mutable_flags();
}

inline ::uint32_t EventOrderFail::_internal_flags(int index) const {
  return _internal_flags().Get(index);
}
inline void EventOrderFail::_internal_add_flags(::uint32_t value) {
  _internal_mutable_flags()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>& EventOrderFail::_internal_flags() const {
  return _impl_.flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint32_t>* EventOrderFail::_internal_mutable_flags() {
  return &_impl_.flags_;
}

// -------------------------------------------------------------------

// EventAtomicMarketOrderFeeMultipliersUpdated

// repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1 [json_name = "marketFeeMultipliers"];
inline int EventAtomicMarketOrderFeeMultipliersUpdated::_internal_market_fee_multipliers_size() const {
  return _impl_.market_fee_multipliers_.size();
}
inline int EventAtomicMarketOrderFeeMultipliersUpdated::market_fee_multipliers_size() const {
  return _internal_market_fee_multipliers_size();
}
inline ::injective::exchange::v1beta1::MarketFeeMultiplier* EventAtomicMarketOrderFeeMultipliersUpdated::mutable_market_fee_multipliers(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.market_fee_multipliers)
  return _internal_mutable_market_fee_multipliers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >*
EventAtomicMarketOrderFeeMultipliersUpdated::mutable_market_fee_multipliers() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.market_fee_multipliers)
  return _internal_mutable_market_fee_multipliers();
}
inline const ::injective::exchange::v1beta1::MarketFeeMultiplier& EventAtomicMarketOrderFeeMultipliersUpdated::_internal_market_fee_multipliers(int index) const {
  return _internal_market_fee_multipliers().Get(index);
}
inline const ::injective::exchange::v1beta1::MarketFeeMultiplier& EventAtomicMarketOrderFeeMultipliersUpdated::market_fee_multipliers(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.market_fee_multipliers)
  return _internal_market_fee_multipliers(index);
}
inline ::injective::exchange::v1beta1::MarketFeeMultiplier* EventAtomicMarketOrderFeeMultipliersUpdated::_internal_add_market_fee_multipliers() {
  return _internal_mutable_market_fee_multipliers()->Add();
}
inline ::injective::exchange::v1beta1::MarketFeeMultiplier* EventAtomicMarketOrderFeeMultipliersUpdated::add_market_fee_multipliers() {
  ::injective::exchange::v1beta1::MarketFeeMultiplier* _add = _internal_add_market_fee_multipliers();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.market_fee_multipliers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketFeeMultiplier >&
EventAtomicMarketOrderFeeMultipliersUpdated::market_fee_multipliers() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.market_fee_multipliers)
  return _internal_market_fee_multipliers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>&
EventAtomicMarketOrderFeeMultipliersUpdated::_internal_market_fee_multipliers() const {
  return _impl_.market_fee_multipliers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketFeeMultiplier>*
EventAtomicMarketOrderFeeMultipliersUpdated::_internal_mutable_market_fee_multipliers() {
  return &_impl_.market_fee_multipliers_;
}

// -------------------------------------------------------------------

// EventOrderbookUpdate

// repeated .injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1 [json_name = "spotUpdates"];
inline int EventOrderbookUpdate::_internal_spot_updates_size() const {
  return _impl_.spot_updates_.size();
}
inline int EventOrderbookUpdate::spot_updates_size() const {
  return _internal_spot_updates_size();
}
inline void EventOrderbookUpdate::clear_spot_updates() {
  _internal_mutable_spot_updates()->Clear();
}
inline ::injective::exchange::v1beta1::OrderbookUpdate* EventOrderbookUpdate::mutable_spot_updates(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventOrderbookUpdate.spot_updates)
  return _internal_mutable_spot_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >*
EventOrderbookUpdate::mutable_spot_updates() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventOrderbookUpdate.spot_updates)
  return _internal_mutable_spot_updates();
}
inline const ::injective::exchange::v1beta1::OrderbookUpdate& EventOrderbookUpdate::_internal_spot_updates(int index) const {
  return _internal_spot_updates().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderbookUpdate& EventOrderbookUpdate::spot_updates(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventOrderbookUpdate.spot_updates)
  return _internal_spot_updates(index);
}
inline ::injective::exchange::v1beta1::OrderbookUpdate* EventOrderbookUpdate::_internal_add_spot_updates() {
  return _internal_mutable_spot_updates()->Add();
}
inline ::injective::exchange::v1beta1::OrderbookUpdate* EventOrderbookUpdate::add_spot_updates() {
  ::injective::exchange::v1beta1::OrderbookUpdate* _add = _internal_add_spot_updates();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventOrderbookUpdate.spot_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >&
EventOrderbookUpdate::spot_updates() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventOrderbookUpdate.spot_updates)
  return _internal_spot_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>&
EventOrderbookUpdate::_internal_spot_updates() const {
  return _impl_.spot_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>*
EventOrderbookUpdate::_internal_mutable_spot_updates() {
  return &_impl_.spot_updates_;
}

// repeated .injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2 [json_name = "derivativeUpdates"];
inline int EventOrderbookUpdate::_internal_derivative_updates_size() const {
  return _impl_.derivative_updates_.size();
}
inline int EventOrderbookUpdate::derivative_updates_size() const {
  return _internal_derivative_updates_size();
}
inline void EventOrderbookUpdate::clear_derivative_updates() {
  _internal_mutable_derivative_updates()->Clear();
}
inline ::injective::exchange::v1beta1::OrderbookUpdate* EventOrderbookUpdate::mutable_derivative_updates(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EventOrderbookUpdate.derivative_updates)
  return _internal_mutable_derivative_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >*
EventOrderbookUpdate::mutable_derivative_updates() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.EventOrderbookUpdate.derivative_updates)
  return _internal_mutable_derivative_updates();
}
inline const ::injective::exchange::v1beta1::OrderbookUpdate& EventOrderbookUpdate::_internal_derivative_updates(int index) const {
  return _internal_derivative_updates().Get(index);
}
inline const ::injective::exchange::v1beta1::OrderbookUpdate& EventOrderbookUpdate::derivative_updates(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EventOrderbookUpdate.derivative_updates)
  return _internal_derivative_updates(index);
}
inline ::injective::exchange::v1beta1::OrderbookUpdate* EventOrderbookUpdate::_internal_add_derivative_updates() {
  return _internal_mutable_derivative_updates()->Add();
}
inline ::injective::exchange::v1beta1::OrderbookUpdate* EventOrderbookUpdate::add_derivative_updates() {
  ::injective::exchange::v1beta1::OrderbookUpdate* _add = _internal_add_derivative_updates();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.EventOrderbookUpdate.derivative_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::OrderbookUpdate >&
EventOrderbookUpdate::derivative_updates() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.EventOrderbookUpdate.derivative_updates)
  return _internal_derivative_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>&
EventOrderbookUpdate::_internal_derivative_updates() const {
  return _impl_.derivative_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::OrderbookUpdate>*
EventOrderbookUpdate::_internal_mutable_derivative_updates() {
  return &_impl_.derivative_updates_;
}

// -------------------------------------------------------------------

// OrderbookUpdate

// uint64 seq = 1 [json_name = "seq"];
inline void OrderbookUpdate::clear_seq() {
  _impl_.seq_ = ::uint64_t{0u};
}
inline ::uint64_t OrderbookUpdate::seq() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderbookUpdate.seq)
  return _internal_seq();
}
inline void OrderbookUpdate::set_seq(::uint64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.OrderbookUpdate.seq)
}
inline ::uint64_t OrderbookUpdate::_internal_seq() const {
  return _impl_.seq_;
}
inline void OrderbookUpdate::_internal_set_seq(::uint64_t value) {
  ;
  _impl_.seq_ = value;
}

// .injective.exchange.v1beta1.Orderbook orderbook = 2 [json_name = "orderbook"];
inline bool OrderbookUpdate::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void OrderbookUpdate::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::Orderbook& OrderbookUpdate::_internal_orderbook() const {
  const ::injective::exchange::v1beta1::Orderbook* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Orderbook&>(
      ::injective::exchange::v1beta1::_Orderbook_default_instance_);
}
inline const ::injective::exchange::v1beta1::Orderbook& OrderbookUpdate::orderbook() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.OrderbookUpdate.orderbook)
  return _internal_orderbook();
}
inline void OrderbookUpdate::unsafe_arena_set_allocated_orderbook(
    ::injective::exchange::v1beta1::Orderbook* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.OrderbookUpdate.orderbook)
}
inline ::injective::exchange::v1beta1::Orderbook* OrderbookUpdate::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Orderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Orderbook* OrderbookUpdate::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.OrderbookUpdate.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Orderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Orderbook* OrderbookUpdate::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Orderbook>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective::exchange::v1beta1::Orderbook* OrderbookUpdate::mutable_orderbook() {
  ::injective::exchange::v1beta1::Orderbook* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.OrderbookUpdate.orderbook)
  return _msg;
}
inline void OrderbookUpdate::set_allocated_orderbook(::injective::exchange::v1beta1::Orderbook* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.OrderbookUpdate.orderbook)
}

// -------------------------------------------------------------------

// Orderbook

// bytes market_id = 1 [json_name = "marketId"];
inline void Orderbook::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& Orderbook::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Orderbook.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Orderbook::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Orderbook.market_id)
}
inline std::string* Orderbook::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Orderbook.market_id)
  return _s;
}
inline const std::string& Orderbook::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void Orderbook::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Orderbook::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Orderbook::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Orderbook.market_id)
  return _impl_.market_id_.Release();
}
inline void Orderbook::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Orderbook.market_id)
}

// repeated .injective.exchange.v1beta1.Level buy_levels = 2 [json_name = "buyLevels"];
inline int Orderbook::_internal_buy_levels_size() const {
  return _impl_.buy_levels_.size();
}
inline int Orderbook::buy_levels_size() const {
  return _internal_buy_levels_size();
}
inline ::injective::exchange::v1beta1::Level* Orderbook::mutable_buy_levels(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Orderbook.buy_levels)
  return _internal_mutable_buy_levels()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
Orderbook::mutable_buy_levels() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.Orderbook.buy_levels)
  return _internal_mutable_buy_levels();
}
inline const ::injective::exchange::v1beta1::Level& Orderbook::_internal_buy_levels(int index) const {
  return _internal_buy_levels().Get(index);
}
inline const ::injective::exchange::v1beta1::Level& Orderbook::buy_levels(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Orderbook.buy_levels)
  return _internal_buy_levels(index);
}
inline ::injective::exchange::v1beta1::Level* Orderbook::_internal_add_buy_levels() {
  return _internal_mutable_buy_levels()->Add();
}
inline ::injective::exchange::v1beta1::Level* Orderbook::add_buy_levels() {
  ::injective::exchange::v1beta1::Level* _add = _internal_add_buy_levels();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.Orderbook.buy_levels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
Orderbook::buy_levels() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.Orderbook.buy_levels)
  return _internal_buy_levels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>&
Orderbook::_internal_buy_levels() const {
  return _impl_.buy_levels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>*
Orderbook::_internal_mutable_buy_levels() {
  return &_impl_.buy_levels_;
}

// repeated .injective.exchange.v1beta1.Level sell_levels = 3 [json_name = "sellLevels"];
inline int Orderbook::_internal_sell_levels_size() const {
  return _impl_.sell_levels_.size();
}
inline int Orderbook::sell_levels_size() const {
  return _internal_sell_levels_size();
}
inline ::injective::exchange::v1beta1::Level* Orderbook::mutable_sell_levels(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Orderbook.sell_levels)
  return _internal_mutable_sell_levels()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
Orderbook::mutable_sell_levels() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.Orderbook.sell_levels)
  return _internal_mutable_sell_levels();
}
inline const ::injective::exchange::v1beta1::Level& Orderbook::_internal_sell_levels(int index) const {
  return _internal_sell_levels().Get(index);
}
inline const ::injective::exchange::v1beta1::Level& Orderbook::sell_levels(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Orderbook.sell_levels)
  return _internal_sell_levels(index);
}
inline ::injective::exchange::v1beta1::Level* Orderbook::_internal_add_sell_levels() {
  return _internal_mutable_sell_levels()->Add();
}
inline ::injective::exchange::v1beta1::Level* Orderbook::add_sell_levels() {
  ::injective::exchange::v1beta1::Level* _add = _internal_add_sell_levels();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.Orderbook.sell_levels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
Orderbook::sell_levels() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.Orderbook.sell_levels)
  return _internal_sell_levels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>&
Orderbook::_internal_sell_levels() const {
  return _impl_.sell_levels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>*
Orderbook::_internal_mutable_sell_levels() {
  return &_impl_.sell_levels_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fevents_2eproto_2epb_2eh
