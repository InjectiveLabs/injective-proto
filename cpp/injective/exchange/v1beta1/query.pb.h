// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: injective/exchange/v1beta1/query.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fquery_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fquery_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/api/annotations.pb.h"
#include "injective/exchange/v1beta1/exchange.pb.h"
#include "injective/exchange/v1beta1/genesis.pb.h"
#include "injective/oracle/v1beta1/oracle.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_injective_2fexchange_2fv1beta1_2fquery_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_injective_2fexchange_2fv1beta1_2fquery_2eproto;
namespace injective {
namespace exchange {
namespace v1beta1 {
class BalanceMismatch;
struct BalanceMismatchDefaultTypeInternal;
extern BalanceMismatchDefaultTypeInternal _BalanceMismatch_default_instance_;
class BalanceWithMarginHold;
struct BalanceWithMarginHoldDefaultTypeInternal;
extern BalanceWithMarginHoldDefaultTypeInternal _BalanceWithMarginHold_default_instance_;
class EffectivePosition;
struct EffectivePositionDefaultTypeInternal;
extern EffectivePositionDefaultTypeInternal _EffectivePosition_default_instance_;
class FullDerivativeMarket;
struct FullDerivativeMarketDefaultTypeInternal;
extern FullDerivativeMarketDefaultTypeInternal _FullDerivativeMarket_default_instance_;
class FullSpotMarket;
struct FullSpotMarketDefaultTypeInternal;
extern FullSpotMarketDefaultTypeInternal _FullSpotMarket_default_instance_;
class MitoVaultInfosRequest;
struct MitoVaultInfosRequestDefaultTypeInternal;
extern MitoVaultInfosRequestDefaultTypeInternal _MitoVaultInfosRequest_default_instance_;
class MitoVaultInfosResponse;
struct MitoVaultInfosResponseDefaultTypeInternal;
extern MitoVaultInfosResponseDefaultTypeInternal _MitoVaultInfosResponse_default_instance_;
class PerpetualMarketState;
struct PerpetualMarketStateDefaultTypeInternal;
extern PerpetualMarketStateDefaultTypeInternal _PerpetualMarketState_default_instance_;
class PriceLevel;
struct PriceLevelDefaultTypeInternal;
extern PriceLevelDefaultTypeInternal _PriceLevel_default_instance_;
class QueryAccountAddressDerivativeOrdersRequest;
struct QueryAccountAddressDerivativeOrdersRequestDefaultTypeInternal;
extern QueryAccountAddressDerivativeOrdersRequestDefaultTypeInternal _QueryAccountAddressDerivativeOrdersRequest_default_instance_;
class QueryAccountAddressDerivativeOrdersResponse;
struct QueryAccountAddressDerivativeOrdersResponseDefaultTypeInternal;
extern QueryAccountAddressDerivativeOrdersResponseDefaultTypeInternal _QueryAccountAddressDerivativeOrdersResponse_default_instance_;
class QueryAccountAddressSpotOrdersRequest;
struct QueryAccountAddressSpotOrdersRequestDefaultTypeInternal;
extern QueryAccountAddressSpotOrdersRequestDefaultTypeInternal _QueryAccountAddressSpotOrdersRequest_default_instance_;
class QueryAccountAddressSpotOrdersResponse;
struct QueryAccountAddressSpotOrdersResponseDefaultTypeInternal;
extern QueryAccountAddressSpotOrdersResponseDefaultTypeInternal _QueryAccountAddressSpotOrdersResponse_default_instance_;
class QueryAggregateMarketVolumeRequest;
struct QueryAggregateMarketVolumeRequestDefaultTypeInternal;
extern QueryAggregateMarketVolumeRequestDefaultTypeInternal _QueryAggregateMarketVolumeRequest_default_instance_;
class QueryAggregateMarketVolumeResponse;
struct QueryAggregateMarketVolumeResponseDefaultTypeInternal;
extern QueryAggregateMarketVolumeResponseDefaultTypeInternal _QueryAggregateMarketVolumeResponse_default_instance_;
class QueryAggregateMarketVolumesRequest;
struct QueryAggregateMarketVolumesRequestDefaultTypeInternal;
extern QueryAggregateMarketVolumesRequestDefaultTypeInternal _QueryAggregateMarketVolumesRequest_default_instance_;
class QueryAggregateMarketVolumesResponse;
struct QueryAggregateMarketVolumesResponseDefaultTypeInternal;
extern QueryAggregateMarketVolumesResponseDefaultTypeInternal _QueryAggregateMarketVolumesResponse_default_instance_;
class QueryAggregateVolumeRequest;
struct QueryAggregateVolumeRequestDefaultTypeInternal;
extern QueryAggregateVolumeRequestDefaultTypeInternal _QueryAggregateVolumeRequest_default_instance_;
class QueryAggregateVolumeResponse;
struct QueryAggregateVolumeResponseDefaultTypeInternal;
extern QueryAggregateVolumeResponseDefaultTypeInternal _QueryAggregateVolumeResponse_default_instance_;
class QueryAggregateVolumesRequest;
struct QueryAggregateVolumesRequestDefaultTypeInternal;
extern QueryAggregateVolumesRequestDefaultTypeInternal _QueryAggregateVolumesRequest_default_instance_;
class QueryAggregateVolumesResponse;
struct QueryAggregateVolumesResponseDefaultTypeInternal;
extern QueryAggregateVolumesResponseDefaultTypeInternal _QueryAggregateVolumesResponse_default_instance_;
class QueryBalanceMismatchesRequest;
struct QueryBalanceMismatchesRequestDefaultTypeInternal;
extern QueryBalanceMismatchesRequestDefaultTypeInternal _QueryBalanceMismatchesRequest_default_instance_;
class QueryBalanceMismatchesResponse;
struct QueryBalanceMismatchesResponseDefaultTypeInternal;
extern QueryBalanceMismatchesResponseDefaultTypeInternal _QueryBalanceMismatchesResponse_default_instance_;
class QueryBalanceWithBalanceHoldsRequest;
struct QueryBalanceWithBalanceHoldsRequestDefaultTypeInternal;
extern QueryBalanceWithBalanceHoldsRequestDefaultTypeInternal _QueryBalanceWithBalanceHoldsRequest_default_instance_;
class QueryBalanceWithBalanceHoldsResponse;
struct QueryBalanceWithBalanceHoldsResponseDefaultTypeInternal;
extern QueryBalanceWithBalanceHoldsResponseDefaultTypeInternal _QueryBalanceWithBalanceHoldsResponse_default_instance_;
class QueryBinaryMarketsRequest;
struct QueryBinaryMarketsRequestDefaultTypeInternal;
extern QueryBinaryMarketsRequestDefaultTypeInternal _QueryBinaryMarketsRequest_default_instance_;
class QueryBinaryMarketsResponse;
struct QueryBinaryMarketsResponseDefaultTypeInternal;
extern QueryBinaryMarketsResponseDefaultTypeInternal _QueryBinaryMarketsResponse_default_instance_;
class QueryDenomDecimalRequest;
struct QueryDenomDecimalRequestDefaultTypeInternal;
extern QueryDenomDecimalRequestDefaultTypeInternal _QueryDenomDecimalRequest_default_instance_;
class QueryDenomDecimalResponse;
struct QueryDenomDecimalResponseDefaultTypeInternal;
extern QueryDenomDecimalResponseDefaultTypeInternal _QueryDenomDecimalResponse_default_instance_;
class QueryDenomDecimalsRequest;
struct QueryDenomDecimalsRequestDefaultTypeInternal;
extern QueryDenomDecimalsRequestDefaultTypeInternal _QueryDenomDecimalsRequest_default_instance_;
class QueryDenomDecimalsResponse;
struct QueryDenomDecimalsResponseDefaultTypeInternal;
extern QueryDenomDecimalsResponseDefaultTypeInternal _QueryDenomDecimalsResponse_default_instance_;
class QueryDerivativeMarketAddressRequest;
struct QueryDerivativeMarketAddressRequestDefaultTypeInternal;
extern QueryDerivativeMarketAddressRequestDefaultTypeInternal _QueryDerivativeMarketAddressRequest_default_instance_;
class QueryDerivativeMarketAddressResponse;
struct QueryDerivativeMarketAddressResponseDefaultTypeInternal;
extern QueryDerivativeMarketAddressResponseDefaultTypeInternal _QueryDerivativeMarketAddressResponse_default_instance_;
class QueryDerivativeMarketRequest;
struct QueryDerivativeMarketRequestDefaultTypeInternal;
extern QueryDerivativeMarketRequestDefaultTypeInternal _QueryDerivativeMarketRequest_default_instance_;
class QueryDerivativeMarketResponse;
struct QueryDerivativeMarketResponseDefaultTypeInternal;
extern QueryDerivativeMarketResponseDefaultTypeInternal _QueryDerivativeMarketResponse_default_instance_;
class QueryDerivativeMarketsRequest;
struct QueryDerivativeMarketsRequestDefaultTypeInternal;
extern QueryDerivativeMarketsRequestDefaultTypeInternal _QueryDerivativeMarketsRequest_default_instance_;
class QueryDerivativeMarketsResponse;
struct QueryDerivativeMarketsResponseDefaultTypeInternal;
extern QueryDerivativeMarketsResponseDefaultTypeInternal _QueryDerivativeMarketsResponse_default_instance_;
class QueryDerivativeMidPriceAndTOBRequest;
struct QueryDerivativeMidPriceAndTOBRequestDefaultTypeInternal;
extern QueryDerivativeMidPriceAndTOBRequestDefaultTypeInternal _QueryDerivativeMidPriceAndTOBRequest_default_instance_;
class QueryDerivativeMidPriceAndTOBResponse;
struct QueryDerivativeMidPriceAndTOBResponseDefaultTypeInternal;
extern QueryDerivativeMidPriceAndTOBResponseDefaultTypeInternal _QueryDerivativeMidPriceAndTOBResponse_default_instance_;
class QueryDerivativeOrderbookRequest;
struct QueryDerivativeOrderbookRequestDefaultTypeInternal;
extern QueryDerivativeOrderbookRequestDefaultTypeInternal _QueryDerivativeOrderbookRequest_default_instance_;
class QueryDerivativeOrderbookResponse;
struct QueryDerivativeOrderbookResponseDefaultTypeInternal;
extern QueryDerivativeOrderbookResponseDefaultTypeInternal _QueryDerivativeOrderbookResponse_default_instance_;
class QueryDerivativeOrdersByHashesRequest;
struct QueryDerivativeOrdersByHashesRequestDefaultTypeInternal;
extern QueryDerivativeOrdersByHashesRequestDefaultTypeInternal _QueryDerivativeOrdersByHashesRequest_default_instance_;
class QueryDerivativeOrdersByHashesResponse;
struct QueryDerivativeOrdersByHashesResponseDefaultTypeInternal;
extern QueryDerivativeOrdersByHashesResponseDefaultTypeInternal _QueryDerivativeOrdersByHashesResponse_default_instance_;
class QueryExchangeBalancesRequest;
struct QueryExchangeBalancesRequestDefaultTypeInternal;
extern QueryExchangeBalancesRequestDefaultTypeInternal _QueryExchangeBalancesRequest_default_instance_;
class QueryExchangeBalancesResponse;
struct QueryExchangeBalancesResponseDefaultTypeInternal;
extern QueryExchangeBalancesResponseDefaultTypeInternal _QueryExchangeBalancesResponse_default_instance_;
class QueryExchangeParamsRequest;
struct QueryExchangeParamsRequestDefaultTypeInternal;
extern QueryExchangeParamsRequestDefaultTypeInternal _QueryExchangeParamsRequest_default_instance_;
class QueryExchangeParamsResponse;
struct QueryExchangeParamsResponseDefaultTypeInternal;
extern QueryExchangeParamsResponseDefaultTypeInternal _QueryExchangeParamsResponse_default_instance_;
class QueryExpiryFuturesMarketInfoRequest;
struct QueryExpiryFuturesMarketInfoRequestDefaultTypeInternal;
extern QueryExpiryFuturesMarketInfoRequestDefaultTypeInternal _QueryExpiryFuturesMarketInfoRequest_default_instance_;
class QueryExpiryFuturesMarketInfoResponse;
struct QueryExpiryFuturesMarketInfoResponseDefaultTypeInternal;
extern QueryExpiryFuturesMarketInfoResponseDefaultTypeInternal _QueryExpiryFuturesMarketInfoResponse_default_instance_;
class QueryFeeDiscountAccountInfoRequest;
struct QueryFeeDiscountAccountInfoRequestDefaultTypeInternal;
extern QueryFeeDiscountAccountInfoRequestDefaultTypeInternal _QueryFeeDiscountAccountInfoRequest_default_instance_;
class QueryFeeDiscountAccountInfoResponse;
struct QueryFeeDiscountAccountInfoResponseDefaultTypeInternal;
extern QueryFeeDiscountAccountInfoResponseDefaultTypeInternal _QueryFeeDiscountAccountInfoResponse_default_instance_;
class QueryFeeDiscountScheduleRequest;
struct QueryFeeDiscountScheduleRequestDefaultTypeInternal;
extern QueryFeeDiscountScheduleRequestDefaultTypeInternal _QueryFeeDiscountScheduleRequest_default_instance_;
class QueryFeeDiscountScheduleResponse;
struct QueryFeeDiscountScheduleResponseDefaultTypeInternal;
extern QueryFeeDiscountScheduleResponseDefaultTypeInternal _QueryFeeDiscountScheduleResponse_default_instance_;
class QueryFeeDiscountTierStatisticsRequest;
struct QueryFeeDiscountTierStatisticsRequestDefaultTypeInternal;
extern QueryFeeDiscountTierStatisticsRequestDefaultTypeInternal _QueryFeeDiscountTierStatisticsRequest_default_instance_;
class QueryFeeDiscountTierStatisticsResponse;
struct QueryFeeDiscountTierStatisticsResponseDefaultTypeInternal;
extern QueryFeeDiscountTierStatisticsResponseDefaultTypeInternal _QueryFeeDiscountTierStatisticsResponse_default_instance_;
class QueryFullSpotMarketRequest;
struct QueryFullSpotMarketRequestDefaultTypeInternal;
extern QueryFullSpotMarketRequestDefaultTypeInternal _QueryFullSpotMarketRequest_default_instance_;
class QueryFullSpotMarketResponse;
struct QueryFullSpotMarketResponseDefaultTypeInternal;
extern QueryFullSpotMarketResponseDefaultTypeInternal _QueryFullSpotMarketResponse_default_instance_;
class QueryFullSpotMarketsRequest;
struct QueryFullSpotMarketsRequestDefaultTypeInternal;
extern QueryFullSpotMarketsRequestDefaultTypeInternal _QueryFullSpotMarketsRequest_default_instance_;
class QueryFullSpotMarketsResponse;
struct QueryFullSpotMarketsResponseDefaultTypeInternal;
extern QueryFullSpotMarketsResponseDefaultTypeInternal _QueryFullSpotMarketsResponse_default_instance_;
class QueryHistoricalTradeRecordsRequest;
struct QueryHistoricalTradeRecordsRequestDefaultTypeInternal;
extern QueryHistoricalTradeRecordsRequestDefaultTypeInternal _QueryHistoricalTradeRecordsRequest_default_instance_;
class QueryHistoricalTradeRecordsResponse;
struct QueryHistoricalTradeRecordsResponseDefaultTypeInternal;
extern QueryHistoricalTradeRecordsResponseDefaultTypeInternal _QueryHistoricalTradeRecordsResponse_default_instance_;
class QueryIsOptedOutOfRewardsRequest;
struct QueryIsOptedOutOfRewardsRequestDefaultTypeInternal;
extern QueryIsOptedOutOfRewardsRequestDefaultTypeInternal _QueryIsOptedOutOfRewardsRequest_default_instance_;
class QueryIsOptedOutOfRewardsResponse;
struct QueryIsOptedOutOfRewardsResponseDefaultTypeInternal;
extern QueryIsOptedOutOfRewardsResponseDefaultTypeInternal _QueryIsOptedOutOfRewardsResponse_default_instance_;
class QueryMarketAtomicExecutionFeeMultiplierRequest;
struct QueryMarketAtomicExecutionFeeMultiplierRequestDefaultTypeInternal;
extern QueryMarketAtomicExecutionFeeMultiplierRequestDefaultTypeInternal _QueryMarketAtomicExecutionFeeMultiplierRequest_default_instance_;
class QueryMarketAtomicExecutionFeeMultiplierResponse;
struct QueryMarketAtomicExecutionFeeMultiplierResponseDefaultTypeInternal;
extern QueryMarketAtomicExecutionFeeMultiplierResponseDefaultTypeInternal _QueryMarketAtomicExecutionFeeMultiplierResponse_default_instance_;
class QueryMarketIDFromVaultRequest;
struct QueryMarketIDFromVaultRequestDefaultTypeInternal;
extern QueryMarketIDFromVaultRequestDefaultTypeInternal _QueryMarketIDFromVaultRequest_default_instance_;
class QueryMarketIDFromVaultResponse;
struct QueryMarketIDFromVaultResponseDefaultTypeInternal;
extern QueryMarketIDFromVaultResponseDefaultTypeInternal _QueryMarketIDFromVaultResponse_default_instance_;
class QueryMarketVolatilityRequest;
struct QueryMarketVolatilityRequestDefaultTypeInternal;
extern QueryMarketVolatilityRequestDefaultTypeInternal _QueryMarketVolatilityRequest_default_instance_;
class QueryMarketVolatilityResponse;
struct QueryMarketVolatilityResponseDefaultTypeInternal;
extern QueryMarketVolatilityResponseDefaultTypeInternal _QueryMarketVolatilityResponse_default_instance_;
class QueryModuleStateRequest;
struct QueryModuleStateRequestDefaultTypeInternal;
extern QueryModuleStateRequestDefaultTypeInternal _QueryModuleStateRequest_default_instance_;
class QueryModuleStateResponse;
struct QueryModuleStateResponseDefaultTypeInternal;
extern QueryModuleStateResponseDefaultTypeInternal _QueryModuleStateResponse_default_instance_;
class QueryOptedOutOfRewardsAccountsRequest;
struct QueryOptedOutOfRewardsAccountsRequestDefaultTypeInternal;
extern QueryOptedOutOfRewardsAccountsRequestDefaultTypeInternal _QueryOptedOutOfRewardsAccountsRequest_default_instance_;
class QueryOptedOutOfRewardsAccountsResponse;
struct QueryOptedOutOfRewardsAccountsResponseDefaultTypeInternal;
extern QueryOptedOutOfRewardsAccountsResponseDefaultTypeInternal _QueryOptedOutOfRewardsAccountsResponse_default_instance_;
class QueryPerpetualMarketFundingRequest;
struct QueryPerpetualMarketFundingRequestDefaultTypeInternal;
extern QueryPerpetualMarketFundingRequestDefaultTypeInternal _QueryPerpetualMarketFundingRequest_default_instance_;
class QueryPerpetualMarketFundingResponse;
struct QueryPerpetualMarketFundingResponseDefaultTypeInternal;
extern QueryPerpetualMarketFundingResponseDefaultTypeInternal _QueryPerpetualMarketFundingResponse_default_instance_;
class QueryPerpetualMarketInfoRequest;
struct QueryPerpetualMarketInfoRequestDefaultTypeInternal;
extern QueryPerpetualMarketInfoRequestDefaultTypeInternal _QueryPerpetualMarketInfoRequest_default_instance_;
class QueryPerpetualMarketInfoResponse;
struct QueryPerpetualMarketInfoResponseDefaultTypeInternal;
extern QueryPerpetualMarketInfoResponseDefaultTypeInternal _QueryPerpetualMarketInfoResponse_default_instance_;
class QueryPositionsRequest;
struct QueryPositionsRequestDefaultTypeInternal;
extern QueryPositionsRequestDefaultTypeInternal _QueryPositionsRequest_default_instance_;
class QueryPositionsResponse;
struct QueryPositionsResponseDefaultTypeInternal;
extern QueryPositionsResponseDefaultTypeInternal _QueryPositionsResponse_default_instance_;
class QuerySpotMarketRequest;
struct QuerySpotMarketRequestDefaultTypeInternal;
extern QuerySpotMarketRequestDefaultTypeInternal _QuerySpotMarketRequest_default_instance_;
class QuerySpotMarketResponse;
struct QuerySpotMarketResponseDefaultTypeInternal;
extern QuerySpotMarketResponseDefaultTypeInternal _QuerySpotMarketResponse_default_instance_;
class QuerySpotMarketsRequest;
struct QuerySpotMarketsRequestDefaultTypeInternal;
extern QuerySpotMarketsRequestDefaultTypeInternal _QuerySpotMarketsRequest_default_instance_;
class QuerySpotMarketsResponse;
struct QuerySpotMarketsResponseDefaultTypeInternal;
extern QuerySpotMarketsResponseDefaultTypeInternal _QuerySpotMarketsResponse_default_instance_;
class QuerySpotMidPriceAndTOBRequest;
struct QuerySpotMidPriceAndTOBRequestDefaultTypeInternal;
extern QuerySpotMidPriceAndTOBRequestDefaultTypeInternal _QuerySpotMidPriceAndTOBRequest_default_instance_;
class QuerySpotMidPriceAndTOBResponse;
struct QuerySpotMidPriceAndTOBResponseDefaultTypeInternal;
extern QuerySpotMidPriceAndTOBResponseDefaultTypeInternal _QuerySpotMidPriceAndTOBResponse_default_instance_;
class QuerySpotOrderbookRequest;
struct QuerySpotOrderbookRequestDefaultTypeInternal;
extern QuerySpotOrderbookRequestDefaultTypeInternal _QuerySpotOrderbookRequest_default_instance_;
class QuerySpotOrderbookResponse;
struct QuerySpotOrderbookResponseDefaultTypeInternal;
extern QuerySpotOrderbookResponseDefaultTypeInternal _QuerySpotOrderbookResponse_default_instance_;
class QuerySpotOrdersByHashesRequest;
struct QuerySpotOrdersByHashesRequestDefaultTypeInternal;
extern QuerySpotOrdersByHashesRequestDefaultTypeInternal _QuerySpotOrdersByHashesRequest_default_instance_;
class QuerySpotOrdersByHashesResponse;
struct QuerySpotOrdersByHashesResponseDefaultTypeInternal;
extern QuerySpotOrdersByHashesResponseDefaultTypeInternal _QuerySpotOrdersByHashesResponse_default_instance_;
class QuerySubaccountDepositRequest;
struct QuerySubaccountDepositRequestDefaultTypeInternal;
extern QuerySubaccountDepositRequestDefaultTypeInternal _QuerySubaccountDepositRequest_default_instance_;
class QuerySubaccountDepositResponse;
struct QuerySubaccountDepositResponseDefaultTypeInternal;
extern QuerySubaccountDepositResponseDefaultTypeInternal _QuerySubaccountDepositResponse_default_instance_;
class QuerySubaccountDepositsRequest;
struct QuerySubaccountDepositsRequestDefaultTypeInternal;
extern QuerySubaccountDepositsRequestDefaultTypeInternal _QuerySubaccountDepositsRequest_default_instance_;
class QuerySubaccountDepositsResponse;
struct QuerySubaccountDepositsResponseDefaultTypeInternal;
extern QuerySubaccountDepositsResponseDefaultTypeInternal _QuerySubaccountDepositsResponse_default_instance_;
class QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse;
struct QuerySubaccountDepositsResponse_DepositsEntry_DoNotUseDefaultTypeInternal;
extern QuerySubaccountDepositsResponse_DepositsEntry_DoNotUseDefaultTypeInternal _QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse_default_instance_;
class QuerySubaccountEffectivePositionInMarketRequest;
struct QuerySubaccountEffectivePositionInMarketRequestDefaultTypeInternal;
extern QuerySubaccountEffectivePositionInMarketRequestDefaultTypeInternal _QuerySubaccountEffectivePositionInMarketRequest_default_instance_;
class QuerySubaccountEffectivePositionInMarketResponse;
struct QuerySubaccountEffectivePositionInMarketResponseDefaultTypeInternal;
extern QuerySubaccountEffectivePositionInMarketResponseDefaultTypeInternal _QuerySubaccountEffectivePositionInMarketResponse_default_instance_;
class QuerySubaccountOrderMetadataRequest;
struct QuerySubaccountOrderMetadataRequestDefaultTypeInternal;
extern QuerySubaccountOrderMetadataRequestDefaultTypeInternal _QuerySubaccountOrderMetadataRequest_default_instance_;
class QuerySubaccountOrderMetadataResponse;
struct QuerySubaccountOrderMetadataResponseDefaultTypeInternal;
extern QuerySubaccountOrderMetadataResponseDefaultTypeInternal _QuerySubaccountOrderMetadataResponse_default_instance_;
class QuerySubaccountOrdersRequest;
struct QuerySubaccountOrdersRequestDefaultTypeInternal;
extern QuerySubaccountOrdersRequestDefaultTypeInternal _QuerySubaccountOrdersRequest_default_instance_;
class QuerySubaccountOrdersResponse;
struct QuerySubaccountOrdersResponseDefaultTypeInternal;
extern QuerySubaccountOrdersResponseDefaultTypeInternal _QuerySubaccountOrdersResponse_default_instance_;
class QuerySubaccountPositionInMarketRequest;
struct QuerySubaccountPositionInMarketRequestDefaultTypeInternal;
extern QuerySubaccountPositionInMarketRequestDefaultTypeInternal _QuerySubaccountPositionInMarketRequest_default_instance_;
class QuerySubaccountPositionInMarketResponse;
struct QuerySubaccountPositionInMarketResponseDefaultTypeInternal;
extern QuerySubaccountPositionInMarketResponseDefaultTypeInternal _QuerySubaccountPositionInMarketResponse_default_instance_;
class QuerySubaccountPositionsRequest;
struct QuerySubaccountPositionsRequestDefaultTypeInternal;
extern QuerySubaccountPositionsRequestDefaultTypeInternal _QuerySubaccountPositionsRequest_default_instance_;
class QuerySubaccountPositionsResponse;
struct QuerySubaccountPositionsResponseDefaultTypeInternal;
extern QuerySubaccountPositionsResponseDefaultTypeInternal _QuerySubaccountPositionsResponse_default_instance_;
class QuerySubaccountTradeNonceRequest;
struct QuerySubaccountTradeNonceRequestDefaultTypeInternal;
extern QuerySubaccountTradeNonceRequestDefaultTypeInternal _QuerySubaccountTradeNonceRequest_default_instance_;
class QuerySubaccountTradeNonceResponse;
struct QuerySubaccountTradeNonceResponseDefaultTypeInternal;
extern QuerySubaccountTradeNonceResponseDefaultTypeInternal _QuerySubaccountTradeNonceResponse_default_instance_;
class QueryTradeRewardCampaignRequest;
struct QueryTradeRewardCampaignRequestDefaultTypeInternal;
extern QueryTradeRewardCampaignRequestDefaultTypeInternal _QueryTradeRewardCampaignRequest_default_instance_;
class QueryTradeRewardCampaignResponse;
struct QueryTradeRewardCampaignResponseDefaultTypeInternal;
extern QueryTradeRewardCampaignResponseDefaultTypeInternal _QueryTradeRewardCampaignResponse_default_instance_;
class QueryTradeRewardPointsRequest;
struct QueryTradeRewardPointsRequestDefaultTypeInternal;
extern QueryTradeRewardPointsRequestDefaultTypeInternal _QueryTradeRewardPointsRequest_default_instance_;
class QueryTradeRewardPointsResponse;
struct QueryTradeRewardPointsResponseDefaultTypeInternal;
extern QueryTradeRewardPointsResponseDefaultTypeInternal _QueryTradeRewardPointsResponse_default_instance_;
class QueryTraderDerivativeConditionalOrdersRequest;
struct QueryTraderDerivativeConditionalOrdersRequestDefaultTypeInternal;
extern QueryTraderDerivativeConditionalOrdersRequestDefaultTypeInternal _QueryTraderDerivativeConditionalOrdersRequest_default_instance_;
class QueryTraderDerivativeConditionalOrdersResponse;
struct QueryTraderDerivativeConditionalOrdersResponseDefaultTypeInternal;
extern QueryTraderDerivativeConditionalOrdersResponseDefaultTypeInternal _QueryTraderDerivativeConditionalOrdersResponse_default_instance_;
class QueryTraderDerivativeOrdersRequest;
struct QueryTraderDerivativeOrdersRequestDefaultTypeInternal;
extern QueryTraderDerivativeOrdersRequestDefaultTypeInternal _QueryTraderDerivativeOrdersRequest_default_instance_;
class QueryTraderDerivativeOrdersResponse;
struct QueryTraderDerivativeOrdersResponseDefaultTypeInternal;
extern QueryTraderDerivativeOrdersResponseDefaultTypeInternal _QueryTraderDerivativeOrdersResponse_default_instance_;
class QueryTraderDerivativeOrdersToCancelUpToAmountRequest;
struct QueryTraderDerivativeOrdersToCancelUpToAmountRequestDefaultTypeInternal;
extern QueryTraderDerivativeOrdersToCancelUpToAmountRequestDefaultTypeInternal _QueryTraderDerivativeOrdersToCancelUpToAmountRequest_default_instance_;
class QueryTraderSpotOrdersRequest;
struct QueryTraderSpotOrdersRequestDefaultTypeInternal;
extern QueryTraderSpotOrdersRequestDefaultTypeInternal _QueryTraderSpotOrdersRequest_default_instance_;
class QueryTraderSpotOrdersResponse;
struct QueryTraderSpotOrdersResponseDefaultTypeInternal;
extern QueryTraderSpotOrdersResponseDefaultTypeInternal _QueryTraderSpotOrdersResponse_default_instance_;
class QueryTraderSpotOrdersToCancelUpToAmountRequest;
struct QueryTraderSpotOrdersToCancelUpToAmountRequestDefaultTypeInternal;
extern QueryTraderSpotOrdersToCancelUpToAmountRequestDefaultTypeInternal _QueryTraderSpotOrdersToCancelUpToAmountRequest_default_instance_;
class Subaccount;
struct SubaccountDefaultTypeInternal;
extern SubaccountDefaultTypeInternal _Subaccount_default_instance_;
class SubaccountOrderbookMetadataWithMarket;
struct SubaccountOrderbookMetadataWithMarketDefaultTypeInternal;
extern SubaccountOrderbookMetadataWithMarketDefaultTypeInternal _SubaccountOrderbookMetadataWithMarket_default_instance_;
class TierStatistic;
struct TierStatisticDefaultTypeInternal;
extern TierStatisticDefaultTypeInternal _TierStatistic_default_instance_;
class TradeHistoryOptions;
struct TradeHistoryOptionsDefaultTypeInternal;
extern TradeHistoryOptionsDefaultTypeInternal _TradeHistoryOptions_default_instance_;
class TrimmedDerivativeConditionalOrder;
struct TrimmedDerivativeConditionalOrderDefaultTypeInternal;
extern TrimmedDerivativeConditionalOrderDefaultTypeInternal _TrimmedDerivativeConditionalOrder_default_instance_;
class TrimmedDerivativeLimitOrder;
struct TrimmedDerivativeLimitOrderDefaultTypeInternal;
extern TrimmedDerivativeLimitOrderDefaultTypeInternal _TrimmedDerivativeLimitOrder_default_instance_;
class TrimmedSpotLimitOrder;
struct TrimmedSpotLimitOrderDefaultTypeInternal;
extern TrimmedSpotLimitOrderDefaultTypeInternal _TrimmedSpotLimitOrder_default_instance_;
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective
PROTOBUF_NAMESPACE_OPEN
template <>
::injective::exchange::v1beta1::BalanceMismatch* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::BalanceMismatch>(Arena*);
template <>
::injective::exchange::v1beta1::BalanceWithMarginHold* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::BalanceWithMarginHold>(Arena*);
template <>
::injective::exchange::v1beta1::EffectivePosition* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::EffectivePosition>(Arena*);
template <>
::injective::exchange::v1beta1::FullDerivativeMarket* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::FullDerivativeMarket>(Arena*);
template <>
::injective::exchange::v1beta1::FullSpotMarket* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::FullSpotMarket>(Arena*);
template <>
::injective::exchange::v1beta1::MitoVaultInfosRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MitoVaultInfosRequest>(Arena*);
template <>
::injective::exchange::v1beta1::MitoVaultInfosResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::MitoVaultInfosResponse>(Arena*);
template <>
::injective::exchange::v1beta1::PerpetualMarketState* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketState>(Arena*);
template <>
::injective::exchange::v1beta1::PriceLevel* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::PriceLevel>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAccountAddressDerivativeOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAccountAddressSpotOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateMarketVolumeRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateMarketVolumeResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateMarketVolumesRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateMarketVolumesResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateVolumeRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateVolumeRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateVolumeResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateVolumeResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateVolumesRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateVolumesRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryAggregateVolumesResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryAggregateVolumesResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryBalanceMismatchesRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryBalanceMismatchesRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryBalanceMismatchesResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryBalanceMismatchesResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryBalanceWithBalanceHoldsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryBinaryMarketsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryBinaryMarketsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryBinaryMarketsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryBinaryMarketsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDenomDecimalRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDenomDecimalRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDenomDecimalResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDenomDecimalResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDenomDecimalsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDenomDecimalsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDenomDecimalsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDenomDecimalsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMarketAddressRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMarketAddressResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMarketRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMarketRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMarketResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMarketResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMarketsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMarketsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMarketsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMarketsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeMidPriceAndTOBResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeOrderbookRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeOrderbookResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryDerivativeOrdersByHashesResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryExchangeBalancesRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryExchangeBalancesRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryExchangeBalancesResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryExchangeBalancesResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryExchangeParamsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryExchangeParamsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryExchangeParamsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryExchangeParamsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryExpiryFuturesMarketInfoResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFeeDiscountAccountInfoResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFeeDiscountScheduleRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFeeDiscountScheduleResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFeeDiscountTierStatisticsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFullSpotMarketRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFullSpotMarketRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFullSpotMarketResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFullSpotMarketResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFullSpotMarketsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFullSpotMarketsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryFullSpotMarketsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryFullSpotMarketsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryHistoricalTradeRecordsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryHistoricalTradeRecordsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryIsOptedOutOfRewardsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryMarketAtomicExecutionFeeMultiplierResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryMarketIDFromVaultRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryMarketIDFromVaultResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryMarketVolatilityRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryMarketVolatilityRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryMarketVolatilityResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryMarketVolatilityResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryModuleStateRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryModuleStateRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryModuleStateResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryModuleStateResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryOptedOutOfRewardsAccountsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryPerpetualMarketFundingRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryPerpetualMarketFundingResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryPerpetualMarketInfoRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryPerpetualMarketInfoResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryPositionsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryPositionsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryPositionsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryPositionsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotMarketRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotMarketRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotMarketResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotMarketResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotMarketsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotMarketsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotMarketsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotMarketsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotMidPriceAndTOBResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotOrderbookRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotOrderbookRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotOrderbookResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotOrderbookResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotOrdersByHashesRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySpotOrdersByHashesResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountDepositRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountDepositRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountDepositResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountDepositResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountDepositsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountDepositsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountDepositsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountDepositsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountEffectivePositionInMarketResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountOrderMetadataRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountOrderMetadataResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountOrdersRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountOrdersRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountPositionInMarketRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountPositionInMarketResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountPositionsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountPositionsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountPositionsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountPositionsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountTradeNonceRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QuerySubaccountTradeNonceResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTradeRewardCampaignRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTradeRewardCampaignResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTradeRewardPointsRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTradeRewardPointsRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTradeRewardPointsResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTradeRewardPointsResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderDerivativeConditionalOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderDerivativeOrdersRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderDerivativeOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderDerivativeOrdersToCancelUpToAmountRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderDerivativeOrdersToCancelUpToAmountRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderSpotOrdersRequest>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderSpotOrdersResponse>(Arena*);
template <>
::injective::exchange::v1beta1::QueryTraderSpotOrdersToCancelUpToAmountRequest* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::QueryTraderSpotOrdersToCancelUpToAmountRequest>(Arena*);
template <>
::injective::exchange::v1beta1::Subaccount* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::Subaccount>(Arena*);
template <>
::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket>(Arena*);
template <>
::injective::exchange::v1beta1::TierStatistic* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TierStatistic>(Arena*);
template <>
::injective::exchange::v1beta1::TradeHistoryOptions* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TradeHistoryOptions>(Arena*);
template <>
::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder>(Arena*);
template <>
::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>(Arena*);
template <>
::injective::exchange::v1beta1::TrimmedSpotLimitOrder* Arena::CreateMaybeMessage<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective {
namespace exchange {
namespace v1beta1 {
enum OrderSide : int {
  Side_Unspecified = 0,
  Buy = 1,
  Sell = 2,
  OrderSide_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderSide_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderSide_IsValid(int value);
constexpr OrderSide OrderSide_MIN = static_cast<OrderSide>(0);
constexpr OrderSide OrderSide_MAX = static_cast<OrderSide>(2);
constexpr int OrderSide_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderSide_descriptor();
template <typename T>
const std::string& OrderSide_Name(T value) {
  static_assert(std::is_same<T, OrderSide>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderSide_Name().");
  return OrderSide_Name(static_cast<OrderSide>(value));
}
template <>
inline const std::string& OrderSide_Name(OrderSide value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderSide_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool OrderSide_Parse(absl::string_view name, OrderSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderSide>(
      OrderSide_descriptor(), name, value);
}
enum CancellationStrategy : int {
  UnspecifiedOrder = 0,
  FromWorstToBest = 1,
  FromBestToWorst = 2,
  CancellationStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CancellationStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CancellationStrategy_IsValid(int value);
constexpr CancellationStrategy CancellationStrategy_MIN = static_cast<CancellationStrategy>(0);
constexpr CancellationStrategy CancellationStrategy_MAX = static_cast<CancellationStrategy>(2);
constexpr int CancellationStrategy_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CancellationStrategy_descriptor();
template <typename T>
const std::string& CancellationStrategy_Name(T value) {
  static_assert(std::is_same<T, CancellationStrategy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CancellationStrategy_Name().");
  return CancellationStrategy_Name(static_cast<CancellationStrategy>(value));
}
template <>
inline const std::string& CancellationStrategy_Name(CancellationStrategy value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CancellationStrategy_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CancellationStrategy_Parse(absl::string_view name, CancellationStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CancellationStrategy>(
      CancellationStrategy_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Subaccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.Subaccount) */ {
 public:
  inline Subaccount() : Subaccount(nullptr) {}
  ~Subaccount() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Subaccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subaccount(const Subaccount& from);
  Subaccount(Subaccount&& from) noexcept
    : Subaccount() {
    *this = ::std::move(from);
  }

  inline Subaccount& operator=(const Subaccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subaccount& operator=(Subaccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subaccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subaccount* internal_default_instance() {
    return reinterpret_cast<const Subaccount*>(
               &_Subaccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Subaccount& a, Subaccount& b) {
    a.Swap(&b);
  }
  inline void Swap(Subaccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subaccount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subaccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subaccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subaccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subaccount& from) {
    Subaccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subaccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.Subaccount";
  }
  protected:
  explicit Subaccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraderFieldNumber = 1,
    kSubaccountNonceFieldNumber = 2,
  };
  // string trader = 1 [json_name = "trader"];
  void clear_trader() ;
  const std::string& trader() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trader(Arg_&& arg, Args_... args);
  std::string* mutable_trader();
  PROTOBUF_NODISCARD std::string* release_trader();
  void set_allocated_trader(std::string* ptr);

  private:
  const std::string& _internal_trader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trader(
      const std::string& value);
  std::string* _internal_mutable_trader();

  public:
  // uint32 subaccount_nonce = 2 [json_name = "subaccountNonce"];
  void clear_subaccount_nonce() ;
  ::uint32_t subaccount_nonce() const;
  void set_subaccount_nonce(::uint32_t value);

  private:
  ::uint32_t _internal_subaccount_nonce() const;
  void _internal_set_subaccount_nonce(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.Subaccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trader_;
    ::uint32_t subaccount_nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountOrdersRequest) */ {
 public:
  inline QuerySubaccountOrdersRequest() : QuerySubaccountOrdersRequest(nullptr) {}
  ~QuerySubaccountOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountOrdersRequest(const QuerySubaccountOrdersRequest& from);
  QuerySubaccountOrdersRequest(QuerySubaccountOrdersRequest&& from) noexcept
    : QuerySubaccountOrdersRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountOrdersRequest& operator=(const QuerySubaccountOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountOrdersRequest& operator=(QuerySubaccountOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountOrdersRequest*>(
               &_QuerySubaccountOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QuerySubaccountOrdersRequest& a, QuerySubaccountOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountOrdersRequest& from) {
    QuerySubaccountOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountOrdersRequest";
  }
  protected:
  explicit QuerySubaccountOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountOrdersResponse) */ {
 public:
  inline QuerySubaccountOrdersResponse() : QuerySubaccountOrdersResponse(nullptr) {}
  ~QuerySubaccountOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountOrdersResponse(const QuerySubaccountOrdersResponse& from);
  QuerySubaccountOrdersResponse(QuerySubaccountOrdersResponse&& from) noexcept
    : QuerySubaccountOrdersResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountOrdersResponse& operator=(const QuerySubaccountOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountOrdersResponse& operator=(QuerySubaccountOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountOrdersResponse*>(
               &_QuerySubaccountOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QuerySubaccountOrdersResponse& a, QuerySubaccountOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountOrdersResponse& from) {
    QuerySubaccountOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountOrdersResponse";
  }
  protected:
  explicit QuerySubaccountOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuyOrdersFieldNumber = 1,
    kSellOrdersFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.SubaccountOrderData buy_orders = 1 [json_name = "buyOrders"];
  int buy_orders_size() const;
  private:
  int _internal_buy_orders_size() const;

  public:
  void clear_buy_orders() ;
  ::injective::exchange::v1beta1::SubaccountOrderData* mutable_buy_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >*
      mutable_buy_orders();
  private:
  const ::injective::exchange::v1beta1::SubaccountOrderData& _internal_buy_orders(int index) const;
  ::injective::exchange::v1beta1::SubaccountOrderData* _internal_add_buy_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>& _internal_buy_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>* _internal_mutable_buy_orders();
  public:
  const ::injective::exchange::v1beta1::SubaccountOrderData& buy_orders(int index) const;
  ::injective::exchange::v1beta1::SubaccountOrderData* add_buy_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >&
      buy_orders() const;
  // repeated .injective.exchange.v1beta1.SubaccountOrderData sell_orders = 2 [json_name = "sellOrders"];
  int sell_orders_size() const;
  private:
  int _internal_sell_orders_size() const;

  public:
  void clear_sell_orders() ;
  ::injective::exchange::v1beta1::SubaccountOrderData* mutable_sell_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >*
      mutable_sell_orders();
  private:
  const ::injective::exchange::v1beta1::SubaccountOrderData& _internal_sell_orders(int index) const;
  ::injective::exchange::v1beta1::SubaccountOrderData* _internal_add_sell_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>& _internal_sell_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>* _internal_mutable_sell_orders();
  public:
  const ::injective::exchange::v1beta1::SubaccountOrderData& sell_orders(int index) const;
  ::injective::exchange::v1beta1::SubaccountOrderData* add_sell_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >&
      sell_orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData > buy_orders_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData > sell_orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrderbookMetadataWithMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket) */ {
 public:
  inline SubaccountOrderbookMetadataWithMarket() : SubaccountOrderbookMetadataWithMarket(nullptr) {}
  ~SubaccountOrderbookMetadataWithMarket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrderbookMetadataWithMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrderbookMetadataWithMarket(const SubaccountOrderbookMetadataWithMarket& from);
  SubaccountOrderbookMetadataWithMarket(SubaccountOrderbookMetadataWithMarket&& from) noexcept
    : SubaccountOrderbookMetadataWithMarket() {
    *this = ::std::move(from);
  }

  inline SubaccountOrderbookMetadataWithMarket& operator=(const SubaccountOrderbookMetadataWithMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrderbookMetadataWithMarket& operator=(SubaccountOrderbookMetadataWithMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrderbookMetadataWithMarket& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrderbookMetadataWithMarket* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrderbookMetadataWithMarket*>(
               &_SubaccountOrderbookMetadataWithMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubaccountOrderbookMetadataWithMarket& a, SubaccountOrderbookMetadataWithMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrderbookMetadataWithMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrderbookMetadataWithMarket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrderbookMetadataWithMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrderbookMetadataWithMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrderbookMetadataWithMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrderbookMetadataWithMarket& from) {
    SubaccountOrderbookMetadataWithMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrderbookMetadataWithMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket";
  }
  protected:
  explicit SubaccountOrderbookMetadataWithMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 2,
    kMetadataFieldNumber = 1,
    kIsBuyFieldNumber = 3,
  };
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective.exchange.v1beta1.SubaccountOrderbookMetadata metadata = 1 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::injective::exchange::v1beta1::SubaccountOrderbookMetadata& metadata() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* release_metadata();
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* mutable_metadata();
  void set_allocated_metadata(::injective::exchange::v1beta1::SubaccountOrderbookMetadata* metadata);
  private:
  const ::injective::exchange::v1beta1::SubaccountOrderbookMetadata& _internal_metadata() const;
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* metadata);
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* unsafe_arena_release_metadata();
  // bool isBuy = 3 [json_name = "isBuy"];
  void clear_isbuy() ;
  bool isbuy() const;
  void set_isbuy(bool value);

  private:
  bool _internal_isbuy() const;
  void _internal_set_isbuy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* metadata_;
    bool isbuy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryExchangeParamsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryExchangeParamsRequest) */ {
 public:
  inline QueryExchangeParamsRequest() : QueryExchangeParamsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryExchangeParamsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryExchangeParamsRequest(const QueryExchangeParamsRequest& from);
  QueryExchangeParamsRequest(QueryExchangeParamsRequest&& from) noexcept
    : QueryExchangeParamsRequest() {
    *this = ::std::move(from);
  }

  inline QueryExchangeParamsRequest& operator=(const QueryExchangeParamsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryExchangeParamsRequest& operator=(QueryExchangeParamsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryExchangeParamsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryExchangeParamsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryExchangeParamsRequest*>(
               &_QueryExchangeParamsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QueryExchangeParamsRequest& a, QueryExchangeParamsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryExchangeParamsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryExchangeParamsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryExchangeParamsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryExchangeParamsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryExchangeParamsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryExchangeParamsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryExchangeParamsRequest";
  }
  protected:
  explicit QueryExchangeParamsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryExchangeParamsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryExchangeParamsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryExchangeParamsResponse) */ {
 public:
  inline QueryExchangeParamsResponse() : QueryExchangeParamsResponse(nullptr) {}
  ~QueryExchangeParamsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryExchangeParamsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryExchangeParamsResponse(const QueryExchangeParamsResponse& from);
  QueryExchangeParamsResponse(QueryExchangeParamsResponse&& from) noexcept
    : QueryExchangeParamsResponse() {
    *this = ::std::move(from);
  }

  inline QueryExchangeParamsResponse& operator=(const QueryExchangeParamsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryExchangeParamsResponse& operator=(QueryExchangeParamsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryExchangeParamsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryExchangeParamsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryExchangeParamsResponse*>(
               &_QueryExchangeParamsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(QueryExchangeParamsResponse& a, QueryExchangeParamsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryExchangeParamsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryExchangeParamsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryExchangeParamsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryExchangeParamsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryExchangeParamsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryExchangeParamsResponse& from) {
    QueryExchangeParamsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryExchangeParamsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryExchangeParamsResponse";
  }
  protected:
  explicit QueryExchangeParamsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.Params params = 1 [json_name = "params", (.gogoproto.nullable) = false];
  bool has_params() const;
  void clear_params() ;
  const ::injective::exchange::v1beta1::Params& params() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Params* release_params();
  ::injective::exchange::v1beta1::Params* mutable_params();
  void set_allocated_params(::injective::exchange::v1beta1::Params* params);
  private:
  const ::injective::exchange::v1beta1::Params& _internal_params() const;
  ::injective::exchange::v1beta1::Params* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::injective::exchange::v1beta1::Params* params);
  ::injective::exchange::v1beta1::Params* unsafe_arena_release_params();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryExchangeParamsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::Params* params_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountDepositsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountDepositsRequest) */ {
 public:
  inline QuerySubaccountDepositsRequest() : QuerySubaccountDepositsRequest(nullptr) {}
  ~QuerySubaccountDepositsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountDepositsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountDepositsRequest(const QuerySubaccountDepositsRequest& from);
  QuerySubaccountDepositsRequest(QuerySubaccountDepositsRequest&& from) noexcept
    : QuerySubaccountDepositsRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountDepositsRequest& operator=(const QuerySubaccountDepositsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountDepositsRequest& operator=(QuerySubaccountDepositsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountDepositsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountDepositsRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountDepositsRequest*>(
               &_QuerySubaccountDepositsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QuerySubaccountDepositsRequest& a, QuerySubaccountDepositsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountDepositsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountDepositsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountDepositsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountDepositsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountDepositsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountDepositsRequest& from) {
    QuerySubaccountDepositsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountDepositsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountDepositsRequest";
  }
  protected:
  explicit QuerySubaccountDepositsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kSubaccountFieldNumber = 2,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // .injective.exchange.v1beta1.Subaccount subaccount = 2 [json_name = "subaccount", (.gogoproto.nullable) = true];
  bool has_subaccount() const;
  void clear_subaccount() ;
  const ::injective::exchange::v1beta1::Subaccount& subaccount() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Subaccount* release_subaccount();
  ::injective::exchange::v1beta1::Subaccount* mutable_subaccount();
  void set_allocated_subaccount(::injective::exchange::v1beta1::Subaccount* subaccount);
  private:
  const ::injective::exchange::v1beta1::Subaccount& _internal_subaccount() const;
  ::injective::exchange::v1beta1::Subaccount* _internal_mutable_subaccount();
  public:
  void unsafe_arena_set_allocated_subaccount(
      ::injective::exchange::v1beta1::Subaccount* subaccount);
  ::injective::exchange::v1beta1::Subaccount* unsafe_arena_release_subaccount();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountDepositsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::injective::exchange::v1beta1::Subaccount* subaccount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse, 
    std::string, ::injective::exchange::v1beta1::Deposit,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse, 
    std::string, ::injective::exchange::v1beta1::Deposit,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse& other);
  static const QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse*>(&_QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "injective.exchange.v1beta1.QuerySubaccountDepositsResponse.DepositsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};
// -------------------------------------------------------------------

class QuerySubaccountDepositsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountDepositsResponse) */ {
 public:
  inline QuerySubaccountDepositsResponse() : QuerySubaccountDepositsResponse(nullptr) {}
  ~QuerySubaccountDepositsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountDepositsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountDepositsResponse(const QuerySubaccountDepositsResponse& from);
  QuerySubaccountDepositsResponse(QuerySubaccountDepositsResponse&& from) noexcept
    : QuerySubaccountDepositsResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountDepositsResponse& operator=(const QuerySubaccountDepositsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountDepositsResponse& operator=(QuerySubaccountDepositsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountDepositsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountDepositsResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountDepositsResponse*>(
               &_QuerySubaccountDepositsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(QuerySubaccountDepositsResponse& a, QuerySubaccountDepositsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountDepositsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountDepositsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountDepositsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountDepositsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountDepositsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountDepositsResponse& from) {
    QuerySubaccountDepositsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountDepositsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountDepositsResponse";
  }
  protected:
  explicit QuerySubaccountDepositsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDepositsFieldNumber = 1,
  };
  // map<string, .injective.exchange.v1beta1.Deposit> deposits = 1 [json_name = "deposits"];
  int deposits_size() const;
  private:
  int _internal_deposits_size() const;

  public:
  void clear_deposits() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >&
      _internal_deposits() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >*
      _internal_mutable_deposits();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >&
      deposits() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >*
      mutable_deposits();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountDepositsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        QuerySubaccountDepositsResponse_DepositsEntry_DoNotUse,
        std::string, ::injective::exchange::v1beta1::Deposit,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> deposits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryExchangeBalancesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryExchangeBalancesRequest) */ {
 public:
  inline QueryExchangeBalancesRequest() : QueryExchangeBalancesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryExchangeBalancesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryExchangeBalancesRequest(const QueryExchangeBalancesRequest& from);
  QueryExchangeBalancesRequest(QueryExchangeBalancesRequest&& from) noexcept
    : QueryExchangeBalancesRequest() {
    *this = ::std::move(from);
  }

  inline QueryExchangeBalancesRequest& operator=(const QueryExchangeBalancesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryExchangeBalancesRequest& operator=(QueryExchangeBalancesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryExchangeBalancesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryExchangeBalancesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryExchangeBalancesRequest*>(
               &_QueryExchangeBalancesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(QueryExchangeBalancesRequest& a, QueryExchangeBalancesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryExchangeBalancesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryExchangeBalancesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryExchangeBalancesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryExchangeBalancesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryExchangeBalancesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryExchangeBalancesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryExchangeBalancesRequest";
  }
  protected:
  explicit QueryExchangeBalancesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryExchangeBalancesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryExchangeBalancesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryExchangeBalancesResponse) */ {
 public:
  inline QueryExchangeBalancesResponse() : QueryExchangeBalancesResponse(nullptr) {}
  ~QueryExchangeBalancesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryExchangeBalancesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryExchangeBalancesResponse(const QueryExchangeBalancesResponse& from);
  QueryExchangeBalancesResponse(QueryExchangeBalancesResponse&& from) noexcept
    : QueryExchangeBalancesResponse() {
    *this = ::std::move(from);
  }

  inline QueryExchangeBalancesResponse& operator=(const QueryExchangeBalancesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryExchangeBalancesResponse& operator=(QueryExchangeBalancesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryExchangeBalancesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryExchangeBalancesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryExchangeBalancesResponse*>(
               &_QueryExchangeBalancesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(QueryExchangeBalancesResponse& a, QueryExchangeBalancesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryExchangeBalancesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryExchangeBalancesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryExchangeBalancesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryExchangeBalancesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryExchangeBalancesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryExchangeBalancesResponse& from) {
    QueryExchangeBalancesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryExchangeBalancesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryExchangeBalancesResponse";
  }
  protected:
  explicit QueryExchangeBalancesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalancesFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.Balance balances = 1 [json_name = "balances", (.gogoproto.nullable) = false];
  int balances_size() const;
  private:
  int _internal_balances_size() const;

  public:
  void clear_balances() ;
  ::injective::exchange::v1beta1::Balance* mutable_balances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Balance >*
      mutable_balances();
  private:
  const ::injective::exchange::v1beta1::Balance& _internal_balances(int index) const;
  ::injective::exchange::v1beta1::Balance* _internal_add_balances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Balance>& _internal_balances() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Balance>* _internal_mutable_balances();
  public:
  const ::injective::exchange::v1beta1::Balance& balances(int index) const;
  ::injective::exchange::v1beta1::Balance* add_balances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Balance >&
      balances() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryExchangeBalancesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Balance > balances_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateVolumeRequest) */ {
 public:
  inline QueryAggregateVolumeRequest() : QueryAggregateVolumeRequest(nullptr) {}
  ~QueryAggregateVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateVolumeRequest(const QueryAggregateVolumeRequest& from);
  QueryAggregateVolumeRequest(QueryAggregateVolumeRequest&& from) noexcept
    : QueryAggregateVolumeRequest() {
    *this = ::std::move(from);
  }

  inline QueryAggregateVolumeRequest& operator=(const QueryAggregateVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateVolumeRequest& operator=(QueryAggregateVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateVolumeRequest*>(
               &_QueryAggregateVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(QueryAggregateVolumeRequest& a, QueryAggregateVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateVolumeRequest& from) {
    QueryAggregateVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateVolumeRequest";
  }
  protected:
  explicit QueryAggregateVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // string account = 1 [json_name = "account"];
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateVolumeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateVolumeResponse) */ {
 public:
  inline QueryAggregateVolumeResponse() : QueryAggregateVolumeResponse(nullptr) {}
  ~QueryAggregateVolumeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateVolumeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateVolumeResponse(const QueryAggregateVolumeResponse& from);
  QueryAggregateVolumeResponse(QueryAggregateVolumeResponse&& from) noexcept
    : QueryAggregateVolumeResponse() {
    *this = ::std::move(from);
  }

  inline QueryAggregateVolumeResponse& operator=(const QueryAggregateVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateVolumeResponse& operator=(QueryAggregateVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateVolumeResponse*>(
               &_QueryAggregateVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(QueryAggregateVolumeResponse& a, QueryAggregateVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateVolumeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateVolumeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateVolumeResponse& from) {
    QueryAggregateVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateVolumeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateVolumeResponse";
  }
  protected:
  explicit QueryAggregateVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregateVolumesFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.MarketVolume aggregate_volumes = 1 [json_name = "aggregateVolumes"];
  int aggregate_volumes_size() const;
  private:
  int _internal_aggregate_volumes_size() const;

  public:
  void clear_aggregate_volumes() ;
  ::injective::exchange::v1beta1::MarketVolume* mutable_aggregate_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
      mutable_aggregate_volumes();
  private:
  const ::injective::exchange::v1beta1::MarketVolume& _internal_aggregate_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* _internal_add_aggregate_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>& _internal_aggregate_volumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>* _internal_mutable_aggregate_volumes();
  public:
  const ::injective::exchange::v1beta1::MarketVolume& aggregate_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* add_aggregate_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
      aggregate_volumes() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume > aggregate_volumes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateVolumesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateVolumesRequest) */ {
 public:
  inline QueryAggregateVolumesRequest() : QueryAggregateVolumesRequest(nullptr) {}
  ~QueryAggregateVolumesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateVolumesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateVolumesRequest(const QueryAggregateVolumesRequest& from);
  QueryAggregateVolumesRequest(QueryAggregateVolumesRequest&& from) noexcept
    : QueryAggregateVolumesRequest() {
    *this = ::std::move(from);
  }

  inline QueryAggregateVolumesRequest& operator=(const QueryAggregateVolumesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateVolumesRequest& operator=(QueryAggregateVolumesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateVolumesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateVolumesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateVolumesRequest*>(
               &_QueryAggregateVolumesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(QueryAggregateVolumesRequest& a, QueryAggregateVolumesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateVolumesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateVolumesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateVolumesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateVolumesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateVolumesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateVolumesRequest& from) {
    QueryAggregateVolumesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateVolumesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateVolumesRequest";
  }
  protected:
  explicit QueryAggregateVolumesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
    kMarketIdsFieldNumber = 2,
  };
  // repeated string accounts = 1 [json_name = "accounts"];
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;

  public:
  void clear_accounts() ;
  const std::string& accounts(int index) const;
  std::string* mutable_accounts(int index);
  void set_accounts(int index, const std::string& value);
  void set_accounts(int index, std::string&& value);
  void set_accounts(int index, const char* value);
  void set_accounts(int index, const char* value, std::size_t size);
  void set_accounts(int index, absl::string_view value);
  std::string* add_accounts();
  void add_accounts(const std::string& value);
  void add_accounts(std::string&& value);
  void add_accounts(const char* value);
  void add_accounts(const char* value, std::size_t size);
  void add_accounts(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& accounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_accounts();

  private:
  const std::string& _internal_accounts(int index) const;
  std::string* _internal_add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_accounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_accounts();

  public:
  // repeated string market_ids = 2 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateVolumesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> accounts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateVolumesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateVolumesResponse) */ {
 public:
  inline QueryAggregateVolumesResponse() : QueryAggregateVolumesResponse(nullptr) {}
  ~QueryAggregateVolumesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateVolumesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateVolumesResponse(const QueryAggregateVolumesResponse& from);
  QueryAggregateVolumesResponse(QueryAggregateVolumesResponse&& from) noexcept
    : QueryAggregateVolumesResponse() {
    *this = ::std::move(from);
  }

  inline QueryAggregateVolumesResponse& operator=(const QueryAggregateVolumesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateVolumesResponse& operator=(QueryAggregateVolumesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateVolumesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateVolumesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateVolumesResponse*>(
               &_QueryAggregateVolumesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(QueryAggregateVolumesResponse& a, QueryAggregateVolumesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateVolumesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateVolumesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateVolumesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateVolumesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateVolumesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateVolumesResponse& from) {
    QueryAggregateVolumesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateVolumesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateVolumesResponse";
  }
  protected:
  explicit QueryAggregateVolumesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregateAccountVolumesFieldNumber = 1,
    kAggregateMarketVolumesFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.AggregateAccountVolumeRecord aggregate_account_volumes = 1 [json_name = "aggregateAccountVolumes"];
  int aggregate_account_volumes_size() const;
  private:
  int _internal_aggregate_account_volumes_size() const;

  public:
  void clear_aggregate_account_volumes() ;
  ::injective::exchange::v1beta1::AggregateAccountVolumeRecord* mutable_aggregate_account_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AggregateAccountVolumeRecord >*
      mutable_aggregate_account_volumes();
  private:
  const ::injective::exchange::v1beta1::AggregateAccountVolumeRecord& _internal_aggregate_account_volumes(int index) const;
  ::injective::exchange::v1beta1::AggregateAccountVolumeRecord* _internal_add_aggregate_account_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AggregateAccountVolumeRecord>& _internal_aggregate_account_volumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AggregateAccountVolumeRecord>* _internal_mutable_aggregate_account_volumes();
  public:
  const ::injective::exchange::v1beta1::AggregateAccountVolumeRecord& aggregate_account_volumes(int index) const;
  ::injective::exchange::v1beta1::AggregateAccountVolumeRecord* add_aggregate_account_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AggregateAccountVolumeRecord >&
      aggregate_account_volumes() const;
  // repeated .injective.exchange.v1beta1.MarketVolume aggregate_market_volumes = 2 [json_name = "aggregateMarketVolumes"];
  int aggregate_market_volumes_size() const;
  private:
  int _internal_aggregate_market_volumes_size() const;

  public:
  void clear_aggregate_market_volumes() ;
  ::injective::exchange::v1beta1::MarketVolume* mutable_aggregate_market_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
      mutable_aggregate_market_volumes();
  private:
  const ::injective::exchange::v1beta1::MarketVolume& _internal_aggregate_market_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* _internal_add_aggregate_market_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>& _internal_aggregate_market_volumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>* _internal_mutable_aggregate_market_volumes();
  public:
  const ::injective::exchange::v1beta1::MarketVolume& aggregate_market_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* add_aggregate_market_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
      aggregate_market_volumes() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateVolumesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AggregateAccountVolumeRecord > aggregate_account_volumes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume > aggregate_market_volumes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateMarketVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest) */ {
 public:
  inline QueryAggregateMarketVolumeRequest() : QueryAggregateMarketVolumeRequest(nullptr) {}
  ~QueryAggregateMarketVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateMarketVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateMarketVolumeRequest(const QueryAggregateMarketVolumeRequest& from);
  QueryAggregateMarketVolumeRequest(QueryAggregateMarketVolumeRequest&& from) noexcept
    : QueryAggregateMarketVolumeRequest() {
    *this = ::std::move(from);
  }

  inline QueryAggregateMarketVolumeRequest& operator=(const QueryAggregateMarketVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateMarketVolumeRequest& operator=(QueryAggregateMarketVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateMarketVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateMarketVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateMarketVolumeRequest*>(
               &_QueryAggregateMarketVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(QueryAggregateMarketVolumeRequest& a, QueryAggregateMarketVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateMarketVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateMarketVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateMarketVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateMarketVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateMarketVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateMarketVolumeRequest& from) {
    QueryAggregateMarketVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateMarketVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest";
  }
  protected:
  explicit QueryAggregateMarketVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateMarketVolumeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse) */ {
 public:
  inline QueryAggregateMarketVolumeResponse() : QueryAggregateMarketVolumeResponse(nullptr) {}
  ~QueryAggregateMarketVolumeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateMarketVolumeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateMarketVolumeResponse(const QueryAggregateMarketVolumeResponse& from);
  QueryAggregateMarketVolumeResponse(QueryAggregateMarketVolumeResponse&& from) noexcept
    : QueryAggregateMarketVolumeResponse() {
    *this = ::std::move(from);
  }

  inline QueryAggregateMarketVolumeResponse& operator=(const QueryAggregateMarketVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateMarketVolumeResponse& operator=(QueryAggregateMarketVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateMarketVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateMarketVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateMarketVolumeResponse*>(
               &_QueryAggregateMarketVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(QueryAggregateMarketVolumeResponse& a, QueryAggregateMarketVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateMarketVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateMarketVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateMarketVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateMarketVolumeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateMarketVolumeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateMarketVolumeResponse& from) {
    QueryAggregateMarketVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateMarketVolumeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse";
  }
  protected:
  explicit QueryAggregateMarketVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.VolumeRecord volume = 1 [json_name = "volume", (.gogoproto.nullable) = false];
  bool has_volume() const;
  void clear_volume() ;
  const ::injective::exchange::v1beta1::VolumeRecord& volume() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::VolumeRecord* release_volume();
  ::injective::exchange::v1beta1::VolumeRecord* mutable_volume();
  void set_allocated_volume(::injective::exchange::v1beta1::VolumeRecord* volume);
  private:
  const ::injective::exchange::v1beta1::VolumeRecord& _internal_volume() const;
  ::injective::exchange::v1beta1::VolumeRecord* _internal_mutable_volume();
  public:
  void unsafe_arena_set_allocated_volume(
      ::injective::exchange::v1beta1::VolumeRecord* volume);
  ::injective::exchange::v1beta1::VolumeRecord* unsafe_arena_release_volume();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::VolumeRecord* volume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDenomDecimalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDenomDecimalRequest) */ {
 public:
  inline QueryDenomDecimalRequest() : QueryDenomDecimalRequest(nullptr) {}
  ~QueryDenomDecimalRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDenomDecimalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDenomDecimalRequest(const QueryDenomDecimalRequest& from);
  QueryDenomDecimalRequest(QueryDenomDecimalRequest&& from) noexcept
    : QueryDenomDecimalRequest() {
    *this = ::std::move(from);
  }

  inline QueryDenomDecimalRequest& operator=(const QueryDenomDecimalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDenomDecimalRequest& operator=(QueryDenomDecimalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDenomDecimalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDenomDecimalRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDenomDecimalRequest*>(
               &_QueryDenomDecimalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(QueryDenomDecimalRequest& a, QueryDenomDecimalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDenomDecimalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDenomDecimalRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDenomDecimalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDenomDecimalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDenomDecimalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDenomDecimalRequest& from) {
    QueryDenomDecimalRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDenomDecimalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDenomDecimalRequest";
  }
  protected:
  explicit QueryDenomDecimalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDenomDecimalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDenomDecimalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDenomDecimalResponse) */ {
 public:
  inline QueryDenomDecimalResponse() : QueryDenomDecimalResponse(nullptr) {}
  ~QueryDenomDecimalResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDenomDecimalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDenomDecimalResponse(const QueryDenomDecimalResponse& from);
  QueryDenomDecimalResponse(QueryDenomDecimalResponse&& from) noexcept
    : QueryDenomDecimalResponse() {
    *this = ::std::move(from);
  }

  inline QueryDenomDecimalResponse& operator=(const QueryDenomDecimalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDenomDecimalResponse& operator=(QueryDenomDecimalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDenomDecimalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDenomDecimalResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDenomDecimalResponse*>(
               &_QueryDenomDecimalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(QueryDenomDecimalResponse& a, QueryDenomDecimalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDenomDecimalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDenomDecimalResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDenomDecimalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDenomDecimalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDenomDecimalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDenomDecimalResponse& from) {
    QueryDenomDecimalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDenomDecimalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDenomDecimalResponse";
  }
  protected:
  explicit QueryDenomDecimalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecimalFieldNumber = 1,
  };
  // uint64 decimal = 1 [json_name = "decimal"];
  void clear_decimal() ;
  ::uint64_t decimal() const;
  void set_decimal(::uint64_t value);

  private:
  ::uint64_t _internal_decimal() const;
  void _internal_set_decimal(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDenomDecimalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t decimal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDenomDecimalsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDenomDecimalsRequest) */ {
 public:
  inline QueryDenomDecimalsRequest() : QueryDenomDecimalsRequest(nullptr) {}
  ~QueryDenomDecimalsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDenomDecimalsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDenomDecimalsRequest(const QueryDenomDecimalsRequest& from);
  QueryDenomDecimalsRequest(QueryDenomDecimalsRequest&& from) noexcept
    : QueryDenomDecimalsRequest() {
    *this = ::std::move(from);
  }

  inline QueryDenomDecimalsRequest& operator=(const QueryDenomDecimalsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDenomDecimalsRequest& operator=(QueryDenomDecimalsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDenomDecimalsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDenomDecimalsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDenomDecimalsRequest*>(
               &_QueryDenomDecimalsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(QueryDenomDecimalsRequest& a, QueryDenomDecimalsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDenomDecimalsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDenomDecimalsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDenomDecimalsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDenomDecimalsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDenomDecimalsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDenomDecimalsRequest& from) {
    QueryDenomDecimalsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDenomDecimalsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDenomDecimalsRequest";
  }
  protected:
  explicit QueryDenomDecimalsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomsFieldNumber = 1,
  };
  // repeated string denoms = 1 [json_name = "denoms"];
  int denoms_size() const;
  private:
  int _internal_denoms_size() const;

  public:
  void clear_denoms() ;
  const std::string& denoms(int index) const;
  std::string* mutable_denoms(int index);
  void set_denoms(int index, const std::string& value);
  void set_denoms(int index, std::string&& value);
  void set_denoms(int index, const char* value);
  void set_denoms(int index, const char* value, std::size_t size);
  void set_denoms(int index, absl::string_view value);
  std::string* add_denoms();
  void add_denoms(const std::string& value);
  void add_denoms(std::string&& value);
  void add_denoms(const char* value);
  void add_denoms(const char* value, std::size_t size);
  void add_denoms(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_denoms();

  private:
  const std::string& _internal_denoms(int index) const;
  std::string* _internal_add_denoms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_denoms();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDenomDecimalsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> denoms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDenomDecimalsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDenomDecimalsResponse) */ {
 public:
  inline QueryDenomDecimalsResponse() : QueryDenomDecimalsResponse(nullptr) {}
  ~QueryDenomDecimalsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDenomDecimalsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDenomDecimalsResponse(const QueryDenomDecimalsResponse& from);
  QueryDenomDecimalsResponse(QueryDenomDecimalsResponse&& from) noexcept
    : QueryDenomDecimalsResponse() {
    *this = ::std::move(from);
  }

  inline QueryDenomDecimalsResponse& operator=(const QueryDenomDecimalsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDenomDecimalsResponse& operator=(QueryDenomDecimalsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDenomDecimalsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDenomDecimalsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDenomDecimalsResponse*>(
               &_QueryDenomDecimalsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(QueryDenomDecimalsResponse& a, QueryDenomDecimalsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDenomDecimalsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDenomDecimalsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDenomDecimalsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDenomDecimalsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDenomDecimalsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDenomDecimalsResponse& from) {
    QueryDenomDecimalsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDenomDecimalsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDenomDecimalsResponse";
  }
  protected:
  explicit QueryDenomDecimalsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomDecimalsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 1 [json_name = "denomDecimals", (.gogoproto.nullable) = false];
  int denom_decimals_size() const;
  private:
  int _internal_denom_decimals_size() const;

  public:
  void clear_denom_decimals() ;
  ::injective::exchange::v1beta1::DenomDecimals* mutable_denom_decimals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >*
      mutable_denom_decimals();
  private:
  const ::injective::exchange::v1beta1::DenomDecimals& _internal_denom_decimals(int index) const;
  ::injective::exchange::v1beta1::DenomDecimals* _internal_add_denom_decimals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>& _internal_denom_decimals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>* _internal_mutable_denom_decimals();
  public:
  const ::injective::exchange::v1beta1::DenomDecimals& denom_decimals(int index) const;
  ::injective::exchange::v1beta1::DenomDecimals* add_denom_decimals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >&
      denom_decimals() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDenomDecimalsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals > denom_decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateMarketVolumesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest) */ {
 public:
  inline QueryAggregateMarketVolumesRequest() : QueryAggregateMarketVolumesRequest(nullptr) {}
  ~QueryAggregateMarketVolumesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateMarketVolumesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateMarketVolumesRequest(const QueryAggregateMarketVolumesRequest& from);
  QueryAggregateMarketVolumesRequest(QueryAggregateMarketVolumesRequest&& from) noexcept
    : QueryAggregateMarketVolumesRequest() {
    *this = ::std::move(from);
  }

  inline QueryAggregateMarketVolumesRequest& operator=(const QueryAggregateMarketVolumesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateMarketVolumesRequest& operator=(QueryAggregateMarketVolumesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateMarketVolumesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateMarketVolumesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateMarketVolumesRequest*>(
               &_QueryAggregateMarketVolumesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(QueryAggregateMarketVolumesRequest& a, QueryAggregateMarketVolumesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateMarketVolumesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateMarketVolumesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateMarketVolumesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateMarketVolumesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateMarketVolumesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateMarketVolumesRequest& from) {
    QueryAggregateMarketVolumesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateMarketVolumesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest";
  }
  protected:
  explicit QueryAggregateMarketVolumesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAggregateMarketVolumesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse) */ {
 public:
  inline QueryAggregateMarketVolumesResponse() : QueryAggregateMarketVolumesResponse(nullptr) {}
  ~QueryAggregateMarketVolumesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAggregateMarketVolumesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAggregateMarketVolumesResponse(const QueryAggregateMarketVolumesResponse& from);
  QueryAggregateMarketVolumesResponse(QueryAggregateMarketVolumesResponse&& from) noexcept
    : QueryAggregateMarketVolumesResponse() {
    *this = ::std::move(from);
  }

  inline QueryAggregateMarketVolumesResponse& operator=(const QueryAggregateMarketVolumesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAggregateMarketVolumesResponse& operator=(QueryAggregateMarketVolumesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAggregateMarketVolumesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAggregateMarketVolumesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAggregateMarketVolumesResponse*>(
               &_QueryAggregateMarketVolumesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(QueryAggregateMarketVolumesResponse& a, QueryAggregateMarketVolumesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAggregateMarketVolumesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAggregateMarketVolumesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAggregateMarketVolumesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAggregateMarketVolumesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAggregateMarketVolumesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAggregateMarketVolumesResponse& from) {
    QueryAggregateMarketVolumesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAggregateMarketVolumesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse";
  }
  protected:
  explicit QueryAggregateMarketVolumesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumesFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.MarketVolume volumes = 1 [json_name = "volumes"];
  int volumes_size() const;
  private:
  int _internal_volumes_size() const;

  public:
  void clear_volumes() ;
  ::injective::exchange::v1beta1::MarketVolume* mutable_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
      mutable_volumes();
  private:
  const ::injective::exchange::v1beta1::MarketVolume& _internal_volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* _internal_add_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>& _internal_volumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>* _internal_mutable_volumes();
  public:
  const ::injective::exchange::v1beta1::MarketVolume& volumes(int index) const;
  ::injective::exchange::v1beta1::MarketVolume* add_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
      volumes() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume > volumes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountDepositRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountDepositRequest) */ {
 public:
  inline QuerySubaccountDepositRequest() : QuerySubaccountDepositRequest(nullptr) {}
  ~QuerySubaccountDepositRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountDepositRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountDepositRequest(const QuerySubaccountDepositRequest& from);
  QuerySubaccountDepositRequest(QuerySubaccountDepositRequest&& from) noexcept
    : QuerySubaccountDepositRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountDepositRequest& operator=(const QuerySubaccountDepositRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountDepositRequest& operator=(QuerySubaccountDepositRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountDepositRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountDepositRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountDepositRequest*>(
               &_QuerySubaccountDepositRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(QuerySubaccountDepositRequest& a, QuerySubaccountDepositRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountDepositRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountDepositRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountDepositRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountDepositRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountDepositRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountDepositRequest& from) {
    QuerySubaccountDepositRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountDepositRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountDepositRequest";
  }
  protected:
  explicit QuerySubaccountDepositRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kDenomFieldNumber = 2,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string denom = 2 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountDepositRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountDepositResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountDepositResponse) */ {
 public:
  inline QuerySubaccountDepositResponse() : QuerySubaccountDepositResponse(nullptr) {}
  ~QuerySubaccountDepositResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountDepositResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountDepositResponse(const QuerySubaccountDepositResponse& from);
  QuerySubaccountDepositResponse(QuerySubaccountDepositResponse&& from) noexcept
    : QuerySubaccountDepositResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountDepositResponse& operator=(const QuerySubaccountDepositResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountDepositResponse& operator=(QuerySubaccountDepositResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountDepositResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountDepositResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountDepositResponse*>(
               &_QuerySubaccountDepositResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(QuerySubaccountDepositResponse& a, QuerySubaccountDepositResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountDepositResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountDepositResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountDepositResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountDepositResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountDepositResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountDepositResponse& from) {
    QuerySubaccountDepositResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountDepositResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountDepositResponse";
  }
  protected:
  explicit QuerySubaccountDepositResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepositsFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.Deposit deposits = 1 [json_name = "deposits"];
  bool has_deposits() const;
  void clear_deposits() ;
  const ::injective::exchange::v1beta1::Deposit& deposits() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Deposit* release_deposits();
  ::injective::exchange::v1beta1::Deposit* mutable_deposits();
  void set_allocated_deposits(::injective::exchange::v1beta1::Deposit* deposits);
  private:
  const ::injective::exchange::v1beta1::Deposit& _internal_deposits() const;
  ::injective::exchange::v1beta1::Deposit* _internal_mutable_deposits();
  public:
  void unsafe_arena_set_allocated_deposits(
      ::injective::exchange::v1beta1::Deposit* deposits);
  ::injective::exchange::v1beta1::Deposit* unsafe_arena_release_deposits();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountDepositResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::Deposit* deposits_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotMarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotMarketsRequest) */ {
 public:
  inline QuerySpotMarketsRequest() : QuerySpotMarketsRequest(nullptr) {}
  ~QuerySpotMarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotMarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotMarketsRequest(const QuerySpotMarketsRequest& from);
  QuerySpotMarketsRequest(QuerySpotMarketsRequest&& from) noexcept
    : QuerySpotMarketsRequest() {
    *this = ::std::move(from);
  }

  inline QuerySpotMarketsRequest& operator=(const QuerySpotMarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotMarketsRequest& operator=(QuerySpotMarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotMarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotMarketsRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySpotMarketsRequest*>(
               &_QuerySpotMarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(QuerySpotMarketsRequest& a, QuerySpotMarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotMarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotMarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotMarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotMarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotMarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotMarketsRequest& from) {
    QuerySpotMarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotMarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotMarketsRequest";
  }
  protected:
  explicit QuerySpotMarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated string market_ids = 2 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string status = 1 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotMarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotMarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotMarketsResponse) */ {
 public:
  inline QuerySpotMarketsResponse() : QuerySpotMarketsResponse(nullptr) {}
  ~QuerySpotMarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotMarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotMarketsResponse(const QuerySpotMarketsResponse& from);
  QuerySpotMarketsResponse(QuerySpotMarketsResponse&& from) noexcept
    : QuerySpotMarketsResponse() {
    *this = ::std::move(from);
  }

  inline QuerySpotMarketsResponse& operator=(const QuerySpotMarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotMarketsResponse& operator=(QuerySpotMarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotMarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotMarketsResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySpotMarketsResponse*>(
               &_QuerySpotMarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(QuerySpotMarketsResponse& a, QuerySpotMarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotMarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotMarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotMarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotMarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotMarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotMarketsResponse& from) {
    QuerySpotMarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotMarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotMarketsResponse";
  }
  protected:
  explicit QuerySpotMarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.SpotMarket markets = 1 [json_name = "markets"];
  int markets_size() const;
  private:
  int _internal_markets_size() const;

  public:
  void clear_markets() ;
  ::injective::exchange::v1beta1::SpotMarket* mutable_markets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarket >*
      mutable_markets();
  private:
  const ::injective::exchange::v1beta1::SpotMarket& _internal_markets(int index) const;
  ::injective::exchange::v1beta1::SpotMarket* _internal_add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarket>& _internal_markets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarket>* _internal_mutable_markets();
  public:
  const ::injective::exchange::v1beta1::SpotMarket& markets(int index) const;
  ::injective::exchange::v1beta1::SpotMarket* add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarket >&
      markets() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotMarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarket > markets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotMarketRequest) */ {
 public:
  inline QuerySpotMarketRequest() : QuerySpotMarketRequest(nullptr) {}
  ~QuerySpotMarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotMarketRequest(const QuerySpotMarketRequest& from);
  QuerySpotMarketRequest(QuerySpotMarketRequest&& from) noexcept
    : QuerySpotMarketRequest() {
    *this = ::std::move(from);
  }

  inline QuerySpotMarketRequest& operator=(const QuerySpotMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotMarketRequest& operator=(QuerySpotMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotMarketRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySpotMarketRequest*>(
               &_QuerySpotMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(QuerySpotMarketRequest& a, QuerySpotMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotMarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotMarketRequest& from) {
    QuerySpotMarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotMarketRequest";
  }
  protected:
  explicit QuerySpotMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotMarketResponse) */ {
 public:
  inline QuerySpotMarketResponse() : QuerySpotMarketResponse(nullptr) {}
  ~QuerySpotMarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotMarketResponse(const QuerySpotMarketResponse& from);
  QuerySpotMarketResponse(QuerySpotMarketResponse&& from) noexcept
    : QuerySpotMarketResponse() {
    *this = ::std::move(from);
  }

  inline QuerySpotMarketResponse& operator=(const QuerySpotMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotMarketResponse& operator=(QuerySpotMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotMarketResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySpotMarketResponse*>(
               &_QuerySpotMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(QuerySpotMarketResponse& a, QuerySpotMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotMarketResponse& from) {
    QuerySpotMarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotMarketResponse";
  }
  protected:
  explicit QuerySpotMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::SpotMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SpotMarket* release_market();
  ::injective::exchange::v1beta1::SpotMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::SpotMarket* market);
  private:
  const ::injective::exchange::v1beta1::SpotMarket& _internal_market() const;
  ::injective::exchange::v1beta1::SpotMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::SpotMarket* market);
  ::injective::exchange::v1beta1::SpotMarket* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::SpotMarket* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotOrderbookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotOrderbookRequest) */ {
 public:
  inline QuerySpotOrderbookRequest() : QuerySpotOrderbookRequest(nullptr) {}
  ~QuerySpotOrderbookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotOrderbookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotOrderbookRequest(const QuerySpotOrderbookRequest& from);
  QuerySpotOrderbookRequest(QuerySpotOrderbookRequest&& from) noexcept
    : QuerySpotOrderbookRequest() {
    *this = ::std::move(from);
  }

  inline QuerySpotOrderbookRequest& operator=(const QuerySpotOrderbookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotOrderbookRequest& operator=(QuerySpotOrderbookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotOrderbookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotOrderbookRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySpotOrderbookRequest*>(
               &_QuerySpotOrderbookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(QuerySpotOrderbookRequest& a, QuerySpotOrderbookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotOrderbookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotOrderbookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotOrderbookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotOrderbookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotOrderbookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotOrderbookRequest& from) {
    QuerySpotOrderbookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotOrderbookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotOrderbookRequest";
  }
  protected:
  explicit QuerySpotOrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kLimitCumulativeNotionalFieldNumber = 4,
    kLimitCumulativeQuantityFieldNumber = 5,
    kLimitFieldNumber = 2,
    kOrderSideFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string limit_cumulative_notional = 4 [json_name = "limitCumulativeNotional", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_limit_cumulative_notional() ;
  const std::string& limit_cumulative_notional() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_limit_cumulative_notional(Arg_&& arg, Args_... args);
  std::string* mutable_limit_cumulative_notional();
  PROTOBUF_NODISCARD std::string* release_limit_cumulative_notional();
  void set_allocated_limit_cumulative_notional(std::string* ptr);

  private:
  const std::string& _internal_limit_cumulative_notional() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_limit_cumulative_notional(
      const std::string& value);
  std::string* _internal_mutable_limit_cumulative_notional();

  public:
  // string limit_cumulative_quantity = 5 [json_name = "limitCumulativeQuantity", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_limit_cumulative_quantity() ;
  const std::string& limit_cumulative_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_limit_cumulative_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_limit_cumulative_quantity();
  PROTOBUF_NODISCARD std::string* release_limit_cumulative_quantity();
  void set_allocated_limit_cumulative_quantity(std::string* ptr);

  private:
  const std::string& _internal_limit_cumulative_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_limit_cumulative_quantity(
      const std::string& value);
  std::string* _internal_mutable_limit_cumulative_quantity();

  public:
  // uint64 limit = 2 [json_name = "limit"];
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // .injective.exchange.v1beta1.OrderSide order_side = 3 [json_name = "orderSide"];
  void clear_order_side() ;
  ::injective::exchange::v1beta1::OrderSide order_side() const;
  void set_order_side(::injective::exchange::v1beta1::OrderSide value);

  private:
  ::injective::exchange::v1beta1::OrderSide _internal_order_side() const;
  void _internal_set_order_side(::injective::exchange::v1beta1::OrderSide value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotOrderbookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr limit_cumulative_notional_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr limit_cumulative_quantity_;
    ::uint64_t limit_;
    int order_side_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotOrderbookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotOrderbookResponse) */ {
 public:
  inline QuerySpotOrderbookResponse() : QuerySpotOrderbookResponse(nullptr) {}
  ~QuerySpotOrderbookResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotOrderbookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotOrderbookResponse(const QuerySpotOrderbookResponse& from);
  QuerySpotOrderbookResponse(QuerySpotOrderbookResponse&& from) noexcept
    : QuerySpotOrderbookResponse() {
    *this = ::std::move(from);
  }

  inline QuerySpotOrderbookResponse& operator=(const QuerySpotOrderbookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotOrderbookResponse& operator=(QuerySpotOrderbookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotOrderbookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotOrderbookResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySpotOrderbookResponse*>(
               &_QuerySpotOrderbookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(QuerySpotOrderbookResponse& a, QuerySpotOrderbookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotOrderbookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotOrderbookResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotOrderbookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotOrderbookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotOrderbookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotOrderbookResponse& from) {
    QuerySpotOrderbookResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotOrderbookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotOrderbookResponse";
  }
  protected:
  explicit QuerySpotOrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysPriceLevelFieldNumber = 1,
    kSellsPriceLevelFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.Level buys_price_level = 1 [json_name = "buysPriceLevel"];
  int buys_price_level_size() const;
  private:
  int _internal_buys_price_level_size() const;

  public:
  void clear_buys_price_level() ;
  ::injective::exchange::v1beta1::Level* mutable_buys_price_level(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
      mutable_buys_price_level();
  private:
  const ::injective::exchange::v1beta1::Level& _internal_buys_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* _internal_add_buys_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>& _internal_buys_price_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>* _internal_mutable_buys_price_level();
  public:
  const ::injective::exchange::v1beta1::Level& buys_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* add_buys_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
      buys_price_level() const;
  // repeated .injective.exchange.v1beta1.Level sells_price_level = 2 [json_name = "sellsPriceLevel"];
  int sells_price_level_size() const;
  private:
  int _internal_sells_price_level_size() const;

  public:
  void clear_sells_price_level() ;
  ::injective::exchange::v1beta1::Level* mutable_sells_price_level(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
      mutable_sells_price_level();
  private:
  const ::injective::exchange::v1beta1::Level& _internal_sells_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* _internal_add_sells_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>& _internal_sells_price_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>* _internal_mutable_sells_price_level();
  public:
  const ::injective::exchange::v1beta1::Level& sells_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* add_sells_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
      sells_price_level() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotOrderbookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level > buys_price_level_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level > sells_price_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class FullSpotMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.FullSpotMarket) */ {
 public:
  inline FullSpotMarket() : FullSpotMarket(nullptr) {}
  ~FullSpotMarket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FullSpotMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FullSpotMarket(const FullSpotMarket& from);
  FullSpotMarket(FullSpotMarket&& from) noexcept
    : FullSpotMarket() {
    *this = ::std::move(from);
  }

  inline FullSpotMarket& operator=(const FullSpotMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline FullSpotMarket& operator=(FullSpotMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FullSpotMarket& default_instance() {
    return *internal_default_instance();
  }
  static inline const FullSpotMarket* internal_default_instance() {
    return reinterpret_cast<const FullSpotMarket*>(
               &_FullSpotMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(FullSpotMarket& a, FullSpotMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(FullSpotMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FullSpotMarket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FullSpotMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FullSpotMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FullSpotMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FullSpotMarket& from) {
    FullSpotMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FullSpotMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.FullSpotMarket";
  }
  protected:
  explicit FullSpotMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
    kMidPriceAndTobFieldNumber = 2,
  };
  // .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::SpotMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::SpotMarket* release_market();
  ::injective::exchange::v1beta1::SpotMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::SpotMarket* market);
  private:
  const ::injective::exchange::v1beta1::SpotMarket& _internal_market() const;
  ::injective::exchange::v1beta1::SpotMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::SpotMarket* market);
  ::injective::exchange::v1beta1::SpotMarket* unsafe_arena_release_market();
  // .injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 2 [json_name = "midPriceAndTob", (.gogoproto.nullable) = true];
  bool has_mid_price_and_tob() const;
  void clear_mid_price_and_tob() ;
  const ::injective::exchange::v1beta1::MidPriceAndTOB& mid_price_and_tob() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::MidPriceAndTOB* release_mid_price_and_tob();
  ::injective::exchange::v1beta1::MidPriceAndTOB* mutable_mid_price_and_tob();
  void set_allocated_mid_price_and_tob(::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob);
  private:
  const ::injective::exchange::v1beta1::MidPriceAndTOB& _internal_mid_price_and_tob() const;
  ::injective::exchange::v1beta1::MidPriceAndTOB* _internal_mutable_mid_price_and_tob();
  public:
  void unsafe_arena_set_allocated_mid_price_and_tob(
      ::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob);
  ::injective::exchange::v1beta1::MidPriceAndTOB* unsafe_arena_release_mid_price_and_tob();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.FullSpotMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::SpotMarket* market_;
    ::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFullSpotMarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFullSpotMarketsRequest) */ {
 public:
  inline QueryFullSpotMarketsRequest() : QueryFullSpotMarketsRequest(nullptr) {}
  ~QueryFullSpotMarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFullSpotMarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFullSpotMarketsRequest(const QueryFullSpotMarketsRequest& from);
  QueryFullSpotMarketsRequest(QueryFullSpotMarketsRequest&& from) noexcept
    : QueryFullSpotMarketsRequest() {
    *this = ::std::move(from);
  }

  inline QueryFullSpotMarketsRequest& operator=(const QueryFullSpotMarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFullSpotMarketsRequest& operator=(QueryFullSpotMarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFullSpotMarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFullSpotMarketsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryFullSpotMarketsRequest*>(
               &_QueryFullSpotMarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(QueryFullSpotMarketsRequest& a, QueryFullSpotMarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFullSpotMarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFullSpotMarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFullSpotMarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFullSpotMarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFullSpotMarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFullSpotMarketsRequest& from) {
    QueryFullSpotMarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFullSpotMarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFullSpotMarketsRequest";
  }
  protected:
  explicit QueryFullSpotMarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 2,
    kStatusFieldNumber = 1,
    kWithMidPriceAndTobFieldNumber = 3,
  };
  // repeated string market_ids = 2 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string status = 1 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // bool with_mid_price_and_tob = 3 [json_name = "withMidPriceAndTob"];
  void clear_with_mid_price_and_tob() ;
  bool with_mid_price_and_tob() const;
  void set_with_mid_price_and_tob(bool value);

  private:
  bool _internal_with_mid_price_and_tob() const;
  void _internal_set_with_mid_price_and_tob(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFullSpotMarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    bool with_mid_price_and_tob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFullSpotMarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFullSpotMarketsResponse) */ {
 public:
  inline QueryFullSpotMarketsResponse() : QueryFullSpotMarketsResponse(nullptr) {}
  ~QueryFullSpotMarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFullSpotMarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFullSpotMarketsResponse(const QueryFullSpotMarketsResponse& from);
  QueryFullSpotMarketsResponse(QueryFullSpotMarketsResponse&& from) noexcept
    : QueryFullSpotMarketsResponse() {
    *this = ::std::move(from);
  }

  inline QueryFullSpotMarketsResponse& operator=(const QueryFullSpotMarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFullSpotMarketsResponse& operator=(QueryFullSpotMarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFullSpotMarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFullSpotMarketsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryFullSpotMarketsResponse*>(
               &_QueryFullSpotMarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(QueryFullSpotMarketsResponse& a, QueryFullSpotMarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFullSpotMarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFullSpotMarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFullSpotMarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFullSpotMarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFullSpotMarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFullSpotMarketsResponse& from) {
    QueryFullSpotMarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFullSpotMarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFullSpotMarketsResponse";
  }
  protected:
  explicit QueryFullSpotMarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.FullSpotMarket markets = 1 [json_name = "markets"];
  int markets_size() const;
  private:
  int _internal_markets_size() const;

  public:
  void clear_markets() ;
  ::injective::exchange::v1beta1::FullSpotMarket* mutable_markets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullSpotMarket >*
      mutable_markets();
  private:
  const ::injective::exchange::v1beta1::FullSpotMarket& _internal_markets(int index) const;
  ::injective::exchange::v1beta1::FullSpotMarket* _internal_add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullSpotMarket>& _internal_markets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullSpotMarket>* _internal_mutable_markets();
  public:
  const ::injective::exchange::v1beta1::FullSpotMarket& markets(int index) const;
  ::injective::exchange::v1beta1::FullSpotMarket* add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullSpotMarket >&
      markets() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFullSpotMarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullSpotMarket > markets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFullSpotMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFullSpotMarketRequest) */ {
 public:
  inline QueryFullSpotMarketRequest() : QueryFullSpotMarketRequest(nullptr) {}
  ~QueryFullSpotMarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFullSpotMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFullSpotMarketRequest(const QueryFullSpotMarketRequest& from);
  QueryFullSpotMarketRequest(QueryFullSpotMarketRequest&& from) noexcept
    : QueryFullSpotMarketRequest() {
    *this = ::std::move(from);
  }

  inline QueryFullSpotMarketRequest& operator=(const QueryFullSpotMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFullSpotMarketRequest& operator=(QueryFullSpotMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFullSpotMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFullSpotMarketRequest* internal_default_instance() {
    return reinterpret_cast<const QueryFullSpotMarketRequest*>(
               &_QueryFullSpotMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(QueryFullSpotMarketRequest& a, QueryFullSpotMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFullSpotMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFullSpotMarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFullSpotMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFullSpotMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFullSpotMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFullSpotMarketRequest& from) {
    QueryFullSpotMarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFullSpotMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFullSpotMarketRequest";
  }
  protected:
  explicit QueryFullSpotMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kWithMidPriceAndTobFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // bool with_mid_price_and_tob = 2 [json_name = "withMidPriceAndTob"];
  void clear_with_mid_price_and_tob() ;
  bool with_mid_price_and_tob() const;
  void set_with_mid_price_and_tob(bool value);

  private:
  bool _internal_with_mid_price_and_tob() const;
  void _internal_set_with_mid_price_and_tob(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFullSpotMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    bool with_mid_price_and_tob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFullSpotMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFullSpotMarketResponse) */ {
 public:
  inline QueryFullSpotMarketResponse() : QueryFullSpotMarketResponse(nullptr) {}
  ~QueryFullSpotMarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFullSpotMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFullSpotMarketResponse(const QueryFullSpotMarketResponse& from);
  QueryFullSpotMarketResponse(QueryFullSpotMarketResponse&& from) noexcept
    : QueryFullSpotMarketResponse() {
    *this = ::std::move(from);
  }

  inline QueryFullSpotMarketResponse& operator=(const QueryFullSpotMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFullSpotMarketResponse& operator=(QueryFullSpotMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFullSpotMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFullSpotMarketResponse* internal_default_instance() {
    return reinterpret_cast<const QueryFullSpotMarketResponse*>(
               &_QueryFullSpotMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(QueryFullSpotMarketResponse& a, QueryFullSpotMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFullSpotMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFullSpotMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFullSpotMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFullSpotMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFullSpotMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFullSpotMarketResponse& from) {
    QueryFullSpotMarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFullSpotMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFullSpotMarketResponse";
  }
  protected:
  explicit QueryFullSpotMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.FullSpotMarket market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::FullSpotMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::FullSpotMarket* release_market();
  ::injective::exchange::v1beta1::FullSpotMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::FullSpotMarket* market);
  private:
  const ::injective::exchange::v1beta1::FullSpotMarket& _internal_market() const;
  ::injective::exchange::v1beta1::FullSpotMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::FullSpotMarket* market);
  ::injective::exchange::v1beta1::FullSpotMarket* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFullSpotMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::FullSpotMarket* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotOrdersByHashesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest) */ {
 public:
  inline QuerySpotOrdersByHashesRequest() : QuerySpotOrdersByHashesRequest(nullptr) {}
  ~QuerySpotOrdersByHashesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotOrdersByHashesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotOrdersByHashesRequest(const QuerySpotOrdersByHashesRequest& from);
  QuerySpotOrdersByHashesRequest(QuerySpotOrdersByHashesRequest&& from) noexcept
    : QuerySpotOrdersByHashesRequest() {
    *this = ::std::move(from);
  }

  inline QuerySpotOrdersByHashesRequest& operator=(const QuerySpotOrdersByHashesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotOrdersByHashesRequest& operator=(QuerySpotOrdersByHashesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotOrdersByHashesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotOrdersByHashesRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySpotOrdersByHashesRequest*>(
               &_QuerySpotOrdersByHashesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(QuerySpotOrdersByHashesRequest& a, QuerySpotOrdersByHashesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotOrdersByHashesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotOrdersByHashesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotOrdersByHashesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotOrdersByHashesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotOrdersByHashesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotOrdersByHashesRequest& from) {
    QuerySpotOrdersByHashesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotOrdersByHashesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest";
  }
  protected:
  explicit QuerySpotOrdersByHashesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashesFieldNumber = 3,
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
  };
  // repeated string order_hashes = 3 [json_name = "orderHashes"];
  int order_hashes_size() const;
  private:
  int _internal_order_hashes_size() const;

  public:
  void clear_order_hashes() ;
  const std::string& order_hashes(int index) const;
  std::string* mutable_order_hashes(int index);
  void set_order_hashes(int index, const std::string& value);
  void set_order_hashes(int index, std::string&& value);
  void set_order_hashes(int index, const char* value);
  void set_order_hashes(int index, const char* value, std::size_t size);
  void set_order_hashes(int index, absl::string_view value);
  std::string* add_order_hashes();
  void add_order_hashes(const std::string& value);
  void add_order_hashes(std::string&& value);
  void add_order_hashes(const char* value);
  void add_order_hashes(const char* value, std::size_t size);
  void add_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_hashes();

  private:
  const std::string& _internal_order_hashes(int index) const;
  std::string* _internal_add_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_hashes();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_hashes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotOrdersByHashesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse) */ {
 public:
  inline QuerySpotOrdersByHashesResponse() : QuerySpotOrdersByHashesResponse(nullptr) {}
  ~QuerySpotOrdersByHashesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotOrdersByHashesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotOrdersByHashesResponse(const QuerySpotOrdersByHashesResponse& from);
  QuerySpotOrdersByHashesResponse(QuerySpotOrdersByHashesResponse&& from) noexcept
    : QuerySpotOrdersByHashesResponse() {
    *this = ::std::move(from);
  }

  inline QuerySpotOrdersByHashesResponse& operator=(const QuerySpotOrdersByHashesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotOrdersByHashesResponse& operator=(QuerySpotOrdersByHashesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotOrdersByHashesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotOrdersByHashesResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySpotOrdersByHashesResponse*>(
               &_QuerySpotOrdersByHashesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(QuerySpotOrdersByHashesResponse& a, QuerySpotOrdersByHashesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotOrdersByHashesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotOrdersByHashesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotOrdersByHashesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotOrdersByHashesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotOrdersByHashesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotOrdersByHashesResponse& from) {
    QuerySpotOrdersByHashesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotOrdersByHashesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse";
  }
  protected:
  explicit QuerySpotOrdersByHashesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >&
      orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder > orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderSpotOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest) */ {
 public:
  inline QueryTraderSpotOrdersRequest() : QueryTraderSpotOrdersRequest(nullptr) {}
  ~QueryTraderSpotOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderSpotOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderSpotOrdersRequest(const QueryTraderSpotOrdersRequest& from);
  QueryTraderSpotOrdersRequest(QueryTraderSpotOrdersRequest&& from) noexcept
    : QueryTraderSpotOrdersRequest() {
    *this = ::std::move(from);
  }

  inline QueryTraderSpotOrdersRequest& operator=(const QueryTraderSpotOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderSpotOrdersRequest& operator=(QueryTraderSpotOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderSpotOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderSpotOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTraderSpotOrdersRequest*>(
               &_QueryTraderSpotOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(QueryTraderSpotOrdersRequest& a, QueryTraderSpotOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderSpotOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderSpotOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderSpotOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderSpotOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderSpotOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderSpotOrdersRequest& from) {
    QueryTraderSpotOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderSpotOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderSpotOrdersRequest";
  }
  protected:
  explicit QueryTraderSpotOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAccountAddressSpotOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest) */ {
 public:
  inline QueryAccountAddressSpotOrdersRequest() : QueryAccountAddressSpotOrdersRequest(nullptr) {}
  ~QueryAccountAddressSpotOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAccountAddressSpotOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAccountAddressSpotOrdersRequest(const QueryAccountAddressSpotOrdersRequest& from);
  QueryAccountAddressSpotOrdersRequest(QueryAccountAddressSpotOrdersRequest&& from) noexcept
    : QueryAccountAddressSpotOrdersRequest() {
    *this = ::std::move(from);
  }

  inline QueryAccountAddressSpotOrdersRequest& operator=(const QueryAccountAddressSpotOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAccountAddressSpotOrdersRequest& operator=(QueryAccountAddressSpotOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAccountAddressSpotOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAccountAddressSpotOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAccountAddressSpotOrdersRequest*>(
               &_QueryAccountAddressSpotOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(QueryAccountAddressSpotOrdersRequest& a, QueryAccountAddressSpotOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAccountAddressSpotOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAccountAddressSpotOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAccountAddressSpotOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAccountAddressSpotOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAccountAddressSpotOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAccountAddressSpotOrdersRequest& from) {
    QueryAccountAddressSpotOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAccountAddressSpotOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest";
  }
  protected:
  explicit QueryAccountAddressSpotOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kAccountAddressFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string account_address = 2 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class TrimmedSpotLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TrimmedSpotLimitOrder) */ {
 public:
  inline TrimmedSpotLimitOrder() : TrimmedSpotLimitOrder(nullptr) {}
  ~TrimmedSpotLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrimmedSpotLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrimmedSpotLimitOrder(const TrimmedSpotLimitOrder& from);
  TrimmedSpotLimitOrder(TrimmedSpotLimitOrder&& from) noexcept
    : TrimmedSpotLimitOrder() {
    *this = ::std::move(from);
  }

  inline TrimmedSpotLimitOrder& operator=(const TrimmedSpotLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrimmedSpotLimitOrder& operator=(TrimmedSpotLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrimmedSpotLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrimmedSpotLimitOrder* internal_default_instance() {
    return reinterpret_cast<const TrimmedSpotLimitOrder*>(
               &_TrimmedSpotLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TrimmedSpotLimitOrder& a, TrimmedSpotLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(TrimmedSpotLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrimmedSpotLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrimmedSpotLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrimmedSpotLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrimmedSpotLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrimmedSpotLimitOrder& from) {
    TrimmedSpotLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrimmedSpotLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TrimmedSpotLimitOrder";
  }
  protected:
  explicit TrimmedSpotLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kFillableFieldNumber = 3,
    kOrderHashFieldNumber = 5,
    kIsBuyFieldNumber = 4,
  };
  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string fillable = 3 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fillable() ;
  const std::string& fillable() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fillable(Arg_&& arg, Args_... args);
  std::string* mutable_fillable();
  PROTOBUF_NODISCARD std::string* release_fillable();
  void set_allocated_fillable(std::string* ptr);

  private:
  const std::string& _internal_fillable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fillable(
      const std::string& value);
  std::string* _internal_mutable_fillable();

  public:
  // string order_hash = 5 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // bool isBuy = 4 [json_name = "isBuy"];
  void clear_isbuy() ;
  bool isbuy() const;
  void set_isbuy(bool value);

  private:
  bool _internal_isbuy() const;
  void _internal_set_isbuy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TrimmedSpotLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fillable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    bool isbuy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderSpotOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderSpotOrdersResponse) */ {
 public:
  inline QueryTraderSpotOrdersResponse() : QueryTraderSpotOrdersResponse(nullptr) {}
  ~QueryTraderSpotOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderSpotOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderSpotOrdersResponse(const QueryTraderSpotOrdersResponse& from);
  QueryTraderSpotOrdersResponse(QueryTraderSpotOrdersResponse&& from) noexcept
    : QueryTraderSpotOrdersResponse() {
    *this = ::std::move(from);
  }

  inline QueryTraderSpotOrdersResponse& operator=(const QueryTraderSpotOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderSpotOrdersResponse& operator=(QueryTraderSpotOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderSpotOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderSpotOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTraderSpotOrdersResponse*>(
               &_QueryTraderSpotOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(QueryTraderSpotOrdersResponse& a, QueryTraderSpotOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderSpotOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderSpotOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderSpotOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderSpotOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderSpotOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderSpotOrdersResponse& from) {
    QueryTraderSpotOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderSpotOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderSpotOrdersResponse";
  }
  protected:
  explicit QueryTraderSpotOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >&
      orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderSpotOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder > orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAccountAddressSpotOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse) */ {
 public:
  inline QueryAccountAddressSpotOrdersResponse() : QueryAccountAddressSpotOrdersResponse(nullptr) {}
  ~QueryAccountAddressSpotOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAccountAddressSpotOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAccountAddressSpotOrdersResponse(const QueryAccountAddressSpotOrdersResponse& from);
  QueryAccountAddressSpotOrdersResponse(QueryAccountAddressSpotOrdersResponse&& from) noexcept
    : QueryAccountAddressSpotOrdersResponse() {
    *this = ::std::move(from);
  }

  inline QueryAccountAddressSpotOrdersResponse& operator=(const QueryAccountAddressSpotOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAccountAddressSpotOrdersResponse& operator=(QueryAccountAddressSpotOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAccountAddressSpotOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAccountAddressSpotOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAccountAddressSpotOrdersResponse*>(
               &_QueryAccountAddressSpotOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(QueryAccountAddressSpotOrdersResponse& a, QueryAccountAddressSpotOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAccountAddressSpotOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAccountAddressSpotOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAccountAddressSpotOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAccountAddressSpotOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAccountAddressSpotOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAccountAddressSpotOrdersResponse& from) {
    QueryAccountAddressSpotOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAccountAddressSpotOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse";
  }
  protected:
  explicit QueryAccountAddressSpotOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >&
      orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder > orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotMidPriceAndTOBRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest) */ {
 public:
  inline QuerySpotMidPriceAndTOBRequest() : QuerySpotMidPriceAndTOBRequest(nullptr) {}
  ~QuerySpotMidPriceAndTOBRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotMidPriceAndTOBRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotMidPriceAndTOBRequest(const QuerySpotMidPriceAndTOBRequest& from);
  QuerySpotMidPriceAndTOBRequest(QuerySpotMidPriceAndTOBRequest&& from) noexcept
    : QuerySpotMidPriceAndTOBRequest() {
    *this = ::std::move(from);
  }

  inline QuerySpotMidPriceAndTOBRequest& operator=(const QuerySpotMidPriceAndTOBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotMidPriceAndTOBRequest& operator=(QuerySpotMidPriceAndTOBRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotMidPriceAndTOBRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotMidPriceAndTOBRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySpotMidPriceAndTOBRequest*>(
               &_QuerySpotMidPriceAndTOBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(QuerySpotMidPriceAndTOBRequest& a, QuerySpotMidPriceAndTOBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotMidPriceAndTOBRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotMidPriceAndTOBRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotMidPriceAndTOBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotMidPriceAndTOBRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotMidPriceAndTOBRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotMidPriceAndTOBRequest& from) {
    QuerySpotMidPriceAndTOBRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotMidPriceAndTOBRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest";
  }
  protected:
  explicit QuerySpotMidPriceAndTOBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySpotMidPriceAndTOBResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse) */ {
 public:
  inline QuerySpotMidPriceAndTOBResponse() : QuerySpotMidPriceAndTOBResponse(nullptr) {}
  ~QuerySpotMidPriceAndTOBResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySpotMidPriceAndTOBResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpotMidPriceAndTOBResponse(const QuerySpotMidPriceAndTOBResponse& from);
  QuerySpotMidPriceAndTOBResponse(QuerySpotMidPriceAndTOBResponse&& from) noexcept
    : QuerySpotMidPriceAndTOBResponse() {
    *this = ::std::move(from);
  }

  inline QuerySpotMidPriceAndTOBResponse& operator=(const QuerySpotMidPriceAndTOBResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpotMidPriceAndTOBResponse& operator=(QuerySpotMidPriceAndTOBResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpotMidPriceAndTOBResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpotMidPriceAndTOBResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySpotMidPriceAndTOBResponse*>(
               &_QuerySpotMidPriceAndTOBResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(QuerySpotMidPriceAndTOBResponse& a, QuerySpotMidPriceAndTOBResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpotMidPriceAndTOBResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpotMidPriceAndTOBResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpotMidPriceAndTOBResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpotMidPriceAndTOBResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpotMidPriceAndTOBResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpotMidPriceAndTOBResponse& from) {
    QuerySpotMidPriceAndTOBResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpotMidPriceAndTOBResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse";
  }
  protected:
  explicit QuerySpotMidPriceAndTOBResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMidPriceFieldNumber = 1,
    kBestBuyPriceFieldNumber = 2,
    kBestSellPriceFieldNumber = 3,
  };
  // string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_mid_price() ;
  const std::string& mid_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mid_price(Arg_&& arg, Args_... args);
  std::string* mutable_mid_price();
  PROTOBUF_NODISCARD std::string* release_mid_price();
  void set_allocated_mid_price(std::string* ptr);

  private:
  const std::string& _internal_mid_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mid_price(
      const std::string& value);
  std::string* _internal_mutable_mid_price();

  public:
  // string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_best_buy_price() ;
  const std::string& best_buy_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_best_buy_price(Arg_&& arg, Args_... args);
  std::string* mutable_best_buy_price();
  PROTOBUF_NODISCARD std::string* release_best_buy_price();
  void set_allocated_best_buy_price(std::string* ptr);

  private:
  const std::string& _internal_best_buy_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_best_buy_price(
      const std::string& value);
  std::string* _internal_mutable_best_buy_price();

  public:
  // string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_best_sell_price() ;
  const std::string& best_sell_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_best_sell_price(Arg_&& arg, Args_... args);
  std::string* mutable_best_sell_price();
  PROTOBUF_NODISCARD std::string* release_best_sell_price();
  void set_allocated_best_sell_price(std::string* ptr);

  private:
  const std::string& _internal_best_sell_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_best_sell_price(
      const std::string& value);
  std::string* _internal_mutable_best_sell_price();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr best_buy_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr best_sell_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMidPriceAndTOBRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest) */ {
 public:
  inline QueryDerivativeMidPriceAndTOBRequest() : QueryDerivativeMidPriceAndTOBRequest(nullptr) {}
  ~QueryDerivativeMidPriceAndTOBRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMidPriceAndTOBRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMidPriceAndTOBRequest(const QueryDerivativeMidPriceAndTOBRequest& from);
  QueryDerivativeMidPriceAndTOBRequest(QueryDerivativeMidPriceAndTOBRequest&& from) noexcept
    : QueryDerivativeMidPriceAndTOBRequest() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMidPriceAndTOBRequest& operator=(const QueryDerivativeMidPriceAndTOBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMidPriceAndTOBRequest& operator=(QueryDerivativeMidPriceAndTOBRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMidPriceAndTOBRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMidPriceAndTOBRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMidPriceAndTOBRequest*>(
               &_QueryDerivativeMidPriceAndTOBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(QueryDerivativeMidPriceAndTOBRequest& a, QueryDerivativeMidPriceAndTOBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMidPriceAndTOBRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMidPriceAndTOBRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMidPriceAndTOBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMidPriceAndTOBRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMidPriceAndTOBRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMidPriceAndTOBRequest& from) {
    QueryDerivativeMidPriceAndTOBRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMidPriceAndTOBRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest";
  }
  protected:
  explicit QueryDerivativeMidPriceAndTOBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMidPriceAndTOBResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse) */ {
 public:
  inline QueryDerivativeMidPriceAndTOBResponse() : QueryDerivativeMidPriceAndTOBResponse(nullptr) {}
  ~QueryDerivativeMidPriceAndTOBResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMidPriceAndTOBResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMidPriceAndTOBResponse(const QueryDerivativeMidPriceAndTOBResponse& from);
  QueryDerivativeMidPriceAndTOBResponse(QueryDerivativeMidPriceAndTOBResponse&& from) noexcept
    : QueryDerivativeMidPriceAndTOBResponse() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMidPriceAndTOBResponse& operator=(const QueryDerivativeMidPriceAndTOBResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMidPriceAndTOBResponse& operator=(QueryDerivativeMidPriceAndTOBResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMidPriceAndTOBResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMidPriceAndTOBResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMidPriceAndTOBResponse*>(
               &_QueryDerivativeMidPriceAndTOBResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(QueryDerivativeMidPriceAndTOBResponse& a, QueryDerivativeMidPriceAndTOBResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMidPriceAndTOBResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMidPriceAndTOBResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMidPriceAndTOBResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMidPriceAndTOBResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMidPriceAndTOBResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMidPriceAndTOBResponse& from) {
    QueryDerivativeMidPriceAndTOBResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMidPriceAndTOBResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse";
  }
  protected:
  explicit QueryDerivativeMidPriceAndTOBResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMidPriceFieldNumber = 1,
    kBestBuyPriceFieldNumber = 2,
    kBestSellPriceFieldNumber = 3,
  };
  // string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_mid_price() ;
  const std::string& mid_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mid_price(Arg_&& arg, Args_... args);
  std::string* mutable_mid_price();
  PROTOBUF_NODISCARD std::string* release_mid_price();
  void set_allocated_mid_price(std::string* ptr);

  private:
  const std::string& _internal_mid_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mid_price(
      const std::string& value);
  std::string* _internal_mutable_mid_price();

  public:
  // string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_best_buy_price() ;
  const std::string& best_buy_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_best_buy_price(Arg_&& arg, Args_... args);
  std::string* mutable_best_buy_price();
  PROTOBUF_NODISCARD std::string* release_best_buy_price();
  void set_allocated_best_buy_price(std::string* ptr);

  private:
  const std::string& _internal_best_buy_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_best_buy_price(
      const std::string& value);
  std::string* _internal_mutable_best_buy_price();

  public:
  // string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_best_sell_price() ;
  const std::string& best_sell_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_best_sell_price(Arg_&& arg, Args_... args);
  std::string* mutable_best_sell_price();
  PROTOBUF_NODISCARD std::string* release_best_sell_price();
  void set_allocated_best_sell_price(std::string* ptr);

  private:
  const std::string& _internal_best_sell_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_best_sell_price(
      const std::string& value);
  std::string* _internal_mutable_best_sell_price();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr best_buy_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr best_sell_price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeOrderbookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest) */ {
 public:
  inline QueryDerivativeOrderbookRequest() : QueryDerivativeOrderbookRequest(nullptr) {}
  ~QueryDerivativeOrderbookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeOrderbookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeOrderbookRequest(const QueryDerivativeOrderbookRequest& from);
  QueryDerivativeOrderbookRequest(QueryDerivativeOrderbookRequest&& from) noexcept
    : QueryDerivativeOrderbookRequest() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeOrderbookRequest& operator=(const QueryDerivativeOrderbookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeOrderbookRequest& operator=(QueryDerivativeOrderbookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeOrderbookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeOrderbookRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeOrderbookRequest*>(
               &_QueryDerivativeOrderbookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(QueryDerivativeOrderbookRequest& a, QueryDerivativeOrderbookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeOrderbookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeOrderbookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeOrderbookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeOrderbookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeOrderbookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeOrderbookRequest& from) {
    QueryDerivativeOrderbookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeOrderbookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeOrderbookRequest";
  }
  protected:
  explicit QueryDerivativeOrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kLimitCumulativeNotionalFieldNumber = 3,
    kLimitFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string limit_cumulative_notional = 3 [json_name = "limitCumulativeNotional", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_limit_cumulative_notional() ;
  const std::string& limit_cumulative_notional() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_limit_cumulative_notional(Arg_&& arg, Args_... args);
  std::string* mutable_limit_cumulative_notional();
  PROTOBUF_NODISCARD std::string* release_limit_cumulative_notional();
  void set_allocated_limit_cumulative_notional(std::string* ptr);

  private:
  const std::string& _internal_limit_cumulative_notional() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_limit_cumulative_notional(
      const std::string& value);
  std::string* _internal_mutable_limit_cumulative_notional();

  public:
  // uint64 limit = 2 [json_name = "limit"];
  void clear_limit() ;
  ::uint64_t limit() const;
  void set_limit(::uint64_t value);

  private:
  ::uint64_t _internal_limit() const;
  void _internal_set_limit(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr limit_cumulative_notional_;
    ::uint64_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeOrderbookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse) */ {
 public:
  inline QueryDerivativeOrderbookResponse() : QueryDerivativeOrderbookResponse(nullptr) {}
  ~QueryDerivativeOrderbookResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeOrderbookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeOrderbookResponse(const QueryDerivativeOrderbookResponse& from);
  QueryDerivativeOrderbookResponse(QueryDerivativeOrderbookResponse&& from) noexcept
    : QueryDerivativeOrderbookResponse() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeOrderbookResponse& operator=(const QueryDerivativeOrderbookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeOrderbookResponse& operator=(QueryDerivativeOrderbookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeOrderbookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeOrderbookResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeOrderbookResponse*>(
               &_QueryDerivativeOrderbookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(QueryDerivativeOrderbookResponse& a, QueryDerivativeOrderbookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeOrderbookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeOrderbookResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeOrderbookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeOrderbookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeOrderbookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeOrderbookResponse& from) {
    QueryDerivativeOrderbookResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeOrderbookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeOrderbookResponse";
  }
  protected:
  explicit QueryDerivativeOrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysPriceLevelFieldNumber = 1,
    kSellsPriceLevelFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.Level buys_price_level = 1 [json_name = "buysPriceLevel"];
  int buys_price_level_size() const;
  private:
  int _internal_buys_price_level_size() const;

  public:
  void clear_buys_price_level() ;
  ::injective::exchange::v1beta1::Level* mutable_buys_price_level(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
      mutable_buys_price_level();
  private:
  const ::injective::exchange::v1beta1::Level& _internal_buys_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* _internal_add_buys_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>& _internal_buys_price_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>* _internal_mutable_buys_price_level();
  public:
  const ::injective::exchange::v1beta1::Level& buys_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* add_buys_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
      buys_price_level() const;
  // repeated .injective.exchange.v1beta1.Level sells_price_level = 2 [json_name = "sellsPriceLevel"];
  int sells_price_level_size() const;
  private:
  int _internal_sells_price_level_size() const;

  public:
  void clear_sells_price_level() ;
  ::injective::exchange::v1beta1::Level* mutable_sells_price_level(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
      mutable_sells_price_level();
  private:
  const ::injective::exchange::v1beta1::Level& _internal_sells_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* _internal_add_sells_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>& _internal_sells_price_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>* _internal_mutable_sells_price_level();
  public:
  const ::injective::exchange::v1beta1::Level& sells_price_level(int index) const;
  ::injective::exchange::v1beta1::Level* add_sells_price_level();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
      sells_price_level() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level > buys_price_level_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level > sells_price_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderSpotOrdersToCancelUpToAmountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest) */ {
 public:
  inline QueryTraderSpotOrdersToCancelUpToAmountRequest() : QueryTraderSpotOrdersToCancelUpToAmountRequest(nullptr) {}
  ~QueryTraderSpotOrdersToCancelUpToAmountRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderSpotOrdersToCancelUpToAmountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderSpotOrdersToCancelUpToAmountRequest(const QueryTraderSpotOrdersToCancelUpToAmountRequest& from);
  QueryTraderSpotOrdersToCancelUpToAmountRequest(QueryTraderSpotOrdersToCancelUpToAmountRequest&& from) noexcept
    : QueryTraderSpotOrdersToCancelUpToAmountRequest() {
    *this = ::std::move(from);
  }

  inline QueryTraderSpotOrdersToCancelUpToAmountRequest& operator=(const QueryTraderSpotOrdersToCancelUpToAmountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderSpotOrdersToCancelUpToAmountRequest& operator=(QueryTraderSpotOrdersToCancelUpToAmountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderSpotOrdersToCancelUpToAmountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderSpotOrdersToCancelUpToAmountRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTraderSpotOrdersToCancelUpToAmountRequest*>(
               &_QueryTraderSpotOrdersToCancelUpToAmountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(QueryTraderSpotOrdersToCancelUpToAmountRequest& a, QueryTraderSpotOrdersToCancelUpToAmountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderSpotOrdersToCancelUpToAmountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderSpotOrdersToCancelUpToAmountRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderSpotOrdersToCancelUpToAmountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderSpotOrdersToCancelUpToAmountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderSpotOrdersToCancelUpToAmountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderSpotOrdersToCancelUpToAmountRequest& from) {
    QueryTraderSpotOrdersToCancelUpToAmountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderSpotOrdersToCancelUpToAmountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest";
  }
  protected:
  explicit QueryTraderSpotOrdersToCancelUpToAmountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kBaseAmountFieldNumber = 3,
    kQuoteAmountFieldNumber = 4,
    kReferencePriceFieldNumber = 6,
    kStrategyFieldNumber = 5,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string base_amount = 3 [json_name = "baseAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_base_amount() ;
  const std::string& base_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_amount(Arg_&& arg, Args_... args);
  std::string* mutable_base_amount();
  PROTOBUF_NODISCARD std::string* release_base_amount();
  void set_allocated_base_amount(std::string* ptr);

  private:
  const std::string& _internal_base_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_amount(
      const std::string& value);
  std::string* _internal_mutable_base_amount();

  public:
  // string quote_amount = 4 [json_name = "quoteAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quote_amount() ;
  const std::string& quote_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_amount(Arg_&& arg, Args_... args);
  std::string* mutable_quote_amount();
  PROTOBUF_NODISCARD std::string* release_quote_amount();
  void set_allocated_quote_amount(std::string* ptr);

  private:
  const std::string& _internal_quote_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_amount(
      const std::string& value);
  std::string* _internal_mutable_quote_amount();

  public:
  // string reference_price = 6 [json_name = "referencePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_reference_price() ;
  const std::string& reference_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reference_price(Arg_&& arg, Args_... args);
  std::string* mutable_reference_price();
  PROTOBUF_NODISCARD std::string* release_reference_price();
  void set_allocated_reference_price(std::string* ptr);

  private:
  const std::string& _internal_reference_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reference_price(
      const std::string& value);
  std::string* _internal_mutable_reference_price();

  public:
  // .injective.exchange.v1beta1.CancellationStrategy strategy = 5 [json_name = "strategy"];
  void clear_strategy() ;
  ::injective::exchange::v1beta1::CancellationStrategy strategy() const;
  void set_strategy(::injective::exchange::v1beta1::CancellationStrategy value);

  private:
  ::injective::exchange::v1beta1::CancellationStrategy _internal_strategy() const;
  void _internal_set_strategy(::injective::exchange::v1beta1::CancellationStrategy value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_price_;
    int strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderDerivativeOrdersToCancelUpToAmountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest) */ {
 public:
  inline QueryTraderDerivativeOrdersToCancelUpToAmountRequest() : QueryTraderDerivativeOrdersToCancelUpToAmountRequest(nullptr) {}
  ~QueryTraderDerivativeOrdersToCancelUpToAmountRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderDerivativeOrdersToCancelUpToAmountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderDerivativeOrdersToCancelUpToAmountRequest(const QueryTraderDerivativeOrdersToCancelUpToAmountRequest& from);
  QueryTraderDerivativeOrdersToCancelUpToAmountRequest(QueryTraderDerivativeOrdersToCancelUpToAmountRequest&& from) noexcept
    : QueryTraderDerivativeOrdersToCancelUpToAmountRequest() {
    *this = ::std::move(from);
  }

  inline QueryTraderDerivativeOrdersToCancelUpToAmountRequest& operator=(const QueryTraderDerivativeOrdersToCancelUpToAmountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderDerivativeOrdersToCancelUpToAmountRequest& operator=(QueryTraderDerivativeOrdersToCancelUpToAmountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderDerivativeOrdersToCancelUpToAmountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderDerivativeOrdersToCancelUpToAmountRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTraderDerivativeOrdersToCancelUpToAmountRequest*>(
               &_QueryTraderDerivativeOrdersToCancelUpToAmountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(QueryTraderDerivativeOrdersToCancelUpToAmountRequest& a, QueryTraderDerivativeOrdersToCancelUpToAmountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderDerivativeOrdersToCancelUpToAmountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderDerivativeOrdersToCancelUpToAmountRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderDerivativeOrdersToCancelUpToAmountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderDerivativeOrdersToCancelUpToAmountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderDerivativeOrdersToCancelUpToAmountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderDerivativeOrdersToCancelUpToAmountRequest& from) {
    QueryTraderDerivativeOrdersToCancelUpToAmountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderDerivativeOrdersToCancelUpToAmountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest";
  }
  protected:
  explicit QueryTraderDerivativeOrdersToCancelUpToAmountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kQuoteAmountFieldNumber = 3,
    kReferencePriceFieldNumber = 5,
    kStrategyFieldNumber = 4,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string quote_amount = 3 [json_name = "quoteAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quote_amount() ;
  const std::string& quote_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_amount(Arg_&& arg, Args_... args);
  std::string* mutable_quote_amount();
  PROTOBUF_NODISCARD std::string* release_quote_amount();
  void set_allocated_quote_amount(std::string* ptr);

  private:
  const std::string& _internal_quote_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_amount(
      const std::string& value);
  std::string* _internal_mutable_quote_amount();

  public:
  // string reference_price = 5 [json_name = "referencePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_reference_price() ;
  const std::string& reference_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reference_price(Arg_&& arg, Args_... args);
  std::string* mutable_reference_price();
  PROTOBUF_NODISCARD std::string* release_reference_price();
  void set_allocated_reference_price(std::string* ptr);

  private:
  const std::string& _internal_reference_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reference_price(
      const std::string& value);
  std::string* _internal_mutable_reference_price();

  public:
  // .injective.exchange.v1beta1.CancellationStrategy strategy = 4 [json_name = "strategy"];
  void clear_strategy() ;
  ::injective::exchange::v1beta1::CancellationStrategy strategy() const;
  void set_strategy(::injective::exchange::v1beta1::CancellationStrategy value);

  private:
  ::injective::exchange::v1beta1::CancellationStrategy _internal_strategy() const;
  void _internal_set_strategy(::injective::exchange::v1beta1::CancellationStrategy value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_price_;
    int strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderDerivativeOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest) */ {
 public:
  inline QueryTraderDerivativeOrdersRequest() : QueryTraderDerivativeOrdersRequest(nullptr) {}
  ~QueryTraderDerivativeOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderDerivativeOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderDerivativeOrdersRequest(const QueryTraderDerivativeOrdersRequest& from);
  QueryTraderDerivativeOrdersRequest(QueryTraderDerivativeOrdersRequest&& from) noexcept
    : QueryTraderDerivativeOrdersRequest() {
    *this = ::std::move(from);
  }

  inline QueryTraderDerivativeOrdersRequest& operator=(const QueryTraderDerivativeOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderDerivativeOrdersRequest& operator=(QueryTraderDerivativeOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderDerivativeOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderDerivativeOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTraderDerivativeOrdersRequest*>(
               &_QueryTraderDerivativeOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(QueryTraderDerivativeOrdersRequest& a, QueryTraderDerivativeOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderDerivativeOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderDerivativeOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderDerivativeOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderDerivativeOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderDerivativeOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderDerivativeOrdersRequest& from) {
    QueryTraderDerivativeOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderDerivativeOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest";
  }
  protected:
  explicit QueryTraderDerivativeOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAccountAddressDerivativeOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest) */ {
 public:
  inline QueryAccountAddressDerivativeOrdersRequest() : QueryAccountAddressDerivativeOrdersRequest(nullptr) {}
  ~QueryAccountAddressDerivativeOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAccountAddressDerivativeOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAccountAddressDerivativeOrdersRequest(const QueryAccountAddressDerivativeOrdersRequest& from);
  QueryAccountAddressDerivativeOrdersRequest(QueryAccountAddressDerivativeOrdersRequest&& from) noexcept
    : QueryAccountAddressDerivativeOrdersRequest() {
    *this = ::std::move(from);
  }

  inline QueryAccountAddressDerivativeOrdersRequest& operator=(const QueryAccountAddressDerivativeOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAccountAddressDerivativeOrdersRequest& operator=(QueryAccountAddressDerivativeOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAccountAddressDerivativeOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAccountAddressDerivativeOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAccountAddressDerivativeOrdersRequest*>(
               &_QueryAccountAddressDerivativeOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(QueryAccountAddressDerivativeOrdersRequest& a, QueryAccountAddressDerivativeOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAccountAddressDerivativeOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAccountAddressDerivativeOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAccountAddressDerivativeOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAccountAddressDerivativeOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAccountAddressDerivativeOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAccountAddressDerivativeOrdersRequest& from) {
    QueryAccountAddressDerivativeOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAccountAddressDerivativeOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest";
  }
  protected:
  explicit QueryAccountAddressDerivativeOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kAccountAddressFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string account_address = 2 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class TrimmedDerivativeLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder) */ {
 public:
  inline TrimmedDerivativeLimitOrder() : TrimmedDerivativeLimitOrder(nullptr) {}
  ~TrimmedDerivativeLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrimmedDerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrimmedDerivativeLimitOrder(const TrimmedDerivativeLimitOrder& from);
  TrimmedDerivativeLimitOrder(TrimmedDerivativeLimitOrder&& from) noexcept
    : TrimmedDerivativeLimitOrder() {
    *this = ::std::move(from);
  }

  inline TrimmedDerivativeLimitOrder& operator=(const TrimmedDerivativeLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrimmedDerivativeLimitOrder& operator=(TrimmedDerivativeLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrimmedDerivativeLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrimmedDerivativeLimitOrder* internal_default_instance() {
    return reinterpret_cast<const TrimmedDerivativeLimitOrder*>(
               &_TrimmedDerivativeLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(TrimmedDerivativeLimitOrder& a, TrimmedDerivativeLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(TrimmedDerivativeLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrimmedDerivativeLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrimmedDerivativeLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrimmedDerivativeLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrimmedDerivativeLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrimmedDerivativeLimitOrder& from) {
    TrimmedDerivativeLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrimmedDerivativeLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TrimmedDerivativeLimitOrder";
  }
  protected:
  explicit TrimmedDerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kMarginFieldNumber = 3,
    kFillableFieldNumber = 4,
    kOrderHashFieldNumber = 6,
    kIsBuyFieldNumber = 5,
  };
  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string fillable = 4 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_fillable() ;
  const std::string& fillable() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fillable(Arg_&& arg, Args_... args);
  std::string* mutable_fillable();
  PROTOBUF_NODISCARD std::string* release_fillable();
  void set_allocated_fillable(std::string* ptr);

  private:
  const std::string& _internal_fillable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fillable(
      const std::string& value);
  std::string* _internal_mutable_fillable();

  public:
  // string order_hash = 6 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // bool isBuy = 5 [json_name = "isBuy", (.gogoproto.jsontag) = "isBuy"];
  void clear_isbuy() ;
  bool isbuy() const;
  void set_isbuy(bool value);

  private:
  bool _internal_isbuy() const;
  void _internal_set_isbuy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fillable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    bool isbuy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderDerivativeOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse) */ {
 public:
  inline QueryTraderDerivativeOrdersResponse() : QueryTraderDerivativeOrdersResponse(nullptr) {}
  ~QueryTraderDerivativeOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderDerivativeOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderDerivativeOrdersResponse(const QueryTraderDerivativeOrdersResponse& from);
  QueryTraderDerivativeOrdersResponse(QueryTraderDerivativeOrdersResponse&& from) noexcept
    : QueryTraderDerivativeOrdersResponse() {
    *this = ::std::move(from);
  }

  inline QueryTraderDerivativeOrdersResponse& operator=(const QueryTraderDerivativeOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderDerivativeOrdersResponse& operator=(QueryTraderDerivativeOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderDerivativeOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderDerivativeOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTraderDerivativeOrdersResponse*>(
               &_QueryTraderDerivativeOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(QueryTraderDerivativeOrdersResponse& a, QueryTraderDerivativeOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderDerivativeOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderDerivativeOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderDerivativeOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderDerivativeOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderDerivativeOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderDerivativeOrdersResponse& from) {
    QueryTraderDerivativeOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderDerivativeOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse";
  }
  protected:
  explicit QueryTraderDerivativeOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >&
      orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder > orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryAccountAddressDerivativeOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse) */ {
 public:
  inline QueryAccountAddressDerivativeOrdersResponse() : QueryAccountAddressDerivativeOrdersResponse(nullptr) {}
  ~QueryAccountAddressDerivativeOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAccountAddressDerivativeOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAccountAddressDerivativeOrdersResponse(const QueryAccountAddressDerivativeOrdersResponse& from);
  QueryAccountAddressDerivativeOrdersResponse(QueryAccountAddressDerivativeOrdersResponse&& from) noexcept
    : QueryAccountAddressDerivativeOrdersResponse() {
    *this = ::std::move(from);
  }

  inline QueryAccountAddressDerivativeOrdersResponse& operator=(const QueryAccountAddressDerivativeOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAccountAddressDerivativeOrdersResponse& operator=(QueryAccountAddressDerivativeOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAccountAddressDerivativeOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAccountAddressDerivativeOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAccountAddressDerivativeOrdersResponse*>(
               &_QueryAccountAddressDerivativeOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(QueryAccountAddressDerivativeOrdersResponse& a, QueryAccountAddressDerivativeOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAccountAddressDerivativeOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAccountAddressDerivativeOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAccountAddressDerivativeOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAccountAddressDerivativeOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAccountAddressDerivativeOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAccountAddressDerivativeOrdersResponse& from) {
    QueryAccountAddressDerivativeOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAccountAddressDerivativeOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse";
  }
  protected:
  explicit QueryAccountAddressDerivativeOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >&
      orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder > orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeOrdersByHashesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest) */ {
 public:
  inline QueryDerivativeOrdersByHashesRequest() : QueryDerivativeOrdersByHashesRequest(nullptr) {}
  ~QueryDerivativeOrdersByHashesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeOrdersByHashesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeOrdersByHashesRequest(const QueryDerivativeOrdersByHashesRequest& from);
  QueryDerivativeOrdersByHashesRequest(QueryDerivativeOrdersByHashesRequest&& from) noexcept
    : QueryDerivativeOrdersByHashesRequest() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeOrdersByHashesRequest& operator=(const QueryDerivativeOrdersByHashesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeOrdersByHashesRequest& operator=(QueryDerivativeOrdersByHashesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeOrdersByHashesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeOrdersByHashesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeOrdersByHashesRequest*>(
               &_QueryDerivativeOrdersByHashesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(QueryDerivativeOrdersByHashesRequest& a, QueryDerivativeOrdersByHashesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeOrdersByHashesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeOrdersByHashesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeOrdersByHashesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeOrdersByHashesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeOrdersByHashesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeOrdersByHashesRequest& from) {
    QueryDerivativeOrdersByHashesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeOrdersByHashesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest";
  }
  protected:
  explicit QueryDerivativeOrdersByHashesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashesFieldNumber = 3,
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
  };
  // repeated string order_hashes = 3 [json_name = "orderHashes"];
  int order_hashes_size() const;
  private:
  int _internal_order_hashes_size() const;

  public:
  void clear_order_hashes() ;
  const std::string& order_hashes(int index) const;
  std::string* mutable_order_hashes(int index);
  void set_order_hashes(int index, const std::string& value);
  void set_order_hashes(int index, std::string&& value);
  void set_order_hashes(int index, const char* value);
  void set_order_hashes(int index, const char* value, std::size_t size);
  void set_order_hashes(int index, absl::string_view value);
  std::string* add_order_hashes();
  void add_order_hashes(const std::string& value);
  void add_order_hashes(std::string&& value);
  void add_order_hashes(const char* value);
  void add_order_hashes(const char* value, std::size_t size);
  void add_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_hashes();

  private:
  const std::string& _internal_order_hashes(int index) const;
  std::string* _internal_add_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_hashes();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_hashes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeOrdersByHashesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse) */ {
 public:
  inline QueryDerivativeOrdersByHashesResponse() : QueryDerivativeOrdersByHashesResponse(nullptr) {}
  ~QueryDerivativeOrdersByHashesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeOrdersByHashesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeOrdersByHashesResponse(const QueryDerivativeOrdersByHashesResponse& from);
  QueryDerivativeOrdersByHashesResponse(QueryDerivativeOrdersByHashesResponse&& from) noexcept
    : QueryDerivativeOrdersByHashesResponse() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeOrdersByHashesResponse& operator=(const QueryDerivativeOrdersByHashesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeOrdersByHashesResponse& operator=(QueryDerivativeOrdersByHashesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeOrdersByHashesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeOrdersByHashesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeOrdersByHashesResponse*>(
               &_QueryDerivativeOrdersByHashesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(QueryDerivativeOrdersByHashesResponse& a, QueryDerivativeOrdersByHashesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeOrdersByHashesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeOrdersByHashesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeOrdersByHashesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeOrdersByHashesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeOrdersByHashesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeOrdersByHashesResponse& from) {
    QueryDerivativeOrdersByHashesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeOrdersByHashesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse";
  }
  protected:
  explicit QueryDerivativeOrdersByHashesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >&
      orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder > orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMarketsRequest) */ {
 public:
  inline QueryDerivativeMarketsRequest() : QueryDerivativeMarketsRequest(nullptr) {}
  ~QueryDerivativeMarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMarketsRequest(const QueryDerivativeMarketsRequest& from);
  QueryDerivativeMarketsRequest(QueryDerivativeMarketsRequest&& from) noexcept
    : QueryDerivativeMarketsRequest() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMarketsRequest& operator=(const QueryDerivativeMarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMarketsRequest& operator=(QueryDerivativeMarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMarketsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMarketsRequest*>(
               &_QueryDerivativeMarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(QueryDerivativeMarketsRequest& a, QueryDerivativeMarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMarketsRequest& from) {
    QueryDerivativeMarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMarketsRequest";
  }
  protected:
  explicit QueryDerivativeMarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 2,
    kStatusFieldNumber = 1,
    kWithMidPriceAndTobFieldNumber = 3,
  };
  // repeated string market_ids = 2 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string status = 1 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // bool with_mid_price_and_tob = 3 [json_name = "withMidPriceAndTob"];
  void clear_with_mid_price_and_tob() ;
  bool with_mid_price_and_tob() const;
  void set_with_mid_price_and_tob(bool value);

  private:
  bool _internal_with_mid_price_and_tob() const;
  void _internal_set_with_mid_price_and_tob(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    bool with_mid_price_and_tob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class PriceLevel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.PriceLevel) */ {
 public:
  inline PriceLevel() : PriceLevel(nullptr) {}
  ~PriceLevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceLevel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceLevel(const PriceLevel& from);
  PriceLevel(PriceLevel&& from) noexcept
    : PriceLevel() {
    *this = ::std::move(from);
  }

  inline PriceLevel& operator=(const PriceLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceLevel& operator=(PriceLevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceLevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceLevel* internal_default_instance() {
    return reinterpret_cast<const PriceLevel*>(
               &_PriceLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(PriceLevel& a, PriceLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceLevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceLevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceLevel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceLevel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceLevel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceLevel& from) {
    PriceLevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceLevel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.PriceLevel";
  }
  protected:
  explicit PriceLevel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.PriceLevel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class PerpetualMarketState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.PerpetualMarketState) */ {
 public:
  inline PerpetualMarketState() : PerpetualMarketState(nullptr) {}
  ~PerpetualMarketState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerpetualMarketState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerpetualMarketState(const PerpetualMarketState& from);
  PerpetualMarketState(PerpetualMarketState&& from) noexcept
    : PerpetualMarketState() {
    *this = ::std::move(from);
  }

  inline PerpetualMarketState& operator=(const PerpetualMarketState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerpetualMarketState& operator=(PerpetualMarketState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerpetualMarketState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerpetualMarketState* internal_default_instance() {
    return reinterpret_cast<const PerpetualMarketState*>(
               &_PerpetualMarketState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(PerpetualMarketState& a, PerpetualMarketState& b) {
    a.Swap(&b);
  }
  inline void Swap(PerpetualMarketState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerpetualMarketState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerpetualMarketState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerpetualMarketState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerpetualMarketState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerpetualMarketState& from) {
    PerpetualMarketState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerpetualMarketState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.PerpetualMarketState";
  }
  protected:
  explicit PerpetualMarketState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketInfoFieldNumber = 1,
    kFundingInfoFieldNumber = 2,
  };
  // .injective.exchange.v1beta1.PerpetualMarketInfo market_info = 1 [json_name = "marketInfo"];
  bool has_market_info() const;
  void clear_market_info() ;
  const ::injective::exchange::v1beta1::PerpetualMarketInfo& market_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketInfo* release_market_info();
  ::injective::exchange::v1beta1::PerpetualMarketInfo* mutable_market_info();
  void set_allocated_market_info(::injective::exchange::v1beta1::PerpetualMarketInfo* market_info);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketInfo& _internal_market_info() const;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* _internal_mutable_market_info();
  public:
  void unsafe_arena_set_allocated_market_info(
      ::injective::exchange::v1beta1::PerpetualMarketInfo* market_info);
  ::injective::exchange::v1beta1::PerpetualMarketInfo* unsafe_arena_release_market_info();
  // .injective.exchange.v1beta1.PerpetualMarketFunding funding_info = 2 [json_name = "fundingInfo"];
  bool has_funding_info() const;
  void clear_funding_info() ;
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& funding_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketFunding* release_funding_info();
  ::injective::exchange::v1beta1::PerpetualMarketFunding* mutable_funding_info();
  void set_allocated_funding_info(::injective::exchange::v1beta1::PerpetualMarketFunding* funding_info);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& _internal_funding_info() const;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _internal_mutable_funding_info();
  public:
  void unsafe_arena_set_allocated_funding_info(
      ::injective::exchange::v1beta1::PerpetualMarketFunding* funding_info);
  ::injective::exchange::v1beta1::PerpetualMarketFunding* unsafe_arena_release_funding_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.PerpetualMarketState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::PerpetualMarketInfo* market_info_;
    ::injective::exchange::v1beta1::PerpetualMarketFunding* funding_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class FullDerivativeMarket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.FullDerivativeMarket) */ {
 public:
  inline FullDerivativeMarket() : FullDerivativeMarket(nullptr) {}
  ~FullDerivativeMarket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FullDerivativeMarket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FullDerivativeMarket(const FullDerivativeMarket& from);
  FullDerivativeMarket(FullDerivativeMarket&& from) noexcept
    : FullDerivativeMarket() {
    *this = ::std::move(from);
  }

  inline FullDerivativeMarket& operator=(const FullDerivativeMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline FullDerivativeMarket& operator=(FullDerivativeMarket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FullDerivativeMarket& default_instance() {
    return *internal_default_instance();
  }
  enum InfoCase {
    kPerpetualInfo = 2,
    kFuturesInfo = 3,
    INFO_NOT_SET = 0,
  };

  static inline const FullDerivativeMarket* internal_default_instance() {
    return reinterpret_cast<const FullDerivativeMarket*>(
               &_FullDerivativeMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(FullDerivativeMarket& a, FullDerivativeMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(FullDerivativeMarket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FullDerivativeMarket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FullDerivativeMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FullDerivativeMarket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FullDerivativeMarket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FullDerivativeMarket& from) {
    FullDerivativeMarket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FullDerivativeMarket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.FullDerivativeMarket";
  }
  protected:
  explicit FullDerivativeMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarkPriceFieldNumber = 4,
    kMarketFieldNumber = 1,
    kMidPriceAndTobFieldNumber = 5,
    kPerpetualInfoFieldNumber = 2,
    kFuturesInfoFieldNumber = 3,
  };
  // string mark_price = 4 [json_name = "markPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_mark_price() ;
  const std::string& mark_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mark_price(Arg_&& arg, Args_... args);
  std::string* mutable_mark_price();
  PROTOBUF_NODISCARD std::string* release_mark_price();
  void set_allocated_mark_price(std::string* ptr);

  private:
  const std::string& _internal_mark_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_price(
      const std::string& value);
  std::string* _internal_mutable_mark_price();

  public:
  // .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::DerivativeMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::DerivativeMarket* release_market();
  ::injective::exchange::v1beta1::DerivativeMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::DerivativeMarket* market);
  private:
  const ::injective::exchange::v1beta1::DerivativeMarket& _internal_market() const;
  ::injective::exchange::v1beta1::DerivativeMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::DerivativeMarket* market);
  ::injective::exchange::v1beta1::DerivativeMarket* unsafe_arena_release_market();
  // .injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 5 [json_name = "midPriceAndTob", (.gogoproto.nullable) = true];
  bool has_mid_price_and_tob() const;
  void clear_mid_price_and_tob() ;
  const ::injective::exchange::v1beta1::MidPriceAndTOB& mid_price_and_tob() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::MidPriceAndTOB* release_mid_price_and_tob();
  ::injective::exchange::v1beta1::MidPriceAndTOB* mutable_mid_price_and_tob();
  void set_allocated_mid_price_and_tob(::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob);
  private:
  const ::injective::exchange::v1beta1::MidPriceAndTOB& _internal_mid_price_and_tob() const;
  ::injective::exchange::v1beta1::MidPriceAndTOB* _internal_mutable_mid_price_and_tob();
  public:
  void unsafe_arena_set_allocated_mid_price_and_tob(
      ::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob);
  ::injective::exchange::v1beta1::MidPriceAndTOB* unsafe_arena_release_mid_price_and_tob();
  // .injective.exchange.v1beta1.PerpetualMarketState perpetual_info = 2 [json_name = "perpetualInfo"];
  bool has_perpetual_info() const;
  private:
  bool _internal_has_perpetual_info() const;

  public:
  void clear_perpetual_info() ;
  const ::injective::exchange::v1beta1::PerpetualMarketState& perpetual_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketState* release_perpetual_info();
  ::injective::exchange::v1beta1::PerpetualMarketState* mutable_perpetual_info();
  void set_allocated_perpetual_info(::injective::exchange::v1beta1::PerpetualMarketState* perpetual_info);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketState& _internal_perpetual_info() const;
  ::injective::exchange::v1beta1::PerpetualMarketState* _internal_mutable_perpetual_info();
  public:
  void unsafe_arena_set_allocated_perpetual_info(
      ::injective::exchange::v1beta1::PerpetualMarketState* perpetual_info);
  ::injective::exchange::v1beta1::PerpetualMarketState* unsafe_arena_release_perpetual_info();
  // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo futures_info = 3 [json_name = "futuresInfo"];
  bool has_futures_info() const;
  private:
  bool _internal_has_futures_info() const;

  public:
  void clear_futures_info() ;
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& futures_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* release_futures_info();
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* mutable_futures_info();
  void set_allocated_futures_info(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* futures_info);
  private:
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& _internal_futures_info() const;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* _internal_mutable_futures_info();
  public:
  void unsafe_arena_set_allocated_futures_info(
      ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* futures_info);
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* unsafe_arena_release_futures_info();
  void clear_info();
  InfoCase info_case() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.FullDerivativeMarket)
 private:
  class _Internal;
  void set_has_perpetual_info();
  void set_has_futures_info();

  inline bool has_info() const;
  inline void clear_has_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_price_;
    ::injective::exchange::v1beta1::DerivativeMarket* market_;
    ::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob_;
    union InfoUnion {
      constexpr InfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::injective::exchange::v1beta1::PerpetualMarketState* perpetual_info_;
      ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* futures_info_;
    } info_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMarketsResponse) */ {
 public:
  inline QueryDerivativeMarketsResponse() : QueryDerivativeMarketsResponse(nullptr) {}
  ~QueryDerivativeMarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMarketsResponse(const QueryDerivativeMarketsResponse& from);
  QueryDerivativeMarketsResponse(QueryDerivativeMarketsResponse&& from) noexcept
    : QueryDerivativeMarketsResponse() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMarketsResponse& operator=(const QueryDerivativeMarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMarketsResponse& operator=(QueryDerivativeMarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMarketsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMarketsResponse*>(
               &_QueryDerivativeMarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(QueryDerivativeMarketsResponse& a, QueryDerivativeMarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMarketsResponse& from) {
    QueryDerivativeMarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMarketsResponse";
  }
  protected:
  explicit QueryDerivativeMarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.FullDerivativeMarket markets = 1 [json_name = "markets"];
  int markets_size() const;
  private:
  int _internal_markets_size() const;

  public:
  void clear_markets() ;
  ::injective::exchange::v1beta1::FullDerivativeMarket* mutable_markets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullDerivativeMarket >*
      mutable_markets();
  private:
  const ::injective::exchange::v1beta1::FullDerivativeMarket& _internal_markets(int index) const;
  ::injective::exchange::v1beta1::FullDerivativeMarket* _internal_add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullDerivativeMarket>& _internal_markets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullDerivativeMarket>* _internal_mutable_markets();
  public:
  const ::injective::exchange::v1beta1::FullDerivativeMarket& markets(int index) const;
  ::injective::exchange::v1beta1::FullDerivativeMarket* add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullDerivativeMarket >&
      markets() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullDerivativeMarket > markets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMarketRequest) */ {
 public:
  inline QueryDerivativeMarketRequest() : QueryDerivativeMarketRequest(nullptr) {}
  ~QueryDerivativeMarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMarketRequest(const QueryDerivativeMarketRequest& from);
  QueryDerivativeMarketRequest(QueryDerivativeMarketRequest&& from) noexcept
    : QueryDerivativeMarketRequest() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMarketRequest& operator=(const QueryDerivativeMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMarketRequest& operator=(QueryDerivativeMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMarketRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMarketRequest*>(
               &_QueryDerivativeMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(QueryDerivativeMarketRequest& a, QueryDerivativeMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMarketRequest& from) {
    QueryDerivativeMarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMarketRequest";
  }
  protected:
  explicit QueryDerivativeMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMarketResponse) */ {
 public:
  inline QueryDerivativeMarketResponse() : QueryDerivativeMarketResponse(nullptr) {}
  ~QueryDerivativeMarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMarketResponse(const QueryDerivativeMarketResponse& from);
  QueryDerivativeMarketResponse(QueryDerivativeMarketResponse&& from) noexcept
    : QueryDerivativeMarketResponse() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMarketResponse& operator=(const QueryDerivativeMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMarketResponse& operator=(QueryDerivativeMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMarketResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMarketResponse*>(
               &_QueryDerivativeMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(QueryDerivativeMarketResponse& a, QueryDerivativeMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMarketResponse& from) {
    QueryDerivativeMarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMarketResponse";
  }
  protected:
  explicit QueryDerivativeMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.FullDerivativeMarket market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective::exchange::v1beta1::FullDerivativeMarket& market() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::FullDerivativeMarket* release_market();
  ::injective::exchange::v1beta1::FullDerivativeMarket* mutable_market();
  void set_allocated_market(::injective::exchange::v1beta1::FullDerivativeMarket* market);
  private:
  const ::injective::exchange::v1beta1::FullDerivativeMarket& _internal_market() const;
  ::injective::exchange::v1beta1::FullDerivativeMarket* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective::exchange::v1beta1::FullDerivativeMarket* market);
  ::injective::exchange::v1beta1::FullDerivativeMarket* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::FullDerivativeMarket* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMarketAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest) */ {
 public:
  inline QueryDerivativeMarketAddressRequest() : QueryDerivativeMarketAddressRequest(nullptr) {}
  ~QueryDerivativeMarketAddressRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMarketAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMarketAddressRequest(const QueryDerivativeMarketAddressRequest& from);
  QueryDerivativeMarketAddressRequest(QueryDerivativeMarketAddressRequest&& from) noexcept
    : QueryDerivativeMarketAddressRequest() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMarketAddressRequest& operator=(const QueryDerivativeMarketAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMarketAddressRequest& operator=(QueryDerivativeMarketAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMarketAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMarketAddressRequest* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMarketAddressRequest*>(
               &_QueryDerivativeMarketAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(QueryDerivativeMarketAddressRequest& a, QueryDerivativeMarketAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMarketAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMarketAddressRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMarketAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMarketAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMarketAddressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMarketAddressRequest& from) {
    QueryDerivativeMarketAddressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMarketAddressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest";
  }
  protected:
  explicit QueryDerivativeMarketAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryDerivativeMarketAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse) */ {
 public:
  inline QueryDerivativeMarketAddressResponse() : QueryDerivativeMarketAddressResponse(nullptr) {}
  ~QueryDerivativeMarketAddressResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryDerivativeMarketAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDerivativeMarketAddressResponse(const QueryDerivativeMarketAddressResponse& from);
  QueryDerivativeMarketAddressResponse(QueryDerivativeMarketAddressResponse&& from) noexcept
    : QueryDerivativeMarketAddressResponse() {
    *this = ::std::move(from);
  }

  inline QueryDerivativeMarketAddressResponse& operator=(const QueryDerivativeMarketAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDerivativeMarketAddressResponse& operator=(QueryDerivativeMarketAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDerivativeMarketAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDerivativeMarketAddressResponse* internal_default_instance() {
    return reinterpret_cast<const QueryDerivativeMarketAddressResponse*>(
               &_QueryDerivativeMarketAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(QueryDerivativeMarketAddressResponse& a, QueryDerivativeMarketAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDerivativeMarketAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDerivativeMarketAddressResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryDerivativeMarketAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryDerivativeMarketAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDerivativeMarketAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryDerivativeMarketAddressResponse& from) {
    QueryDerivativeMarketAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDerivativeMarketAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse";
  }
  protected:
  explicit QueryDerivativeMarketAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountTradeNonceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest) */ {
 public:
  inline QuerySubaccountTradeNonceRequest() : QuerySubaccountTradeNonceRequest(nullptr) {}
  ~QuerySubaccountTradeNonceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountTradeNonceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountTradeNonceRequest(const QuerySubaccountTradeNonceRequest& from);
  QuerySubaccountTradeNonceRequest(QuerySubaccountTradeNonceRequest&& from) noexcept
    : QuerySubaccountTradeNonceRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountTradeNonceRequest& operator=(const QuerySubaccountTradeNonceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountTradeNonceRequest& operator=(QuerySubaccountTradeNonceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountTradeNonceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountTradeNonceRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountTradeNonceRequest*>(
               &_QuerySubaccountTradeNonceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(QuerySubaccountTradeNonceRequest& a, QuerySubaccountTradeNonceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountTradeNonceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountTradeNonceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountTradeNonceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountTradeNonceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountTradeNonceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountTradeNonceRequest& from) {
    QuerySubaccountTradeNonceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountTradeNonceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest";
  }
  protected:
  explicit QuerySubaccountTradeNonceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountPositionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountPositionsRequest) */ {
 public:
  inline QuerySubaccountPositionsRequest() : QuerySubaccountPositionsRequest(nullptr) {}
  ~QuerySubaccountPositionsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountPositionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountPositionsRequest(const QuerySubaccountPositionsRequest& from);
  QuerySubaccountPositionsRequest(QuerySubaccountPositionsRequest&& from) noexcept
    : QuerySubaccountPositionsRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountPositionsRequest& operator=(const QuerySubaccountPositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountPositionsRequest& operator=(QuerySubaccountPositionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountPositionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountPositionsRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountPositionsRequest*>(
               &_QuerySubaccountPositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(QuerySubaccountPositionsRequest& a, QuerySubaccountPositionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountPositionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountPositionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountPositionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountPositionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountPositionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountPositionsRequest& from) {
    QuerySubaccountPositionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountPositionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountPositionsRequest";
  }
  protected:
  explicit QuerySubaccountPositionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountPositionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountPositionInMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest) */ {
 public:
  inline QuerySubaccountPositionInMarketRequest() : QuerySubaccountPositionInMarketRequest(nullptr) {}
  ~QuerySubaccountPositionInMarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountPositionInMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountPositionInMarketRequest(const QuerySubaccountPositionInMarketRequest& from);
  QuerySubaccountPositionInMarketRequest(QuerySubaccountPositionInMarketRequest&& from) noexcept
    : QuerySubaccountPositionInMarketRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountPositionInMarketRequest& operator=(const QuerySubaccountPositionInMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountPositionInMarketRequest& operator=(QuerySubaccountPositionInMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountPositionInMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountPositionInMarketRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountPositionInMarketRequest*>(
               &_QuerySubaccountPositionInMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(QuerySubaccountPositionInMarketRequest& a, QuerySubaccountPositionInMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountPositionInMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountPositionInMarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountPositionInMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountPositionInMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountPositionInMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountPositionInMarketRequest& from) {
    QuerySubaccountPositionInMarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountPositionInMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest";
  }
  protected:
  explicit QuerySubaccountPositionInMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountEffectivePositionInMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest) */ {
 public:
  inline QuerySubaccountEffectivePositionInMarketRequest() : QuerySubaccountEffectivePositionInMarketRequest(nullptr) {}
  ~QuerySubaccountEffectivePositionInMarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountEffectivePositionInMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountEffectivePositionInMarketRequest(const QuerySubaccountEffectivePositionInMarketRequest& from);
  QuerySubaccountEffectivePositionInMarketRequest(QuerySubaccountEffectivePositionInMarketRequest&& from) noexcept
    : QuerySubaccountEffectivePositionInMarketRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountEffectivePositionInMarketRequest& operator=(const QuerySubaccountEffectivePositionInMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountEffectivePositionInMarketRequest& operator=(QuerySubaccountEffectivePositionInMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountEffectivePositionInMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountEffectivePositionInMarketRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountEffectivePositionInMarketRequest*>(
               &_QuerySubaccountEffectivePositionInMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(QuerySubaccountEffectivePositionInMarketRequest& a, QuerySubaccountEffectivePositionInMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountEffectivePositionInMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountEffectivePositionInMarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountEffectivePositionInMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountEffectivePositionInMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountEffectivePositionInMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountEffectivePositionInMarketRequest& from) {
    QuerySubaccountEffectivePositionInMarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountEffectivePositionInMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest";
  }
  protected:
  explicit QuerySubaccountEffectivePositionInMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountOrderMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest) */ {
 public:
  inline QuerySubaccountOrderMetadataRequest() : QuerySubaccountOrderMetadataRequest(nullptr) {}
  ~QuerySubaccountOrderMetadataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountOrderMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountOrderMetadataRequest(const QuerySubaccountOrderMetadataRequest& from);
  QuerySubaccountOrderMetadataRequest(QuerySubaccountOrderMetadataRequest&& from) noexcept
    : QuerySubaccountOrderMetadataRequest() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountOrderMetadataRequest& operator=(const QuerySubaccountOrderMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountOrderMetadataRequest& operator=(QuerySubaccountOrderMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountOrderMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountOrderMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountOrderMetadataRequest*>(
               &_QuerySubaccountOrderMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(QuerySubaccountOrderMetadataRequest& a, QuerySubaccountOrderMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountOrderMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountOrderMetadataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountOrderMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountOrderMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountOrderMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountOrderMetadataRequest& from) {
    QuerySubaccountOrderMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountOrderMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest";
  }
  protected:
  explicit QuerySubaccountOrderMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountPositionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountPositionsResponse) */ {
 public:
  inline QuerySubaccountPositionsResponse() : QuerySubaccountPositionsResponse(nullptr) {}
  ~QuerySubaccountPositionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountPositionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountPositionsResponse(const QuerySubaccountPositionsResponse& from);
  QuerySubaccountPositionsResponse(QuerySubaccountPositionsResponse&& from) noexcept
    : QuerySubaccountPositionsResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountPositionsResponse& operator=(const QuerySubaccountPositionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountPositionsResponse& operator=(QuerySubaccountPositionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountPositionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountPositionsResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountPositionsResponse*>(
               &_QuerySubaccountPositionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(QuerySubaccountPositionsResponse& a, QuerySubaccountPositionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountPositionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountPositionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountPositionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountPositionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountPositionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountPositionsResponse& from) {
    QuerySubaccountPositionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountPositionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountPositionsResponse";
  }
  protected:
  explicit QuerySubaccountPositionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.DerivativePosition state = 1 [json_name = "state", (.gogoproto.nullable) = false];
  int state_size() const;
  private:
  int _internal_state_size() const;

  public:
  void clear_state() ;
  ::injective::exchange::v1beta1::DerivativePosition* mutable_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >*
      mutable_state();
  private:
  const ::injective::exchange::v1beta1::DerivativePosition& _internal_state(int index) const;
  ::injective::exchange::v1beta1::DerivativePosition* _internal_add_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>& _internal_state() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>* _internal_mutable_state();
  public:
  const ::injective::exchange::v1beta1::DerivativePosition& state(int index) const;
  ::injective::exchange::v1beta1::DerivativePosition* add_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >&
      state() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountPositionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition > state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountPositionInMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse) */ {
 public:
  inline QuerySubaccountPositionInMarketResponse() : QuerySubaccountPositionInMarketResponse(nullptr) {}
  ~QuerySubaccountPositionInMarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountPositionInMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountPositionInMarketResponse(const QuerySubaccountPositionInMarketResponse& from);
  QuerySubaccountPositionInMarketResponse(QuerySubaccountPositionInMarketResponse&& from) noexcept
    : QuerySubaccountPositionInMarketResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountPositionInMarketResponse& operator=(const QuerySubaccountPositionInMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountPositionInMarketResponse& operator=(QuerySubaccountPositionInMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountPositionInMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountPositionInMarketResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountPositionInMarketResponse*>(
               &_QuerySubaccountPositionInMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(QuerySubaccountPositionInMarketResponse& a, QuerySubaccountPositionInMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountPositionInMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountPositionInMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountPositionInMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountPositionInMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountPositionInMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountPositionInMarketResponse& from) {
    QuerySubaccountPositionInMarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountPositionInMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse";
  }
  protected:
  explicit QuerySubaccountPositionInMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.Position state = 1 [json_name = "state", (.gogoproto.nullable) = true];
  bool has_state() const;
  void clear_state() ;
  const ::injective::exchange::v1beta1::Position& state() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::Position* release_state();
  ::injective::exchange::v1beta1::Position* mutable_state();
  void set_allocated_state(::injective::exchange::v1beta1::Position* state);
  private:
  const ::injective::exchange::v1beta1::Position& _internal_state() const;
  ::injective::exchange::v1beta1::Position* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::injective::exchange::v1beta1::Position* state);
  ::injective::exchange::v1beta1::Position* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::Position* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class EffectivePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.EffectivePosition) */ {
 public:
  inline EffectivePosition() : EffectivePosition(nullptr) {}
  ~EffectivePosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EffectivePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EffectivePosition(const EffectivePosition& from);
  EffectivePosition(EffectivePosition&& from) noexcept
    : EffectivePosition() {
    *this = ::std::move(from);
  }

  inline EffectivePosition& operator=(const EffectivePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline EffectivePosition& operator=(EffectivePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EffectivePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const EffectivePosition* internal_default_instance() {
    return reinterpret_cast<const EffectivePosition*>(
               &_EffectivePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(EffectivePosition& a, EffectivePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(EffectivePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EffectivePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EffectivePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EffectivePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EffectivePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EffectivePosition& from) {
    EffectivePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EffectivePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.EffectivePosition";
  }
  protected:
  explicit EffectivePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantityFieldNumber = 2,
    kEntryPriceFieldNumber = 3,
    kEffectiveMarginFieldNumber = 4,
    kIsLongFieldNumber = 1,
  };
  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string entry_price = 3 [json_name = "entryPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_entry_price() ;
  const std::string& entry_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entry_price(Arg_&& arg, Args_... args);
  std::string* mutable_entry_price();
  PROTOBUF_NODISCARD std::string* release_entry_price();
  void set_allocated_entry_price(std::string* ptr);

  private:
  const std::string& _internal_entry_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entry_price(
      const std::string& value);
  std::string* _internal_mutable_entry_price();

  public:
  // string effective_margin = 4 [json_name = "effectiveMargin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_effective_margin() ;
  const std::string& effective_margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_effective_margin(Arg_&& arg, Args_... args);
  std::string* mutable_effective_margin();
  PROTOBUF_NODISCARD std::string* release_effective_margin();
  void set_allocated_effective_margin(std::string* ptr);

  private:
  const std::string& _internal_effective_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effective_margin(
      const std::string& value);
  std::string* _internal_mutable_effective_margin();

  public:
  // bool is_long = 1 [json_name = "isLong"];
  void clear_is_long() ;
  bool is_long() const;
  void set_is_long(bool value);

  private:
  bool _internal_is_long() const;
  void _internal_set_is_long(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.EffectivePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entry_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr effective_margin_;
    bool is_long_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountEffectivePositionInMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse) */ {
 public:
  inline QuerySubaccountEffectivePositionInMarketResponse() : QuerySubaccountEffectivePositionInMarketResponse(nullptr) {}
  ~QuerySubaccountEffectivePositionInMarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountEffectivePositionInMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountEffectivePositionInMarketResponse(const QuerySubaccountEffectivePositionInMarketResponse& from);
  QuerySubaccountEffectivePositionInMarketResponse(QuerySubaccountEffectivePositionInMarketResponse&& from) noexcept
    : QuerySubaccountEffectivePositionInMarketResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountEffectivePositionInMarketResponse& operator=(const QuerySubaccountEffectivePositionInMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountEffectivePositionInMarketResponse& operator=(QuerySubaccountEffectivePositionInMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountEffectivePositionInMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountEffectivePositionInMarketResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountEffectivePositionInMarketResponse*>(
               &_QuerySubaccountEffectivePositionInMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(QuerySubaccountEffectivePositionInMarketResponse& a, QuerySubaccountEffectivePositionInMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountEffectivePositionInMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountEffectivePositionInMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountEffectivePositionInMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountEffectivePositionInMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountEffectivePositionInMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountEffectivePositionInMarketResponse& from) {
    QuerySubaccountEffectivePositionInMarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountEffectivePositionInMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse";
  }
  protected:
  explicit QuerySubaccountEffectivePositionInMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.EffectivePosition state = 1 [json_name = "state", (.gogoproto.nullable) = true];
  bool has_state() const;
  void clear_state() ;
  const ::injective::exchange::v1beta1::EffectivePosition& state() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::EffectivePosition* release_state();
  ::injective::exchange::v1beta1::EffectivePosition* mutable_state();
  void set_allocated_state(::injective::exchange::v1beta1::EffectivePosition* state);
  private:
  const ::injective::exchange::v1beta1::EffectivePosition& _internal_state() const;
  ::injective::exchange::v1beta1::EffectivePosition* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::injective::exchange::v1beta1::EffectivePosition* state);
  ::injective::exchange::v1beta1::EffectivePosition* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::EffectivePosition* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPerpetualMarketInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest) */ {
 public:
  inline QueryPerpetualMarketInfoRequest() : QueryPerpetualMarketInfoRequest(nullptr) {}
  ~QueryPerpetualMarketInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPerpetualMarketInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPerpetualMarketInfoRequest(const QueryPerpetualMarketInfoRequest& from);
  QueryPerpetualMarketInfoRequest(QueryPerpetualMarketInfoRequest&& from) noexcept
    : QueryPerpetualMarketInfoRequest() {
    *this = ::std::move(from);
  }

  inline QueryPerpetualMarketInfoRequest& operator=(const QueryPerpetualMarketInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPerpetualMarketInfoRequest& operator=(QueryPerpetualMarketInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPerpetualMarketInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPerpetualMarketInfoRequest* internal_default_instance() {
    return reinterpret_cast<const QueryPerpetualMarketInfoRequest*>(
               &_QueryPerpetualMarketInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(QueryPerpetualMarketInfoRequest& a, QueryPerpetualMarketInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPerpetualMarketInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPerpetualMarketInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPerpetualMarketInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPerpetualMarketInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPerpetualMarketInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPerpetualMarketInfoRequest& from) {
    QueryPerpetualMarketInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPerpetualMarketInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest";
  }
  protected:
  explicit QueryPerpetualMarketInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPerpetualMarketInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse) */ {
 public:
  inline QueryPerpetualMarketInfoResponse() : QueryPerpetualMarketInfoResponse(nullptr) {}
  ~QueryPerpetualMarketInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPerpetualMarketInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPerpetualMarketInfoResponse(const QueryPerpetualMarketInfoResponse& from);
  QueryPerpetualMarketInfoResponse(QueryPerpetualMarketInfoResponse&& from) noexcept
    : QueryPerpetualMarketInfoResponse() {
    *this = ::std::move(from);
  }

  inline QueryPerpetualMarketInfoResponse& operator=(const QueryPerpetualMarketInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPerpetualMarketInfoResponse& operator=(QueryPerpetualMarketInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPerpetualMarketInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPerpetualMarketInfoResponse* internal_default_instance() {
    return reinterpret_cast<const QueryPerpetualMarketInfoResponse*>(
               &_QueryPerpetualMarketInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(QueryPerpetualMarketInfoResponse& a, QueryPerpetualMarketInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPerpetualMarketInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPerpetualMarketInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPerpetualMarketInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPerpetualMarketInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPerpetualMarketInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPerpetualMarketInfoResponse& from) {
    QueryPerpetualMarketInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPerpetualMarketInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse";
  }
  protected:
  explicit QueryPerpetualMarketInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.PerpetualMarketInfo info = 1 [json_name = "info", (.gogoproto.nullable) = false];
  bool has_info() const;
  void clear_info() ;
  const ::injective::exchange::v1beta1::PerpetualMarketInfo& info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketInfo* release_info();
  ::injective::exchange::v1beta1::PerpetualMarketInfo* mutable_info();
  void set_allocated_info(::injective::exchange::v1beta1::PerpetualMarketInfo* info);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketInfo& _internal_info() const;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::injective::exchange::v1beta1::PerpetualMarketInfo* info);
  ::injective::exchange::v1beta1::PerpetualMarketInfo* unsafe_arena_release_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::PerpetualMarketInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryExpiryFuturesMarketInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest) */ {
 public:
  inline QueryExpiryFuturesMarketInfoRequest() : QueryExpiryFuturesMarketInfoRequest(nullptr) {}
  ~QueryExpiryFuturesMarketInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryExpiryFuturesMarketInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryExpiryFuturesMarketInfoRequest(const QueryExpiryFuturesMarketInfoRequest& from);
  QueryExpiryFuturesMarketInfoRequest(QueryExpiryFuturesMarketInfoRequest&& from) noexcept
    : QueryExpiryFuturesMarketInfoRequest() {
    *this = ::std::move(from);
  }

  inline QueryExpiryFuturesMarketInfoRequest& operator=(const QueryExpiryFuturesMarketInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryExpiryFuturesMarketInfoRequest& operator=(QueryExpiryFuturesMarketInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryExpiryFuturesMarketInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryExpiryFuturesMarketInfoRequest* internal_default_instance() {
    return reinterpret_cast<const QueryExpiryFuturesMarketInfoRequest*>(
               &_QueryExpiryFuturesMarketInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(QueryExpiryFuturesMarketInfoRequest& a, QueryExpiryFuturesMarketInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryExpiryFuturesMarketInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryExpiryFuturesMarketInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryExpiryFuturesMarketInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryExpiryFuturesMarketInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryExpiryFuturesMarketInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryExpiryFuturesMarketInfoRequest& from) {
    QueryExpiryFuturesMarketInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryExpiryFuturesMarketInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest";
  }
  protected:
  explicit QueryExpiryFuturesMarketInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryExpiryFuturesMarketInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse) */ {
 public:
  inline QueryExpiryFuturesMarketInfoResponse() : QueryExpiryFuturesMarketInfoResponse(nullptr) {}
  ~QueryExpiryFuturesMarketInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryExpiryFuturesMarketInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryExpiryFuturesMarketInfoResponse(const QueryExpiryFuturesMarketInfoResponse& from);
  QueryExpiryFuturesMarketInfoResponse(QueryExpiryFuturesMarketInfoResponse&& from) noexcept
    : QueryExpiryFuturesMarketInfoResponse() {
    *this = ::std::move(from);
  }

  inline QueryExpiryFuturesMarketInfoResponse& operator=(const QueryExpiryFuturesMarketInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryExpiryFuturesMarketInfoResponse& operator=(QueryExpiryFuturesMarketInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryExpiryFuturesMarketInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryExpiryFuturesMarketInfoResponse* internal_default_instance() {
    return reinterpret_cast<const QueryExpiryFuturesMarketInfoResponse*>(
               &_QueryExpiryFuturesMarketInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(QueryExpiryFuturesMarketInfoResponse& a, QueryExpiryFuturesMarketInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryExpiryFuturesMarketInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryExpiryFuturesMarketInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryExpiryFuturesMarketInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryExpiryFuturesMarketInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryExpiryFuturesMarketInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryExpiryFuturesMarketInfoResponse& from) {
    QueryExpiryFuturesMarketInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryExpiryFuturesMarketInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse";
  }
  protected:
  explicit QueryExpiryFuturesMarketInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo info = 1 [json_name = "info", (.gogoproto.nullable) = false];
  bool has_info() const;
  void clear_info() ;
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* release_info();
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* mutable_info();
  void set_allocated_info(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* info);
  private:
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& _internal_info() const;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* info);
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* unsafe_arena_release_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPerpetualMarketFundingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest) */ {
 public:
  inline QueryPerpetualMarketFundingRequest() : QueryPerpetualMarketFundingRequest(nullptr) {}
  ~QueryPerpetualMarketFundingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPerpetualMarketFundingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPerpetualMarketFundingRequest(const QueryPerpetualMarketFundingRequest& from);
  QueryPerpetualMarketFundingRequest(QueryPerpetualMarketFundingRequest&& from) noexcept
    : QueryPerpetualMarketFundingRequest() {
    *this = ::std::move(from);
  }

  inline QueryPerpetualMarketFundingRequest& operator=(const QueryPerpetualMarketFundingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPerpetualMarketFundingRequest& operator=(QueryPerpetualMarketFundingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPerpetualMarketFundingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPerpetualMarketFundingRequest* internal_default_instance() {
    return reinterpret_cast<const QueryPerpetualMarketFundingRequest*>(
               &_QueryPerpetualMarketFundingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(QueryPerpetualMarketFundingRequest& a, QueryPerpetualMarketFundingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPerpetualMarketFundingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPerpetualMarketFundingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPerpetualMarketFundingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPerpetualMarketFundingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPerpetualMarketFundingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPerpetualMarketFundingRequest& from) {
    QueryPerpetualMarketFundingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPerpetualMarketFundingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest";
  }
  protected:
  explicit QueryPerpetualMarketFundingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPerpetualMarketFundingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse) */ {
 public:
  inline QueryPerpetualMarketFundingResponse() : QueryPerpetualMarketFundingResponse(nullptr) {}
  ~QueryPerpetualMarketFundingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPerpetualMarketFundingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPerpetualMarketFundingResponse(const QueryPerpetualMarketFundingResponse& from);
  QueryPerpetualMarketFundingResponse(QueryPerpetualMarketFundingResponse&& from) noexcept
    : QueryPerpetualMarketFundingResponse() {
    *this = ::std::move(from);
  }

  inline QueryPerpetualMarketFundingResponse& operator=(const QueryPerpetualMarketFundingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPerpetualMarketFundingResponse& operator=(QueryPerpetualMarketFundingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPerpetualMarketFundingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPerpetualMarketFundingResponse* internal_default_instance() {
    return reinterpret_cast<const QueryPerpetualMarketFundingResponse*>(
               &_QueryPerpetualMarketFundingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(QueryPerpetualMarketFundingResponse& a, QueryPerpetualMarketFundingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPerpetualMarketFundingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPerpetualMarketFundingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPerpetualMarketFundingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPerpetualMarketFundingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPerpetualMarketFundingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPerpetualMarketFundingResponse& from) {
    QueryPerpetualMarketFundingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPerpetualMarketFundingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse";
  }
  protected:
  explicit QueryPerpetualMarketFundingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.PerpetualMarketFunding state = 1 [json_name = "state", (.gogoproto.nullable) = false];
  bool has_state() const;
  void clear_state() ;
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& state() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::PerpetualMarketFunding* release_state();
  ::injective::exchange::v1beta1::PerpetualMarketFunding* mutable_state();
  void set_allocated_state(::injective::exchange::v1beta1::PerpetualMarketFunding* state);
  private:
  const ::injective::exchange::v1beta1::PerpetualMarketFunding& _internal_state() const;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::injective::exchange::v1beta1::PerpetualMarketFunding* state);
  ::injective::exchange::v1beta1::PerpetualMarketFunding* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::PerpetualMarketFunding* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountOrderMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse) */ {
 public:
  inline QuerySubaccountOrderMetadataResponse() : QuerySubaccountOrderMetadataResponse(nullptr) {}
  ~QuerySubaccountOrderMetadataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountOrderMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountOrderMetadataResponse(const QuerySubaccountOrderMetadataResponse& from);
  QuerySubaccountOrderMetadataResponse(QuerySubaccountOrderMetadataResponse&& from) noexcept
    : QuerySubaccountOrderMetadataResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountOrderMetadataResponse& operator=(const QuerySubaccountOrderMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountOrderMetadataResponse& operator=(QuerySubaccountOrderMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountOrderMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountOrderMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountOrderMetadataResponse*>(
               &_QuerySubaccountOrderMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(QuerySubaccountOrderMetadataResponse& a, QuerySubaccountOrderMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountOrderMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountOrderMetadataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountOrderMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountOrderMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountOrderMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountOrderMetadataResponse& from) {
    QuerySubaccountOrderMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountOrderMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse";
  }
  protected:
  explicit QuerySubaccountOrderMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket metadata = 1 [json_name = "metadata", (.gogoproto.nullable) = false];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket >*
      mutable_metadata();
  private:
  const ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket& _internal_metadata(int index) const;
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* _internal_add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket>& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket>* _internal_mutable_metadata();
  public:
  const ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket& metadata(int index) const;
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket >&
      metadata() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket > metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QuerySubaccountTradeNonceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse) */ {
 public:
  inline QuerySubaccountTradeNonceResponse() : QuerySubaccountTradeNonceResponse(nullptr) {}
  ~QuerySubaccountTradeNonceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuerySubaccountTradeNonceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySubaccountTradeNonceResponse(const QuerySubaccountTradeNonceResponse& from);
  QuerySubaccountTradeNonceResponse(QuerySubaccountTradeNonceResponse&& from) noexcept
    : QuerySubaccountTradeNonceResponse() {
    *this = ::std::move(from);
  }

  inline QuerySubaccountTradeNonceResponse& operator=(const QuerySubaccountTradeNonceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySubaccountTradeNonceResponse& operator=(QuerySubaccountTradeNonceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySubaccountTradeNonceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySubaccountTradeNonceResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySubaccountTradeNonceResponse*>(
               &_QuerySubaccountTradeNonceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(QuerySubaccountTradeNonceResponse& a, QuerySubaccountTradeNonceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySubaccountTradeNonceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySubaccountTradeNonceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySubaccountTradeNonceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySubaccountTradeNonceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySubaccountTradeNonceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySubaccountTradeNonceResponse& from) {
    QuerySubaccountTradeNonceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySubaccountTradeNonceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse";
  }
  protected:
  explicit QuerySubaccountTradeNonceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // uint32 nonce = 1 [json_name = "nonce"];
  void clear_nonce() ;
  ::uint32_t nonce() const;
  void set_nonce(::uint32_t value);

  private:
  ::uint32_t _internal_nonce() const;
  void _internal_set_nonce(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryModuleStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryModuleStateRequest) */ {
 public:
  inline QueryModuleStateRequest() : QueryModuleStateRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryModuleStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryModuleStateRequest(const QueryModuleStateRequest& from);
  QueryModuleStateRequest(QueryModuleStateRequest&& from) noexcept
    : QueryModuleStateRequest() {
    *this = ::std::move(from);
  }

  inline QueryModuleStateRequest& operator=(const QueryModuleStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryModuleStateRequest& operator=(QueryModuleStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryModuleStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryModuleStateRequest* internal_default_instance() {
    return reinterpret_cast<const QueryModuleStateRequest*>(
               &_QueryModuleStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(QueryModuleStateRequest& a, QueryModuleStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryModuleStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryModuleStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryModuleStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryModuleStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryModuleStateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryModuleStateRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryModuleStateRequest";
  }
  protected:
  explicit QueryModuleStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryModuleStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryModuleStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryModuleStateResponse) */ {
 public:
  inline QueryModuleStateResponse() : QueryModuleStateResponse(nullptr) {}
  ~QueryModuleStateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryModuleStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryModuleStateResponse(const QueryModuleStateResponse& from);
  QueryModuleStateResponse(QueryModuleStateResponse&& from) noexcept
    : QueryModuleStateResponse() {
    *this = ::std::move(from);
  }

  inline QueryModuleStateResponse& operator=(const QueryModuleStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryModuleStateResponse& operator=(QueryModuleStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryModuleStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryModuleStateResponse* internal_default_instance() {
    return reinterpret_cast<const QueryModuleStateResponse*>(
               &_QueryModuleStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(QueryModuleStateResponse& a, QueryModuleStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryModuleStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryModuleStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryModuleStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryModuleStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryModuleStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryModuleStateResponse& from) {
    QueryModuleStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryModuleStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryModuleStateResponse";
  }
  protected:
  explicit QueryModuleStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.GenesisState state = 1 [json_name = "state"];
  bool has_state() const;
  void clear_state() ;
  const ::injective::exchange::v1beta1::GenesisState& state() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::GenesisState* release_state();
  ::injective::exchange::v1beta1::GenesisState* mutable_state();
  void set_allocated_state(::injective::exchange::v1beta1::GenesisState* state);
  private:
  const ::injective::exchange::v1beta1::GenesisState& _internal_state() const;
  ::injective::exchange::v1beta1::GenesisState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::injective::exchange::v1beta1::GenesisState* state);
  ::injective::exchange::v1beta1::GenesisState* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryModuleStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::GenesisState* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPositionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryPositionsRequest) */ {
 public:
  inline QueryPositionsRequest() : QueryPositionsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPositionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPositionsRequest(const QueryPositionsRequest& from);
  QueryPositionsRequest(QueryPositionsRequest&& from) noexcept
    : QueryPositionsRequest() {
    *this = ::std::move(from);
  }

  inline QueryPositionsRequest& operator=(const QueryPositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPositionsRequest& operator=(QueryPositionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPositionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPositionsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryPositionsRequest*>(
               &_QueryPositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(QueryPositionsRequest& a, QueryPositionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPositionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPositionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPositionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPositionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryPositionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryPositionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryPositionsRequest";
  }
  protected:
  explicit QueryPositionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryPositionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryPositionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryPositionsResponse) */ {
 public:
  inline QueryPositionsResponse() : QueryPositionsResponse(nullptr) {}
  ~QueryPositionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPositionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPositionsResponse(const QueryPositionsResponse& from);
  QueryPositionsResponse(QueryPositionsResponse&& from) noexcept
    : QueryPositionsResponse() {
    *this = ::std::move(from);
  }

  inline QueryPositionsResponse& operator=(const QueryPositionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPositionsResponse& operator=(QueryPositionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPositionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPositionsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryPositionsResponse*>(
               &_QueryPositionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(QueryPositionsResponse& a, QueryPositionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPositionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPositionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPositionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPositionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPositionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPositionsResponse& from) {
    QueryPositionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPositionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryPositionsResponse";
  }
  protected:
  explicit QueryPositionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.DerivativePosition state = 1 [json_name = "state", (.gogoproto.nullable) = false];
  int state_size() const;
  private:
  int _internal_state_size() const;

  public:
  void clear_state() ;
  ::injective::exchange::v1beta1::DerivativePosition* mutable_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >*
      mutable_state();
  private:
  const ::injective::exchange::v1beta1::DerivativePosition& _internal_state(int index) const;
  ::injective::exchange::v1beta1::DerivativePosition* _internal_add_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>& _internal_state() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>* _internal_mutable_state();
  public:
  const ::injective::exchange::v1beta1::DerivativePosition& state(int index) const;
  ::injective::exchange::v1beta1::DerivativePosition* add_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >&
      state() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryPositionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition > state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTradeRewardPointsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTradeRewardPointsRequest) */ {
 public:
  inline QueryTradeRewardPointsRequest() : QueryTradeRewardPointsRequest(nullptr) {}
  ~QueryTradeRewardPointsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTradeRewardPointsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTradeRewardPointsRequest(const QueryTradeRewardPointsRequest& from);
  QueryTradeRewardPointsRequest(QueryTradeRewardPointsRequest&& from) noexcept
    : QueryTradeRewardPointsRequest() {
    *this = ::std::move(from);
  }

  inline QueryTradeRewardPointsRequest& operator=(const QueryTradeRewardPointsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTradeRewardPointsRequest& operator=(QueryTradeRewardPointsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTradeRewardPointsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTradeRewardPointsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTradeRewardPointsRequest*>(
               &_QueryTradeRewardPointsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(QueryTradeRewardPointsRequest& a, QueryTradeRewardPointsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTradeRewardPointsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTradeRewardPointsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTradeRewardPointsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTradeRewardPointsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTradeRewardPointsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTradeRewardPointsRequest& from) {
    QueryTradeRewardPointsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTradeRewardPointsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTradeRewardPointsRequest";
  }
  protected:
  explicit QueryTradeRewardPointsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
    kPendingPoolTimestampFieldNumber = 2,
  };
  // repeated string accounts = 1 [json_name = "accounts"];
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;

  public:
  void clear_accounts() ;
  const std::string& accounts(int index) const;
  std::string* mutable_accounts(int index);
  void set_accounts(int index, const std::string& value);
  void set_accounts(int index, std::string&& value);
  void set_accounts(int index, const char* value);
  void set_accounts(int index, const char* value, std::size_t size);
  void set_accounts(int index, absl::string_view value);
  std::string* add_accounts();
  void add_accounts(const std::string& value);
  void add_accounts(std::string&& value);
  void add_accounts(const char* value);
  void add_accounts(const char* value, std::size_t size);
  void add_accounts(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& accounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_accounts();

  private:
  const std::string& _internal_accounts(int index) const;
  std::string* _internal_add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_accounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_accounts();

  public:
  // int64 pending_pool_timestamp = 2 [json_name = "pendingPoolTimestamp"];
  void clear_pending_pool_timestamp() ;
  ::int64_t pending_pool_timestamp() const;
  void set_pending_pool_timestamp(::int64_t value);

  private:
  ::int64_t _internal_pending_pool_timestamp() const;
  void _internal_set_pending_pool_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTradeRewardPointsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> accounts_;
    ::int64_t pending_pool_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTradeRewardPointsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTradeRewardPointsResponse) */ {
 public:
  inline QueryTradeRewardPointsResponse() : QueryTradeRewardPointsResponse(nullptr) {}
  ~QueryTradeRewardPointsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTradeRewardPointsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTradeRewardPointsResponse(const QueryTradeRewardPointsResponse& from);
  QueryTradeRewardPointsResponse(QueryTradeRewardPointsResponse&& from) noexcept
    : QueryTradeRewardPointsResponse() {
    *this = ::std::move(from);
  }

  inline QueryTradeRewardPointsResponse& operator=(const QueryTradeRewardPointsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTradeRewardPointsResponse& operator=(QueryTradeRewardPointsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTradeRewardPointsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTradeRewardPointsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTradeRewardPointsResponse*>(
               &_QueryTradeRewardPointsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(QueryTradeRewardPointsResponse& a, QueryTradeRewardPointsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTradeRewardPointsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTradeRewardPointsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTradeRewardPointsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTradeRewardPointsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTradeRewardPointsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTradeRewardPointsResponse& from) {
    QueryTradeRewardPointsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTradeRewardPointsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTradeRewardPointsResponse";
  }
  protected:
  explicit QueryTradeRewardPointsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountTradeRewardPointsFieldNumber = 1,
  };
  // repeated string account_trade_reward_points = 1 [json_name = "accountTradeRewardPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  int account_trade_reward_points_size() const;
  private:
  int _internal_account_trade_reward_points_size() const;

  public:
  void clear_account_trade_reward_points() ;
  const std::string& account_trade_reward_points(int index) const;
  std::string* mutable_account_trade_reward_points(int index);
  void set_account_trade_reward_points(int index, const std::string& value);
  void set_account_trade_reward_points(int index, std::string&& value);
  void set_account_trade_reward_points(int index, const char* value);
  void set_account_trade_reward_points(int index, const char* value, std::size_t size);
  void set_account_trade_reward_points(int index, absl::string_view value);
  std::string* add_account_trade_reward_points();
  void add_account_trade_reward_points(const std::string& value);
  void add_account_trade_reward_points(std::string&& value);
  void add_account_trade_reward_points(const char* value);
  void add_account_trade_reward_points(const char* value, std::size_t size);
  void add_account_trade_reward_points(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& account_trade_reward_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_account_trade_reward_points();

  private:
  const std::string& _internal_account_trade_reward_points(int index) const;
  std::string* _internal_add_account_trade_reward_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_account_trade_reward_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_account_trade_reward_points();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTradeRewardPointsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> account_trade_reward_points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTradeRewardCampaignRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTradeRewardCampaignRequest) */ {
 public:
  inline QueryTradeRewardCampaignRequest() : QueryTradeRewardCampaignRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTradeRewardCampaignRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTradeRewardCampaignRequest(const QueryTradeRewardCampaignRequest& from);
  QueryTradeRewardCampaignRequest(QueryTradeRewardCampaignRequest&& from) noexcept
    : QueryTradeRewardCampaignRequest() {
    *this = ::std::move(from);
  }

  inline QueryTradeRewardCampaignRequest& operator=(const QueryTradeRewardCampaignRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTradeRewardCampaignRequest& operator=(QueryTradeRewardCampaignRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTradeRewardCampaignRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTradeRewardCampaignRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTradeRewardCampaignRequest*>(
               &_QueryTradeRewardCampaignRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(QueryTradeRewardCampaignRequest& a, QueryTradeRewardCampaignRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTradeRewardCampaignRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTradeRewardCampaignRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTradeRewardCampaignRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTradeRewardCampaignRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryTradeRewardCampaignRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryTradeRewardCampaignRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTradeRewardCampaignRequest";
  }
  protected:
  explicit QueryTradeRewardCampaignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTradeRewardCampaignRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTradeRewardCampaignResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse) */ {
 public:
  inline QueryTradeRewardCampaignResponse() : QueryTradeRewardCampaignResponse(nullptr) {}
  ~QueryTradeRewardCampaignResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTradeRewardCampaignResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTradeRewardCampaignResponse(const QueryTradeRewardCampaignResponse& from);
  QueryTradeRewardCampaignResponse(QueryTradeRewardCampaignResponse&& from) noexcept
    : QueryTradeRewardCampaignResponse() {
    *this = ::std::move(from);
  }

  inline QueryTradeRewardCampaignResponse& operator=(const QueryTradeRewardCampaignResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTradeRewardCampaignResponse& operator=(QueryTradeRewardCampaignResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTradeRewardCampaignResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTradeRewardCampaignResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTradeRewardCampaignResponse*>(
               &_QueryTradeRewardCampaignResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(QueryTradeRewardCampaignResponse& a, QueryTradeRewardCampaignResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTradeRewardCampaignResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTradeRewardCampaignResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTradeRewardCampaignResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTradeRewardCampaignResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTradeRewardCampaignResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTradeRewardCampaignResponse& from) {
    QueryTradeRewardCampaignResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTradeRewardCampaignResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTradeRewardCampaignResponse";
  }
  protected:
  explicit QueryTradeRewardCampaignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradingRewardPoolCampaignScheduleFieldNumber = 2,
    kPendingTradingRewardPoolCampaignScheduleFieldNumber = 4,
    kPendingTotalTradeRewardPointsFieldNumber = 5,
    kTotalTradeRewardPointsFieldNumber = 3,
    kTradingRewardCampaignInfoFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 2 [json_name = "tradingRewardPoolCampaignSchedule"];
  int trading_reward_pool_campaign_schedule_size() const;
  private:
  int _internal_trading_reward_pool_campaign_schedule_size() const;

  public:
  void clear_trading_reward_pool_campaign_schedule() ;
  ::injective::exchange::v1beta1::CampaignRewardPool* mutable_trading_reward_pool_campaign_schedule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
      mutable_trading_reward_pool_campaign_schedule();
  private:
  const ::injective::exchange::v1beta1::CampaignRewardPool& _internal_trading_reward_pool_campaign_schedule(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* _internal_add_trading_reward_pool_campaign_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>& _internal_trading_reward_pool_campaign_schedule() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>* _internal_mutable_trading_reward_pool_campaign_schedule();
  public:
  const ::injective::exchange::v1beta1::CampaignRewardPool& trading_reward_pool_campaign_schedule(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* add_trading_reward_pool_campaign_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
      trading_reward_pool_campaign_schedule() const;
  // repeated .injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4 [json_name = "pendingTradingRewardPoolCampaignSchedule"];
  int pending_trading_reward_pool_campaign_schedule_size() const;
  private:
  int _internal_pending_trading_reward_pool_campaign_schedule_size() const;

  public:
  void clear_pending_trading_reward_pool_campaign_schedule() ;
  ::injective::exchange::v1beta1::CampaignRewardPool* mutable_pending_trading_reward_pool_campaign_schedule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
      mutable_pending_trading_reward_pool_campaign_schedule();
  private:
  const ::injective::exchange::v1beta1::CampaignRewardPool& _internal_pending_trading_reward_pool_campaign_schedule(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* _internal_add_pending_trading_reward_pool_campaign_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>& _internal_pending_trading_reward_pool_campaign_schedule() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>* _internal_mutable_pending_trading_reward_pool_campaign_schedule();
  public:
  const ::injective::exchange::v1beta1::CampaignRewardPool& pending_trading_reward_pool_campaign_schedule(int index) const;
  ::injective::exchange::v1beta1::CampaignRewardPool* add_pending_trading_reward_pool_campaign_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
      pending_trading_reward_pool_campaign_schedule() const;
  // repeated string pending_total_trade_reward_points = 5 [json_name = "pendingTotalTradeRewardPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  int pending_total_trade_reward_points_size() const;
  private:
  int _internal_pending_total_trade_reward_points_size() const;

  public:
  void clear_pending_total_trade_reward_points() ;
  const std::string& pending_total_trade_reward_points(int index) const;
  std::string* mutable_pending_total_trade_reward_points(int index);
  void set_pending_total_trade_reward_points(int index, const std::string& value);
  void set_pending_total_trade_reward_points(int index, std::string&& value);
  void set_pending_total_trade_reward_points(int index, const char* value);
  void set_pending_total_trade_reward_points(int index, const char* value, std::size_t size);
  void set_pending_total_trade_reward_points(int index, absl::string_view value);
  std::string* add_pending_total_trade_reward_points();
  void add_pending_total_trade_reward_points(const std::string& value);
  void add_pending_total_trade_reward_points(std::string&& value);
  void add_pending_total_trade_reward_points(const char* value);
  void add_pending_total_trade_reward_points(const char* value, std::size_t size);
  void add_pending_total_trade_reward_points(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pending_total_trade_reward_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pending_total_trade_reward_points();

  private:
  const std::string& _internal_pending_total_trade_reward_points(int index) const;
  std::string* _internal_add_pending_total_trade_reward_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_pending_total_trade_reward_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_pending_total_trade_reward_points();

  public:
  // string total_trade_reward_points = 3 [json_name = "totalTradeRewardPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_total_trade_reward_points() ;
  const std::string& total_trade_reward_points() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_trade_reward_points(Arg_&& arg, Args_... args);
  std::string* mutable_total_trade_reward_points();
  PROTOBUF_NODISCARD std::string* release_total_trade_reward_points();
  void set_allocated_total_trade_reward_points(std::string* ptr);

  private:
  const std::string& _internal_total_trade_reward_points() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_trade_reward_points(
      const std::string& value);
  std::string* _internal_mutable_total_trade_reward_points();

  public:
  // .injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 1 [json_name = "tradingRewardCampaignInfo"];
  bool has_trading_reward_campaign_info() const;
  void clear_trading_reward_campaign_info() ;
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& trading_reward_campaign_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::TradingRewardCampaignInfo* release_trading_reward_campaign_info();
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* mutable_trading_reward_campaign_info();
  void set_allocated_trading_reward_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* trading_reward_campaign_info);
  private:
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& _internal_trading_reward_campaign_info() const;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _internal_mutable_trading_reward_campaign_info();
  public:
  void unsafe_arena_set_allocated_trading_reward_campaign_info(
      ::injective::exchange::v1beta1::TradingRewardCampaignInfo* trading_reward_campaign_info);
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* unsafe_arena_release_trading_reward_campaign_info();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool > trading_reward_pool_campaign_schedule_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool > pending_trading_reward_pool_campaign_schedule_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pending_total_trade_reward_points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_trade_reward_points_;
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* trading_reward_campaign_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryIsOptedOutOfRewardsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest) */ {
 public:
  inline QueryIsOptedOutOfRewardsRequest() : QueryIsOptedOutOfRewardsRequest(nullptr) {}
  ~QueryIsOptedOutOfRewardsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryIsOptedOutOfRewardsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryIsOptedOutOfRewardsRequest(const QueryIsOptedOutOfRewardsRequest& from);
  QueryIsOptedOutOfRewardsRequest(QueryIsOptedOutOfRewardsRequest&& from) noexcept
    : QueryIsOptedOutOfRewardsRequest() {
    *this = ::std::move(from);
  }

  inline QueryIsOptedOutOfRewardsRequest& operator=(const QueryIsOptedOutOfRewardsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryIsOptedOutOfRewardsRequest& operator=(QueryIsOptedOutOfRewardsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryIsOptedOutOfRewardsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryIsOptedOutOfRewardsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryIsOptedOutOfRewardsRequest*>(
               &_QueryIsOptedOutOfRewardsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(QueryIsOptedOutOfRewardsRequest& a, QueryIsOptedOutOfRewardsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryIsOptedOutOfRewardsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryIsOptedOutOfRewardsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryIsOptedOutOfRewardsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryIsOptedOutOfRewardsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryIsOptedOutOfRewardsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryIsOptedOutOfRewardsRequest& from) {
    QueryIsOptedOutOfRewardsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryIsOptedOutOfRewardsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest";
  }
  protected:
  explicit QueryIsOptedOutOfRewardsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // string account = 1 [json_name = "account"];
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryIsOptedOutOfRewardsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse) */ {
 public:
  inline QueryIsOptedOutOfRewardsResponse() : QueryIsOptedOutOfRewardsResponse(nullptr) {}
  ~QueryIsOptedOutOfRewardsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryIsOptedOutOfRewardsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryIsOptedOutOfRewardsResponse(const QueryIsOptedOutOfRewardsResponse& from);
  QueryIsOptedOutOfRewardsResponse(QueryIsOptedOutOfRewardsResponse&& from) noexcept
    : QueryIsOptedOutOfRewardsResponse() {
    *this = ::std::move(from);
  }

  inline QueryIsOptedOutOfRewardsResponse& operator=(const QueryIsOptedOutOfRewardsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryIsOptedOutOfRewardsResponse& operator=(QueryIsOptedOutOfRewardsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryIsOptedOutOfRewardsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryIsOptedOutOfRewardsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryIsOptedOutOfRewardsResponse*>(
               &_QueryIsOptedOutOfRewardsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(QueryIsOptedOutOfRewardsResponse& a, QueryIsOptedOutOfRewardsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryIsOptedOutOfRewardsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryIsOptedOutOfRewardsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryIsOptedOutOfRewardsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryIsOptedOutOfRewardsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryIsOptedOutOfRewardsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryIsOptedOutOfRewardsResponse& from) {
    QueryIsOptedOutOfRewardsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryIsOptedOutOfRewardsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse";
  }
  protected:
  explicit QueryIsOptedOutOfRewardsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsOptedOutFieldNumber = 1,
  };
  // bool is_opted_out = 1 [json_name = "isOptedOut"];
  void clear_is_opted_out() ;
  bool is_opted_out() const;
  void set_is_opted_out(bool value);

  private:
  bool _internal_is_opted_out() const;
  void _internal_set_is_opted_out(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_opted_out_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryOptedOutOfRewardsAccountsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest) */ {
 public:
  inline QueryOptedOutOfRewardsAccountsRequest() : QueryOptedOutOfRewardsAccountsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryOptedOutOfRewardsAccountsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryOptedOutOfRewardsAccountsRequest(const QueryOptedOutOfRewardsAccountsRequest& from);
  QueryOptedOutOfRewardsAccountsRequest(QueryOptedOutOfRewardsAccountsRequest&& from) noexcept
    : QueryOptedOutOfRewardsAccountsRequest() {
    *this = ::std::move(from);
  }

  inline QueryOptedOutOfRewardsAccountsRequest& operator=(const QueryOptedOutOfRewardsAccountsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryOptedOutOfRewardsAccountsRequest& operator=(QueryOptedOutOfRewardsAccountsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryOptedOutOfRewardsAccountsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryOptedOutOfRewardsAccountsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryOptedOutOfRewardsAccountsRequest*>(
               &_QueryOptedOutOfRewardsAccountsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(QueryOptedOutOfRewardsAccountsRequest& a, QueryOptedOutOfRewardsAccountsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryOptedOutOfRewardsAccountsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryOptedOutOfRewardsAccountsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryOptedOutOfRewardsAccountsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryOptedOutOfRewardsAccountsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryOptedOutOfRewardsAccountsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryOptedOutOfRewardsAccountsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest";
  }
  protected:
  explicit QueryOptedOutOfRewardsAccountsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryOptedOutOfRewardsAccountsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse) */ {
 public:
  inline QueryOptedOutOfRewardsAccountsResponse() : QueryOptedOutOfRewardsAccountsResponse(nullptr) {}
  ~QueryOptedOutOfRewardsAccountsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryOptedOutOfRewardsAccountsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryOptedOutOfRewardsAccountsResponse(const QueryOptedOutOfRewardsAccountsResponse& from);
  QueryOptedOutOfRewardsAccountsResponse(QueryOptedOutOfRewardsAccountsResponse&& from) noexcept
    : QueryOptedOutOfRewardsAccountsResponse() {
    *this = ::std::move(from);
  }

  inline QueryOptedOutOfRewardsAccountsResponse& operator=(const QueryOptedOutOfRewardsAccountsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryOptedOutOfRewardsAccountsResponse& operator=(QueryOptedOutOfRewardsAccountsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryOptedOutOfRewardsAccountsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryOptedOutOfRewardsAccountsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryOptedOutOfRewardsAccountsResponse*>(
               &_QueryOptedOutOfRewardsAccountsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(QueryOptedOutOfRewardsAccountsResponse& a, QueryOptedOutOfRewardsAccountsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryOptedOutOfRewardsAccountsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryOptedOutOfRewardsAccountsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryOptedOutOfRewardsAccountsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryOptedOutOfRewardsAccountsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryOptedOutOfRewardsAccountsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryOptedOutOfRewardsAccountsResponse& from) {
    QueryOptedOutOfRewardsAccountsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryOptedOutOfRewardsAccountsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse";
  }
  protected:
  explicit QueryOptedOutOfRewardsAccountsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
  };
  // repeated string accounts = 1 [json_name = "accounts"];
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;

  public:
  void clear_accounts() ;
  const std::string& accounts(int index) const;
  std::string* mutable_accounts(int index);
  void set_accounts(int index, const std::string& value);
  void set_accounts(int index, std::string&& value);
  void set_accounts(int index, const char* value);
  void set_accounts(int index, const char* value, std::size_t size);
  void set_accounts(int index, absl::string_view value);
  std::string* add_accounts();
  void add_accounts(const std::string& value);
  void add_accounts(std::string&& value);
  void add_accounts(const char* value);
  void add_accounts(const char* value, std::size_t size);
  void add_accounts(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& accounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_accounts();

  private:
  const std::string& _internal_accounts(int index) const;
  std::string* _internal_add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_accounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_accounts();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> accounts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFeeDiscountAccountInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest) */ {
 public:
  inline QueryFeeDiscountAccountInfoRequest() : QueryFeeDiscountAccountInfoRequest(nullptr) {}
  ~QueryFeeDiscountAccountInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFeeDiscountAccountInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFeeDiscountAccountInfoRequest(const QueryFeeDiscountAccountInfoRequest& from);
  QueryFeeDiscountAccountInfoRequest(QueryFeeDiscountAccountInfoRequest&& from) noexcept
    : QueryFeeDiscountAccountInfoRequest() {
    *this = ::std::move(from);
  }

  inline QueryFeeDiscountAccountInfoRequest& operator=(const QueryFeeDiscountAccountInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFeeDiscountAccountInfoRequest& operator=(QueryFeeDiscountAccountInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFeeDiscountAccountInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFeeDiscountAccountInfoRequest* internal_default_instance() {
    return reinterpret_cast<const QueryFeeDiscountAccountInfoRequest*>(
               &_QueryFeeDiscountAccountInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(QueryFeeDiscountAccountInfoRequest& a, QueryFeeDiscountAccountInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFeeDiscountAccountInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFeeDiscountAccountInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFeeDiscountAccountInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFeeDiscountAccountInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFeeDiscountAccountInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFeeDiscountAccountInfoRequest& from) {
    QueryFeeDiscountAccountInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFeeDiscountAccountInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest";
  }
  protected:
  explicit QueryFeeDiscountAccountInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // string account = 1 [json_name = "account"];
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFeeDiscountAccountInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse) */ {
 public:
  inline QueryFeeDiscountAccountInfoResponse() : QueryFeeDiscountAccountInfoResponse(nullptr) {}
  ~QueryFeeDiscountAccountInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFeeDiscountAccountInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFeeDiscountAccountInfoResponse(const QueryFeeDiscountAccountInfoResponse& from);
  QueryFeeDiscountAccountInfoResponse(QueryFeeDiscountAccountInfoResponse&& from) noexcept
    : QueryFeeDiscountAccountInfoResponse() {
    *this = ::std::move(from);
  }

  inline QueryFeeDiscountAccountInfoResponse& operator=(const QueryFeeDiscountAccountInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFeeDiscountAccountInfoResponse& operator=(QueryFeeDiscountAccountInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFeeDiscountAccountInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFeeDiscountAccountInfoResponse* internal_default_instance() {
    return reinterpret_cast<const QueryFeeDiscountAccountInfoResponse*>(
               &_QueryFeeDiscountAccountInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(QueryFeeDiscountAccountInfoResponse& a, QueryFeeDiscountAccountInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFeeDiscountAccountInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFeeDiscountAccountInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFeeDiscountAccountInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFeeDiscountAccountInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFeeDiscountAccountInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFeeDiscountAccountInfoResponse& from) {
    QueryFeeDiscountAccountInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFeeDiscountAccountInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse";
  }
  protected:
  explicit QueryFeeDiscountAccountInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountInfoFieldNumber = 2,
    kAccountTtlFieldNumber = 3,
    kTierLevelFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.FeeDiscountTierInfo account_info = 2 [json_name = "accountInfo"];
  bool has_account_info() const;
  void clear_account_info() ;
  const ::injective::exchange::v1beta1::FeeDiscountTierInfo& account_info() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::FeeDiscountTierInfo* release_account_info();
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* mutable_account_info();
  void set_allocated_account_info(::injective::exchange::v1beta1::FeeDiscountTierInfo* account_info);
  private:
  const ::injective::exchange::v1beta1::FeeDiscountTierInfo& _internal_account_info() const;
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* _internal_mutable_account_info();
  public:
  void unsafe_arena_set_allocated_account_info(
      ::injective::exchange::v1beta1::FeeDiscountTierInfo* account_info);
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* unsafe_arena_release_account_info();
  // .injective.exchange.v1beta1.FeeDiscountTierTTL account_ttl = 3 [json_name = "accountTtl"];
  bool has_account_ttl() const;
  void clear_account_ttl() ;
  const ::injective::exchange::v1beta1::FeeDiscountTierTTL& account_ttl() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::FeeDiscountTierTTL* release_account_ttl();
  ::injective::exchange::v1beta1::FeeDiscountTierTTL* mutable_account_ttl();
  void set_allocated_account_ttl(::injective::exchange::v1beta1::FeeDiscountTierTTL* account_ttl);
  private:
  const ::injective::exchange::v1beta1::FeeDiscountTierTTL& _internal_account_ttl() const;
  ::injective::exchange::v1beta1::FeeDiscountTierTTL* _internal_mutable_account_ttl();
  public:
  void unsafe_arena_set_allocated_account_ttl(
      ::injective::exchange::v1beta1::FeeDiscountTierTTL* account_ttl);
  ::injective::exchange::v1beta1::FeeDiscountTierTTL* unsafe_arena_release_account_ttl();
  // uint64 tier_level = 1 [json_name = "tierLevel"];
  void clear_tier_level() ;
  ::uint64_t tier_level() const;
  void set_tier_level(::uint64_t value);

  private:
  ::uint64_t _internal_tier_level() const;
  void _internal_set_tier_level(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::FeeDiscountTierInfo* account_info_;
    ::injective::exchange::v1beta1::FeeDiscountTierTTL* account_ttl_;
    ::uint64_t tier_level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFeeDiscountScheduleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest) */ {
 public:
  inline QueryFeeDiscountScheduleRequest() : QueryFeeDiscountScheduleRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFeeDiscountScheduleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFeeDiscountScheduleRequest(const QueryFeeDiscountScheduleRequest& from);
  QueryFeeDiscountScheduleRequest(QueryFeeDiscountScheduleRequest&& from) noexcept
    : QueryFeeDiscountScheduleRequest() {
    *this = ::std::move(from);
  }

  inline QueryFeeDiscountScheduleRequest& operator=(const QueryFeeDiscountScheduleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFeeDiscountScheduleRequest& operator=(QueryFeeDiscountScheduleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFeeDiscountScheduleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFeeDiscountScheduleRequest* internal_default_instance() {
    return reinterpret_cast<const QueryFeeDiscountScheduleRequest*>(
               &_QueryFeeDiscountScheduleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(QueryFeeDiscountScheduleRequest& a, QueryFeeDiscountScheduleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFeeDiscountScheduleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFeeDiscountScheduleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFeeDiscountScheduleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFeeDiscountScheduleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryFeeDiscountScheduleRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryFeeDiscountScheduleRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest";
  }
  protected:
  explicit QueryFeeDiscountScheduleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFeeDiscountScheduleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFeeDiscountScheduleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse) */ {
 public:
  inline QueryFeeDiscountScheduleResponse() : QueryFeeDiscountScheduleResponse(nullptr) {}
  ~QueryFeeDiscountScheduleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFeeDiscountScheduleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFeeDiscountScheduleResponse(const QueryFeeDiscountScheduleResponse& from);
  QueryFeeDiscountScheduleResponse(QueryFeeDiscountScheduleResponse&& from) noexcept
    : QueryFeeDiscountScheduleResponse() {
    *this = ::std::move(from);
  }

  inline QueryFeeDiscountScheduleResponse& operator=(const QueryFeeDiscountScheduleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFeeDiscountScheduleResponse& operator=(QueryFeeDiscountScheduleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFeeDiscountScheduleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFeeDiscountScheduleResponse* internal_default_instance() {
    return reinterpret_cast<const QueryFeeDiscountScheduleResponse*>(
               &_QueryFeeDiscountScheduleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(QueryFeeDiscountScheduleResponse& a, QueryFeeDiscountScheduleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFeeDiscountScheduleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFeeDiscountScheduleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFeeDiscountScheduleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFeeDiscountScheduleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFeeDiscountScheduleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFeeDiscountScheduleResponse& from) {
    QueryFeeDiscountScheduleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFeeDiscountScheduleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse";
  }
  protected:
  explicit QueryFeeDiscountScheduleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeeDiscountScheduleFieldNumber = 1,
  };
  // .injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 1 [json_name = "feeDiscountSchedule"];
  bool has_fee_discount_schedule() const;
  void clear_fee_discount_schedule() ;
  const ::injective::exchange::v1beta1::FeeDiscountSchedule& fee_discount_schedule() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::FeeDiscountSchedule* release_fee_discount_schedule();
  ::injective::exchange::v1beta1::FeeDiscountSchedule* mutable_fee_discount_schedule();
  void set_allocated_fee_discount_schedule(::injective::exchange::v1beta1::FeeDiscountSchedule* fee_discount_schedule);
  private:
  const ::injective::exchange::v1beta1::FeeDiscountSchedule& _internal_fee_discount_schedule() const;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* _internal_mutable_fee_discount_schedule();
  public:
  void unsafe_arena_set_allocated_fee_discount_schedule(
      ::injective::exchange::v1beta1::FeeDiscountSchedule* fee_discount_schedule);
  ::injective::exchange::v1beta1::FeeDiscountSchedule* unsafe_arena_release_fee_discount_schedule();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective::exchange::v1beta1::FeeDiscountSchedule* fee_discount_schedule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBalanceMismatchesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryBalanceMismatchesRequest) */ {
 public:
  inline QueryBalanceMismatchesRequest() : QueryBalanceMismatchesRequest(nullptr) {}
  ~QueryBalanceMismatchesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBalanceMismatchesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBalanceMismatchesRequest(const QueryBalanceMismatchesRequest& from);
  QueryBalanceMismatchesRequest(QueryBalanceMismatchesRequest&& from) noexcept
    : QueryBalanceMismatchesRequest() {
    *this = ::std::move(from);
  }

  inline QueryBalanceMismatchesRequest& operator=(const QueryBalanceMismatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBalanceMismatchesRequest& operator=(QueryBalanceMismatchesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBalanceMismatchesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBalanceMismatchesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryBalanceMismatchesRequest*>(
               &_QueryBalanceMismatchesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(QueryBalanceMismatchesRequest& a, QueryBalanceMismatchesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBalanceMismatchesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBalanceMismatchesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBalanceMismatchesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBalanceMismatchesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBalanceMismatchesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBalanceMismatchesRequest& from) {
    QueryBalanceMismatchesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBalanceMismatchesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryBalanceMismatchesRequest";
  }
  protected:
  explicit QueryBalanceMismatchesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDustFactorFieldNumber = 1,
  };
  // int64 dust_factor = 1 [json_name = "dustFactor"];
  void clear_dust_factor() ;
  ::int64_t dust_factor() const;
  void set_dust_factor(::int64_t value);

  private:
  ::int64_t _internal_dust_factor() const;
  void _internal_set_dust_factor(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryBalanceMismatchesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t dust_factor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class BalanceMismatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.BalanceMismatch) */ {
 public:
  inline BalanceMismatch() : BalanceMismatch(nullptr) {}
  ~BalanceMismatch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BalanceMismatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BalanceMismatch(const BalanceMismatch& from);
  BalanceMismatch(BalanceMismatch&& from) noexcept
    : BalanceMismatch() {
    *this = ::std::move(from);
  }

  inline BalanceMismatch& operator=(const BalanceMismatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceMismatch& operator=(BalanceMismatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalanceMismatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalanceMismatch* internal_default_instance() {
    return reinterpret_cast<const BalanceMismatch*>(
               &_BalanceMismatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(BalanceMismatch& a, BalanceMismatch& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceMismatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceMismatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalanceMismatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalanceMismatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BalanceMismatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BalanceMismatch& from) {
    BalanceMismatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceMismatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.BalanceMismatch";
  }
  protected:
  explicit BalanceMismatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kDenomFieldNumber = 2,
    kAvailableFieldNumber = 3,
    kTotalFieldNumber = 4,
    kBalanceHoldFieldNumber = 5,
    kExpectedTotalFieldNumber = 6,
    kDifferenceFieldNumber = 7,
  };
  // string subaccountId = 1 [json_name = "subaccountId"];
  void clear_subaccountid() ;
  const std::string& subaccountid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccountid(Arg_&& arg, Args_... args);
  std::string* mutable_subaccountid();
  PROTOBUF_NODISCARD std::string* release_subaccountid();
  void set_allocated_subaccountid(std::string* ptr);

  private:
  const std::string& _internal_subaccountid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccountid(
      const std::string& value);
  std::string* _internal_mutable_subaccountid();

  public:
  // string denom = 2 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string available = 3 [json_name = "available", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_available() ;
  const std::string& available() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_available(Arg_&& arg, Args_... args);
  std::string* mutable_available();
  PROTOBUF_NODISCARD std::string* release_available();
  void set_allocated_available(std::string* ptr);

  private:
  const std::string& _internal_available() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available(
      const std::string& value);
  std::string* _internal_mutable_available();

  public:
  // string total = 4 [json_name = "total", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_total() ;
  const std::string& total() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total(Arg_&& arg, Args_... args);
  std::string* mutable_total();
  PROTOBUF_NODISCARD std::string* release_total();
  void set_allocated_total(std::string* ptr);

  private:
  const std::string& _internal_total() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total(
      const std::string& value);
  std::string* _internal_mutable_total();

  public:
  // string balance_hold = 5 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_balance_hold() ;
  const std::string& balance_hold() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance_hold(Arg_&& arg, Args_... args);
  std::string* mutable_balance_hold();
  PROTOBUF_NODISCARD std::string* release_balance_hold();
  void set_allocated_balance_hold(std::string* ptr);

  private:
  const std::string& _internal_balance_hold() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance_hold(
      const std::string& value);
  std::string* _internal_mutable_balance_hold();

  public:
  // string expected_total = 6 [json_name = "expectedTotal", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_expected_total() ;
  const std::string& expected_total() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expected_total(Arg_&& arg, Args_... args);
  std::string* mutable_expected_total();
  PROTOBUF_NODISCARD std::string* release_expected_total();
  void set_allocated_expected_total(std::string* ptr);

  private:
  const std::string& _internal_expected_total() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expected_total(
      const std::string& value);
  std::string* _internal_mutable_expected_total();

  public:
  // string difference = 7 [json_name = "difference", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_difference() ;
  const std::string& difference() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_difference(Arg_&& arg, Args_... args);
  std::string* mutable_difference();
  PROTOBUF_NODISCARD std::string* release_difference();
  void set_allocated_difference(std::string* ptr);

  private:
  const std::string& _internal_difference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_difference(
      const std::string& value);
  std::string* _internal_mutable_difference();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.BalanceMismatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccountid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_hold_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expected_total_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr difference_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBalanceMismatchesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryBalanceMismatchesResponse) */ {
 public:
  inline QueryBalanceMismatchesResponse() : QueryBalanceMismatchesResponse(nullptr) {}
  ~QueryBalanceMismatchesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBalanceMismatchesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBalanceMismatchesResponse(const QueryBalanceMismatchesResponse& from);
  QueryBalanceMismatchesResponse(QueryBalanceMismatchesResponse&& from) noexcept
    : QueryBalanceMismatchesResponse() {
    *this = ::std::move(from);
  }

  inline QueryBalanceMismatchesResponse& operator=(const QueryBalanceMismatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBalanceMismatchesResponse& operator=(QueryBalanceMismatchesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBalanceMismatchesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBalanceMismatchesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryBalanceMismatchesResponse*>(
               &_QueryBalanceMismatchesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(QueryBalanceMismatchesResponse& a, QueryBalanceMismatchesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBalanceMismatchesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBalanceMismatchesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBalanceMismatchesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBalanceMismatchesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBalanceMismatchesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBalanceMismatchesResponse& from) {
    QueryBalanceMismatchesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBalanceMismatchesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryBalanceMismatchesResponse";
  }
  protected:
  explicit QueryBalanceMismatchesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceMismatchesFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.BalanceMismatch balance_mismatches = 1 [json_name = "balanceMismatches"];
  int balance_mismatches_size() const;
  private:
  int _internal_balance_mismatches_size() const;

  public:
  void clear_balance_mismatches() ;
  ::injective::exchange::v1beta1::BalanceMismatch* mutable_balance_mismatches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceMismatch >*
      mutable_balance_mismatches();
  private:
  const ::injective::exchange::v1beta1::BalanceMismatch& _internal_balance_mismatches(int index) const;
  ::injective::exchange::v1beta1::BalanceMismatch* _internal_add_balance_mismatches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceMismatch>& _internal_balance_mismatches() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceMismatch>* _internal_mutable_balance_mismatches();
  public:
  const ::injective::exchange::v1beta1::BalanceMismatch& balance_mismatches(int index) const;
  ::injective::exchange::v1beta1::BalanceMismatch* add_balance_mismatches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceMismatch >&
      balance_mismatches() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryBalanceMismatchesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceMismatch > balance_mismatches_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBalanceWithBalanceHoldsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest) */ {
 public:
  inline QueryBalanceWithBalanceHoldsRequest() : QueryBalanceWithBalanceHoldsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBalanceWithBalanceHoldsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBalanceWithBalanceHoldsRequest(const QueryBalanceWithBalanceHoldsRequest& from);
  QueryBalanceWithBalanceHoldsRequest(QueryBalanceWithBalanceHoldsRequest&& from) noexcept
    : QueryBalanceWithBalanceHoldsRequest() {
    *this = ::std::move(from);
  }

  inline QueryBalanceWithBalanceHoldsRequest& operator=(const QueryBalanceWithBalanceHoldsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBalanceWithBalanceHoldsRequest& operator=(QueryBalanceWithBalanceHoldsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBalanceWithBalanceHoldsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBalanceWithBalanceHoldsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryBalanceWithBalanceHoldsRequest*>(
               &_QueryBalanceWithBalanceHoldsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(QueryBalanceWithBalanceHoldsRequest& a, QueryBalanceWithBalanceHoldsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBalanceWithBalanceHoldsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBalanceWithBalanceHoldsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBalanceWithBalanceHoldsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBalanceWithBalanceHoldsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryBalanceWithBalanceHoldsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryBalanceWithBalanceHoldsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest";
  }
  protected:
  explicit QueryBalanceWithBalanceHoldsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class BalanceWithMarginHold final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.BalanceWithMarginHold) */ {
 public:
  inline BalanceWithMarginHold() : BalanceWithMarginHold(nullptr) {}
  ~BalanceWithMarginHold() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BalanceWithMarginHold(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BalanceWithMarginHold(const BalanceWithMarginHold& from);
  BalanceWithMarginHold(BalanceWithMarginHold&& from) noexcept
    : BalanceWithMarginHold() {
    *this = ::std::move(from);
  }

  inline BalanceWithMarginHold& operator=(const BalanceWithMarginHold& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceWithMarginHold& operator=(BalanceWithMarginHold&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalanceWithMarginHold& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalanceWithMarginHold* internal_default_instance() {
    return reinterpret_cast<const BalanceWithMarginHold*>(
               &_BalanceWithMarginHold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(BalanceWithMarginHold& a, BalanceWithMarginHold& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceWithMarginHold* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceWithMarginHold* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalanceWithMarginHold* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalanceWithMarginHold>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BalanceWithMarginHold& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BalanceWithMarginHold& from) {
    BalanceWithMarginHold::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceWithMarginHold* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.BalanceWithMarginHold";
  }
  protected:
  explicit BalanceWithMarginHold(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kDenomFieldNumber = 2,
    kAvailableFieldNumber = 3,
    kTotalFieldNumber = 4,
    kBalanceHoldFieldNumber = 5,
  };
  // string subaccountId = 1 [json_name = "subaccountId"];
  void clear_subaccountid() ;
  const std::string& subaccountid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccountid(Arg_&& arg, Args_... args);
  std::string* mutable_subaccountid();
  PROTOBUF_NODISCARD std::string* release_subaccountid();
  void set_allocated_subaccountid(std::string* ptr);

  private:
  const std::string& _internal_subaccountid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccountid(
      const std::string& value);
  std::string* _internal_mutable_subaccountid();

  public:
  // string denom = 2 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string available = 3 [json_name = "available", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_available() ;
  const std::string& available() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_available(Arg_&& arg, Args_... args);
  std::string* mutable_available();
  PROTOBUF_NODISCARD std::string* release_available();
  void set_allocated_available(std::string* ptr);

  private:
  const std::string& _internal_available() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available(
      const std::string& value);
  std::string* _internal_mutable_available();

  public:
  // string total = 4 [json_name = "total", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_total() ;
  const std::string& total() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total(Arg_&& arg, Args_... args);
  std::string* mutable_total();
  PROTOBUF_NODISCARD std::string* release_total();
  void set_allocated_total(std::string* ptr);

  private:
  const std::string& _internal_total() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total(
      const std::string& value);
  std::string* _internal_mutable_total();

  public:
  // string balance_hold = 5 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_balance_hold() ;
  const std::string& balance_hold() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance_hold(Arg_&& arg, Args_... args);
  std::string* mutable_balance_hold();
  PROTOBUF_NODISCARD std::string* release_balance_hold();
  void set_allocated_balance_hold(std::string* ptr);

  private:
  const std::string& _internal_balance_hold() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance_hold(
      const std::string& value);
  std::string* _internal_mutable_balance_hold();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.BalanceWithMarginHold)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccountid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_hold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBalanceWithBalanceHoldsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse) */ {
 public:
  inline QueryBalanceWithBalanceHoldsResponse() : QueryBalanceWithBalanceHoldsResponse(nullptr) {}
  ~QueryBalanceWithBalanceHoldsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBalanceWithBalanceHoldsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBalanceWithBalanceHoldsResponse(const QueryBalanceWithBalanceHoldsResponse& from);
  QueryBalanceWithBalanceHoldsResponse(QueryBalanceWithBalanceHoldsResponse&& from) noexcept
    : QueryBalanceWithBalanceHoldsResponse() {
    *this = ::std::move(from);
  }

  inline QueryBalanceWithBalanceHoldsResponse& operator=(const QueryBalanceWithBalanceHoldsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBalanceWithBalanceHoldsResponse& operator=(QueryBalanceWithBalanceHoldsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBalanceWithBalanceHoldsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBalanceWithBalanceHoldsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryBalanceWithBalanceHoldsResponse*>(
               &_QueryBalanceWithBalanceHoldsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(QueryBalanceWithBalanceHoldsResponse& a, QueryBalanceWithBalanceHoldsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBalanceWithBalanceHoldsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBalanceWithBalanceHoldsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBalanceWithBalanceHoldsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBalanceWithBalanceHoldsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBalanceWithBalanceHoldsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBalanceWithBalanceHoldsResponse& from) {
    QueryBalanceWithBalanceHoldsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBalanceWithBalanceHoldsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse";
  }
  protected:
  explicit QueryBalanceWithBalanceHoldsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceWithBalanceHoldsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.BalanceWithMarginHold balance_with_balance_holds = 1 [json_name = "balanceWithBalanceHolds"];
  int balance_with_balance_holds_size() const;
  private:
  int _internal_balance_with_balance_holds_size() const;

  public:
  void clear_balance_with_balance_holds() ;
  ::injective::exchange::v1beta1::BalanceWithMarginHold* mutable_balance_with_balance_holds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceWithMarginHold >*
      mutable_balance_with_balance_holds();
  private:
  const ::injective::exchange::v1beta1::BalanceWithMarginHold& _internal_balance_with_balance_holds(int index) const;
  ::injective::exchange::v1beta1::BalanceWithMarginHold* _internal_add_balance_with_balance_holds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceWithMarginHold>& _internal_balance_with_balance_holds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceWithMarginHold>* _internal_mutable_balance_with_balance_holds();
  public:
  const ::injective::exchange::v1beta1::BalanceWithMarginHold& balance_with_balance_holds(int index) const;
  ::injective::exchange::v1beta1::BalanceWithMarginHold* add_balance_with_balance_holds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceWithMarginHold >&
      balance_with_balance_holds() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceWithMarginHold > balance_with_balance_holds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFeeDiscountTierStatisticsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest) */ {
 public:
  inline QueryFeeDiscountTierStatisticsRequest() : QueryFeeDiscountTierStatisticsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFeeDiscountTierStatisticsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFeeDiscountTierStatisticsRequest(const QueryFeeDiscountTierStatisticsRequest& from);
  QueryFeeDiscountTierStatisticsRequest(QueryFeeDiscountTierStatisticsRequest&& from) noexcept
    : QueryFeeDiscountTierStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline QueryFeeDiscountTierStatisticsRequest& operator=(const QueryFeeDiscountTierStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFeeDiscountTierStatisticsRequest& operator=(QueryFeeDiscountTierStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFeeDiscountTierStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFeeDiscountTierStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryFeeDiscountTierStatisticsRequest*>(
               &_QueryFeeDiscountTierStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(QueryFeeDiscountTierStatisticsRequest& a, QueryFeeDiscountTierStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFeeDiscountTierStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFeeDiscountTierStatisticsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFeeDiscountTierStatisticsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFeeDiscountTierStatisticsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QueryFeeDiscountTierStatisticsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QueryFeeDiscountTierStatisticsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest";
  }
  protected:
  explicit QueryFeeDiscountTierStatisticsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class TierStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TierStatistic) */ {
 public:
  inline TierStatistic() : TierStatistic(nullptr) {}
  ~TierStatistic() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TierStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TierStatistic(const TierStatistic& from);
  TierStatistic(TierStatistic&& from) noexcept
    : TierStatistic() {
    *this = ::std::move(from);
  }

  inline TierStatistic& operator=(const TierStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline TierStatistic& operator=(TierStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TierStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const TierStatistic* internal_default_instance() {
    return reinterpret_cast<const TierStatistic*>(
               &_TierStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(TierStatistic& a, TierStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(TierStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TierStatistic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TierStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TierStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TierStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TierStatistic& from) {
    TierStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TierStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TierStatistic";
  }
  protected:
  explicit TierStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTierFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // uint64 tier = 1 [json_name = "tier"];
  void clear_tier() ;
  ::uint64_t tier() const;
  void set_tier(::uint64_t value);

  private:
  ::uint64_t _internal_tier() const;
  void _internal_set_tier(::uint64_t value);

  public:
  // uint64 count = 2 [json_name = "count"];
  void clear_count() ;
  ::uint64_t count() const;
  void set_count(::uint64_t value);

  private:
  ::uint64_t _internal_count() const;
  void _internal_set_count(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TierStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t tier_;
    ::uint64_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryFeeDiscountTierStatisticsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse) */ {
 public:
  inline QueryFeeDiscountTierStatisticsResponse() : QueryFeeDiscountTierStatisticsResponse(nullptr) {}
  ~QueryFeeDiscountTierStatisticsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryFeeDiscountTierStatisticsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryFeeDiscountTierStatisticsResponse(const QueryFeeDiscountTierStatisticsResponse& from);
  QueryFeeDiscountTierStatisticsResponse(QueryFeeDiscountTierStatisticsResponse&& from) noexcept
    : QueryFeeDiscountTierStatisticsResponse() {
    *this = ::std::move(from);
  }

  inline QueryFeeDiscountTierStatisticsResponse& operator=(const QueryFeeDiscountTierStatisticsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryFeeDiscountTierStatisticsResponse& operator=(QueryFeeDiscountTierStatisticsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryFeeDiscountTierStatisticsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryFeeDiscountTierStatisticsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryFeeDiscountTierStatisticsResponse*>(
               &_QueryFeeDiscountTierStatisticsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(QueryFeeDiscountTierStatisticsResponse& a, QueryFeeDiscountTierStatisticsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryFeeDiscountTierStatisticsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryFeeDiscountTierStatisticsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryFeeDiscountTierStatisticsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryFeeDiscountTierStatisticsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryFeeDiscountTierStatisticsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryFeeDiscountTierStatisticsResponse& from) {
    QueryFeeDiscountTierStatisticsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFeeDiscountTierStatisticsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse";
  }
  protected:
  explicit QueryFeeDiscountTierStatisticsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatisticsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TierStatistic statistics = 1 [json_name = "statistics"];
  int statistics_size() const;
  private:
  int _internal_statistics_size() const;

  public:
  void clear_statistics() ;
  ::injective::exchange::v1beta1::TierStatistic* mutable_statistics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TierStatistic >*
      mutable_statistics();
  private:
  const ::injective::exchange::v1beta1::TierStatistic& _internal_statistics(int index) const;
  ::injective::exchange::v1beta1::TierStatistic* _internal_add_statistics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TierStatistic>& _internal_statistics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TierStatistic>* _internal_mutable_statistics();
  public:
  const ::injective::exchange::v1beta1::TierStatistic& statistics(int index) const;
  ::injective::exchange::v1beta1::TierStatistic* add_statistics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TierStatistic >&
      statistics() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TierStatistic > statistics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class MitoVaultInfosRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MitoVaultInfosRequest) */ {
 public:
  inline MitoVaultInfosRequest() : MitoVaultInfosRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MitoVaultInfosRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MitoVaultInfosRequest(const MitoVaultInfosRequest& from);
  MitoVaultInfosRequest(MitoVaultInfosRequest&& from) noexcept
    : MitoVaultInfosRequest() {
    *this = ::std::move(from);
  }

  inline MitoVaultInfosRequest& operator=(const MitoVaultInfosRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MitoVaultInfosRequest& operator=(MitoVaultInfosRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MitoVaultInfosRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MitoVaultInfosRequest* internal_default_instance() {
    return reinterpret_cast<const MitoVaultInfosRequest*>(
               &_MitoVaultInfosRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(MitoVaultInfosRequest& a, MitoVaultInfosRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MitoVaultInfosRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MitoVaultInfosRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MitoVaultInfosRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MitoVaultInfosRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MitoVaultInfosRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MitoVaultInfosRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MitoVaultInfosRequest";
  }
  protected:
  explicit MitoVaultInfosRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MitoVaultInfosRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class MitoVaultInfosResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.MitoVaultInfosResponse) */ {
 public:
  inline MitoVaultInfosResponse() : MitoVaultInfosResponse(nullptr) {}
  ~MitoVaultInfosResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MitoVaultInfosResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MitoVaultInfosResponse(const MitoVaultInfosResponse& from);
  MitoVaultInfosResponse(MitoVaultInfosResponse&& from) noexcept
    : MitoVaultInfosResponse() {
    *this = ::std::move(from);
  }

  inline MitoVaultInfosResponse& operator=(const MitoVaultInfosResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MitoVaultInfosResponse& operator=(MitoVaultInfosResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MitoVaultInfosResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MitoVaultInfosResponse* internal_default_instance() {
    return reinterpret_cast<const MitoVaultInfosResponse*>(
               &_MitoVaultInfosResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(MitoVaultInfosResponse& a, MitoVaultInfosResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MitoVaultInfosResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MitoVaultInfosResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MitoVaultInfosResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MitoVaultInfosResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MitoVaultInfosResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MitoVaultInfosResponse& from) {
    MitoVaultInfosResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MitoVaultInfosResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.MitoVaultInfosResponse";
  }
  protected:
  explicit MitoVaultInfosResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMasterAddressesFieldNumber = 1,
    kDerivativeAddressesFieldNumber = 2,
    kSpotAddressesFieldNumber = 3,
    kCw20AddressesFieldNumber = 4,
  };
  // repeated string master_addresses = 1 [json_name = "masterAddresses"];
  int master_addresses_size() const;
  private:
  int _internal_master_addresses_size() const;

  public:
  void clear_master_addresses() ;
  const std::string& master_addresses(int index) const;
  std::string* mutable_master_addresses(int index);
  void set_master_addresses(int index, const std::string& value);
  void set_master_addresses(int index, std::string&& value);
  void set_master_addresses(int index, const char* value);
  void set_master_addresses(int index, const char* value, std::size_t size);
  void set_master_addresses(int index, absl::string_view value);
  std::string* add_master_addresses();
  void add_master_addresses(const std::string& value);
  void add_master_addresses(std::string&& value);
  void add_master_addresses(const char* value);
  void add_master_addresses(const char* value, std::size_t size);
  void add_master_addresses(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& master_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_master_addresses();

  private:
  const std::string& _internal_master_addresses(int index) const;
  std::string* _internal_add_master_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_master_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_master_addresses();

  public:
  // repeated string derivative_addresses = 2 [json_name = "derivativeAddresses"];
  int derivative_addresses_size() const;
  private:
  int _internal_derivative_addresses_size() const;

  public:
  void clear_derivative_addresses() ;
  const std::string& derivative_addresses(int index) const;
  std::string* mutable_derivative_addresses(int index);
  void set_derivative_addresses(int index, const std::string& value);
  void set_derivative_addresses(int index, std::string&& value);
  void set_derivative_addresses(int index, const char* value);
  void set_derivative_addresses(int index, const char* value, std::size_t size);
  void set_derivative_addresses(int index, absl::string_view value);
  std::string* add_derivative_addresses();
  void add_derivative_addresses(const std::string& value);
  void add_derivative_addresses(std::string&& value);
  void add_derivative_addresses(const char* value);
  void add_derivative_addresses(const char* value, std::size_t size);
  void add_derivative_addresses(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& derivative_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_derivative_addresses();

  private:
  const std::string& _internal_derivative_addresses(int index) const;
  std::string* _internal_add_derivative_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_derivative_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_derivative_addresses();

  public:
  // repeated string spot_addresses = 3 [json_name = "spotAddresses"];
  int spot_addresses_size() const;
  private:
  int _internal_spot_addresses_size() const;

  public:
  void clear_spot_addresses() ;
  const std::string& spot_addresses(int index) const;
  std::string* mutable_spot_addresses(int index);
  void set_spot_addresses(int index, const std::string& value);
  void set_spot_addresses(int index, std::string&& value);
  void set_spot_addresses(int index, const char* value);
  void set_spot_addresses(int index, const char* value, std::size_t size);
  void set_spot_addresses(int index, absl::string_view value);
  std::string* add_spot_addresses();
  void add_spot_addresses(const std::string& value);
  void add_spot_addresses(std::string&& value);
  void add_spot_addresses(const char* value);
  void add_spot_addresses(const char* value, std::size_t size);
  void add_spot_addresses(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& spot_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_spot_addresses();

  private:
  const std::string& _internal_spot_addresses(int index) const;
  std::string* _internal_add_spot_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_spot_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_spot_addresses();

  public:
  // repeated string cw20_addresses = 4 [json_name = "cw20Addresses"];
  int cw20_addresses_size() const;
  private:
  int _internal_cw20_addresses_size() const;

  public:
  void clear_cw20_addresses() ;
  const std::string& cw20_addresses(int index) const;
  std::string* mutable_cw20_addresses(int index);
  void set_cw20_addresses(int index, const std::string& value);
  void set_cw20_addresses(int index, std::string&& value);
  void set_cw20_addresses(int index, const char* value);
  void set_cw20_addresses(int index, const char* value, std::size_t size);
  void set_cw20_addresses(int index, absl::string_view value);
  std::string* add_cw20_addresses();
  void add_cw20_addresses(const std::string& value);
  void add_cw20_addresses(std::string&& value);
  void add_cw20_addresses(const char* value);
  void add_cw20_addresses(const char* value, std::size_t size);
  void add_cw20_addresses(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cw20_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cw20_addresses();

  private:
  const std::string& _internal_cw20_addresses(int index) const;
  std::string* _internal_add_cw20_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_cw20_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_cw20_addresses();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.MitoVaultInfosResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> master_addresses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> derivative_addresses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> spot_addresses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cw20_addresses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryMarketIDFromVaultRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryMarketIDFromVaultRequest) */ {
 public:
  inline QueryMarketIDFromVaultRequest() : QueryMarketIDFromVaultRequest(nullptr) {}
  ~QueryMarketIDFromVaultRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryMarketIDFromVaultRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMarketIDFromVaultRequest(const QueryMarketIDFromVaultRequest& from);
  QueryMarketIDFromVaultRequest(QueryMarketIDFromVaultRequest&& from) noexcept
    : QueryMarketIDFromVaultRequest() {
    *this = ::std::move(from);
  }

  inline QueryMarketIDFromVaultRequest& operator=(const QueryMarketIDFromVaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMarketIDFromVaultRequest& operator=(QueryMarketIDFromVaultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMarketIDFromVaultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMarketIDFromVaultRequest* internal_default_instance() {
    return reinterpret_cast<const QueryMarketIDFromVaultRequest*>(
               &_QueryMarketIDFromVaultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(QueryMarketIDFromVaultRequest& a, QueryMarketIDFromVaultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMarketIDFromVaultRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMarketIDFromVaultRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMarketIDFromVaultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMarketIDFromVaultRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMarketIDFromVaultRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMarketIDFromVaultRequest& from) {
    QueryMarketIDFromVaultRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMarketIDFromVaultRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryMarketIDFromVaultRequest";
  }
  protected:
  explicit QueryMarketIDFromVaultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVaultAddressFieldNumber = 1,
  };
  // string vault_address = 1 [json_name = "vaultAddress"];
  void clear_vault_address() ;
  const std::string& vault_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vault_address(Arg_&& arg, Args_... args);
  std::string* mutable_vault_address();
  PROTOBUF_NODISCARD std::string* release_vault_address();
  void set_allocated_vault_address(std::string* ptr);

  private:
  const std::string& _internal_vault_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vault_address(
      const std::string& value);
  std::string* _internal_mutable_vault_address();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryMarketIDFromVaultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vault_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryMarketIDFromVaultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryMarketIDFromVaultResponse) */ {
 public:
  inline QueryMarketIDFromVaultResponse() : QueryMarketIDFromVaultResponse(nullptr) {}
  ~QueryMarketIDFromVaultResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryMarketIDFromVaultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMarketIDFromVaultResponse(const QueryMarketIDFromVaultResponse& from);
  QueryMarketIDFromVaultResponse(QueryMarketIDFromVaultResponse&& from) noexcept
    : QueryMarketIDFromVaultResponse() {
    *this = ::std::move(from);
  }

  inline QueryMarketIDFromVaultResponse& operator=(const QueryMarketIDFromVaultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMarketIDFromVaultResponse& operator=(QueryMarketIDFromVaultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMarketIDFromVaultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMarketIDFromVaultResponse* internal_default_instance() {
    return reinterpret_cast<const QueryMarketIDFromVaultResponse*>(
               &_QueryMarketIDFromVaultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(QueryMarketIDFromVaultResponse& a, QueryMarketIDFromVaultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMarketIDFromVaultResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMarketIDFromVaultResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMarketIDFromVaultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMarketIDFromVaultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMarketIDFromVaultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMarketIDFromVaultResponse& from) {
    QueryMarketIDFromVaultResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMarketIDFromVaultResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryMarketIDFromVaultResponse";
  }
  protected:
  explicit QueryMarketIDFromVaultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryMarketIDFromVaultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryHistoricalTradeRecordsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest) */ {
 public:
  inline QueryHistoricalTradeRecordsRequest() : QueryHistoricalTradeRecordsRequest(nullptr) {}
  ~QueryHistoricalTradeRecordsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryHistoricalTradeRecordsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryHistoricalTradeRecordsRequest(const QueryHistoricalTradeRecordsRequest& from);
  QueryHistoricalTradeRecordsRequest(QueryHistoricalTradeRecordsRequest&& from) noexcept
    : QueryHistoricalTradeRecordsRequest() {
    *this = ::std::move(from);
  }

  inline QueryHistoricalTradeRecordsRequest& operator=(const QueryHistoricalTradeRecordsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryHistoricalTradeRecordsRequest& operator=(QueryHistoricalTradeRecordsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryHistoricalTradeRecordsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryHistoricalTradeRecordsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryHistoricalTradeRecordsRequest*>(
               &_QueryHistoricalTradeRecordsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(QueryHistoricalTradeRecordsRequest& a, QueryHistoricalTradeRecordsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryHistoricalTradeRecordsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryHistoricalTradeRecordsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryHistoricalTradeRecordsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryHistoricalTradeRecordsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryHistoricalTradeRecordsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryHistoricalTradeRecordsRequest& from) {
    QueryHistoricalTradeRecordsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryHistoricalTradeRecordsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest";
  }
  protected:
  explicit QueryHistoricalTradeRecordsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryHistoricalTradeRecordsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse) */ {
 public:
  inline QueryHistoricalTradeRecordsResponse() : QueryHistoricalTradeRecordsResponse(nullptr) {}
  ~QueryHistoricalTradeRecordsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryHistoricalTradeRecordsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryHistoricalTradeRecordsResponse(const QueryHistoricalTradeRecordsResponse& from);
  QueryHistoricalTradeRecordsResponse(QueryHistoricalTradeRecordsResponse&& from) noexcept
    : QueryHistoricalTradeRecordsResponse() {
    *this = ::std::move(from);
  }

  inline QueryHistoricalTradeRecordsResponse& operator=(const QueryHistoricalTradeRecordsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryHistoricalTradeRecordsResponse& operator=(QueryHistoricalTradeRecordsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryHistoricalTradeRecordsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryHistoricalTradeRecordsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryHistoricalTradeRecordsResponse*>(
               &_QueryHistoricalTradeRecordsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(QueryHistoricalTradeRecordsResponse& a, QueryHistoricalTradeRecordsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryHistoricalTradeRecordsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryHistoricalTradeRecordsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryHistoricalTradeRecordsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryHistoricalTradeRecordsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryHistoricalTradeRecordsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryHistoricalTradeRecordsResponse& from) {
    QueryHistoricalTradeRecordsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryHistoricalTradeRecordsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse";
  }
  protected:
  explicit QueryHistoricalTradeRecordsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradeRecordsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TradeRecords trade_records = 1 [json_name = "tradeRecords"];
  int trade_records_size() const;
  private:
  int _internal_trade_records_size() const;

  public:
  void clear_trade_records() ;
  ::injective::exchange::v1beta1::TradeRecords* mutable_trade_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecords >*
      mutable_trade_records();
  private:
  const ::injective::exchange::v1beta1::TradeRecords& _internal_trade_records(int index) const;
  ::injective::exchange::v1beta1::TradeRecords* _internal_add_trade_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecords>& _internal_trade_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecords>* _internal_mutable_trade_records();
  public:
  const ::injective::exchange::v1beta1::TradeRecords& trade_records(int index) const;
  ::injective::exchange::v1beta1::TradeRecords* add_trade_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecords >&
      trade_records() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecords > trade_records_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class TradeHistoryOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TradeHistoryOptions) */ {
 public:
  inline TradeHistoryOptions() : TradeHistoryOptions(nullptr) {}
  ~TradeHistoryOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeHistoryOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradeHistoryOptions(const TradeHistoryOptions& from);
  TradeHistoryOptions(TradeHistoryOptions&& from) noexcept
    : TradeHistoryOptions() {
    *this = ::std::move(from);
  }

  inline TradeHistoryOptions& operator=(const TradeHistoryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeHistoryOptions& operator=(TradeHistoryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeHistoryOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeHistoryOptions* internal_default_instance() {
    return reinterpret_cast<const TradeHistoryOptions*>(
               &_TradeHistoryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(TradeHistoryOptions& a, TradeHistoryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeHistoryOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeHistoryOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeHistoryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeHistoryOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradeHistoryOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradeHistoryOptions& from) {
    TradeHistoryOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeHistoryOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TradeHistoryOptions";
  }
  protected:
  explicit TradeHistoryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradeGroupingSecFieldNumber = 1,
    kMaxAgeFieldNumber = 2,
    kIncludeRawHistoryFieldNumber = 4,
    kIncludeMetadataFieldNumber = 5,
  };
  // uint64 trade_grouping_sec = 1 [json_name = "tradeGroupingSec"];
  void clear_trade_grouping_sec() ;
  ::uint64_t trade_grouping_sec() const;
  void set_trade_grouping_sec(::uint64_t value);

  private:
  ::uint64_t _internal_trade_grouping_sec() const;
  void _internal_set_trade_grouping_sec(::uint64_t value);

  public:
  // uint64 max_age = 2 [json_name = "maxAge"];
  void clear_max_age() ;
  ::uint64_t max_age() const;
  void set_max_age(::uint64_t value);

  private:
  ::uint64_t _internal_max_age() const;
  void _internal_set_max_age(::uint64_t value);

  public:
  // bool include_raw_history = 4 [json_name = "includeRawHistory"];
  void clear_include_raw_history() ;
  bool include_raw_history() const;
  void set_include_raw_history(bool value);

  private:
  bool _internal_include_raw_history() const;
  void _internal_set_include_raw_history(bool value);

  public:
  // bool include_metadata = 5 [json_name = "includeMetadata"];
  void clear_include_metadata() ;
  bool include_metadata() const;
  void set_include_metadata(bool value);

  private:
  bool _internal_include_metadata() const;
  void _internal_set_include_metadata(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TradeHistoryOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t trade_grouping_sec_;
    ::uint64_t max_age_;
    bool include_raw_history_;
    bool include_metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryMarketVolatilityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryMarketVolatilityRequest) */ {
 public:
  inline QueryMarketVolatilityRequest() : QueryMarketVolatilityRequest(nullptr) {}
  ~QueryMarketVolatilityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryMarketVolatilityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMarketVolatilityRequest(const QueryMarketVolatilityRequest& from);
  QueryMarketVolatilityRequest(QueryMarketVolatilityRequest&& from) noexcept
    : QueryMarketVolatilityRequest() {
    *this = ::std::move(from);
  }

  inline QueryMarketVolatilityRequest& operator=(const QueryMarketVolatilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMarketVolatilityRequest& operator=(QueryMarketVolatilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMarketVolatilityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMarketVolatilityRequest* internal_default_instance() {
    return reinterpret_cast<const QueryMarketVolatilityRequest*>(
               &_QueryMarketVolatilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(QueryMarketVolatilityRequest& a, QueryMarketVolatilityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMarketVolatilityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMarketVolatilityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMarketVolatilityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMarketVolatilityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMarketVolatilityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMarketVolatilityRequest& from) {
    QueryMarketVolatilityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMarketVolatilityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryMarketVolatilityRequest";
  }
  protected:
  explicit QueryMarketVolatilityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kTradeHistoryOptionsFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective.exchange.v1beta1.TradeHistoryOptions trade_history_options = 2 [json_name = "tradeHistoryOptions"];
  bool has_trade_history_options() const;
  void clear_trade_history_options() ;
  const ::injective::exchange::v1beta1::TradeHistoryOptions& trade_history_options() const;
  PROTOBUF_NODISCARD ::injective::exchange::v1beta1::TradeHistoryOptions* release_trade_history_options();
  ::injective::exchange::v1beta1::TradeHistoryOptions* mutable_trade_history_options();
  void set_allocated_trade_history_options(::injective::exchange::v1beta1::TradeHistoryOptions* trade_history_options);
  private:
  const ::injective::exchange::v1beta1::TradeHistoryOptions& _internal_trade_history_options() const;
  ::injective::exchange::v1beta1::TradeHistoryOptions* _internal_mutable_trade_history_options();
  public:
  void unsafe_arena_set_allocated_trade_history_options(
      ::injective::exchange::v1beta1::TradeHistoryOptions* trade_history_options);
  ::injective::exchange::v1beta1::TradeHistoryOptions* unsafe_arena_release_trade_history_options();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryMarketVolatilityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective::exchange::v1beta1::TradeHistoryOptions* trade_history_options_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryMarketVolatilityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryMarketVolatilityResponse) */ {
 public:
  inline QueryMarketVolatilityResponse() : QueryMarketVolatilityResponse(nullptr) {}
  ~QueryMarketVolatilityResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryMarketVolatilityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMarketVolatilityResponse(const QueryMarketVolatilityResponse& from);
  QueryMarketVolatilityResponse(QueryMarketVolatilityResponse&& from) noexcept
    : QueryMarketVolatilityResponse() {
    *this = ::std::move(from);
  }

  inline QueryMarketVolatilityResponse& operator=(const QueryMarketVolatilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMarketVolatilityResponse& operator=(QueryMarketVolatilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMarketVolatilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMarketVolatilityResponse* internal_default_instance() {
    return reinterpret_cast<const QueryMarketVolatilityResponse*>(
               &_QueryMarketVolatilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(QueryMarketVolatilityResponse& a, QueryMarketVolatilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMarketVolatilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMarketVolatilityResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMarketVolatilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMarketVolatilityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMarketVolatilityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMarketVolatilityResponse& from) {
    QueryMarketVolatilityResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMarketVolatilityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryMarketVolatilityResponse";
  }
  protected:
  explicit QueryMarketVolatilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawHistoryFieldNumber = 3,
    kVolatilityFieldNumber = 1,
    kHistoryMetadataFieldNumber = 2,
  };
  // repeated .injective.exchange.v1beta1.TradeRecord raw_history = 3 [json_name = "rawHistory"];
  int raw_history_size() const;
  private:
  int _internal_raw_history_size() const;

  public:
  void clear_raw_history() ;
  ::injective::exchange::v1beta1::TradeRecord* mutable_raw_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >*
      mutable_raw_history();
  private:
  const ::injective::exchange::v1beta1::TradeRecord& _internal_raw_history(int index) const;
  ::injective::exchange::v1beta1::TradeRecord* _internal_add_raw_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>& _internal_raw_history() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>* _internal_mutable_raw_history();
  public:
  const ::injective::exchange::v1beta1::TradeRecord& raw_history(int index) const;
  ::injective::exchange::v1beta1::TradeRecord* add_raw_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >&
      raw_history() const;
  // string volatility = 1 [json_name = "volatility", (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_volatility() ;
  const std::string& volatility() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volatility(Arg_&& arg, Args_... args);
  std::string* mutable_volatility();
  PROTOBUF_NODISCARD std::string* release_volatility();
  void set_allocated_volatility(std::string* ptr);

  private:
  const std::string& _internal_volatility() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volatility(
      const std::string& value);
  std::string* _internal_mutable_volatility();

  public:
  // .injective.oracle.v1beta1.MetadataStatistics history_metadata = 2 [json_name = "historyMetadata"];
  bool has_history_metadata() const;
  void clear_history_metadata() ;
  const ::injective::oracle::v1beta1::MetadataStatistics& history_metadata() const;
  PROTOBUF_NODISCARD ::injective::oracle::v1beta1::MetadataStatistics* release_history_metadata();
  ::injective::oracle::v1beta1::MetadataStatistics* mutable_history_metadata();
  void set_allocated_history_metadata(::injective::oracle::v1beta1::MetadataStatistics* history_metadata);
  private:
  const ::injective::oracle::v1beta1::MetadataStatistics& _internal_history_metadata() const;
  ::injective::oracle::v1beta1::MetadataStatistics* _internal_mutable_history_metadata();
  public:
  void unsafe_arena_set_allocated_history_metadata(
      ::injective::oracle::v1beta1::MetadataStatistics* history_metadata);
  ::injective::oracle::v1beta1::MetadataStatistics* unsafe_arena_release_history_metadata();
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryMarketVolatilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord > raw_history_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volatility_;
    ::injective::oracle::v1beta1::MetadataStatistics* history_metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBinaryMarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryBinaryMarketsRequest) */ {
 public:
  inline QueryBinaryMarketsRequest() : QueryBinaryMarketsRequest(nullptr) {}
  ~QueryBinaryMarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBinaryMarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBinaryMarketsRequest(const QueryBinaryMarketsRequest& from);
  QueryBinaryMarketsRequest(QueryBinaryMarketsRequest&& from) noexcept
    : QueryBinaryMarketsRequest() {
    *this = ::std::move(from);
  }

  inline QueryBinaryMarketsRequest& operator=(const QueryBinaryMarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBinaryMarketsRequest& operator=(QueryBinaryMarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBinaryMarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBinaryMarketsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryBinaryMarketsRequest*>(
               &_QueryBinaryMarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(QueryBinaryMarketsRequest& a, QueryBinaryMarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBinaryMarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBinaryMarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBinaryMarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBinaryMarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBinaryMarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBinaryMarketsRequest& from) {
    QueryBinaryMarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBinaryMarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryBinaryMarketsRequest";
  }
  protected:
  explicit QueryBinaryMarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryBinaryMarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryBinaryMarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryBinaryMarketsResponse) */ {
 public:
  inline QueryBinaryMarketsResponse() : QueryBinaryMarketsResponse(nullptr) {}
  ~QueryBinaryMarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryBinaryMarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryBinaryMarketsResponse(const QueryBinaryMarketsResponse& from);
  QueryBinaryMarketsResponse(QueryBinaryMarketsResponse&& from) noexcept
    : QueryBinaryMarketsResponse() {
    *this = ::std::move(from);
  }

  inline QueryBinaryMarketsResponse& operator=(const QueryBinaryMarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryBinaryMarketsResponse& operator=(QueryBinaryMarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryBinaryMarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryBinaryMarketsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryBinaryMarketsResponse*>(
               &_QueryBinaryMarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(QueryBinaryMarketsResponse& a, QueryBinaryMarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryBinaryMarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryBinaryMarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryBinaryMarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryBinaryMarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryBinaryMarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryBinaryMarketsResponse& from) {
    QueryBinaryMarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryBinaryMarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryBinaryMarketsResponse";
  }
  protected:
  explicit QueryBinaryMarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketsFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.BinaryOptionsMarket markets = 1 [json_name = "markets"];
  int markets_size() const;
  private:
  int _internal_markets_size() const;

  public:
  void clear_markets() ;
  ::injective::exchange::v1beta1::BinaryOptionsMarket* mutable_markets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarket >*
      mutable_markets();
  private:
  const ::injective::exchange::v1beta1::BinaryOptionsMarket& _internal_markets(int index) const;
  ::injective::exchange::v1beta1::BinaryOptionsMarket* _internal_add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarket>& _internal_markets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarket>* _internal_mutable_markets();
  public:
  const ::injective::exchange::v1beta1::BinaryOptionsMarket& markets(int index) const;
  ::injective::exchange::v1beta1::BinaryOptionsMarket* add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarket >&
      markets() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryBinaryMarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarket > markets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderDerivativeConditionalOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest) */ {
 public:
  inline QueryTraderDerivativeConditionalOrdersRequest() : QueryTraderDerivativeConditionalOrdersRequest(nullptr) {}
  ~QueryTraderDerivativeConditionalOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderDerivativeConditionalOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderDerivativeConditionalOrdersRequest(const QueryTraderDerivativeConditionalOrdersRequest& from);
  QueryTraderDerivativeConditionalOrdersRequest(QueryTraderDerivativeConditionalOrdersRequest&& from) noexcept
    : QueryTraderDerivativeConditionalOrdersRequest() {
    *this = ::std::move(from);
  }

  inline QueryTraderDerivativeConditionalOrdersRequest& operator=(const QueryTraderDerivativeConditionalOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderDerivativeConditionalOrdersRequest& operator=(QueryTraderDerivativeConditionalOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderDerivativeConditionalOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderDerivativeConditionalOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTraderDerivativeConditionalOrdersRequest*>(
               &_QueryTraderDerivativeConditionalOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(QueryTraderDerivativeConditionalOrdersRequest& a, QueryTraderDerivativeConditionalOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderDerivativeConditionalOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderDerivativeConditionalOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderDerivativeConditionalOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderDerivativeConditionalOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderDerivativeConditionalOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderDerivativeConditionalOrdersRequest& from) {
    QueryTraderDerivativeConditionalOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderDerivativeConditionalOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest";
  }
  protected:
  explicit QueryTraderDerivativeConditionalOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class TrimmedDerivativeConditionalOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder) */ {
 public:
  inline TrimmedDerivativeConditionalOrder() : TrimmedDerivativeConditionalOrder(nullptr) {}
  ~TrimmedDerivativeConditionalOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrimmedDerivativeConditionalOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrimmedDerivativeConditionalOrder(const TrimmedDerivativeConditionalOrder& from);
  TrimmedDerivativeConditionalOrder(TrimmedDerivativeConditionalOrder&& from) noexcept
    : TrimmedDerivativeConditionalOrder() {
    *this = ::std::move(from);
  }

  inline TrimmedDerivativeConditionalOrder& operator=(const TrimmedDerivativeConditionalOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrimmedDerivativeConditionalOrder& operator=(TrimmedDerivativeConditionalOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrimmedDerivativeConditionalOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrimmedDerivativeConditionalOrder* internal_default_instance() {
    return reinterpret_cast<const TrimmedDerivativeConditionalOrder*>(
               &_TrimmedDerivativeConditionalOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(TrimmedDerivativeConditionalOrder& a, TrimmedDerivativeConditionalOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(TrimmedDerivativeConditionalOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrimmedDerivativeConditionalOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrimmedDerivativeConditionalOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrimmedDerivativeConditionalOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrimmedDerivativeConditionalOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrimmedDerivativeConditionalOrder& from) {
    TrimmedDerivativeConditionalOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrimmedDerivativeConditionalOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder";
  }
  protected:
  explicit TrimmedDerivativeConditionalOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kMarginFieldNumber = 3,
    kTriggerPriceFieldNumber = 4,
    kOrderHashFieldNumber = 7,
    kIsBuyFieldNumber = 5,
    kIsLimitFieldNumber = 6,
  };
  // string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string triggerPrice = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_triggerprice() ;
  const std::string& triggerprice() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_triggerprice(Arg_&& arg, Args_... args);
  std::string* mutable_triggerprice();
  PROTOBUF_NODISCARD std::string* release_triggerprice();
  void set_allocated_triggerprice(std::string* ptr);

  private:
  const std::string& _internal_triggerprice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triggerprice(
      const std::string& value);
  std::string* _internal_mutable_triggerprice();

  public:
  // string order_hash = 7 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // bool isBuy = 5 [json_name = "isBuy", (.gogoproto.jsontag) = "isBuy"];
  void clear_isbuy() ;
  bool isbuy() const;
  void set_isbuy(bool value);

  private:
  bool _internal_isbuy() const;
  void _internal_set_isbuy(bool value);

  public:
  // bool isLimit = 6 [json_name = "isLimit", (.gogoproto.jsontag) = "isLimit"];
  void clear_islimit() ;
  bool islimit() const;
  void set_islimit(bool value);

  private:
  bool _internal_islimit() const;
  void _internal_set_islimit(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr triggerprice_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    bool isbuy_;
    bool islimit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryTraderDerivativeConditionalOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse) */ {
 public:
  inline QueryTraderDerivativeConditionalOrdersResponse() : QueryTraderDerivativeConditionalOrdersResponse(nullptr) {}
  ~QueryTraderDerivativeConditionalOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryTraderDerivativeConditionalOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTraderDerivativeConditionalOrdersResponse(const QueryTraderDerivativeConditionalOrdersResponse& from);
  QueryTraderDerivativeConditionalOrdersResponse(QueryTraderDerivativeConditionalOrdersResponse&& from) noexcept
    : QueryTraderDerivativeConditionalOrdersResponse() {
    *this = ::std::move(from);
  }

  inline QueryTraderDerivativeConditionalOrdersResponse& operator=(const QueryTraderDerivativeConditionalOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTraderDerivativeConditionalOrdersResponse& operator=(QueryTraderDerivativeConditionalOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTraderDerivativeConditionalOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTraderDerivativeConditionalOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTraderDerivativeConditionalOrdersResponse*>(
               &_QueryTraderDerivativeConditionalOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(QueryTraderDerivativeConditionalOrdersResponse& a, QueryTraderDerivativeConditionalOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTraderDerivativeConditionalOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTraderDerivativeConditionalOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTraderDerivativeConditionalOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTraderDerivativeConditionalOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTraderDerivativeConditionalOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTraderDerivativeConditionalOrdersResponse& from) {
    QueryTraderDerivativeConditionalOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTraderDerivativeConditionalOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse";
  }
  protected:
  explicit QueryTraderDerivativeConditionalOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder >*
      mutable_orders();
  private:
  const ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder& _internal_orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder>* _internal_mutable_orders();
  public:
  const ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder& orders(int index) const;
  ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder >&
      orders() const;
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder > orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryMarketAtomicExecutionFeeMultiplierRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest) */ {
 public:
  inline QueryMarketAtomicExecutionFeeMultiplierRequest() : QueryMarketAtomicExecutionFeeMultiplierRequest(nullptr) {}
  ~QueryMarketAtomicExecutionFeeMultiplierRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryMarketAtomicExecutionFeeMultiplierRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMarketAtomicExecutionFeeMultiplierRequest(const QueryMarketAtomicExecutionFeeMultiplierRequest& from);
  QueryMarketAtomicExecutionFeeMultiplierRequest(QueryMarketAtomicExecutionFeeMultiplierRequest&& from) noexcept
    : QueryMarketAtomicExecutionFeeMultiplierRequest() {
    *this = ::std::move(from);
  }

  inline QueryMarketAtomicExecutionFeeMultiplierRequest& operator=(const QueryMarketAtomicExecutionFeeMultiplierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMarketAtomicExecutionFeeMultiplierRequest& operator=(QueryMarketAtomicExecutionFeeMultiplierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMarketAtomicExecutionFeeMultiplierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMarketAtomicExecutionFeeMultiplierRequest* internal_default_instance() {
    return reinterpret_cast<const QueryMarketAtomicExecutionFeeMultiplierRequest*>(
               &_QueryMarketAtomicExecutionFeeMultiplierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(QueryMarketAtomicExecutionFeeMultiplierRequest& a, QueryMarketAtomicExecutionFeeMultiplierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMarketAtomicExecutionFeeMultiplierRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMarketAtomicExecutionFeeMultiplierRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMarketAtomicExecutionFeeMultiplierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMarketAtomicExecutionFeeMultiplierRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMarketAtomicExecutionFeeMultiplierRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMarketAtomicExecutionFeeMultiplierRequest& from) {
    QueryMarketAtomicExecutionFeeMultiplierRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMarketAtomicExecutionFeeMultiplierRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest";
  }
  protected:
  explicit QueryMarketAtomicExecutionFeeMultiplierRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};// -------------------------------------------------------------------

class QueryMarketAtomicExecutionFeeMultiplierResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse) */ {
 public:
  inline QueryMarketAtomicExecutionFeeMultiplierResponse() : QueryMarketAtomicExecutionFeeMultiplierResponse(nullptr) {}
  ~QueryMarketAtomicExecutionFeeMultiplierResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryMarketAtomicExecutionFeeMultiplierResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMarketAtomicExecutionFeeMultiplierResponse(const QueryMarketAtomicExecutionFeeMultiplierResponse& from);
  QueryMarketAtomicExecutionFeeMultiplierResponse(QueryMarketAtomicExecutionFeeMultiplierResponse&& from) noexcept
    : QueryMarketAtomicExecutionFeeMultiplierResponse() {
    *this = ::std::move(from);
  }

  inline QueryMarketAtomicExecutionFeeMultiplierResponse& operator=(const QueryMarketAtomicExecutionFeeMultiplierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMarketAtomicExecutionFeeMultiplierResponse& operator=(QueryMarketAtomicExecutionFeeMultiplierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMarketAtomicExecutionFeeMultiplierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMarketAtomicExecutionFeeMultiplierResponse* internal_default_instance() {
    return reinterpret_cast<const QueryMarketAtomicExecutionFeeMultiplierResponse*>(
               &_QueryMarketAtomicExecutionFeeMultiplierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(QueryMarketAtomicExecutionFeeMultiplierResponse& a, QueryMarketAtomicExecutionFeeMultiplierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMarketAtomicExecutionFeeMultiplierResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMarketAtomicExecutionFeeMultiplierResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMarketAtomicExecutionFeeMultiplierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMarketAtomicExecutionFeeMultiplierResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMarketAtomicExecutionFeeMultiplierResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMarketAtomicExecutionFeeMultiplierResponse& from) {
    QueryMarketAtomicExecutionFeeMultiplierResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMarketAtomicExecutionFeeMultiplierResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse";
  }
  protected:
  explicit QueryMarketAtomicExecutionFeeMultiplierResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultiplierFieldNumber = 1,
  };
  // string multiplier = 1 [json_name = "multiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
  void clear_multiplier() ;
  const std::string& multiplier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_multiplier(Arg_&& arg, Args_... args);
  std::string* mutable_multiplier();
  PROTOBUF_NODISCARD std::string* release_multiplier();
  void set_allocated_multiplier(std::string* ptr);

  private:
  const std::string& _internal_multiplier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_multiplier(
      const std::string& value);
  std::string* _internal_mutable_multiplier();

  public:
  // @@protoc_insertion_point(class_scope:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multiplier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_injective_2fexchange_2fv1beta1_2fquery_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Subaccount

// string trader = 1 [json_name = "trader"];
inline void Subaccount::clear_trader() {
  _impl_.trader_.ClearToEmpty();
}
inline const std::string& Subaccount::trader() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Subaccount.trader)
  return _internal_trader();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Subaccount::set_trader(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trader_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Subaccount.trader)
}
inline std::string* Subaccount::mutable_trader() {
  std::string* _s = _internal_mutable_trader();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.Subaccount.trader)
  return _s;
}
inline const std::string& Subaccount::_internal_trader() const {
  return _impl_.trader_.Get();
}
inline void Subaccount::_internal_set_trader(const std::string& value) {
  ;


  _impl_.trader_.Set(value, GetArenaForAllocation());
}
inline std::string* Subaccount::_internal_mutable_trader() {
  ;
  return _impl_.trader_.Mutable( GetArenaForAllocation());
}
inline std::string* Subaccount::release_trader() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.Subaccount.trader)
  return _impl_.trader_.Release();
}
inline void Subaccount::set_allocated_trader(std::string* value) {
  _impl_.trader_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trader_.IsDefault()) {
          _impl_.trader_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.Subaccount.trader)
}

// uint32 subaccount_nonce = 2 [json_name = "subaccountNonce"];
inline void Subaccount::clear_subaccount_nonce() {
  _impl_.subaccount_nonce_ = 0u;
}
inline ::uint32_t Subaccount::subaccount_nonce() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.Subaccount.subaccount_nonce)
  return _internal_subaccount_nonce();
}
inline void Subaccount::set_subaccount_nonce(::uint32_t value) {
  _internal_set_subaccount_nonce(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.Subaccount.subaccount_nonce)
}
inline ::uint32_t Subaccount::_internal_subaccount_nonce() const {
  return _impl_.subaccount_nonce_;
}
inline void Subaccount::_internal_set_subaccount_nonce(::uint32_t value) {
  ;
  _impl_.subaccount_nonce_ = value;
}

// -------------------------------------------------------------------

// QuerySubaccountOrdersRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountOrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountOrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountOrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.subaccount_id)
}
inline std::string* QuerySubaccountOrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountOrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountOrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountOrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountOrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountOrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void QuerySubaccountOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.market_id)
}
inline std::string* QuerySubaccountOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.market_id)
  return _s;
}
inline const std::string& QuerySubaccountOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QuerySubaccountOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QuerySubaccountOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountOrdersRequest.market_id)
}

// -------------------------------------------------------------------

// QuerySubaccountOrdersResponse

// repeated .injective.exchange.v1beta1.SubaccountOrderData buy_orders = 1 [json_name = "buyOrders"];
inline int QuerySubaccountOrdersResponse::_internal_buy_orders_size() const {
  return _impl_.buy_orders_.size();
}
inline int QuerySubaccountOrdersResponse::buy_orders_size() const {
  return _internal_buy_orders_size();
}
inline ::injective::exchange::v1beta1::SubaccountOrderData* QuerySubaccountOrdersResponse::mutable_buy_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.buy_orders)
  return _internal_mutable_buy_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >*
QuerySubaccountOrdersResponse::mutable_buy_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.buy_orders)
  return _internal_mutable_buy_orders();
}
inline const ::injective::exchange::v1beta1::SubaccountOrderData& QuerySubaccountOrdersResponse::_internal_buy_orders(int index) const {
  return _internal_buy_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::SubaccountOrderData& QuerySubaccountOrdersResponse::buy_orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.buy_orders)
  return _internal_buy_orders(index);
}
inline ::injective::exchange::v1beta1::SubaccountOrderData* QuerySubaccountOrdersResponse::_internal_add_buy_orders() {
  return _internal_mutable_buy_orders()->Add();
}
inline ::injective::exchange::v1beta1::SubaccountOrderData* QuerySubaccountOrdersResponse::add_buy_orders() {
  ::injective::exchange::v1beta1::SubaccountOrderData* _add = _internal_add_buy_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.buy_orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >&
QuerySubaccountOrdersResponse::buy_orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.buy_orders)
  return _internal_buy_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>&
QuerySubaccountOrdersResponse::_internal_buy_orders() const {
  return _impl_.buy_orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>*
QuerySubaccountOrdersResponse::_internal_mutable_buy_orders() {
  return &_impl_.buy_orders_;
}

// repeated .injective.exchange.v1beta1.SubaccountOrderData sell_orders = 2 [json_name = "sellOrders"];
inline int QuerySubaccountOrdersResponse::_internal_sell_orders_size() const {
  return _impl_.sell_orders_.size();
}
inline int QuerySubaccountOrdersResponse::sell_orders_size() const {
  return _internal_sell_orders_size();
}
inline ::injective::exchange::v1beta1::SubaccountOrderData* QuerySubaccountOrdersResponse::mutable_sell_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.sell_orders)
  return _internal_mutable_sell_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >*
QuerySubaccountOrdersResponse::mutable_sell_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.sell_orders)
  return _internal_mutable_sell_orders();
}
inline const ::injective::exchange::v1beta1::SubaccountOrderData& QuerySubaccountOrdersResponse::_internal_sell_orders(int index) const {
  return _internal_sell_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::SubaccountOrderData& QuerySubaccountOrdersResponse::sell_orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.sell_orders)
  return _internal_sell_orders(index);
}
inline ::injective::exchange::v1beta1::SubaccountOrderData* QuerySubaccountOrdersResponse::_internal_add_sell_orders() {
  return _internal_mutable_sell_orders()->Add();
}
inline ::injective::exchange::v1beta1::SubaccountOrderData* QuerySubaccountOrdersResponse::add_sell_orders() {
  ::injective::exchange::v1beta1::SubaccountOrderData* _add = _internal_add_sell_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.sell_orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderData >&
QuerySubaccountOrdersResponse::sell_orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySubaccountOrdersResponse.sell_orders)
  return _internal_sell_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>&
QuerySubaccountOrdersResponse::_internal_sell_orders() const {
  return _impl_.sell_orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderData>*
QuerySubaccountOrdersResponse::_internal_mutable_sell_orders() {
  return &_impl_.sell_orders_;
}

// -------------------------------------------------------------------

// SubaccountOrderbookMetadataWithMarket

// .injective.exchange.v1beta1.SubaccountOrderbookMetadata metadata = 1 [json_name = "metadata"];
inline bool SubaccountOrderbookMetadataWithMarket::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::SubaccountOrderbookMetadata& SubaccountOrderbookMetadataWithMarket::_internal_metadata() const {
  const ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SubaccountOrderbookMetadata&>(
      ::injective::exchange::v1beta1::_SubaccountOrderbookMetadata_default_instance_);
}
inline const ::injective::exchange::v1beta1::SubaccountOrderbookMetadata& SubaccountOrderbookMetadataWithMarket::metadata() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.metadata)
  return _internal_metadata();
}
inline void SubaccountOrderbookMetadataWithMarket::unsafe_arena_set_allocated_metadata(
    ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.metadata)
}
inline ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* SubaccountOrderbookMetadataWithMarket::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* SubaccountOrderbookMetadataWithMarket::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* SubaccountOrderbookMetadataWithMarket::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SubaccountOrderbookMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* SubaccountOrderbookMetadataWithMarket::mutable_metadata() {
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.metadata)
  return _msg;
}
inline void SubaccountOrderbookMetadataWithMarket::set_allocated_metadata(::injective::exchange::v1beta1::SubaccountOrderbookMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.metadata)
}

// string market_id = 2 [json_name = "marketId"];
inline void SubaccountOrderbookMetadataWithMarket::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SubaccountOrderbookMetadataWithMarket::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrderbookMetadataWithMarket::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.market_id)
}
inline std::string* SubaccountOrderbookMetadataWithMarket::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.market_id)
  return _s;
}
inline const std::string& SubaccountOrderbookMetadataWithMarket::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SubaccountOrderbookMetadataWithMarket::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrderbookMetadataWithMarket::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrderbookMetadataWithMarket::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.market_id)
  return _impl_.market_id_.Release();
}
inline void SubaccountOrderbookMetadataWithMarket::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.market_id)
}

// bool isBuy = 3 [json_name = "isBuy"];
inline void SubaccountOrderbookMetadataWithMarket::clear_isbuy() {
  _impl_.isbuy_ = false;
}
inline bool SubaccountOrderbookMetadataWithMarket::isbuy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.isBuy)
  return _internal_isbuy();
}
inline void SubaccountOrderbookMetadataWithMarket::set_isbuy(bool value) {
  _internal_set_isbuy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket.isBuy)
}
inline bool SubaccountOrderbookMetadataWithMarket::_internal_isbuy() const {
  return _impl_.isbuy_;
}
inline void SubaccountOrderbookMetadataWithMarket::_internal_set_isbuy(bool value) {
  ;
  _impl_.isbuy_ = value;
}

// -------------------------------------------------------------------

// QueryExchangeParamsRequest

// -------------------------------------------------------------------

// QueryExchangeParamsResponse

// .injective.exchange.v1beta1.Params params = 1 [json_name = "params", (.gogoproto.nullable) = false];
inline bool QueryExchangeParamsResponse::has_params() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.params_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::Params& QueryExchangeParamsResponse::_internal_params() const {
  const ::injective::exchange::v1beta1::Params* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Params&>(
      ::injective::exchange::v1beta1::_Params_default_instance_);
}
inline const ::injective::exchange::v1beta1::Params& QueryExchangeParamsResponse::params() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryExchangeParamsResponse.params)
  return _internal_params();
}
inline void QueryExchangeParamsResponse::unsafe_arena_set_allocated_params(
    ::injective::exchange::v1beta1::Params* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryExchangeParamsResponse.params)
}
inline ::injective::exchange::v1beta1::Params* QueryExchangeParamsResponse::release_params() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Params* QueryExchangeParamsResponse::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryExchangeParamsResponse.params)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Params* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Params* QueryExchangeParamsResponse::_internal_mutable_params() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Params>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::injective::exchange::v1beta1::Params* QueryExchangeParamsResponse::mutable_params() {
  ::injective::exchange::v1beta1::Params* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryExchangeParamsResponse.params)
  return _msg;
}
inline void QueryExchangeParamsResponse::set_allocated_params(::injective::exchange::v1beta1::Params* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryExchangeParamsResponse.params)
}

// -------------------------------------------------------------------

// QuerySubaccountDepositsRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountDepositsRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountDepositsRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountDepositsRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount_id)
}
inline std::string* QuerySubaccountDepositsRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountDepositsRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountDepositsRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountDepositsRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountDepositsRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountDepositsRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount_id)
}

// .injective.exchange.v1beta1.Subaccount subaccount = 2 [json_name = "subaccount", (.gogoproto.nullable) = true];
inline bool QuerySubaccountDepositsRequest::has_subaccount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subaccount_ != nullptr);
  return value;
}
inline void QuerySubaccountDepositsRequest::clear_subaccount() {
  if (_impl_.subaccount_ != nullptr) _impl_.subaccount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::Subaccount& QuerySubaccountDepositsRequest::_internal_subaccount() const {
  const ::injective::exchange::v1beta1::Subaccount* p = _impl_.subaccount_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Subaccount&>(
      ::injective::exchange::v1beta1::_Subaccount_default_instance_);
}
inline const ::injective::exchange::v1beta1::Subaccount& QuerySubaccountDepositsRequest::subaccount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount)
  return _internal_subaccount();
}
inline void QuerySubaccountDepositsRequest::unsafe_arena_set_allocated_subaccount(
    ::injective::exchange::v1beta1::Subaccount* subaccount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subaccount_);
  }
  _impl_.subaccount_ = subaccount;
  if (subaccount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount)
}
inline ::injective::exchange::v1beta1::Subaccount* QuerySubaccountDepositsRequest::release_subaccount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Subaccount* temp = _impl_.subaccount_;
  _impl_.subaccount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Subaccount* QuerySubaccountDepositsRequest::unsafe_arena_release_subaccount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Subaccount* temp = _impl_.subaccount_;
  _impl_.subaccount_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Subaccount* QuerySubaccountDepositsRequest::_internal_mutable_subaccount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.subaccount_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Subaccount>(GetArenaForAllocation());
    _impl_.subaccount_ = p;
  }
  return _impl_.subaccount_;
}
inline ::injective::exchange::v1beta1::Subaccount* QuerySubaccountDepositsRequest::mutable_subaccount() {
  ::injective::exchange::v1beta1::Subaccount* _msg = _internal_mutable_subaccount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount)
  return _msg;
}
inline void QuerySubaccountDepositsRequest::set_allocated_subaccount(::injective::exchange::v1beta1::Subaccount* subaccount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subaccount_;
  }
  if (subaccount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subaccount);
    if (message_arena != submessage_arena) {
      subaccount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subaccount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subaccount_ = subaccount;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountDepositsRequest.subaccount)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// QuerySubaccountDepositsResponse

// map<string, .injective.exchange.v1beta1.Deposit> deposits = 1 [json_name = "deposits"];
inline int QuerySubaccountDepositsResponse::_internal_deposits_size() const {
  return _impl_.deposits_.size();
}
inline int QuerySubaccountDepositsResponse::deposits_size() const {
  return _internal_deposits_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >&
QuerySubaccountDepositsResponse::_internal_deposits() const {
  return _impl_.deposits_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >&
QuerySubaccountDepositsResponse::deposits() const {
  // @@protoc_insertion_point(field_map:injective.exchange.v1beta1.QuerySubaccountDepositsResponse.deposits)
  return _internal_deposits();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >*
QuerySubaccountDepositsResponse::_internal_mutable_deposits() {
  return _impl_.deposits_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::injective::exchange::v1beta1::Deposit >*
QuerySubaccountDepositsResponse::mutable_deposits() {
  // @@protoc_insertion_point(field_mutable_map:injective.exchange.v1beta1.QuerySubaccountDepositsResponse.deposits)
  return _internal_mutable_deposits();
}

// -------------------------------------------------------------------

// QueryExchangeBalancesRequest

// -------------------------------------------------------------------

// QueryExchangeBalancesResponse

// repeated .injective.exchange.v1beta1.Balance balances = 1 [json_name = "balances", (.gogoproto.nullable) = false];
inline int QueryExchangeBalancesResponse::_internal_balances_size() const {
  return _impl_.balances_.size();
}
inline int QueryExchangeBalancesResponse::balances_size() const {
  return _internal_balances_size();
}
inline ::injective::exchange::v1beta1::Balance* QueryExchangeBalancesResponse::mutable_balances(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryExchangeBalancesResponse.balances)
  return _internal_mutable_balances()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Balance >*
QueryExchangeBalancesResponse::mutable_balances() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryExchangeBalancesResponse.balances)
  return _internal_mutable_balances();
}
inline const ::injective::exchange::v1beta1::Balance& QueryExchangeBalancesResponse::_internal_balances(int index) const {
  return _internal_balances().Get(index);
}
inline const ::injective::exchange::v1beta1::Balance& QueryExchangeBalancesResponse::balances(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryExchangeBalancesResponse.balances)
  return _internal_balances(index);
}
inline ::injective::exchange::v1beta1::Balance* QueryExchangeBalancesResponse::_internal_add_balances() {
  return _internal_mutable_balances()->Add();
}
inline ::injective::exchange::v1beta1::Balance* QueryExchangeBalancesResponse::add_balances() {
  ::injective::exchange::v1beta1::Balance* _add = _internal_add_balances();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryExchangeBalancesResponse.balances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Balance >&
QueryExchangeBalancesResponse::balances() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryExchangeBalancesResponse.balances)
  return _internal_balances();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Balance>&
QueryExchangeBalancesResponse::_internal_balances() const {
  return _impl_.balances_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Balance>*
QueryExchangeBalancesResponse::_internal_mutable_balances() {
  return &_impl_.balances_;
}

// -------------------------------------------------------------------

// QueryAggregateVolumeRequest

// string account = 1 [json_name = "account"];
inline void QueryAggregateVolumeRequest::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& QueryAggregateVolumeRequest::account() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateVolumeRequest.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAggregateVolumeRequest::set_account(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateVolumeRequest.account)
}
inline std::string* QueryAggregateVolumeRequest::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateVolumeRequest.account)
  return _s;
}
inline const std::string& QueryAggregateVolumeRequest::_internal_account() const {
  return _impl_.account_.Get();
}
inline void QueryAggregateVolumeRequest::_internal_set_account(const std::string& value) {
  ;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAggregateVolumeRequest::_internal_mutable_account() {
  ;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryAggregateVolumeRequest::release_account() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryAggregateVolumeRequest.account)
  return _impl_.account_.Release();
}
inline void QueryAggregateVolumeRequest::set_allocated_account(std::string* value) {
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryAggregateVolumeRequest.account)
}

// -------------------------------------------------------------------

// QueryAggregateVolumeResponse

// repeated .injective.exchange.v1beta1.MarketVolume aggregate_volumes = 1 [json_name = "aggregateVolumes"];
inline int QueryAggregateVolumeResponse::_internal_aggregate_volumes_size() const {
  return _impl_.aggregate_volumes_.size();
}
inline int QueryAggregateVolumeResponse::aggregate_volumes_size() const {
  return _internal_aggregate_volumes_size();
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateVolumeResponse::mutable_aggregate_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateVolumeResponse.aggregate_volumes)
  return _internal_mutable_aggregate_volumes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
QueryAggregateVolumeResponse::mutable_aggregate_volumes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAggregateVolumeResponse.aggregate_volumes)
  return _internal_mutable_aggregate_volumes();
}
inline const ::injective::exchange::v1beta1::MarketVolume& QueryAggregateVolumeResponse::_internal_aggregate_volumes(int index) const {
  return _internal_aggregate_volumes().Get(index);
}
inline const ::injective::exchange::v1beta1::MarketVolume& QueryAggregateVolumeResponse::aggregate_volumes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateVolumeResponse.aggregate_volumes)
  return _internal_aggregate_volumes(index);
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateVolumeResponse::_internal_add_aggregate_volumes() {
  return _internal_mutable_aggregate_volumes()->Add();
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateVolumeResponse::add_aggregate_volumes() {
  ::injective::exchange::v1beta1::MarketVolume* _add = _internal_add_aggregate_volumes();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateVolumeResponse.aggregate_volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
QueryAggregateVolumeResponse::aggregate_volumes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAggregateVolumeResponse.aggregate_volumes)
  return _internal_aggregate_volumes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>&
QueryAggregateVolumeResponse::_internal_aggregate_volumes() const {
  return _impl_.aggregate_volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>*
QueryAggregateVolumeResponse::_internal_mutable_aggregate_volumes() {
  return &_impl_.aggregate_volumes_;
}

// -------------------------------------------------------------------

// QueryAggregateVolumesRequest

// repeated string accounts = 1 [json_name = "accounts"];
inline int QueryAggregateVolumesRequest::_internal_accounts_size() const {
  return _impl_.accounts_.size();
}
inline int QueryAggregateVolumesRequest::accounts_size() const {
  return _internal_accounts_size();
}
inline void QueryAggregateVolumesRequest::clear_accounts() {
  _internal_mutable_accounts()->Clear();
}
inline std::string* QueryAggregateVolumesRequest::add_accounts() {
  std::string* _s = _internal_add_accounts();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
  return _s;
}
inline const std::string& QueryAggregateVolumesRequest::accounts(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
  return _internal_accounts(index);
}
inline std::string* QueryAggregateVolumesRequest::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
  return _internal_mutable_accounts()->Mutable(index);
}
inline void QueryAggregateVolumesRequest::set_accounts(int index, const std::string& value) {
  _internal_mutable_accounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::set_accounts(int index, std::string&& value) {
  _internal_mutable_accounts()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::set_accounts(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_accounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::set_accounts(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_accounts()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::set_accounts(int index, absl::string_view value) {
  _internal_mutable_accounts()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::add_accounts(const std::string& value) {
  _internal_mutable_accounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::add_accounts(std::string&& value) {
  _internal_mutable_accounts()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::add_accounts(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_accounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::add_accounts(const char* value, std::size_t size) {
  _internal_mutable_accounts()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline void QueryAggregateVolumesRequest::add_accounts(absl::string_view value) {
  _internal_mutable_accounts()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryAggregateVolumesRequest::accounts() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
  return _internal_accounts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryAggregateVolumesRequest::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAggregateVolumesRequest.accounts)
  return _internal_mutable_accounts();
}
inline const std::string& QueryAggregateVolumesRequest::_internal_accounts(int index) const {
  return _internal_accounts().Get(index);
}
inline std::string* QueryAggregateVolumesRequest::_internal_add_accounts() {
  return _internal_mutable_accounts()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryAggregateVolumesRequest::_internal_accounts() const {
  return _impl_.accounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryAggregateVolumesRequest::_internal_mutable_accounts() {
  return &_impl_.accounts_;
}

// repeated string market_ids = 2 [json_name = "marketIds"];
inline int QueryAggregateVolumesRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int QueryAggregateVolumesRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void QueryAggregateVolumesRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* QueryAggregateVolumesRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
  return _s;
}
inline const std::string& QueryAggregateVolumesRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* QueryAggregateVolumesRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void QueryAggregateVolumesRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline void QueryAggregateVolumesRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryAggregateVolumesRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryAggregateVolumesRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAggregateVolumesRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& QueryAggregateVolumesRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* QueryAggregateVolumesRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryAggregateVolumesRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryAggregateVolumesRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// QueryAggregateVolumesResponse

// repeated .injective.exchange.v1beta1.AggregateAccountVolumeRecord aggregate_account_volumes = 1 [json_name = "aggregateAccountVolumes"];
inline int QueryAggregateVolumesResponse::_internal_aggregate_account_volumes_size() const {
  return _impl_.aggregate_account_volumes_.size();
}
inline int QueryAggregateVolumesResponse::aggregate_account_volumes_size() const {
  return _internal_aggregate_account_volumes_size();
}
inline ::injective::exchange::v1beta1::AggregateAccountVolumeRecord* QueryAggregateVolumesResponse::mutable_aggregate_account_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_account_volumes)
  return _internal_mutable_aggregate_account_volumes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AggregateAccountVolumeRecord >*
QueryAggregateVolumesResponse::mutable_aggregate_account_volumes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_account_volumes)
  return _internal_mutable_aggregate_account_volumes();
}
inline const ::injective::exchange::v1beta1::AggregateAccountVolumeRecord& QueryAggregateVolumesResponse::_internal_aggregate_account_volumes(int index) const {
  return _internal_aggregate_account_volumes().Get(index);
}
inline const ::injective::exchange::v1beta1::AggregateAccountVolumeRecord& QueryAggregateVolumesResponse::aggregate_account_volumes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_account_volumes)
  return _internal_aggregate_account_volumes(index);
}
inline ::injective::exchange::v1beta1::AggregateAccountVolumeRecord* QueryAggregateVolumesResponse::_internal_add_aggregate_account_volumes() {
  return _internal_mutable_aggregate_account_volumes()->Add();
}
inline ::injective::exchange::v1beta1::AggregateAccountVolumeRecord* QueryAggregateVolumesResponse::add_aggregate_account_volumes() {
  ::injective::exchange::v1beta1::AggregateAccountVolumeRecord* _add = _internal_add_aggregate_account_volumes();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_account_volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::AggregateAccountVolumeRecord >&
QueryAggregateVolumesResponse::aggregate_account_volumes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_account_volumes)
  return _internal_aggregate_account_volumes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AggregateAccountVolumeRecord>&
QueryAggregateVolumesResponse::_internal_aggregate_account_volumes() const {
  return _impl_.aggregate_account_volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::AggregateAccountVolumeRecord>*
QueryAggregateVolumesResponse::_internal_mutable_aggregate_account_volumes() {
  return &_impl_.aggregate_account_volumes_;
}

// repeated .injective.exchange.v1beta1.MarketVolume aggregate_market_volumes = 2 [json_name = "aggregateMarketVolumes"];
inline int QueryAggregateVolumesResponse::_internal_aggregate_market_volumes_size() const {
  return _impl_.aggregate_market_volumes_.size();
}
inline int QueryAggregateVolumesResponse::aggregate_market_volumes_size() const {
  return _internal_aggregate_market_volumes_size();
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateVolumesResponse::mutable_aggregate_market_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_market_volumes)
  return _internal_mutable_aggregate_market_volumes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
QueryAggregateVolumesResponse::mutable_aggregate_market_volumes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_market_volumes)
  return _internal_mutable_aggregate_market_volumes();
}
inline const ::injective::exchange::v1beta1::MarketVolume& QueryAggregateVolumesResponse::_internal_aggregate_market_volumes(int index) const {
  return _internal_aggregate_market_volumes().Get(index);
}
inline const ::injective::exchange::v1beta1::MarketVolume& QueryAggregateVolumesResponse::aggregate_market_volumes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_market_volumes)
  return _internal_aggregate_market_volumes(index);
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateVolumesResponse::_internal_add_aggregate_market_volumes() {
  return _internal_mutable_aggregate_market_volumes()->Add();
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateVolumesResponse::add_aggregate_market_volumes() {
  ::injective::exchange::v1beta1::MarketVolume* _add = _internal_add_aggregate_market_volumes();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_market_volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
QueryAggregateVolumesResponse::aggregate_market_volumes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAggregateVolumesResponse.aggregate_market_volumes)
  return _internal_aggregate_market_volumes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>&
QueryAggregateVolumesResponse::_internal_aggregate_market_volumes() const {
  return _impl_.aggregate_market_volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>*
QueryAggregateVolumesResponse::_internal_mutable_aggregate_market_volumes() {
  return &_impl_.aggregate_market_volumes_;
}

// -------------------------------------------------------------------

// QueryAggregateMarketVolumeRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryAggregateMarketVolumeRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryAggregateMarketVolumeRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAggregateMarketVolumeRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest.market_id)
}
inline std::string* QueryAggregateMarketVolumeRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest.market_id)
  return _s;
}
inline const std::string& QueryAggregateMarketVolumeRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryAggregateMarketVolumeRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAggregateMarketVolumeRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryAggregateMarketVolumeRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryAggregateMarketVolumeRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryAggregateMarketVolumeRequest.market_id)
}

// -------------------------------------------------------------------

// QueryAggregateMarketVolumeResponse

// .injective.exchange.v1beta1.VolumeRecord volume = 1 [json_name = "volume", (.gogoproto.nullable) = false];
inline bool QueryAggregateMarketVolumeResponse::has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::VolumeRecord& QueryAggregateMarketVolumeResponse::_internal_volume() const {
  const ::injective::exchange::v1beta1::VolumeRecord* p = _impl_.volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::VolumeRecord&>(
      ::injective::exchange::v1beta1::_VolumeRecord_default_instance_);
}
inline const ::injective::exchange::v1beta1::VolumeRecord& QueryAggregateMarketVolumeResponse::volume() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse.volume)
  return _internal_volume();
}
inline void QueryAggregateMarketVolumeResponse::unsafe_arena_set_allocated_volume(
    ::injective::exchange::v1beta1::VolumeRecord* volume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volume_);
  }
  _impl_.volume_ = volume;
  if (volume) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse.volume)
}
inline ::injective::exchange::v1beta1::VolumeRecord* QueryAggregateMarketVolumeResponse::release_volume() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::VolumeRecord* temp = _impl_.volume_;
  _impl_.volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::VolumeRecord* QueryAggregateMarketVolumeResponse::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse.volume)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::VolumeRecord* temp = _impl_.volume_;
  _impl_.volume_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::VolumeRecord* QueryAggregateMarketVolumeResponse::_internal_mutable_volume() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::VolumeRecord>(GetArenaForAllocation());
    _impl_.volume_ = p;
  }
  return _impl_.volume_;
}
inline ::injective::exchange::v1beta1::VolumeRecord* QueryAggregateMarketVolumeResponse::mutable_volume() {
  ::injective::exchange::v1beta1::VolumeRecord* _msg = _internal_mutable_volume();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse.volume)
  return _msg;
}
inline void QueryAggregateMarketVolumeResponse::set_allocated_volume(::injective::exchange::v1beta1::VolumeRecord* volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volume_);
  }
  if (volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume));
    if (message_arena != submessage_arena) {
      volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryAggregateMarketVolumeResponse.volume)
}

// -------------------------------------------------------------------

// QueryDenomDecimalRequest

// string denom = 1 [json_name = "denom"];
inline void QueryDenomDecimalRequest::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& QueryDenomDecimalRequest::denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDenomDecimalRequest.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDenomDecimalRequest::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDenomDecimalRequest.denom)
}
inline std::string* QueryDenomDecimalRequest::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDenomDecimalRequest.denom)
  return _s;
}
inline const std::string& QueryDenomDecimalRequest::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void QueryDenomDecimalRequest::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDenomDecimalRequest::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDenomDecimalRequest::release_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDenomDecimalRequest.denom)
  return _impl_.denom_.Release();
}
inline void QueryDenomDecimalRequest::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDenomDecimalRequest.denom)
}

// -------------------------------------------------------------------

// QueryDenomDecimalResponse

// uint64 decimal = 1 [json_name = "decimal"];
inline void QueryDenomDecimalResponse::clear_decimal() {
  _impl_.decimal_ = ::uint64_t{0u};
}
inline ::uint64_t QueryDenomDecimalResponse::decimal() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDenomDecimalResponse.decimal)
  return _internal_decimal();
}
inline void QueryDenomDecimalResponse::set_decimal(::uint64_t value) {
  _internal_set_decimal(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDenomDecimalResponse.decimal)
}
inline ::uint64_t QueryDenomDecimalResponse::_internal_decimal() const {
  return _impl_.decimal_;
}
inline void QueryDenomDecimalResponse::_internal_set_decimal(::uint64_t value) {
  ;
  _impl_.decimal_ = value;
}

// -------------------------------------------------------------------

// QueryDenomDecimalsRequest

// repeated string denoms = 1 [json_name = "denoms"];
inline int QueryDenomDecimalsRequest::_internal_denoms_size() const {
  return _impl_.denoms_.size();
}
inline int QueryDenomDecimalsRequest::denoms_size() const {
  return _internal_denoms_size();
}
inline void QueryDenomDecimalsRequest::clear_denoms() {
  _internal_mutable_denoms()->Clear();
}
inline std::string* QueryDenomDecimalsRequest::add_denoms() {
  std::string* _s = _internal_add_denoms();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
  return _s;
}
inline const std::string& QueryDenomDecimalsRequest::denoms(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
  return _internal_denoms(index);
}
inline std::string* QueryDenomDecimalsRequest::mutable_denoms(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
  return _internal_mutable_denoms()->Mutable(index);
}
inline void QueryDenomDecimalsRequest::set_denoms(int index, const std::string& value) {
  _internal_mutable_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::set_denoms(int index, std::string&& value) {
  _internal_mutable_denoms()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::set_denoms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::set_denoms(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_denoms()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::set_denoms(int index, absl::string_view value) {
  _internal_mutable_denoms()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::add_denoms(const std::string& value) {
  _internal_mutable_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::add_denoms(std::string&& value) {
  _internal_mutable_denoms()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::add_denoms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::add_denoms(const char* value, std::size_t size) {
  _internal_mutable_denoms()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline void QueryDenomDecimalsRequest::add_denoms(absl::string_view value) {
  _internal_mutable_denoms()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryDenomDecimalsRequest::denoms() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
  return _internal_denoms();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryDenomDecimalsRequest::mutable_denoms() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDenomDecimalsRequest.denoms)
  return _internal_mutable_denoms();
}
inline const std::string& QueryDenomDecimalsRequest::_internal_denoms(int index) const {
  return _internal_denoms().Get(index);
}
inline std::string* QueryDenomDecimalsRequest::_internal_add_denoms() {
  return _internal_mutable_denoms()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryDenomDecimalsRequest::_internal_denoms() const {
  return _impl_.denoms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryDenomDecimalsRequest::_internal_mutable_denoms() {
  return &_impl_.denoms_;
}

// -------------------------------------------------------------------

// QueryDenomDecimalsResponse

// repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 1 [json_name = "denomDecimals", (.gogoproto.nullable) = false];
inline int QueryDenomDecimalsResponse::_internal_denom_decimals_size() const {
  return _impl_.denom_decimals_.size();
}
inline int QueryDenomDecimalsResponse::denom_decimals_size() const {
  return _internal_denom_decimals_size();
}
inline ::injective::exchange::v1beta1::DenomDecimals* QueryDenomDecimalsResponse::mutable_denom_decimals(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDenomDecimalsResponse.denom_decimals)
  return _internal_mutable_denom_decimals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >*
QueryDenomDecimalsResponse::mutable_denom_decimals() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDenomDecimalsResponse.denom_decimals)
  return _internal_mutable_denom_decimals();
}
inline const ::injective::exchange::v1beta1::DenomDecimals& QueryDenomDecimalsResponse::_internal_denom_decimals(int index) const {
  return _internal_denom_decimals().Get(index);
}
inline const ::injective::exchange::v1beta1::DenomDecimals& QueryDenomDecimalsResponse::denom_decimals(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDenomDecimalsResponse.denom_decimals)
  return _internal_denom_decimals(index);
}
inline ::injective::exchange::v1beta1::DenomDecimals* QueryDenomDecimalsResponse::_internal_add_denom_decimals() {
  return _internal_mutable_denom_decimals()->Add();
}
inline ::injective::exchange::v1beta1::DenomDecimals* QueryDenomDecimalsResponse::add_denom_decimals() {
  ::injective::exchange::v1beta1::DenomDecimals* _add = _internal_add_denom_decimals();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDenomDecimalsResponse.denom_decimals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DenomDecimals >&
QueryDenomDecimalsResponse::denom_decimals() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDenomDecimalsResponse.denom_decimals)
  return _internal_denom_decimals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>&
QueryDenomDecimalsResponse::_internal_denom_decimals() const {
  return _impl_.denom_decimals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DenomDecimals>*
QueryDenomDecimalsResponse::_internal_mutable_denom_decimals() {
  return &_impl_.denom_decimals_;
}

// -------------------------------------------------------------------

// QueryAggregateMarketVolumesRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int QueryAggregateMarketVolumesRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int QueryAggregateMarketVolumesRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void QueryAggregateMarketVolumesRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* QueryAggregateMarketVolumesRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
  return _s;
}
inline const std::string& QueryAggregateMarketVolumesRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* QueryAggregateMarketVolumesRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void QueryAggregateMarketVolumesRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline void QueryAggregateMarketVolumesRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryAggregateMarketVolumesRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryAggregateMarketVolumesRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAggregateMarketVolumesRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& QueryAggregateMarketVolumesRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* QueryAggregateMarketVolumesRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryAggregateMarketVolumesRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryAggregateMarketVolumesRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// QueryAggregateMarketVolumesResponse

// repeated .injective.exchange.v1beta1.MarketVolume volumes = 1 [json_name = "volumes"];
inline int QueryAggregateMarketVolumesResponse::_internal_volumes_size() const {
  return _impl_.volumes_.size();
}
inline int QueryAggregateMarketVolumesResponse::volumes_size() const {
  return _internal_volumes_size();
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateMarketVolumesResponse::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse.volumes)
  return _internal_mutable_volumes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >*
QueryAggregateMarketVolumesResponse::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse.volumes)
  return _internal_mutable_volumes();
}
inline const ::injective::exchange::v1beta1::MarketVolume& QueryAggregateMarketVolumesResponse::_internal_volumes(int index) const {
  return _internal_volumes().Get(index);
}
inline const ::injective::exchange::v1beta1::MarketVolume& QueryAggregateMarketVolumesResponse::volumes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse.volumes)
  return _internal_volumes(index);
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateMarketVolumesResponse::_internal_add_volumes() {
  return _internal_mutable_volumes()->Add();
}
inline ::injective::exchange::v1beta1::MarketVolume* QueryAggregateMarketVolumesResponse::add_volumes() {
  ::injective::exchange::v1beta1::MarketVolume* _add = _internal_add_volumes();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse.volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::MarketVolume >&
QueryAggregateMarketVolumesResponse::volumes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAggregateMarketVolumesResponse.volumes)
  return _internal_volumes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>&
QueryAggregateMarketVolumesResponse::_internal_volumes() const {
  return _impl_.volumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::MarketVolume>*
QueryAggregateMarketVolumesResponse::_internal_mutable_volumes() {
  return &_impl_.volumes_;
}

// -------------------------------------------------------------------

// QuerySubaccountDepositRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountDepositRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountDepositRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountDepositRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountDepositRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountDepositRequest.subaccount_id)
}
inline std::string* QuerySubaccountDepositRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountDepositRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountDepositRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountDepositRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountDepositRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountDepositRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountDepositRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountDepositRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountDepositRequest.subaccount_id)
}

// string denom = 2 [json_name = "denom"];
inline void QuerySubaccountDepositRequest::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& QuerySubaccountDepositRequest::denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountDepositRequest.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountDepositRequest::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountDepositRequest.denom)
}
inline std::string* QuerySubaccountDepositRequest::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountDepositRequest.denom)
  return _s;
}
inline const std::string& QuerySubaccountDepositRequest::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void QuerySubaccountDepositRequest::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountDepositRequest::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountDepositRequest::release_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountDepositRequest.denom)
  return _impl_.denom_.Release();
}
inline void QuerySubaccountDepositRequest::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountDepositRequest.denom)
}

// -------------------------------------------------------------------

// QuerySubaccountDepositResponse

// .injective.exchange.v1beta1.Deposit deposits = 1 [json_name = "deposits"];
inline bool QuerySubaccountDepositResponse::has_deposits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deposits_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::Deposit& QuerySubaccountDepositResponse::_internal_deposits() const {
  const ::injective::exchange::v1beta1::Deposit* p = _impl_.deposits_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Deposit&>(
      ::injective::exchange::v1beta1::_Deposit_default_instance_);
}
inline const ::injective::exchange::v1beta1::Deposit& QuerySubaccountDepositResponse::deposits() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountDepositResponse.deposits)
  return _internal_deposits();
}
inline void QuerySubaccountDepositResponse::unsafe_arena_set_allocated_deposits(
    ::injective::exchange::v1beta1::Deposit* deposits) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deposits_);
  }
  _impl_.deposits_ = deposits;
  if (deposits) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QuerySubaccountDepositResponse.deposits)
}
inline ::injective::exchange::v1beta1::Deposit* QuerySubaccountDepositResponse::release_deposits() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Deposit* temp = _impl_.deposits_;
  _impl_.deposits_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Deposit* QuerySubaccountDepositResponse::unsafe_arena_release_deposits() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountDepositResponse.deposits)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Deposit* temp = _impl_.deposits_;
  _impl_.deposits_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Deposit* QuerySubaccountDepositResponse::_internal_mutable_deposits() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deposits_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Deposit>(GetArenaForAllocation());
    _impl_.deposits_ = p;
  }
  return _impl_.deposits_;
}
inline ::injective::exchange::v1beta1::Deposit* QuerySubaccountDepositResponse::mutable_deposits() {
  ::injective::exchange::v1beta1::Deposit* _msg = _internal_mutable_deposits();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountDepositResponse.deposits)
  return _msg;
}
inline void QuerySubaccountDepositResponse::set_allocated_deposits(::injective::exchange::v1beta1::Deposit* deposits) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deposits_);
  }
  if (deposits) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deposits));
    if (message_arena != submessage_arena) {
      deposits = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deposits, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deposits_ = deposits;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountDepositResponse.deposits)
}

// -------------------------------------------------------------------

// QuerySpotMarketsRequest

// string status = 1 [json_name = "status"];
inline void QuerySpotMarketsRequest::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& QuerySpotMarketsRequest::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMarketsRequest.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotMarketsRequest::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMarketsRequest.status)
}
inline std::string* QuerySpotMarketsRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMarketsRequest.status)
  return _s;
}
inline const std::string& QuerySpotMarketsRequest::_internal_status() const {
  return _impl_.status_.Get();
}
inline void QuerySpotMarketsRequest::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotMarketsRequest::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotMarketsRequest::release_status() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotMarketsRequest.status)
  return _impl_.status_.Release();
}
inline void QuerySpotMarketsRequest::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotMarketsRequest.status)
}

// repeated string market_ids = 2 [json_name = "marketIds"];
inline int QuerySpotMarketsRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int QuerySpotMarketsRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void QuerySpotMarketsRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* QuerySpotMarketsRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
  return _s;
}
inline const std::string& QuerySpotMarketsRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* QuerySpotMarketsRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void QuerySpotMarketsRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline void QuerySpotMarketsRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QuerySpotMarketsRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QuerySpotMarketsRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySpotMarketsRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& QuerySpotMarketsRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* QuerySpotMarketsRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QuerySpotMarketsRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QuerySpotMarketsRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// QuerySpotMarketsResponse

// repeated .injective.exchange.v1beta1.SpotMarket markets = 1 [json_name = "markets"];
inline int QuerySpotMarketsResponse::_internal_markets_size() const {
  return _impl_.markets_.size();
}
inline int QuerySpotMarketsResponse::markets_size() const {
  return _internal_markets_size();
}
inline ::injective::exchange::v1beta1::SpotMarket* QuerySpotMarketsResponse::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMarketsResponse.markets)
  return _internal_mutable_markets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarket >*
QuerySpotMarketsResponse::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySpotMarketsResponse.markets)
  return _internal_mutable_markets();
}
inline const ::injective::exchange::v1beta1::SpotMarket& QuerySpotMarketsResponse::_internal_markets(int index) const {
  return _internal_markets().Get(index);
}
inline const ::injective::exchange::v1beta1::SpotMarket& QuerySpotMarketsResponse::markets(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMarketsResponse.markets)
  return _internal_markets(index);
}
inline ::injective::exchange::v1beta1::SpotMarket* QuerySpotMarketsResponse::_internal_add_markets() {
  return _internal_mutable_markets()->Add();
}
inline ::injective::exchange::v1beta1::SpotMarket* QuerySpotMarketsResponse::add_markets() {
  ::injective::exchange::v1beta1::SpotMarket* _add = _internal_add_markets();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotMarketsResponse.markets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SpotMarket >&
QuerySpotMarketsResponse::markets() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySpotMarketsResponse.markets)
  return _internal_markets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarket>&
QuerySpotMarketsResponse::_internal_markets() const {
  return _impl_.markets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SpotMarket>*
QuerySpotMarketsResponse::_internal_mutable_markets() {
  return &_impl_.markets_;
}

// -------------------------------------------------------------------

// QuerySpotMarketRequest

// string market_id = 1 [json_name = "marketId"];
inline void QuerySpotMarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QuerySpotMarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotMarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMarketRequest.market_id)
}
inline std::string* QuerySpotMarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMarketRequest.market_id)
  return _s;
}
inline const std::string& QuerySpotMarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QuerySpotMarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotMarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotMarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotMarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QuerySpotMarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotMarketRequest.market_id)
}

// -------------------------------------------------------------------

// QuerySpotMarketResponse

// .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market"];
inline bool QuerySpotMarketResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::SpotMarket& QuerySpotMarketResponse::_internal_market() const {
  const ::injective::exchange::v1beta1::SpotMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SpotMarket&>(
      ::injective::exchange::v1beta1::_SpotMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::SpotMarket& QuerySpotMarketResponse::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMarketResponse.market)
  return _internal_market();
}
inline void QuerySpotMarketResponse::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::SpotMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QuerySpotMarketResponse.market)
}
inline ::injective::exchange::v1beta1::SpotMarket* QuerySpotMarketResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarket* QuerySpotMarketResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotMarketResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarket* QuerySpotMarketResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::SpotMarket* QuerySpotMarketResponse::mutable_market() {
  ::injective::exchange::v1beta1::SpotMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMarketResponse.market)
  return _msg;
}
inline void QuerySpotMarketResponse::set_allocated_market(::injective::exchange::v1beta1::SpotMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotMarketResponse.market)
}

// -------------------------------------------------------------------

// QuerySpotOrderbookRequest

// string market_id = 1 [json_name = "marketId"];
inline void QuerySpotOrderbookRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QuerySpotOrderbookRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrderbookRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotOrderbookRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrderbookRequest.market_id)
}
inline std::string* QuerySpotOrderbookRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrderbookRequest.market_id)
  return _s;
}
inline const std::string& QuerySpotOrderbookRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QuerySpotOrderbookRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotOrderbookRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotOrderbookRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotOrderbookRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QuerySpotOrderbookRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotOrderbookRequest.market_id)
}

// uint64 limit = 2 [json_name = "limit"];
inline void QuerySpotOrderbookRequest::clear_limit() {
  _impl_.limit_ = ::uint64_t{0u};
}
inline ::uint64_t QuerySpotOrderbookRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit)
  return _internal_limit();
}
inline void QuerySpotOrderbookRequest::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit)
}
inline ::uint64_t QuerySpotOrderbookRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void QuerySpotOrderbookRequest::_internal_set_limit(::uint64_t value) {
  ;
  _impl_.limit_ = value;
}

// .injective.exchange.v1beta1.OrderSide order_side = 3 [json_name = "orderSide"];
inline void QuerySpotOrderbookRequest::clear_order_side() {
  _impl_.order_side_ = 0;
}
inline ::injective::exchange::v1beta1::OrderSide QuerySpotOrderbookRequest::order_side() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrderbookRequest.order_side)
  return _internal_order_side();
}
inline void QuerySpotOrderbookRequest::set_order_side(::injective::exchange::v1beta1::OrderSide value) {
   _internal_set_order_side(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrderbookRequest.order_side)
}
inline ::injective::exchange::v1beta1::OrderSide QuerySpotOrderbookRequest::_internal_order_side() const {
  return static_cast<::injective::exchange::v1beta1::OrderSide>(_impl_.order_side_);
}
inline void QuerySpotOrderbookRequest::_internal_set_order_side(::injective::exchange::v1beta1::OrderSide value) {
  ;
  _impl_.order_side_ = value;
}

// string limit_cumulative_notional = 4 [json_name = "limitCumulativeNotional", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QuerySpotOrderbookRequest::clear_limit_cumulative_notional() {
  _impl_.limit_cumulative_notional_.ClearToEmpty();
}
inline const std::string& QuerySpotOrderbookRequest::limit_cumulative_notional() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_notional)
  return _internal_limit_cumulative_notional();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotOrderbookRequest::set_limit_cumulative_notional(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.limit_cumulative_notional_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_notional)
}
inline std::string* QuerySpotOrderbookRequest::mutable_limit_cumulative_notional() {
  std::string* _s = _internal_mutable_limit_cumulative_notional();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_notional)
  return _s;
}
inline const std::string& QuerySpotOrderbookRequest::_internal_limit_cumulative_notional() const {
  return _impl_.limit_cumulative_notional_.Get();
}
inline void QuerySpotOrderbookRequest::_internal_set_limit_cumulative_notional(const std::string& value) {
  ;


  _impl_.limit_cumulative_notional_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotOrderbookRequest::_internal_mutable_limit_cumulative_notional() {
  ;
  return _impl_.limit_cumulative_notional_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotOrderbookRequest::release_limit_cumulative_notional() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_notional)
  return _impl_.limit_cumulative_notional_.Release();
}
inline void QuerySpotOrderbookRequest::set_allocated_limit_cumulative_notional(std::string* value) {
  _impl_.limit_cumulative_notional_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.limit_cumulative_notional_.IsDefault()) {
          _impl_.limit_cumulative_notional_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_notional)
}

// string limit_cumulative_quantity = 5 [json_name = "limitCumulativeQuantity", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QuerySpotOrderbookRequest::clear_limit_cumulative_quantity() {
  _impl_.limit_cumulative_quantity_.ClearToEmpty();
}
inline const std::string& QuerySpotOrderbookRequest::limit_cumulative_quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_quantity)
  return _internal_limit_cumulative_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotOrderbookRequest::set_limit_cumulative_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.limit_cumulative_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_quantity)
}
inline std::string* QuerySpotOrderbookRequest::mutable_limit_cumulative_quantity() {
  std::string* _s = _internal_mutable_limit_cumulative_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_quantity)
  return _s;
}
inline const std::string& QuerySpotOrderbookRequest::_internal_limit_cumulative_quantity() const {
  return _impl_.limit_cumulative_quantity_.Get();
}
inline void QuerySpotOrderbookRequest::_internal_set_limit_cumulative_quantity(const std::string& value) {
  ;


  _impl_.limit_cumulative_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotOrderbookRequest::_internal_mutable_limit_cumulative_quantity() {
  ;
  return _impl_.limit_cumulative_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotOrderbookRequest::release_limit_cumulative_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_quantity)
  return _impl_.limit_cumulative_quantity_.Release();
}
inline void QuerySpotOrderbookRequest::set_allocated_limit_cumulative_quantity(std::string* value) {
  _impl_.limit_cumulative_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.limit_cumulative_quantity_.IsDefault()) {
          _impl_.limit_cumulative_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotOrderbookRequest.limit_cumulative_quantity)
}

// -------------------------------------------------------------------

// QuerySpotOrderbookResponse

// repeated .injective.exchange.v1beta1.Level buys_price_level = 1 [json_name = "buysPriceLevel"];
inline int QuerySpotOrderbookResponse::_internal_buys_price_level_size() const {
  return _impl_.buys_price_level_.size();
}
inline int QuerySpotOrderbookResponse::buys_price_level_size() const {
  return _internal_buys_price_level_size();
}
inline ::injective::exchange::v1beta1::Level* QuerySpotOrderbookResponse::mutable_buys_price_level(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrderbookResponse.buys_price_level)
  return _internal_mutable_buys_price_level()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
QuerySpotOrderbookResponse::mutable_buys_price_level() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySpotOrderbookResponse.buys_price_level)
  return _internal_mutable_buys_price_level();
}
inline const ::injective::exchange::v1beta1::Level& QuerySpotOrderbookResponse::_internal_buys_price_level(int index) const {
  return _internal_buys_price_level().Get(index);
}
inline const ::injective::exchange::v1beta1::Level& QuerySpotOrderbookResponse::buys_price_level(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrderbookResponse.buys_price_level)
  return _internal_buys_price_level(index);
}
inline ::injective::exchange::v1beta1::Level* QuerySpotOrderbookResponse::_internal_add_buys_price_level() {
  return _internal_mutable_buys_price_level()->Add();
}
inline ::injective::exchange::v1beta1::Level* QuerySpotOrderbookResponse::add_buys_price_level() {
  ::injective::exchange::v1beta1::Level* _add = _internal_add_buys_price_level();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotOrderbookResponse.buys_price_level)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
QuerySpotOrderbookResponse::buys_price_level() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySpotOrderbookResponse.buys_price_level)
  return _internal_buys_price_level();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>&
QuerySpotOrderbookResponse::_internal_buys_price_level() const {
  return _impl_.buys_price_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>*
QuerySpotOrderbookResponse::_internal_mutable_buys_price_level() {
  return &_impl_.buys_price_level_;
}

// repeated .injective.exchange.v1beta1.Level sells_price_level = 2 [json_name = "sellsPriceLevel"];
inline int QuerySpotOrderbookResponse::_internal_sells_price_level_size() const {
  return _impl_.sells_price_level_.size();
}
inline int QuerySpotOrderbookResponse::sells_price_level_size() const {
  return _internal_sells_price_level_size();
}
inline ::injective::exchange::v1beta1::Level* QuerySpotOrderbookResponse::mutable_sells_price_level(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrderbookResponse.sells_price_level)
  return _internal_mutable_sells_price_level()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
QuerySpotOrderbookResponse::mutable_sells_price_level() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySpotOrderbookResponse.sells_price_level)
  return _internal_mutable_sells_price_level();
}
inline const ::injective::exchange::v1beta1::Level& QuerySpotOrderbookResponse::_internal_sells_price_level(int index) const {
  return _internal_sells_price_level().Get(index);
}
inline const ::injective::exchange::v1beta1::Level& QuerySpotOrderbookResponse::sells_price_level(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrderbookResponse.sells_price_level)
  return _internal_sells_price_level(index);
}
inline ::injective::exchange::v1beta1::Level* QuerySpotOrderbookResponse::_internal_add_sells_price_level() {
  return _internal_mutable_sells_price_level()->Add();
}
inline ::injective::exchange::v1beta1::Level* QuerySpotOrderbookResponse::add_sells_price_level() {
  ::injective::exchange::v1beta1::Level* _add = _internal_add_sells_price_level();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotOrderbookResponse.sells_price_level)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
QuerySpotOrderbookResponse::sells_price_level() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySpotOrderbookResponse.sells_price_level)
  return _internal_sells_price_level();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>&
QuerySpotOrderbookResponse::_internal_sells_price_level() const {
  return _impl_.sells_price_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>*
QuerySpotOrderbookResponse::_internal_mutable_sells_price_level() {
  return &_impl_.sells_price_level_;
}

// -------------------------------------------------------------------

// FullSpotMarket

// .injective.exchange.v1beta1.SpotMarket market = 1 [json_name = "market"];
inline bool FullSpotMarket::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::SpotMarket& FullSpotMarket::_internal_market() const {
  const ::injective::exchange::v1beta1::SpotMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::SpotMarket&>(
      ::injective::exchange::v1beta1::_SpotMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::SpotMarket& FullSpotMarket::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FullSpotMarket.market)
  return _internal_market();
}
inline void FullSpotMarket::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::SpotMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.FullSpotMarket.market)
}
inline ::injective::exchange::v1beta1::SpotMarket* FullSpotMarket::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarket* FullSpotMarket::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FullSpotMarket.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::SpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::SpotMarket* FullSpotMarket::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::SpotMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::SpotMarket* FullSpotMarket::mutable_market() {
  ::injective::exchange::v1beta1::SpotMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FullSpotMarket.market)
  return _msg;
}
inline void FullSpotMarket::set_allocated_market(::injective::exchange::v1beta1::SpotMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FullSpotMarket.market)
}

// .injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 2 [json_name = "midPriceAndTob", (.gogoproto.nullable) = true];
inline bool FullSpotMarket::has_mid_price_and_tob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mid_price_and_tob_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::MidPriceAndTOB& FullSpotMarket::_internal_mid_price_and_tob() const {
  const ::injective::exchange::v1beta1::MidPriceAndTOB* p = _impl_.mid_price_and_tob_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::MidPriceAndTOB&>(
      ::injective::exchange::v1beta1::_MidPriceAndTOB_default_instance_);
}
inline const ::injective::exchange::v1beta1::MidPriceAndTOB& FullSpotMarket::mid_price_and_tob() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FullSpotMarket.mid_price_and_tob)
  return _internal_mid_price_and_tob();
}
inline void FullSpotMarket::unsafe_arena_set_allocated_mid_price_and_tob(
    ::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mid_price_and_tob_);
  }
  _impl_.mid_price_and_tob_ = mid_price_and_tob;
  if (mid_price_and_tob) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.FullSpotMarket.mid_price_and_tob)
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullSpotMarket::release_mid_price_and_tob() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::MidPriceAndTOB* temp = _impl_.mid_price_and_tob_;
  _impl_.mid_price_and_tob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullSpotMarket::unsafe_arena_release_mid_price_and_tob() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FullSpotMarket.mid_price_and_tob)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::MidPriceAndTOB* temp = _impl_.mid_price_and_tob_;
  _impl_.mid_price_and_tob_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullSpotMarket::_internal_mutable_mid_price_and_tob() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.mid_price_and_tob_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::MidPriceAndTOB>(GetArenaForAllocation());
    _impl_.mid_price_and_tob_ = p;
  }
  return _impl_.mid_price_and_tob_;
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullSpotMarket::mutable_mid_price_and_tob() {
  ::injective::exchange::v1beta1::MidPriceAndTOB* _msg = _internal_mutable_mid_price_and_tob();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FullSpotMarket.mid_price_and_tob)
  return _msg;
}
inline void FullSpotMarket::set_allocated_mid_price_and_tob(::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mid_price_and_tob_);
  }
  if (mid_price_and_tob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mid_price_and_tob));
    if (message_arena != submessage_arena) {
      mid_price_and_tob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mid_price_and_tob, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mid_price_and_tob_ = mid_price_and_tob;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FullSpotMarket.mid_price_and_tob)
}

// -------------------------------------------------------------------

// QueryFullSpotMarketsRequest

// string status = 1 [json_name = "status"];
inline void QueryFullSpotMarketsRequest::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& QueryFullSpotMarketsRequest::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryFullSpotMarketsRequest::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.status)
}
inline std::string* QueryFullSpotMarketsRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.status)
  return _s;
}
inline const std::string& QueryFullSpotMarketsRequest::_internal_status() const {
  return _impl_.status_.Get();
}
inline void QueryFullSpotMarketsRequest::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryFullSpotMarketsRequest::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryFullSpotMarketsRequest::release_status() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.status)
  return _impl_.status_.Release();
}
inline void QueryFullSpotMarketsRequest::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.status)
}

// repeated string market_ids = 2 [json_name = "marketIds"];
inline int QueryFullSpotMarketsRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int QueryFullSpotMarketsRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void QueryFullSpotMarketsRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* QueryFullSpotMarketsRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
  return _s;
}
inline const std::string& QueryFullSpotMarketsRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* QueryFullSpotMarketsRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void QueryFullSpotMarketsRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline void QueryFullSpotMarketsRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryFullSpotMarketsRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryFullSpotMarketsRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& QueryFullSpotMarketsRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* QueryFullSpotMarketsRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryFullSpotMarketsRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryFullSpotMarketsRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// bool with_mid_price_and_tob = 3 [json_name = "withMidPriceAndTob"];
inline void QueryFullSpotMarketsRequest::clear_with_mid_price_and_tob() {
  _impl_.with_mid_price_and_tob_ = false;
}
inline bool QueryFullSpotMarketsRequest::with_mid_price_and_tob() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.with_mid_price_and_tob)
  return _internal_with_mid_price_and_tob();
}
inline void QueryFullSpotMarketsRequest::set_with_mid_price_and_tob(bool value) {
  _internal_set_with_mid_price_and_tob(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFullSpotMarketsRequest.with_mid_price_and_tob)
}
inline bool QueryFullSpotMarketsRequest::_internal_with_mid_price_and_tob() const {
  return _impl_.with_mid_price_and_tob_;
}
inline void QueryFullSpotMarketsRequest::_internal_set_with_mid_price_and_tob(bool value) {
  ;
  _impl_.with_mid_price_and_tob_ = value;
}

// -------------------------------------------------------------------

// QueryFullSpotMarketsResponse

// repeated .injective.exchange.v1beta1.FullSpotMarket markets = 1 [json_name = "markets"];
inline int QueryFullSpotMarketsResponse::_internal_markets_size() const {
  return _impl_.markets_.size();
}
inline int QueryFullSpotMarketsResponse::markets_size() const {
  return _internal_markets_size();
}
inline void QueryFullSpotMarketsResponse::clear_markets() {
  _internal_mutable_markets()->Clear();
}
inline ::injective::exchange::v1beta1::FullSpotMarket* QueryFullSpotMarketsResponse::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFullSpotMarketsResponse.markets)
  return _internal_mutable_markets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullSpotMarket >*
QueryFullSpotMarketsResponse::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryFullSpotMarketsResponse.markets)
  return _internal_mutable_markets();
}
inline const ::injective::exchange::v1beta1::FullSpotMarket& QueryFullSpotMarketsResponse::_internal_markets(int index) const {
  return _internal_markets().Get(index);
}
inline const ::injective::exchange::v1beta1::FullSpotMarket& QueryFullSpotMarketsResponse::markets(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFullSpotMarketsResponse.markets)
  return _internal_markets(index);
}
inline ::injective::exchange::v1beta1::FullSpotMarket* QueryFullSpotMarketsResponse::_internal_add_markets() {
  return _internal_mutable_markets()->Add();
}
inline ::injective::exchange::v1beta1::FullSpotMarket* QueryFullSpotMarketsResponse::add_markets() {
  ::injective::exchange::v1beta1::FullSpotMarket* _add = _internal_add_markets();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryFullSpotMarketsResponse.markets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullSpotMarket >&
QueryFullSpotMarketsResponse::markets() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryFullSpotMarketsResponse.markets)
  return _internal_markets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullSpotMarket>&
QueryFullSpotMarketsResponse::_internal_markets() const {
  return _impl_.markets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullSpotMarket>*
QueryFullSpotMarketsResponse::_internal_mutable_markets() {
  return &_impl_.markets_;
}

// -------------------------------------------------------------------

// QueryFullSpotMarketRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryFullSpotMarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryFullSpotMarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFullSpotMarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryFullSpotMarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFullSpotMarketRequest.market_id)
}
inline std::string* QueryFullSpotMarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFullSpotMarketRequest.market_id)
  return _s;
}
inline const std::string& QueryFullSpotMarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryFullSpotMarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryFullSpotMarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryFullSpotMarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryFullSpotMarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryFullSpotMarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryFullSpotMarketRequest.market_id)
}

// bool with_mid_price_and_tob = 2 [json_name = "withMidPriceAndTob"];
inline void QueryFullSpotMarketRequest::clear_with_mid_price_and_tob() {
  _impl_.with_mid_price_and_tob_ = false;
}
inline bool QueryFullSpotMarketRequest::with_mid_price_and_tob() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFullSpotMarketRequest.with_mid_price_and_tob)
  return _internal_with_mid_price_and_tob();
}
inline void QueryFullSpotMarketRequest::set_with_mid_price_and_tob(bool value) {
  _internal_set_with_mid_price_and_tob(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFullSpotMarketRequest.with_mid_price_and_tob)
}
inline bool QueryFullSpotMarketRequest::_internal_with_mid_price_and_tob() const {
  return _impl_.with_mid_price_and_tob_;
}
inline void QueryFullSpotMarketRequest::_internal_set_with_mid_price_and_tob(bool value) {
  ;
  _impl_.with_mid_price_and_tob_ = value;
}

// -------------------------------------------------------------------

// QueryFullSpotMarketResponse

// .injective.exchange.v1beta1.FullSpotMarket market = 1 [json_name = "market"];
inline bool QueryFullSpotMarketResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline void QueryFullSpotMarketResponse::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::FullSpotMarket& QueryFullSpotMarketResponse::_internal_market() const {
  const ::injective::exchange::v1beta1::FullSpotMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::FullSpotMarket&>(
      ::injective::exchange::v1beta1::_FullSpotMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::FullSpotMarket& QueryFullSpotMarketResponse::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFullSpotMarketResponse.market)
  return _internal_market();
}
inline void QueryFullSpotMarketResponse::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::FullSpotMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryFullSpotMarketResponse.market)
}
inline ::injective::exchange::v1beta1::FullSpotMarket* QueryFullSpotMarketResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FullSpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::FullSpotMarket* QueryFullSpotMarketResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryFullSpotMarketResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FullSpotMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::FullSpotMarket* QueryFullSpotMarketResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::FullSpotMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::FullSpotMarket* QueryFullSpotMarketResponse::mutable_market() {
  ::injective::exchange::v1beta1::FullSpotMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFullSpotMarketResponse.market)
  return _msg;
}
inline void QueryFullSpotMarketResponse::set_allocated_market(::injective::exchange::v1beta1::FullSpotMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryFullSpotMarketResponse.market)
}

// -------------------------------------------------------------------

// QuerySpotOrdersByHashesRequest

// string market_id = 1 [json_name = "marketId"];
inline void QuerySpotOrdersByHashesRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QuerySpotOrdersByHashesRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotOrdersByHashesRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.market_id)
}
inline std::string* QuerySpotOrdersByHashesRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.market_id)
  return _s;
}
inline const std::string& QuerySpotOrdersByHashesRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QuerySpotOrdersByHashesRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotOrdersByHashesRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotOrdersByHashesRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QuerySpotOrdersByHashesRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void QuerySpotOrdersByHashesRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySpotOrdersByHashesRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotOrdersByHashesRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.subaccount_id)
}
inline std::string* QuerySpotOrdersByHashesRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySpotOrdersByHashesRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySpotOrdersByHashesRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotOrdersByHashesRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotOrdersByHashesRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySpotOrdersByHashesRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.subaccount_id)
}

// repeated string order_hashes = 3 [json_name = "orderHashes"];
inline int QuerySpotOrdersByHashesRequest::_internal_order_hashes_size() const {
  return _impl_.order_hashes_.size();
}
inline int QuerySpotOrdersByHashesRequest::order_hashes_size() const {
  return _internal_order_hashes_size();
}
inline void QuerySpotOrdersByHashesRequest::clear_order_hashes() {
  _internal_mutable_order_hashes()->Clear();
}
inline std::string* QuerySpotOrdersByHashesRequest::add_order_hashes() {
  std::string* _s = _internal_add_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
  return _s;
}
inline const std::string& QuerySpotOrdersByHashesRequest::order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
  return _internal_order_hashes(index);
}
inline std::string* QuerySpotOrdersByHashesRequest::mutable_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
  return _internal_mutable_order_hashes()->Mutable(index);
}
inline void QuerySpotOrdersByHashesRequest::set_order_hashes(int index, const std::string& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::set_order_hashes(int index, std::string&& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::set_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::set_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::set_order_hashes(int index, absl::string_view value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::add_order_hashes(const std::string& value) {
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::add_order_hashes(std::string&& value) {
  _internal_mutable_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::add_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::add_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline void QuerySpotOrdersByHashesRequest::add_order_hashes(absl::string_view value) {
  _internal_mutable_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QuerySpotOrdersByHashesRequest::order_hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
  return _internal_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QuerySpotOrdersByHashesRequest::mutable_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySpotOrdersByHashesRequest.order_hashes)
  return _internal_mutable_order_hashes();
}
inline const std::string& QuerySpotOrdersByHashesRequest::_internal_order_hashes(int index) const {
  return _internal_order_hashes().Get(index);
}
inline std::string* QuerySpotOrdersByHashesRequest::_internal_add_order_hashes() {
  return _internal_mutable_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QuerySpotOrdersByHashesRequest::_internal_order_hashes() const {
  return _impl_.order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QuerySpotOrdersByHashesRequest::_internal_mutable_order_hashes() {
  return &_impl_.order_hashes_;
}

// -------------------------------------------------------------------

// QuerySpotOrdersByHashesResponse

// repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1 [json_name = "orders"];
inline int QuerySpotOrdersByHashesResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int QuerySpotOrdersByHashesResponse::orders_size() const {
  return _internal_orders_size();
}
inline void QuerySpotOrdersByHashesResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QuerySpotOrdersByHashesResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >*
QuerySpotOrdersByHashesResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& QuerySpotOrdersByHashesResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& QuerySpotOrdersByHashesResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QuerySpotOrdersByHashesResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QuerySpotOrdersByHashesResponse::add_orders() {
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >&
QuerySpotOrdersByHashesResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySpotOrdersByHashesResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>&
QuerySpotOrdersByHashesResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>*
QuerySpotOrdersByHashesResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// QueryTraderSpotOrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryTraderSpotOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryTraderSpotOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderSpotOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.market_id)
}
inline std::string* QueryTraderSpotOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.market_id)
  return _s;
}
inline const std::string& QueryTraderSpotOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryTraderSpotOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryTraderSpotOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void QueryTraderSpotOrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QueryTraderSpotOrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderSpotOrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.subaccount_id)
}
inline std::string* QueryTraderSpotOrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& QueryTraderSpotOrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QueryTraderSpotOrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QueryTraderSpotOrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderSpotOrdersRequest.subaccount_id)
}

// -------------------------------------------------------------------

// QueryAccountAddressSpotOrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryAccountAddressSpotOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryAccountAddressSpotOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAccountAddressSpotOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.market_id)
}
inline std::string* QueryAccountAddressSpotOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.market_id)
  return _s;
}
inline const std::string& QueryAccountAddressSpotOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryAccountAddressSpotOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAccountAddressSpotOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryAccountAddressSpotOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryAccountAddressSpotOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.market_id)
}

// string account_address = 2 [json_name = "accountAddress"];
inline void QueryAccountAddressSpotOrdersRequest::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& QueryAccountAddressSpotOrdersRequest::account_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAccountAddressSpotOrdersRequest::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.account_address)
}
inline std::string* QueryAccountAddressSpotOrdersRequest::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.account_address)
  return _s;
}
inline const std::string& QueryAccountAddressSpotOrdersRequest::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void QueryAccountAddressSpotOrdersRequest::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAccountAddressSpotOrdersRequest::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryAccountAddressSpotOrdersRequest::release_account_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.account_address)
  return _impl_.account_address_.Release();
}
inline void QueryAccountAddressSpotOrdersRequest::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersRequest.account_address)
}

// -------------------------------------------------------------------

// TrimmedSpotLimitOrder

// string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedSpotLimitOrder::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& TrimmedSpotLimitOrder::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedSpotLimitOrder.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedSpotLimitOrder::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedSpotLimitOrder.price)
}
inline std::string* TrimmedSpotLimitOrder::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedSpotLimitOrder.price)
  return _s;
}
inline const std::string& TrimmedSpotLimitOrder::_internal_price() const {
  return _impl_.price_.Get();
}
inline void TrimmedSpotLimitOrder::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedSpotLimitOrder.price)
  return _impl_.price_.Release();
}
inline void TrimmedSpotLimitOrder::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedSpotLimitOrder.price)
}

// string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedSpotLimitOrder::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& TrimmedSpotLimitOrder::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedSpotLimitOrder.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedSpotLimitOrder::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedSpotLimitOrder.quantity)
}
inline std::string* TrimmedSpotLimitOrder::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedSpotLimitOrder.quantity)
  return _s;
}
inline const std::string& TrimmedSpotLimitOrder::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void TrimmedSpotLimitOrder::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedSpotLimitOrder.quantity)
  return _impl_.quantity_.Release();
}
inline void TrimmedSpotLimitOrder::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedSpotLimitOrder.quantity)
}

// string fillable = 3 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedSpotLimitOrder::clear_fillable() {
  _impl_.fillable_.ClearToEmpty();
}
inline const std::string& TrimmedSpotLimitOrder::fillable() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedSpotLimitOrder.fillable)
  return _internal_fillable();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedSpotLimitOrder::set_fillable(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fillable_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedSpotLimitOrder.fillable)
}
inline std::string* TrimmedSpotLimitOrder::mutable_fillable() {
  std::string* _s = _internal_mutable_fillable();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedSpotLimitOrder.fillable)
  return _s;
}
inline const std::string& TrimmedSpotLimitOrder::_internal_fillable() const {
  return _impl_.fillable_.Get();
}
inline void TrimmedSpotLimitOrder::_internal_set_fillable(const std::string& value) {
  ;


  _impl_.fillable_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::_internal_mutable_fillable() {
  ;
  return _impl_.fillable_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::release_fillable() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedSpotLimitOrder.fillable)
  return _impl_.fillable_.Release();
}
inline void TrimmedSpotLimitOrder::set_allocated_fillable(std::string* value) {
  _impl_.fillable_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fillable_.IsDefault()) {
          _impl_.fillable_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedSpotLimitOrder.fillable)
}

// bool isBuy = 4 [json_name = "isBuy"];
inline void TrimmedSpotLimitOrder::clear_isbuy() {
  _impl_.isbuy_ = false;
}
inline bool TrimmedSpotLimitOrder::isbuy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedSpotLimitOrder.isBuy)
  return _internal_isbuy();
}
inline void TrimmedSpotLimitOrder::set_isbuy(bool value) {
  _internal_set_isbuy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedSpotLimitOrder.isBuy)
}
inline bool TrimmedSpotLimitOrder::_internal_isbuy() const {
  return _impl_.isbuy_;
}
inline void TrimmedSpotLimitOrder::_internal_set_isbuy(bool value) {
  ;
  _impl_.isbuy_ = value;
}

// string order_hash = 5 [json_name = "orderHash"];
inline void TrimmedSpotLimitOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& TrimmedSpotLimitOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedSpotLimitOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedSpotLimitOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedSpotLimitOrder.order_hash)
}
inline std::string* TrimmedSpotLimitOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedSpotLimitOrder.order_hash)
  return _s;
}
inline const std::string& TrimmedSpotLimitOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void TrimmedSpotLimitOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedSpotLimitOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedSpotLimitOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void TrimmedSpotLimitOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedSpotLimitOrder.order_hash)
}

// -------------------------------------------------------------------

// QueryTraderSpotOrdersResponse

// repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1 [json_name = "orders"];
inline int QueryTraderSpotOrdersResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int QueryTraderSpotOrdersResponse::orders_size() const {
  return _internal_orders_size();
}
inline void QueryTraderSpotOrdersResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QueryTraderSpotOrdersResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >*
QueryTraderSpotOrdersResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTraderSpotOrdersResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& QueryTraderSpotOrdersResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& QueryTraderSpotOrdersResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersResponse.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QueryTraderSpotOrdersResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QueryTraderSpotOrdersResponse::add_orders() {
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTraderSpotOrdersResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >&
QueryTraderSpotOrdersResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTraderSpotOrdersResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>&
QueryTraderSpotOrdersResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>*
QueryTraderSpotOrdersResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// QueryAccountAddressSpotOrdersResponse

// repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1 [json_name = "orders"];
inline int QueryAccountAddressSpotOrdersResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int QueryAccountAddressSpotOrdersResponse::orders_size() const {
  return _internal_orders_size();
}
inline void QueryAccountAddressSpotOrdersResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QueryAccountAddressSpotOrdersResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >*
QueryAccountAddressSpotOrdersResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& QueryAccountAddressSpotOrdersResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::TrimmedSpotLimitOrder& QueryAccountAddressSpotOrdersResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QueryAccountAddressSpotOrdersResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* QueryAccountAddressSpotOrdersResponse::add_orders() {
  ::injective::exchange::v1beta1::TrimmedSpotLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedSpotLimitOrder >&
QueryAccountAddressSpotOrdersResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAccountAddressSpotOrdersResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>&
QueryAccountAddressSpotOrdersResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedSpotLimitOrder>*
QueryAccountAddressSpotOrdersResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// QuerySpotMidPriceAndTOBRequest

// string market_id = 1 [json_name = "marketId"];
inline void QuerySpotMidPriceAndTOBRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QuerySpotMidPriceAndTOBRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotMidPriceAndTOBRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest.market_id)
}
inline std::string* QuerySpotMidPriceAndTOBRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest.market_id)
  return _s;
}
inline const std::string& QuerySpotMidPriceAndTOBRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QuerySpotMidPriceAndTOBRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QuerySpotMidPriceAndTOBRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBRequest.market_id)
}

// -------------------------------------------------------------------

// QuerySpotMidPriceAndTOBResponse

// string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QuerySpotMidPriceAndTOBResponse::clear_mid_price() {
  _impl_.mid_price_.ClearToEmpty();
}
inline const std::string& QuerySpotMidPriceAndTOBResponse::mid_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.mid_price)
  return _internal_mid_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotMidPriceAndTOBResponse::set_mid_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mid_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.mid_price)
}
inline std::string* QuerySpotMidPriceAndTOBResponse::mutable_mid_price() {
  std::string* _s = _internal_mutable_mid_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.mid_price)
  return _s;
}
inline const std::string& QuerySpotMidPriceAndTOBResponse::_internal_mid_price() const {
  return _impl_.mid_price_.Get();
}
inline void QuerySpotMidPriceAndTOBResponse::_internal_set_mid_price(const std::string& value) {
  ;


  _impl_.mid_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBResponse::_internal_mutable_mid_price() {
  ;
  return _impl_.mid_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBResponse::release_mid_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.mid_price)
  return _impl_.mid_price_.Release();
}
inline void QuerySpotMidPriceAndTOBResponse::set_allocated_mid_price(std::string* value) {
  _impl_.mid_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mid_price_.IsDefault()) {
          _impl_.mid_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.mid_price)
}

// string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QuerySpotMidPriceAndTOBResponse::clear_best_buy_price() {
  _impl_.best_buy_price_.ClearToEmpty();
}
inline const std::string& QuerySpotMidPriceAndTOBResponse::best_buy_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_buy_price)
  return _internal_best_buy_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotMidPriceAndTOBResponse::set_best_buy_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.best_buy_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_buy_price)
}
inline std::string* QuerySpotMidPriceAndTOBResponse::mutable_best_buy_price() {
  std::string* _s = _internal_mutable_best_buy_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_buy_price)
  return _s;
}
inline const std::string& QuerySpotMidPriceAndTOBResponse::_internal_best_buy_price() const {
  return _impl_.best_buy_price_.Get();
}
inline void QuerySpotMidPriceAndTOBResponse::_internal_set_best_buy_price(const std::string& value) {
  ;


  _impl_.best_buy_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBResponse::_internal_mutable_best_buy_price() {
  ;
  return _impl_.best_buy_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBResponse::release_best_buy_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_buy_price)
  return _impl_.best_buy_price_.Release();
}
inline void QuerySpotMidPriceAndTOBResponse::set_allocated_best_buy_price(std::string* value) {
  _impl_.best_buy_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.best_buy_price_.IsDefault()) {
          _impl_.best_buy_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_buy_price)
}

// string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QuerySpotMidPriceAndTOBResponse::clear_best_sell_price() {
  _impl_.best_sell_price_.ClearToEmpty();
}
inline const std::string& QuerySpotMidPriceAndTOBResponse::best_sell_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_sell_price)
  return _internal_best_sell_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySpotMidPriceAndTOBResponse::set_best_sell_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.best_sell_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_sell_price)
}
inline std::string* QuerySpotMidPriceAndTOBResponse::mutable_best_sell_price() {
  std::string* _s = _internal_mutable_best_sell_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_sell_price)
  return _s;
}
inline const std::string& QuerySpotMidPriceAndTOBResponse::_internal_best_sell_price() const {
  return _impl_.best_sell_price_.Get();
}
inline void QuerySpotMidPriceAndTOBResponse::_internal_set_best_sell_price(const std::string& value) {
  ;


  _impl_.best_sell_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBResponse::_internal_mutable_best_sell_price() {
  ;
  return _impl_.best_sell_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySpotMidPriceAndTOBResponse::release_best_sell_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_sell_price)
  return _impl_.best_sell_price_.Release();
}
inline void QuerySpotMidPriceAndTOBResponse::set_allocated_best_sell_price(std::string* value) {
  _impl_.best_sell_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.best_sell_price_.IsDefault()) {
          _impl_.best_sell_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySpotMidPriceAndTOBResponse.best_sell_price)
}

// -------------------------------------------------------------------

// QueryDerivativeMidPriceAndTOBRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryDerivativeMidPriceAndTOBRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMidPriceAndTOBRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMidPriceAndTOBRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest.market_id)
}
inline std::string* QueryDerivativeMidPriceAndTOBRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest.market_id)
  return _s;
}
inline const std::string& QueryDerivativeMidPriceAndTOBRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryDerivativeMidPriceAndTOBRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryDerivativeMidPriceAndTOBRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBRequest.market_id)
}

// -------------------------------------------------------------------

// QueryDerivativeMidPriceAndTOBResponse

// string mid_price = 1 [json_name = "midPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryDerivativeMidPriceAndTOBResponse::clear_mid_price() {
  _impl_.mid_price_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMidPriceAndTOBResponse::mid_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.mid_price)
  return _internal_mid_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMidPriceAndTOBResponse::set_mid_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mid_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.mid_price)
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::mutable_mid_price() {
  std::string* _s = _internal_mutable_mid_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.mid_price)
  return _s;
}
inline const std::string& QueryDerivativeMidPriceAndTOBResponse::_internal_mid_price() const {
  return _impl_.mid_price_.Get();
}
inline void QueryDerivativeMidPriceAndTOBResponse::_internal_set_mid_price(const std::string& value) {
  ;


  _impl_.mid_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::_internal_mutable_mid_price() {
  ;
  return _impl_.mid_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::release_mid_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.mid_price)
  return _impl_.mid_price_.Release();
}
inline void QueryDerivativeMidPriceAndTOBResponse::set_allocated_mid_price(std::string* value) {
  _impl_.mid_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mid_price_.IsDefault()) {
          _impl_.mid_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.mid_price)
}

// string best_buy_price = 2 [json_name = "bestBuyPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryDerivativeMidPriceAndTOBResponse::clear_best_buy_price() {
  _impl_.best_buy_price_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMidPriceAndTOBResponse::best_buy_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_buy_price)
  return _internal_best_buy_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMidPriceAndTOBResponse::set_best_buy_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.best_buy_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_buy_price)
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::mutable_best_buy_price() {
  std::string* _s = _internal_mutable_best_buy_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_buy_price)
  return _s;
}
inline const std::string& QueryDerivativeMidPriceAndTOBResponse::_internal_best_buy_price() const {
  return _impl_.best_buy_price_.Get();
}
inline void QueryDerivativeMidPriceAndTOBResponse::_internal_set_best_buy_price(const std::string& value) {
  ;


  _impl_.best_buy_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::_internal_mutable_best_buy_price() {
  ;
  return _impl_.best_buy_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::release_best_buy_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_buy_price)
  return _impl_.best_buy_price_.Release();
}
inline void QueryDerivativeMidPriceAndTOBResponse::set_allocated_best_buy_price(std::string* value) {
  _impl_.best_buy_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.best_buy_price_.IsDefault()) {
          _impl_.best_buy_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_buy_price)
}

// string best_sell_price = 3 [json_name = "bestSellPrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryDerivativeMidPriceAndTOBResponse::clear_best_sell_price() {
  _impl_.best_sell_price_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMidPriceAndTOBResponse::best_sell_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_sell_price)
  return _internal_best_sell_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMidPriceAndTOBResponse::set_best_sell_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.best_sell_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_sell_price)
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::mutable_best_sell_price() {
  std::string* _s = _internal_mutable_best_sell_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_sell_price)
  return _s;
}
inline const std::string& QueryDerivativeMidPriceAndTOBResponse::_internal_best_sell_price() const {
  return _impl_.best_sell_price_.Get();
}
inline void QueryDerivativeMidPriceAndTOBResponse::_internal_set_best_sell_price(const std::string& value) {
  ;


  _impl_.best_sell_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::_internal_mutable_best_sell_price() {
  ;
  return _impl_.best_sell_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMidPriceAndTOBResponse::release_best_sell_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_sell_price)
  return _impl_.best_sell_price_.Release();
}
inline void QueryDerivativeMidPriceAndTOBResponse::set_allocated_best_sell_price(std::string* value) {
  _impl_.best_sell_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.best_sell_price_.IsDefault()) {
          _impl_.best_sell_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMidPriceAndTOBResponse.best_sell_price)
}

// -------------------------------------------------------------------

// QueryDerivativeOrderbookRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryDerivativeOrderbookRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryDerivativeOrderbookRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeOrderbookRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.market_id)
}
inline std::string* QueryDerivativeOrderbookRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.market_id)
  return _s;
}
inline const std::string& QueryDerivativeOrderbookRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryDerivativeOrderbookRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrderbookRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrderbookRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryDerivativeOrderbookRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.market_id)
}

// uint64 limit = 2 [json_name = "limit"];
inline void QueryDerivativeOrderbookRequest::clear_limit() {
  _impl_.limit_ = ::uint64_t{0u};
}
inline ::uint64_t QueryDerivativeOrderbookRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.limit)
  return _internal_limit();
}
inline void QueryDerivativeOrderbookRequest::set_limit(::uint64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.limit)
}
inline ::uint64_t QueryDerivativeOrderbookRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void QueryDerivativeOrderbookRequest::_internal_set_limit(::uint64_t value) {
  ;
  _impl_.limit_ = value;
}

// string limit_cumulative_notional = 3 [json_name = "limitCumulativeNotional", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryDerivativeOrderbookRequest::clear_limit_cumulative_notional() {
  _impl_.limit_cumulative_notional_.ClearToEmpty();
}
inline const std::string& QueryDerivativeOrderbookRequest::limit_cumulative_notional() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.limit_cumulative_notional)
  return _internal_limit_cumulative_notional();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeOrderbookRequest::set_limit_cumulative_notional(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.limit_cumulative_notional_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.limit_cumulative_notional)
}
inline std::string* QueryDerivativeOrderbookRequest::mutable_limit_cumulative_notional() {
  std::string* _s = _internal_mutable_limit_cumulative_notional();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.limit_cumulative_notional)
  return _s;
}
inline const std::string& QueryDerivativeOrderbookRequest::_internal_limit_cumulative_notional() const {
  return _impl_.limit_cumulative_notional_.Get();
}
inline void QueryDerivativeOrderbookRequest::_internal_set_limit_cumulative_notional(const std::string& value) {
  ;


  _impl_.limit_cumulative_notional_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrderbookRequest::_internal_mutable_limit_cumulative_notional() {
  ;
  return _impl_.limit_cumulative_notional_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrderbookRequest::release_limit_cumulative_notional() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.limit_cumulative_notional)
  return _impl_.limit_cumulative_notional_.Release();
}
inline void QueryDerivativeOrderbookRequest::set_allocated_limit_cumulative_notional(std::string* value) {
  _impl_.limit_cumulative_notional_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.limit_cumulative_notional_.IsDefault()) {
          _impl_.limit_cumulative_notional_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeOrderbookRequest.limit_cumulative_notional)
}

// -------------------------------------------------------------------

// QueryDerivativeOrderbookResponse

// repeated .injective.exchange.v1beta1.Level buys_price_level = 1 [json_name = "buysPriceLevel"];
inline int QueryDerivativeOrderbookResponse::_internal_buys_price_level_size() const {
  return _impl_.buys_price_level_.size();
}
inline int QueryDerivativeOrderbookResponse::buys_price_level_size() const {
  return _internal_buys_price_level_size();
}
inline ::injective::exchange::v1beta1::Level* QueryDerivativeOrderbookResponse::mutable_buys_price_level(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.buys_price_level)
  return _internal_mutable_buys_price_level()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
QueryDerivativeOrderbookResponse::mutable_buys_price_level() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.buys_price_level)
  return _internal_mutable_buys_price_level();
}
inline const ::injective::exchange::v1beta1::Level& QueryDerivativeOrderbookResponse::_internal_buys_price_level(int index) const {
  return _internal_buys_price_level().Get(index);
}
inline const ::injective::exchange::v1beta1::Level& QueryDerivativeOrderbookResponse::buys_price_level(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.buys_price_level)
  return _internal_buys_price_level(index);
}
inline ::injective::exchange::v1beta1::Level* QueryDerivativeOrderbookResponse::_internal_add_buys_price_level() {
  return _internal_mutable_buys_price_level()->Add();
}
inline ::injective::exchange::v1beta1::Level* QueryDerivativeOrderbookResponse::add_buys_price_level() {
  ::injective::exchange::v1beta1::Level* _add = _internal_add_buys_price_level();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.buys_price_level)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
QueryDerivativeOrderbookResponse::buys_price_level() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.buys_price_level)
  return _internal_buys_price_level();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>&
QueryDerivativeOrderbookResponse::_internal_buys_price_level() const {
  return _impl_.buys_price_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>*
QueryDerivativeOrderbookResponse::_internal_mutable_buys_price_level() {
  return &_impl_.buys_price_level_;
}

// repeated .injective.exchange.v1beta1.Level sells_price_level = 2 [json_name = "sellsPriceLevel"];
inline int QueryDerivativeOrderbookResponse::_internal_sells_price_level_size() const {
  return _impl_.sells_price_level_.size();
}
inline int QueryDerivativeOrderbookResponse::sells_price_level_size() const {
  return _internal_sells_price_level_size();
}
inline ::injective::exchange::v1beta1::Level* QueryDerivativeOrderbookResponse::mutable_sells_price_level(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.sells_price_level)
  return _internal_mutable_sells_price_level()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >*
QueryDerivativeOrderbookResponse::mutable_sells_price_level() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.sells_price_level)
  return _internal_mutable_sells_price_level();
}
inline const ::injective::exchange::v1beta1::Level& QueryDerivativeOrderbookResponse::_internal_sells_price_level(int index) const {
  return _internal_sells_price_level().Get(index);
}
inline const ::injective::exchange::v1beta1::Level& QueryDerivativeOrderbookResponse::sells_price_level(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.sells_price_level)
  return _internal_sells_price_level(index);
}
inline ::injective::exchange::v1beta1::Level* QueryDerivativeOrderbookResponse::_internal_add_sells_price_level() {
  return _internal_mutable_sells_price_level()->Add();
}
inline ::injective::exchange::v1beta1::Level* QueryDerivativeOrderbookResponse::add_sells_price_level() {
  ::injective::exchange::v1beta1::Level* _add = _internal_add_sells_price_level();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.sells_price_level)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::Level >&
QueryDerivativeOrderbookResponse::sells_price_level() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDerivativeOrderbookResponse.sells_price_level)
  return _internal_sells_price_level();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>&
QueryDerivativeOrderbookResponse::_internal_sells_price_level() const {
  return _impl_.sells_price_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::Level>*
QueryDerivativeOrderbookResponse::_internal_mutable_sells_price_level() {
  return &_impl_.sells_price_level_;
}

// -------------------------------------------------------------------

// QueryTraderSpotOrdersToCancelUpToAmountRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.market_id)
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.market_id)
  return _s;
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.subaccount_id)
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.subaccount_id)
  return _s;
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.subaccount_id)
}

// string base_amount = 3 [json_name = "baseAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::clear_base_amount() {
  _impl_.base_amount_.ClearToEmpty();
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::base_amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.base_amount)
  return _internal_base_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_base_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.base_amount)
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::mutable_base_amount() {
  std::string* _s = _internal_mutable_base_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.base_amount)
  return _s;
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_base_amount() const {
  return _impl_.base_amount_.Get();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_set_base_amount(const std::string& value) {
  ;


  _impl_.base_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_mutable_base_amount() {
  ;
  return _impl_.base_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::release_base_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.base_amount)
  return _impl_.base_amount_.Release();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_allocated_base_amount(std::string* value) {
  _impl_.base_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_amount_.IsDefault()) {
          _impl_.base_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.base_amount)
}

// string quote_amount = 4 [json_name = "quoteAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::clear_quote_amount() {
  _impl_.quote_amount_.ClearToEmpty();
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::quote_amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.quote_amount)
  return _internal_quote_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_quote_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.quote_amount)
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::mutable_quote_amount() {
  std::string* _s = _internal_mutable_quote_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.quote_amount)
  return _s;
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_quote_amount() const {
  return _impl_.quote_amount_.Get();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_set_quote_amount(const std::string& value) {
  ;


  _impl_.quote_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_mutable_quote_amount() {
  ;
  return _impl_.quote_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::release_quote_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.quote_amount)
  return _impl_.quote_amount_.Release();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_allocated_quote_amount(std::string* value) {
  _impl_.quote_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_amount_.IsDefault()) {
          _impl_.quote_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.quote_amount)
}

// .injective.exchange.v1beta1.CancellationStrategy strategy = 5 [json_name = "strategy"];
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::injective::exchange::v1beta1::CancellationStrategy QueryTraderSpotOrdersToCancelUpToAmountRequest::strategy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.strategy)
  return _internal_strategy();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_strategy(::injective::exchange::v1beta1::CancellationStrategy value) {
   _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.strategy)
}
inline ::injective::exchange::v1beta1::CancellationStrategy QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_strategy() const {
  return static_cast<::injective::exchange::v1beta1::CancellationStrategy>(_impl_.strategy_);
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_set_strategy(::injective::exchange::v1beta1::CancellationStrategy value) {
  ;
  _impl_.strategy_ = value;
}

// string reference_price = 6 [json_name = "referencePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::clear_reference_price() {
  _impl_.reference_price_.ClearToEmpty();
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::reference_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.reference_price)
  return _internal_reference_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_reference_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reference_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.reference_price)
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::mutable_reference_price() {
  std::string* _s = _internal_mutable_reference_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.reference_price)
  return _s;
}
inline const std::string& QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_reference_price() const {
  return _impl_.reference_price_.Get();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_set_reference_price(const std::string& value) {
  ;


  _impl_.reference_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::_internal_mutable_reference_price() {
  ;
  return _impl_.reference_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderSpotOrdersToCancelUpToAmountRequest::release_reference_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.reference_price)
  return _impl_.reference_price_.Release();
}
inline void QueryTraderSpotOrdersToCancelUpToAmountRequest::set_allocated_reference_price(std::string* value) {
  _impl_.reference_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reference_price_.IsDefault()) {
          _impl_.reference_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderSpotOrdersToCancelUpToAmountRequest.reference_price)
}

// -------------------------------------------------------------------

// QueryTraderDerivativeOrdersToCancelUpToAmountRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.market_id)
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.market_id)
  return _s;
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.subaccount_id)
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.subaccount_id)
  return _s;
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.subaccount_id)
}

// string quote_amount = 3 [json_name = "quoteAmount", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::clear_quote_amount() {
  _impl_.quote_amount_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::quote_amount() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.quote_amount)
  return _internal_quote_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_quote_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.quote_amount)
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::mutable_quote_amount() {
  std::string* _s = _internal_mutable_quote_amount();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.quote_amount)
  return _s;
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_quote_amount() const {
  return _impl_.quote_amount_.Get();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_set_quote_amount(const std::string& value) {
  ;


  _impl_.quote_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_mutable_quote_amount() {
  ;
  return _impl_.quote_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::release_quote_amount() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.quote_amount)
  return _impl_.quote_amount_.Release();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_allocated_quote_amount(std::string* value) {
  _impl_.quote_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_amount_.IsDefault()) {
          _impl_.quote_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.quote_amount)
}

// .injective.exchange.v1beta1.CancellationStrategy strategy = 4 [json_name = "strategy"];
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::injective::exchange::v1beta1::CancellationStrategy QueryTraderDerivativeOrdersToCancelUpToAmountRequest::strategy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.strategy)
  return _internal_strategy();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_strategy(::injective::exchange::v1beta1::CancellationStrategy value) {
   _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.strategy)
}
inline ::injective::exchange::v1beta1::CancellationStrategy QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_strategy() const {
  return static_cast<::injective::exchange::v1beta1::CancellationStrategy>(_impl_.strategy_);
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_set_strategy(::injective::exchange::v1beta1::CancellationStrategy value) {
  ;
  _impl_.strategy_ = value;
}

// string reference_price = 5 [json_name = "referencePrice", (.gogoproto.nullable) = true, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::clear_reference_price() {
  _impl_.reference_price_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::reference_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.reference_price)
  return _internal_reference_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_reference_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reference_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.reference_price)
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::mutable_reference_price() {
  std::string* _s = _internal_mutable_reference_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.reference_price)
  return _s;
}
inline const std::string& QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_reference_price() const {
  return _impl_.reference_price_.Get();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_set_reference_price(const std::string& value) {
  ;


  _impl_.reference_price_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::_internal_mutable_reference_price() {
  ;
  return _impl_.reference_price_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersToCancelUpToAmountRequest::release_reference_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.reference_price)
  return _impl_.reference_price_.Release();
}
inline void QueryTraderDerivativeOrdersToCancelUpToAmountRequest::set_allocated_reference_price(std::string* value) {
  _impl_.reference_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reference_price_.IsDefault()) {
          _impl_.reference_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeOrdersToCancelUpToAmountRequest.reference_price)
}

// -------------------------------------------------------------------

// QueryTraderDerivativeOrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryTraderDerivativeOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.market_id)
}
inline std::string* QueryTraderDerivativeOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.market_id)
  return _s;
}
inline const std::string& QueryTraderDerivativeOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryTraderDerivativeOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryTraderDerivativeOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void QueryTraderDerivativeOrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeOrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeOrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.subaccount_id)
}
inline std::string* QueryTraderDerivativeOrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& QueryTraderDerivativeOrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QueryTraderDerivativeOrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeOrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QueryTraderDerivativeOrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeOrdersRequest.subaccount_id)
}

// -------------------------------------------------------------------

// QueryAccountAddressDerivativeOrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryAccountAddressDerivativeOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryAccountAddressDerivativeOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAccountAddressDerivativeOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.market_id)
}
inline std::string* QueryAccountAddressDerivativeOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.market_id)
  return _s;
}
inline const std::string& QueryAccountAddressDerivativeOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryAccountAddressDerivativeOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAccountAddressDerivativeOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryAccountAddressDerivativeOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryAccountAddressDerivativeOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.market_id)
}

// string account_address = 2 [json_name = "accountAddress"];
inline void QueryAccountAddressDerivativeOrdersRequest::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& QueryAccountAddressDerivativeOrdersRequest::account_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAccountAddressDerivativeOrdersRequest::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.account_address)
}
inline std::string* QueryAccountAddressDerivativeOrdersRequest::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.account_address)
  return _s;
}
inline const std::string& QueryAccountAddressDerivativeOrdersRequest::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void QueryAccountAddressDerivativeOrdersRequest::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAccountAddressDerivativeOrdersRequest::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryAccountAddressDerivativeOrdersRequest::release_account_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.account_address)
  return _impl_.account_address_.Release();
}
inline void QueryAccountAddressDerivativeOrdersRequest::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersRequest.account_address)
}

// -------------------------------------------------------------------

// TrimmedDerivativeLimitOrder

// string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeLimitOrder::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeLimitOrder::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeLimitOrder::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.price)
}
inline std::string* TrimmedDerivativeLimitOrder::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.price)
  return _s;
}
inline const std::string& TrimmedDerivativeLimitOrder::_internal_price() const {
  return _impl_.price_.Get();
}
inline void TrimmedDerivativeLimitOrder::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.price)
  return _impl_.price_.Release();
}
inline void TrimmedDerivativeLimitOrder::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.price)
}

// string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeLimitOrder::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeLimitOrder::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeLimitOrder::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.quantity)
}
inline std::string* TrimmedDerivativeLimitOrder::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.quantity)
  return _s;
}
inline const std::string& TrimmedDerivativeLimitOrder::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void TrimmedDerivativeLimitOrder::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.quantity)
  return _impl_.quantity_.Release();
}
inline void TrimmedDerivativeLimitOrder::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.quantity)
}

// string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeLimitOrder::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeLimitOrder::margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeLimitOrder::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.margin)
}
inline std::string* TrimmedDerivativeLimitOrder::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.margin)
  return _s;
}
inline const std::string& TrimmedDerivativeLimitOrder::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void TrimmedDerivativeLimitOrder::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::release_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.margin)
  return _impl_.margin_.Release();
}
inline void TrimmedDerivativeLimitOrder::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.margin)
}

// string fillable = 4 [json_name = "fillable", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeLimitOrder::clear_fillable() {
  _impl_.fillable_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeLimitOrder::fillable() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.fillable)
  return _internal_fillable();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeLimitOrder::set_fillable(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fillable_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.fillable)
}
inline std::string* TrimmedDerivativeLimitOrder::mutable_fillable() {
  std::string* _s = _internal_mutable_fillable();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.fillable)
  return _s;
}
inline const std::string& TrimmedDerivativeLimitOrder::_internal_fillable() const {
  return _impl_.fillable_.Get();
}
inline void TrimmedDerivativeLimitOrder::_internal_set_fillable(const std::string& value) {
  ;


  _impl_.fillable_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::_internal_mutable_fillable() {
  ;
  return _impl_.fillable_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::release_fillable() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.fillable)
  return _impl_.fillable_.Release();
}
inline void TrimmedDerivativeLimitOrder::set_allocated_fillable(std::string* value) {
  _impl_.fillable_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fillable_.IsDefault()) {
          _impl_.fillable_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.fillable)
}

// bool isBuy = 5 [json_name = "isBuy", (.gogoproto.jsontag) = "isBuy"];
inline void TrimmedDerivativeLimitOrder::clear_isbuy() {
  _impl_.isbuy_ = false;
}
inline bool TrimmedDerivativeLimitOrder::isbuy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.isBuy)
  return _internal_isbuy();
}
inline void TrimmedDerivativeLimitOrder::set_isbuy(bool value) {
  _internal_set_isbuy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.isBuy)
}
inline bool TrimmedDerivativeLimitOrder::_internal_isbuy() const {
  return _impl_.isbuy_;
}
inline void TrimmedDerivativeLimitOrder::_internal_set_isbuy(bool value) {
  ;
  _impl_.isbuy_ = value;
}

// string order_hash = 6 [json_name = "orderHash"];
inline void TrimmedDerivativeLimitOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeLimitOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeLimitOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.order_hash)
}
inline std::string* TrimmedDerivativeLimitOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.order_hash)
  return _s;
}
inline const std::string& TrimmedDerivativeLimitOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void TrimmedDerivativeLimitOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeLimitOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void TrimmedDerivativeLimitOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeLimitOrder.order_hash)
}

// -------------------------------------------------------------------

// QueryTraderDerivativeOrdersResponse

// repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1 [json_name = "orders"];
inline int QueryTraderDerivativeOrdersResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int QueryTraderDerivativeOrdersResponse::orders_size() const {
  return _internal_orders_size();
}
inline void QueryTraderDerivativeOrdersResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryTraderDerivativeOrdersResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >*
QueryTraderDerivativeOrdersResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& QueryTraderDerivativeOrdersResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& QueryTraderDerivativeOrdersResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryTraderDerivativeOrdersResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryTraderDerivativeOrdersResponse::add_orders() {
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >&
QueryTraderDerivativeOrdersResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTraderDerivativeOrdersResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>&
QueryTraderDerivativeOrdersResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>*
QueryTraderDerivativeOrdersResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// QueryAccountAddressDerivativeOrdersResponse

// repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1 [json_name = "orders"];
inline int QueryAccountAddressDerivativeOrdersResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int QueryAccountAddressDerivativeOrdersResponse::orders_size() const {
  return _internal_orders_size();
}
inline void QueryAccountAddressDerivativeOrdersResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryAccountAddressDerivativeOrdersResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >*
QueryAccountAddressDerivativeOrdersResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& QueryAccountAddressDerivativeOrdersResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& QueryAccountAddressDerivativeOrdersResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryAccountAddressDerivativeOrdersResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryAccountAddressDerivativeOrdersResponse::add_orders() {
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >&
QueryAccountAddressDerivativeOrdersResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryAccountAddressDerivativeOrdersResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>&
QueryAccountAddressDerivativeOrdersResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>*
QueryAccountAddressDerivativeOrdersResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// QueryDerivativeOrdersByHashesRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryDerivativeOrdersByHashesRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryDerivativeOrdersByHashesRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeOrdersByHashesRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.market_id)
}
inline std::string* QueryDerivativeOrdersByHashesRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.market_id)
  return _s;
}
inline const std::string& QueryDerivativeOrdersByHashesRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryDerivativeOrdersByHashesRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrdersByHashesRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrdersByHashesRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryDerivativeOrdersByHashesRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void QueryDerivativeOrdersByHashesRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QueryDerivativeOrdersByHashesRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeOrdersByHashesRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.subaccount_id)
}
inline std::string* QueryDerivativeOrdersByHashesRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.subaccount_id)
  return _s;
}
inline const std::string& QueryDerivativeOrdersByHashesRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QueryDerivativeOrdersByHashesRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrdersByHashesRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeOrdersByHashesRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QueryDerivativeOrdersByHashesRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.subaccount_id)
}

// repeated string order_hashes = 3 [json_name = "orderHashes"];
inline int QueryDerivativeOrdersByHashesRequest::_internal_order_hashes_size() const {
  return _impl_.order_hashes_.size();
}
inline int QueryDerivativeOrdersByHashesRequest::order_hashes_size() const {
  return _internal_order_hashes_size();
}
inline void QueryDerivativeOrdersByHashesRequest::clear_order_hashes() {
  _internal_mutable_order_hashes()->Clear();
}
inline std::string* QueryDerivativeOrdersByHashesRequest::add_order_hashes() {
  std::string* _s = _internal_add_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
  return _s;
}
inline const std::string& QueryDerivativeOrdersByHashesRequest::order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
  return _internal_order_hashes(index);
}
inline std::string* QueryDerivativeOrdersByHashesRequest::mutable_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
  return _internal_mutable_order_hashes()->Mutable(index);
}
inline void QueryDerivativeOrdersByHashesRequest::set_order_hashes(int index, const std::string& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::set_order_hashes(int index, std::string&& value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::set_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::set_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::set_order_hashes(int index, absl::string_view value) {
  _internal_mutable_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::add_order_hashes(const std::string& value) {
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::add_order_hashes(std::string&& value) {
  _internal_mutable_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::add_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::add_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline void QueryDerivativeOrdersByHashesRequest::add_order_hashes(absl::string_view value) {
  _internal_mutable_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryDerivativeOrdersByHashesRequest::order_hashes() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
  return _internal_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryDerivativeOrdersByHashesRequest::mutable_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesRequest.order_hashes)
  return _internal_mutable_order_hashes();
}
inline const std::string& QueryDerivativeOrdersByHashesRequest::_internal_order_hashes(int index) const {
  return _internal_order_hashes().Get(index);
}
inline std::string* QueryDerivativeOrdersByHashesRequest::_internal_add_order_hashes() {
  return _internal_mutable_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryDerivativeOrdersByHashesRequest::_internal_order_hashes() const {
  return _impl_.order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryDerivativeOrdersByHashesRequest::_internal_mutable_order_hashes() {
  return &_impl_.order_hashes_;
}

// -------------------------------------------------------------------

// QueryDerivativeOrdersByHashesResponse

// repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1 [json_name = "orders"];
inline int QueryDerivativeOrdersByHashesResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int QueryDerivativeOrdersByHashesResponse::orders_size() const {
  return _internal_orders_size();
}
inline void QueryDerivativeOrdersByHashesResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryDerivativeOrdersByHashesResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >*
QueryDerivativeOrdersByHashesResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& QueryDerivativeOrdersByHashesResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder& QueryDerivativeOrdersByHashesResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryDerivativeOrdersByHashesResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* QueryDerivativeOrdersByHashesResponse::add_orders() {
  ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder >&
QueryDerivativeOrdersByHashesResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDerivativeOrdersByHashesResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>&
QueryDerivativeOrdersByHashesResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeLimitOrder>*
QueryDerivativeOrdersByHashesResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// QueryDerivativeMarketsRequest

// string status = 1 [json_name = "status"];
inline void QueryDerivativeMarketsRequest::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMarketsRequest::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMarketsRequest::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.status)
}
inline std::string* QueryDerivativeMarketsRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.status)
  return _s;
}
inline const std::string& QueryDerivativeMarketsRequest::_internal_status() const {
  return _impl_.status_.Get();
}
inline void QueryDerivativeMarketsRequest::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketsRequest::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketsRequest::release_status() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.status)
  return _impl_.status_.Release();
}
inline void QueryDerivativeMarketsRequest::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.status)
}

// repeated string market_ids = 2 [json_name = "marketIds"];
inline int QueryDerivativeMarketsRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int QueryDerivativeMarketsRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void QueryDerivativeMarketsRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* QueryDerivativeMarketsRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
  return _s;
}
inline const std::string& QueryDerivativeMarketsRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* QueryDerivativeMarketsRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void QueryDerivativeMarketsRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline void QueryDerivativeMarketsRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryDerivativeMarketsRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryDerivativeMarketsRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& QueryDerivativeMarketsRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* QueryDerivativeMarketsRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryDerivativeMarketsRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryDerivativeMarketsRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// bool with_mid_price_and_tob = 3 [json_name = "withMidPriceAndTob"];
inline void QueryDerivativeMarketsRequest::clear_with_mid_price_and_tob() {
  _impl_.with_mid_price_and_tob_ = false;
}
inline bool QueryDerivativeMarketsRequest::with_mid_price_and_tob() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.with_mid_price_and_tob)
  return _internal_with_mid_price_and_tob();
}
inline void QueryDerivativeMarketsRequest::set_with_mid_price_and_tob(bool value) {
  _internal_set_with_mid_price_and_tob(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketsRequest.with_mid_price_and_tob)
}
inline bool QueryDerivativeMarketsRequest::_internal_with_mid_price_and_tob() const {
  return _impl_.with_mid_price_and_tob_;
}
inline void QueryDerivativeMarketsRequest::_internal_set_with_mid_price_and_tob(bool value) {
  ;
  _impl_.with_mid_price_and_tob_ = value;
}

// -------------------------------------------------------------------

// PriceLevel

// string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PriceLevel::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceLevel::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PriceLevel.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevel::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PriceLevel.price)
}
inline std::string* PriceLevel::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PriceLevel.price)
  return _s;
}
inline const std::string& PriceLevel::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceLevel::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevel::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevel::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PriceLevel.price)
  return _impl_.price_.Release();
}
inline void PriceLevel::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PriceLevel.price)
}

// string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void PriceLevel::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& PriceLevel::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PriceLevel.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevel::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.PriceLevel.quantity)
}
inline std::string* PriceLevel::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PriceLevel.quantity)
  return _s;
}
inline const std::string& PriceLevel::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void PriceLevel::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevel::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevel::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PriceLevel.quantity)
  return _impl_.quantity_.Release();
}
inline void PriceLevel::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PriceLevel.quantity)
}

// -------------------------------------------------------------------

// PerpetualMarketState

// .injective.exchange.v1beta1.PerpetualMarketInfo market_info = 1 [json_name = "marketInfo"];
inline bool PerpetualMarketState::has_market_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PerpetualMarketInfo& PerpetualMarketState::_internal_market_info() const {
  const ::injective::exchange::v1beta1::PerpetualMarketInfo* p = _impl_.market_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PerpetualMarketInfo&>(
      ::injective::exchange::v1beta1::_PerpetualMarketInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketInfo& PerpetualMarketState::market_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketState.market_info)
  return _internal_market_info();
}
inline void PerpetualMarketState::unsafe_arena_set_allocated_market_info(
    ::injective::exchange::v1beta1::PerpetualMarketInfo* market_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_info_);
  }
  _impl_.market_info_ = market_info;
  if (market_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.PerpetualMarketState.market_info)
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* PerpetualMarketState::release_market_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* temp = _impl_.market_info_;
  _impl_.market_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* PerpetualMarketState::unsafe_arena_release_market_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketState.market_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* temp = _impl_.market_info_;
  _impl_.market_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* PerpetualMarketState::_internal_mutable_market_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketInfo>(GetArenaForAllocation());
    _impl_.market_info_ = p;
  }
  return _impl_.market_info_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* PerpetualMarketState::mutable_market_info() {
  ::injective::exchange::v1beta1::PerpetualMarketInfo* _msg = _internal_mutable_market_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketState.market_info)
  return _msg;
}
inline void PerpetualMarketState::set_allocated_market_info(::injective::exchange::v1beta1::PerpetualMarketInfo* market_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_info_);
  }
  if (market_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_info));
    if (message_arena != submessage_arena) {
      market_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_info_ = market_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketState.market_info)
}

// .injective.exchange.v1beta1.PerpetualMarketFunding funding_info = 2 [json_name = "fundingInfo"];
inline bool PerpetualMarketState::has_funding_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.funding_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& PerpetualMarketState::_internal_funding_info() const {
  const ::injective::exchange::v1beta1::PerpetualMarketFunding* p = _impl_.funding_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PerpetualMarketFunding&>(
      ::injective::exchange::v1beta1::_PerpetualMarketFunding_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& PerpetualMarketState::funding_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.PerpetualMarketState.funding_info)
  return _internal_funding_info();
}
inline void PerpetualMarketState::unsafe_arena_set_allocated_funding_info(
    ::injective::exchange::v1beta1::PerpetualMarketFunding* funding_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funding_info_);
  }
  _impl_.funding_info_ = funding_info;
  if (funding_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.PerpetualMarketState.funding_info)
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* PerpetualMarketState::release_funding_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.funding_info_;
  _impl_.funding_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* PerpetualMarketState::unsafe_arena_release_funding_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.PerpetualMarketState.funding_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.funding_info_;
  _impl_.funding_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* PerpetualMarketState::_internal_mutable_funding_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.funding_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketFunding>(GetArenaForAllocation());
    _impl_.funding_info_ = p;
  }
  return _impl_.funding_info_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* PerpetualMarketState::mutable_funding_info() {
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _msg = _internal_mutable_funding_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.PerpetualMarketState.funding_info)
  return _msg;
}
inline void PerpetualMarketState::set_allocated_funding_info(::injective::exchange::v1beta1::PerpetualMarketFunding* funding_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.funding_info_);
  }
  if (funding_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(funding_info));
    if (message_arena != submessage_arena) {
      funding_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, funding_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.funding_info_ = funding_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.PerpetualMarketState.funding_info)
}

// -------------------------------------------------------------------

// FullDerivativeMarket

// .injective.exchange.v1beta1.DerivativeMarket market = 1 [json_name = "market"];
inline bool FullDerivativeMarket::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::DerivativeMarket& FullDerivativeMarket::_internal_market() const {
  const ::injective::exchange::v1beta1::DerivativeMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::DerivativeMarket&>(
      ::injective::exchange::v1beta1::_DerivativeMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::DerivativeMarket& FullDerivativeMarket::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FullDerivativeMarket.market)
  return _internal_market();
}
inline void FullDerivativeMarket::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::DerivativeMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.FullDerivativeMarket.market)
}
inline ::injective::exchange::v1beta1::DerivativeMarket* FullDerivativeMarket::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* FullDerivativeMarket::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FullDerivativeMarket.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::DerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* FullDerivativeMarket::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::DerivativeMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::DerivativeMarket* FullDerivativeMarket::mutable_market() {
  ::injective::exchange::v1beta1::DerivativeMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FullDerivativeMarket.market)
  return _msg;
}
inline void FullDerivativeMarket::set_allocated_market(::injective::exchange::v1beta1::DerivativeMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market));
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FullDerivativeMarket.market)
}

// .injective.exchange.v1beta1.PerpetualMarketState perpetual_info = 2 [json_name = "perpetualInfo"];
inline bool FullDerivativeMarket::has_perpetual_info() const {
  return info_case() == kPerpetualInfo;
}
inline bool FullDerivativeMarket::_internal_has_perpetual_info() const {
  return info_case() == kPerpetualInfo;
}
inline void FullDerivativeMarket::set_has_perpetual_info() {
  _impl_._oneof_case_[0] = kPerpetualInfo;
}
inline void FullDerivativeMarket::clear_perpetual_info() {
  if (info_case() == kPerpetualInfo) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.info_.perpetual_info_;
    }
    clear_has_info();
  }
}
inline ::injective::exchange::v1beta1::PerpetualMarketState* FullDerivativeMarket::release_perpetual_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FullDerivativeMarket.perpetual_info)
  if (info_case() == kPerpetualInfo) {
    clear_has_info();
    ::injective::exchange::v1beta1::PerpetualMarketState* temp = _impl_.info_.perpetual_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.info_.perpetual_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::injective::exchange::v1beta1::PerpetualMarketState& FullDerivativeMarket::_internal_perpetual_info() const {
  return info_case() == kPerpetualInfo
      ? *_impl_.info_.perpetual_info_
      : reinterpret_cast<::injective::exchange::v1beta1::PerpetualMarketState&>(::injective::exchange::v1beta1::_PerpetualMarketState_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketState& FullDerivativeMarket::perpetual_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FullDerivativeMarket.perpetual_info)
  return _internal_perpetual_info();
}
inline ::injective::exchange::v1beta1::PerpetualMarketState* FullDerivativeMarket::unsafe_arena_release_perpetual_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:injective.exchange.v1beta1.FullDerivativeMarket.perpetual_info)
  if (info_case() == kPerpetualInfo) {
    clear_has_info();
    ::injective::exchange::v1beta1::PerpetualMarketState* temp = _impl_.info_.perpetual_info_;
    _impl_.info_.perpetual_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FullDerivativeMarket::unsafe_arena_set_allocated_perpetual_info(::injective::exchange::v1beta1::PerpetualMarketState* perpetual_info) {
  clear_info();
  if (perpetual_info) {
    set_has_perpetual_info();
    _impl_.info_.perpetual_info_ = perpetual_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.FullDerivativeMarket.perpetual_info)
}
inline ::injective::exchange::v1beta1::PerpetualMarketState* FullDerivativeMarket::_internal_mutable_perpetual_info() {
  if (info_case() != kPerpetualInfo) {
    clear_info();
    set_has_perpetual_info();
    _impl_.info_.perpetual_info_ = CreateMaybeMessage< ::injective::exchange::v1beta1::PerpetualMarketState >(GetArenaForAllocation());
  }
  return _impl_.info_.perpetual_info_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketState* FullDerivativeMarket::mutable_perpetual_info() {
  ::injective::exchange::v1beta1::PerpetualMarketState* _msg = _internal_mutable_perpetual_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FullDerivativeMarket.perpetual_info)
  return _msg;
}

// .injective.exchange.v1beta1.ExpiryFuturesMarketInfo futures_info = 3 [json_name = "futuresInfo"];
inline bool FullDerivativeMarket::has_futures_info() const {
  return info_case() == kFuturesInfo;
}
inline bool FullDerivativeMarket::_internal_has_futures_info() const {
  return info_case() == kFuturesInfo;
}
inline void FullDerivativeMarket::set_has_futures_info() {
  _impl_._oneof_case_[0] = kFuturesInfo;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* FullDerivativeMarket::release_futures_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FullDerivativeMarket.futures_info)
  if (info_case() == kFuturesInfo) {
    clear_has_info();
    ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* temp = _impl_.info_.futures_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.info_.futures_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& FullDerivativeMarket::_internal_futures_info() const {
  return info_case() == kFuturesInfo
      ? *_impl_.info_.futures_info_
      : reinterpret_cast<::injective::exchange::v1beta1::ExpiryFuturesMarketInfo&>(::injective::exchange::v1beta1::_ExpiryFuturesMarketInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& FullDerivativeMarket::futures_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FullDerivativeMarket.futures_info)
  return _internal_futures_info();
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* FullDerivativeMarket::unsafe_arena_release_futures_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:injective.exchange.v1beta1.FullDerivativeMarket.futures_info)
  if (info_case() == kFuturesInfo) {
    clear_has_info();
    ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* temp = _impl_.info_.futures_info_;
    _impl_.info_.futures_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FullDerivativeMarket::unsafe_arena_set_allocated_futures_info(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* futures_info) {
  clear_info();
  if (futures_info) {
    set_has_futures_info();
    _impl_.info_.futures_info_ = futures_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.FullDerivativeMarket.futures_info)
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* FullDerivativeMarket::_internal_mutable_futures_info() {
  if (info_case() != kFuturesInfo) {
    clear_info();
    set_has_futures_info();
    _impl_.info_.futures_info_ = CreateMaybeMessage< ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo >(GetArenaForAllocation());
  }
  return _impl_.info_.futures_info_;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* FullDerivativeMarket::mutable_futures_info() {
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* _msg = _internal_mutable_futures_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FullDerivativeMarket.futures_info)
  return _msg;
}

// string mark_price = 4 [json_name = "markPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void FullDerivativeMarket::clear_mark_price() {
  _impl_.mark_price_.ClearToEmpty();
}
inline const std::string& FullDerivativeMarket::mark_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FullDerivativeMarket.mark_price)
  return _internal_mark_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FullDerivativeMarket::set_mark_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mark_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.FullDerivativeMarket.mark_price)
}
inline std::string* FullDerivativeMarket::mutable_mark_price() {
  std::string* _s = _internal_mutable_mark_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FullDerivativeMarket.mark_price)
  return _s;
}
inline const std::string& FullDerivativeMarket::_internal_mark_price() const {
  return _impl_.mark_price_.Get();
}
inline void FullDerivativeMarket::_internal_set_mark_price(const std::string& value) {
  ;


  _impl_.mark_price_.Set(value, GetArenaForAllocation());
}
inline std::string* FullDerivativeMarket::_internal_mutable_mark_price() {
  ;
  return _impl_.mark_price_.Mutable( GetArenaForAllocation());
}
inline std::string* FullDerivativeMarket::release_mark_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FullDerivativeMarket.mark_price)
  return _impl_.mark_price_.Release();
}
inline void FullDerivativeMarket::set_allocated_mark_price(std::string* value) {
  _impl_.mark_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mark_price_.IsDefault()) {
          _impl_.mark_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FullDerivativeMarket.mark_price)
}

// .injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 5 [json_name = "midPriceAndTob", (.gogoproto.nullable) = true];
inline bool FullDerivativeMarket::has_mid_price_and_tob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mid_price_and_tob_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::MidPriceAndTOB& FullDerivativeMarket::_internal_mid_price_and_tob() const {
  const ::injective::exchange::v1beta1::MidPriceAndTOB* p = _impl_.mid_price_and_tob_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::MidPriceAndTOB&>(
      ::injective::exchange::v1beta1::_MidPriceAndTOB_default_instance_);
}
inline const ::injective::exchange::v1beta1::MidPriceAndTOB& FullDerivativeMarket::mid_price_and_tob() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.FullDerivativeMarket.mid_price_and_tob)
  return _internal_mid_price_and_tob();
}
inline void FullDerivativeMarket::unsafe_arena_set_allocated_mid_price_and_tob(
    ::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mid_price_and_tob_);
  }
  _impl_.mid_price_and_tob_ = mid_price_and_tob;
  if (mid_price_and_tob) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.FullDerivativeMarket.mid_price_and_tob)
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullDerivativeMarket::release_mid_price_and_tob() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::MidPriceAndTOB* temp = _impl_.mid_price_and_tob_;
  _impl_.mid_price_and_tob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullDerivativeMarket::unsafe_arena_release_mid_price_and_tob() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.FullDerivativeMarket.mid_price_and_tob)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::MidPriceAndTOB* temp = _impl_.mid_price_and_tob_;
  _impl_.mid_price_and_tob_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullDerivativeMarket::_internal_mutable_mid_price_and_tob() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.mid_price_and_tob_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::MidPriceAndTOB>(GetArenaForAllocation());
    _impl_.mid_price_and_tob_ = p;
  }
  return _impl_.mid_price_and_tob_;
}
inline ::injective::exchange::v1beta1::MidPriceAndTOB* FullDerivativeMarket::mutable_mid_price_and_tob() {
  ::injective::exchange::v1beta1::MidPriceAndTOB* _msg = _internal_mutable_mid_price_and_tob();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.FullDerivativeMarket.mid_price_and_tob)
  return _msg;
}
inline void FullDerivativeMarket::set_allocated_mid_price_and_tob(::injective::exchange::v1beta1::MidPriceAndTOB* mid_price_and_tob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mid_price_and_tob_);
  }
  if (mid_price_and_tob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mid_price_and_tob));
    if (message_arena != submessage_arena) {
      mid_price_and_tob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mid_price_and_tob, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mid_price_and_tob_ = mid_price_and_tob;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.FullDerivativeMarket.mid_price_and_tob)
}

inline bool FullDerivativeMarket::has_info() const {
  return info_case() != INFO_NOT_SET;
}
inline void FullDerivativeMarket::clear_has_info() {
  _impl_._oneof_case_[0] = INFO_NOT_SET;
}
inline FullDerivativeMarket::InfoCase FullDerivativeMarket::info_case() const {
  return FullDerivativeMarket::InfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// QueryDerivativeMarketsResponse

// repeated .injective.exchange.v1beta1.FullDerivativeMarket markets = 1 [json_name = "markets"];
inline int QueryDerivativeMarketsResponse::_internal_markets_size() const {
  return _impl_.markets_.size();
}
inline int QueryDerivativeMarketsResponse::markets_size() const {
  return _internal_markets_size();
}
inline void QueryDerivativeMarketsResponse::clear_markets() {
  _internal_mutable_markets()->Clear();
}
inline ::injective::exchange::v1beta1::FullDerivativeMarket* QueryDerivativeMarketsResponse::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketsResponse.markets)
  return _internal_mutable_markets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullDerivativeMarket >*
QueryDerivativeMarketsResponse::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryDerivativeMarketsResponse.markets)
  return _internal_mutable_markets();
}
inline const ::injective::exchange::v1beta1::FullDerivativeMarket& QueryDerivativeMarketsResponse::_internal_markets(int index) const {
  return _internal_markets().Get(index);
}
inline const ::injective::exchange::v1beta1::FullDerivativeMarket& QueryDerivativeMarketsResponse::markets(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketsResponse.markets)
  return _internal_markets(index);
}
inline ::injective::exchange::v1beta1::FullDerivativeMarket* QueryDerivativeMarketsResponse::_internal_add_markets() {
  return _internal_mutable_markets()->Add();
}
inline ::injective::exchange::v1beta1::FullDerivativeMarket* QueryDerivativeMarketsResponse::add_markets() {
  ::injective::exchange::v1beta1::FullDerivativeMarket* _add = _internal_add_markets();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryDerivativeMarketsResponse.markets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::FullDerivativeMarket >&
QueryDerivativeMarketsResponse::markets() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryDerivativeMarketsResponse.markets)
  return _internal_markets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullDerivativeMarket>&
QueryDerivativeMarketsResponse::_internal_markets() const {
  return _impl_.markets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::FullDerivativeMarket>*
QueryDerivativeMarketsResponse::_internal_mutable_markets() {
  return &_impl_.markets_;
}

// -------------------------------------------------------------------

// QueryDerivativeMarketRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryDerivativeMarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketRequest.market_id)
}
inline std::string* QueryDerivativeMarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketRequest.market_id)
  return _s;
}
inline const std::string& QueryDerivativeMarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryDerivativeMarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryDerivativeMarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMarketRequest.market_id)
}

// -------------------------------------------------------------------

// QueryDerivativeMarketResponse

// .injective.exchange.v1beta1.FullDerivativeMarket market = 1 [json_name = "market"];
inline bool QueryDerivativeMarketResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline void QueryDerivativeMarketResponse::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::FullDerivativeMarket& QueryDerivativeMarketResponse::_internal_market() const {
  const ::injective::exchange::v1beta1::FullDerivativeMarket* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::FullDerivativeMarket&>(
      ::injective::exchange::v1beta1::_FullDerivativeMarket_default_instance_);
}
inline const ::injective::exchange::v1beta1::FullDerivativeMarket& QueryDerivativeMarketResponse::market() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketResponse.market)
  return _internal_market();
}
inline void QueryDerivativeMarketResponse::unsafe_arena_set_allocated_market(
    ::injective::exchange::v1beta1::FullDerivativeMarket* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryDerivativeMarketResponse.market)
}
inline ::injective::exchange::v1beta1::FullDerivativeMarket* QueryDerivativeMarketResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FullDerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::FullDerivativeMarket* QueryDerivativeMarketResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMarketResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FullDerivativeMarket* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::FullDerivativeMarket* QueryDerivativeMarketResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::FullDerivativeMarket>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective::exchange::v1beta1::FullDerivativeMarket* QueryDerivativeMarketResponse::mutable_market() {
  ::injective::exchange::v1beta1::FullDerivativeMarket* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketResponse.market)
  return _msg;
}
inline void QueryDerivativeMarketResponse::set_allocated_market(::injective::exchange::v1beta1::FullDerivativeMarket* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMarketResponse.market)
}

// -------------------------------------------------------------------

// QueryDerivativeMarketAddressRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryDerivativeMarketAddressRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMarketAddressRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMarketAddressRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest.market_id)
}
inline std::string* QueryDerivativeMarketAddressRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest.market_id)
  return _s;
}
inline const std::string& QueryDerivativeMarketAddressRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryDerivativeMarketAddressRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketAddressRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketAddressRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryDerivativeMarketAddressRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMarketAddressRequest.market_id)
}

// -------------------------------------------------------------------

// QueryDerivativeMarketAddressResponse

// string address = 1 [json_name = "address"];
inline void QueryDerivativeMarketAddressResponse::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMarketAddressResponse::address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMarketAddressResponse::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.address)
}
inline std::string* QueryDerivativeMarketAddressResponse::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.address)
  return _s;
}
inline const std::string& QueryDerivativeMarketAddressResponse::_internal_address() const {
  return _impl_.address_.Get();
}
inline void QueryDerivativeMarketAddressResponse::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketAddressResponse::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketAddressResponse::release_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.address)
  return _impl_.address_.Release();
}
inline void QueryDerivativeMarketAddressResponse::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.address)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void QueryDerivativeMarketAddressResponse::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QueryDerivativeMarketAddressResponse::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryDerivativeMarketAddressResponse::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.subaccount_id)
}
inline std::string* QueryDerivativeMarketAddressResponse::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.subaccount_id)
  return _s;
}
inline const std::string& QueryDerivativeMarketAddressResponse::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QueryDerivativeMarketAddressResponse::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketAddressResponse::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryDerivativeMarketAddressResponse::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QueryDerivativeMarketAddressResponse::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryDerivativeMarketAddressResponse.subaccount_id)
}

// -------------------------------------------------------------------

// QuerySubaccountTradeNonceRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountTradeNonceRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountTradeNonceRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountTradeNonceRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest.subaccount_id)
}
inline std::string* QuerySubaccountTradeNonceRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountTradeNonceRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountTradeNonceRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountTradeNonceRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountTradeNonceRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountTradeNonceRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountTradeNonceRequest.subaccount_id)
}

// -------------------------------------------------------------------

// QuerySubaccountPositionsRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountPositionsRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountPositionsRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountPositionsRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountPositionsRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountPositionsRequest.subaccount_id)
}
inline std::string* QuerySubaccountPositionsRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountPositionsRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountPositionsRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountPositionsRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountPositionsRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountPositionsRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountPositionsRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountPositionsRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountPositionsRequest.subaccount_id)
}

// -------------------------------------------------------------------

// QuerySubaccountPositionInMarketRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountPositionInMarketRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountPositionInMarketRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountPositionInMarketRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.subaccount_id)
}
inline std::string* QuerySubaccountPositionInMarketRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountPositionInMarketRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountPositionInMarketRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountPositionInMarketRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountPositionInMarketRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountPositionInMarketRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void QuerySubaccountPositionInMarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountPositionInMarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountPositionInMarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.market_id)
}
inline std::string* QuerySubaccountPositionInMarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.market_id)
  return _s;
}
inline const std::string& QuerySubaccountPositionInMarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QuerySubaccountPositionInMarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountPositionInMarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountPositionInMarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QuerySubaccountPositionInMarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountPositionInMarketRequest.market_id)
}

// -------------------------------------------------------------------

// QuerySubaccountEffectivePositionInMarketRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountEffectivePositionInMarketRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountEffectivePositionInMarketRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountEffectivePositionInMarketRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.subaccount_id)
}
inline std::string* QuerySubaccountEffectivePositionInMarketRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountEffectivePositionInMarketRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountEffectivePositionInMarketRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountEffectivePositionInMarketRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountEffectivePositionInMarketRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountEffectivePositionInMarketRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void QuerySubaccountEffectivePositionInMarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountEffectivePositionInMarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountEffectivePositionInMarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.market_id)
}
inline std::string* QuerySubaccountEffectivePositionInMarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.market_id)
  return _s;
}
inline const std::string& QuerySubaccountEffectivePositionInMarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QuerySubaccountEffectivePositionInMarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountEffectivePositionInMarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountEffectivePositionInMarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QuerySubaccountEffectivePositionInMarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketRequest.market_id)
}

// -------------------------------------------------------------------

// QuerySubaccountOrderMetadataRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QuerySubaccountOrderMetadataRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QuerySubaccountOrderMetadataRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuerySubaccountOrderMetadataRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest.subaccount_id)
}
inline std::string* QuerySubaccountOrderMetadataRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest.subaccount_id)
  return _s;
}
inline const std::string& QuerySubaccountOrderMetadataRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QuerySubaccountOrderMetadataRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySubaccountOrderMetadataRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QuerySubaccountOrderMetadataRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QuerySubaccountOrderMetadataRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountOrderMetadataRequest.subaccount_id)
}

// -------------------------------------------------------------------

// QuerySubaccountPositionsResponse

// repeated .injective.exchange.v1beta1.DerivativePosition state = 1 [json_name = "state", (.gogoproto.nullable) = false];
inline int QuerySubaccountPositionsResponse::_internal_state_size() const {
  return _impl_.state_.size();
}
inline int QuerySubaccountPositionsResponse::state_size() const {
  return _internal_state_size();
}
inline ::injective::exchange::v1beta1::DerivativePosition* QuerySubaccountPositionsResponse::mutable_state(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountPositionsResponse.state)
  return _internal_mutable_state()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >*
QuerySubaccountPositionsResponse::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySubaccountPositionsResponse.state)
  return _internal_mutable_state();
}
inline const ::injective::exchange::v1beta1::DerivativePosition& QuerySubaccountPositionsResponse::_internal_state(int index) const {
  return _internal_state().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativePosition& QuerySubaccountPositionsResponse::state(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountPositionsResponse.state)
  return _internal_state(index);
}
inline ::injective::exchange::v1beta1::DerivativePosition* QuerySubaccountPositionsResponse::_internal_add_state() {
  return _internal_mutable_state()->Add();
}
inline ::injective::exchange::v1beta1::DerivativePosition* QuerySubaccountPositionsResponse::add_state() {
  ::injective::exchange::v1beta1::DerivativePosition* _add = _internal_add_state();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySubaccountPositionsResponse.state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >&
QuerySubaccountPositionsResponse::state() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySubaccountPositionsResponse.state)
  return _internal_state();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>&
QuerySubaccountPositionsResponse::_internal_state() const {
  return _impl_.state_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>*
QuerySubaccountPositionsResponse::_internal_mutable_state() {
  return &_impl_.state_;
}

// -------------------------------------------------------------------

// QuerySubaccountPositionInMarketResponse

// .injective.exchange.v1beta1.Position state = 1 [json_name = "state", (.gogoproto.nullable) = true];
inline bool QuerySubaccountPositionInMarketResponse::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::Position& QuerySubaccountPositionInMarketResponse::_internal_state() const {
  const ::injective::exchange::v1beta1::Position* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::Position&>(
      ::injective::exchange::v1beta1::_Position_default_instance_);
}
inline const ::injective::exchange::v1beta1::Position& QuerySubaccountPositionInMarketResponse::state() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse.state)
  return _internal_state();
}
inline void QuerySubaccountPositionInMarketResponse::unsafe_arena_set_allocated_state(
    ::injective::exchange::v1beta1::Position* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse.state)
}
inline ::injective::exchange::v1beta1::Position* QuerySubaccountPositionInMarketResponse::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Position* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::Position* QuerySubaccountPositionInMarketResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::Position* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::Position* QuerySubaccountPositionInMarketResponse::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::Position>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::injective::exchange::v1beta1::Position* QuerySubaccountPositionInMarketResponse::mutable_state() {
  ::injective::exchange::v1beta1::Position* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse.state)
  return _msg;
}
inline void QuerySubaccountPositionInMarketResponse::set_allocated_state(::injective::exchange::v1beta1::Position* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountPositionInMarketResponse.state)
}

// -------------------------------------------------------------------

// EffectivePosition

// bool is_long = 1 [json_name = "isLong"];
inline void EffectivePosition::clear_is_long() {
  _impl_.is_long_ = false;
}
inline bool EffectivePosition::is_long() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EffectivePosition.is_long)
  return _internal_is_long();
}
inline void EffectivePosition::set_is_long(bool value) {
  _internal_set_is_long(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EffectivePosition.is_long)
}
inline bool EffectivePosition::_internal_is_long() const {
  return _impl_.is_long_;
}
inline void EffectivePosition::_internal_set_is_long(bool value) {
  ;
  _impl_.is_long_ = value;
}

// string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EffectivePosition::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& EffectivePosition::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EffectivePosition.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EffectivePosition::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EffectivePosition.quantity)
}
inline std::string* EffectivePosition::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EffectivePosition.quantity)
  return _s;
}
inline const std::string& EffectivePosition::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void EffectivePosition::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* EffectivePosition::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* EffectivePosition::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EffectivePosition.quantity)
  return _impl_.quantity_.Release();
}
inline void EffectivePosition::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EffectivePosition.quantity)
}

// string entry_price = 3 [json_name = "entryPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EffectivePosition::clear_entry_price() {
  _impl_.entry_price_.ClearToEmpty();
}
inline const std::string& EffectivePosition::entry_price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EffectivePosition.entry_price)
  return _internal_entry_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EffectivePosition::set_entry_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.entry_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EffectivePosition.entry_price)
}
inline std::string* EffectivePosition::mutable_entry_price() {
  std::string* _s = _internal_mutable_entry_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EffectivePosition.entry_price)
  return _s;
}
inline const std::string& EffectivePosition::_internal_entry_price() const {
  return _impl_.entry_price_.Get();
}
inline void EffectivePosition::_internal_set_entry_price(const std::string& value) {
  ;


  _impl_.entry_price_.Set(value, GetArenaForAllocation());
}
inline std::string* EffectivePosition::_internal_mutable_entry_price() {
  ;
  return _impl_.entry_price_.Mutable( GetArenaForAllocation());
}
inline std::string* EffectivePosition::release_entry_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EffectivePosition.entry_price)
  return _impl_.entry_price_.Release();
}
inline void EffectivePosition::set_allocated_entry_price(std::string* value) {
  _impl_.entry_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entry_price_.IsDefault()) {
          _impl_.entry_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EffectivePosition.entry_price)
}

// string effective_margin = 4 [json_name = "effectiveMargin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void EffectivePosition::clear_effective_margin() {
  _impl_.effective_margin_.ClearToEmpty();
}
inline const std::string& EffectivePosition::effective_margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.EffectivePosition.effective_margin)
  return _internal_effective_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EffectivePosition::set_effective_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.effective_margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.EffectivePosition.effective_margin)
}
inline std::string* EffectivePosition::mutable_effective_margin() {
  std::string* _s = _internal_mutable_effective_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.EffectivePosition.effective_margin)
  return _s;
}
inline const std::string& EffectivePosition::_internal_effective_margin() const {
  return _impl_.effective_margin_.Get();
}
inline void EffectivePosition::_internal_set_effective_margin(const std::string& value) {
  ;


  _impl_.effective_margin_.Set(value, GetArenaForAllocation());
}
inline std::string* EffectivePosition::_internal_mutable_effective_margin() {
  ;
  return _impl_.effective_margin_.Mutable( GetArenaForAllocation());
}
inline std::string* EffectivePosition::release_effective_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.EffectivePosition.effective_margin)
  return _impl_.effective_margin_.Release();
}
inline void EffectivePosition::set_allocated_effective_margin(std::string* value) {
  _impl_.effective_margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.effective_margin_.IsDefault()) {
          _impl_.effective_margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.EffectivePosition.effective_margin)
}

// -------------------------------------------------------------------

// QuerySubaccountEffectivePositionInMarketResponse

// .injective.exchange.v1beta1.EffectivePosition state = 1 [json_name = "state", (.gogoproto.nullable) = true];
inline bool QuerySubaccountEffectivePositionInMarketResponse::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void QuerySubaccountEffectivePositionInMarketResponse::clear_state() {
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::EffectivePosition& QuerySubaccountEffectivePositionInMarketResponse::_internal_state() const {
  const ::injective::exchange::v1beta1::EffectivePosition* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::EffectivePosition&>(
      ::injective::exchange::v1beta1::_EffectivePosition_default_instance_);
}
inline const ::injective::exchange::v1beta1::EffectivePosition& QuerySubaccountEffectivePositionInMarketResponse::state() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse.state)
  return _internal_state();
}
inline void QuerySubaccountEffectivePositionInMarketResponse::unsafe_arena_set_allocated_state(
    ::injective::exchange::v1beta1::EffectivePosition* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse.state)
}
inline ::injective::exchange::v1beta1::EffectivePosition* QuerySubaccountEffectivePositionInMarketResponse::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::EffectivePosition* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::EffectivePosition* QuerySubaccountEffectivePositionInMarketResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::EffectivePosition* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::EffectivePosition* QuerySubaccountEffectivePositionInMarketResponse::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::EffectivePosition>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::injective::exchange::v1beta1::EffectivePosition* QuerySubaccountEffectivePositionInMarketResponse::mutable_state() {
  ::injective::exchange::v1beta1::EffectivePosition* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse.state)
  return _msg;
}
inline void QuerySubaccountEffectivePositionInMarketResponse::set_allocated_state(::injective::exchange::v1beta1::EffectivePosition* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QuerySubaccountEffectivePositionInMarketResponse.state)
}

// -------------------------------------------------------------------

// QueryPerpetualMarketInfoRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryPerpetualMarketInfoRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryPerpetualMarketInfoRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryPerpetualMarketInfoRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest.market_id)
}
inline std::string* QueryPerpetualMarketInfoRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest.market_id)
  return _s;
}
inline const std::string& QueryPerpetualMarketInfoRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryPerpetualMarketInfoRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryPerpetualMarketInfoRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryPerpetualMarketInfoRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryPerpetualMarketInfoRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryPerpetualMarketInfoRequest.market_id)
}

// -------------------------------------------------------------------

// QueryPerpetualMarketInfoResponse

// .injective.exchange.v1beta1.PerpetualMarketInfo info = 1 [json_name = "info", (.gogoproto.nullable) = false];
inline bool QueryPerpetualMarketInfoResponse::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PerpetualMarketInfo& QueryPerpetualMarketInfoResponse::_internal_info() const {
  const ::injective::exchange::v1beta1::PerpetualMarketInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PerpetualMarketInfo&>(
      ::injective::exchange::v1beta1::_PerpetualMarketInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketInfo& QueryPerpetualMarketInfoResponse::info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse.info)
  return _internal_info();
}
inline void QueryPerpetualMarketInfoResponse::unsafe_arena_set_allocated_info(
    ::injective::exchange::v1beta1::PerpetualMarketInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse.info)
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* QueryPerpetualMarketInfoResponse::release_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* QueryPerpetualMarketInfoResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse.info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* QueryPerpetualMarketInfoResponse::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketInfo* QueryPerpetualMarketInfoResponse::mutable_info() {
  ::injective::exchange::v1beta1::PerpetualMarketInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse.info)
  return _msg;
}
inline void QueryPerpetualMarketInfoResponse::set_allocated_info(::injective::exchange::v1beta1::PerpetualMarketInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryPerpetualMarketInfoResponse.info)
}

// -------------------------------------------------------------------

// QueryExpiryFuturesMarketInfoRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryExpiryFuturesMarketInfoRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryExpiryFuturesMarketInfoRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryExpiryFuturesMarketInfoRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest.market_id)
}
inline std::string* QueryExpiryFuturesMarketInfoRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest.market_id)
  return _s;
}
inline const std::string& QueryExpiryFuturesMarketInfoRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryExpiryFuturesMarketInfoRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryExpiryFuturesMarketInfoRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryExpiryFuturesMarketInfoRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryExpiryFuturesMarketInfoRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoRequest.market_id)
}

// -------------------------------------------------------------------

// QueryExpiryFuturesMarketInfoResponse

// .injective.exchange.v1beta1.ExpiryFuturesMarketInfo info = 1 [json_name = "info", (.gogoproto.nullable) = false];
inline bool QueryExpiryFuturesMarketInfoResponse::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& QueryExpiryFuturesMarketInfoResponse::_internal_info() const {
  const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo&>(
      ::injective::exchange::v1beta1::_ExpiryFuturesMarketInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo& QueryExpiryFuturesMarketInfoResponse::info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse.info)
  return _internal_info();
}
inline void QueryExpiryFuturesMarketInfoResponse::unsafe_arena_set_allocated_info(
    ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse.info)
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* QueryExpiryFuturesMarketInfoResponse::release_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* QueryExpiryFuturesMarketInfoResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse.info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* QueryExpiryFuturesMarketInfoResponse::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::ExpiryFuturesMarketInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* QueryExpiryFuturesMarketInfoResponse::mutable_info() {
  ::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse.info)
  return _msg;
}
inline void QueryExpiryFuturesMarketInfoResponse::set_allocated_info(::injective::exchange::v1beta1::ExpiryFuturesMarketInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryExpiryFuturesMarketInfoResponse.info)
}

// -------------------------------------------------------------------

// QueryPerpetualMarketFundingRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryPerpetualMarketFundingRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryPerpetualMarketFundingRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryPerpetualMarketFundingRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest.market_id)
}
inline std::string* QueryPerpetualMarketFundingRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest.market_id)
  return _s;
}
inline const std::string& QueryPerpetualMarketFundingRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryPerpetualMarketFundingRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryPerpetualMarketFundingRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryPerpetualMarketFundingRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryPerpetualMarketFundingRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryPerpetualMarketFundingRequest.market_id)
}

// -------------------------------------------------------------------

// QueryPerpetualMarketFundingResponse

// .injective.exchange.v1beta1.PerpetualMarketFunding state = 1 [json_name = "state", (.gogoproto.nullable) = false];
inline bool QueryPerpetualMarketFundingResponse::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& QueryPerpetualMarketFundingResponse::_internal_state() const {
  const ::injective::exchange::v1beta1::PerpetualMarketFunding* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::PerpetualMarketFunding&>(
      ::injective::exchange::v1beta1::_PerpetualMarketFunding_default_instance_);
}
inline const ::injective::exchange::v1beta1::PerpetualMarketFunding& QueryPerpetualMarketFundingResponse::state() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse.state)
  return _internal_state();
}
inline void QueryPerpetualMarketFundingResponse::unsafe_arena_set_allocated_state(
    ::injective::exchange::v1beta1::PerpetualMarketFunding* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse.state)
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* QueryPerpetualMarketFundingResponse::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* QueryPerpetualMarketFundingResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::PerpetualMarketFunding* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* QueryPerpetualMarketFundingResponse::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::PerpetualMarketFunding>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::injective::exchange::v1beta1::PerpetualMarketFunding* QueryPerpetualMarketFundingResponse::mutable_state() {
  ::injective::exchange::v1beta1::PerpetualMarketFunding* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse.state)
  return _msg;
}
inline void QueryPerpetualMarketFundingResponse::set_allocated_state(::injective::exchange::v1beta1::PerpetualMarketFunding* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryPerpetualMarketFundingResponse.state)
}

// -------------------------------------------------------------------

// QuerySubaccountOrderMetadataResponse

// repeated .injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket metadata = 1 [json_name = "metadata", (.gogoproto.nullable) = false];
inline int QuerySubaccountOrderMetadataResponse::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int QuerySubaccountOrderMetadataResponse::metadata_size() const {
  return _internal_metadata_size();
}
inline void QuerySubaccountOrderMetadataResponse::clear_metadata() {
  _internal_mutable_metadata()->Clear();
}
inline ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* QuerySubaccountOrderMetadataResponse::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse.metadata)
  return _internal_mutable_metadata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket >*
QuerySubaccountOrderMetadataResponse::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse.metadata)
  return _internal_mutable_metadata();
}
inline const ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket& QuerySubaccountOrderMetadataResponse::_internal_metadata(int index) const {
  return _internal_metadata().Get(index);
}
inline const ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket& QuerySubaccountOrderMetadataResponse::metadata(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse.metadata)
  return _internal_metadata(index);
}
inline ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* QuerySubaccountOrderMetadataResponse::_internal_add_metadata() {
  return _internal_mutable_metadata()->Add();
}
inline ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* QuerySubaccountOrderMetadataResponse::add_metadata() {
  ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket >&
QuerySubaccountOrderMetadataResponse::metadata() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QuerySubaccountOrderMetadataResponse.metadata)
  return _internal_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket>&
QuerySubaccountOrderMetadataResponse::_internal_metadata() const {
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::SubaccountOrderbookMetadataWithMarket>*
QuerySubaccountOrderMetadataResponse::_internal_mutable_metadata() {
  return &_impl_.metadata_;
}

// -------------------------------------------------------------------

// QuerySubaccountTradeNonceResponse

// uint32 nonce = 1 [json_name = "nonce"];
inline void QuerySubaccountTradeNonceResponse::clear_nonce() {
  _impl_.nonce_ = 0u;
}
inline ::uint32_t QuerySubaccountTradeNonceResponse::nonce() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse.nonce)
  return _internal_nonce();
}
inline void QuerySubaccountTradeNonceResponse::set_nonce(::uint32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QuerySubaccountTradeNonceResponse.nonce)
}
inline ::uint32_t QuerySubaccountTradeNonceResponse::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void QuerySubaccountTradeNonceResponse::_internal_set_nonce(::uint32_t value) {
  ;
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// QueryModuleStateRequest

// -------------------------------------------------------------------

// QueryModuleStateResponse

// .injective.exchange.v1beta1.GenesisState state = 1 [json_name = "state"];
inline bool QueryModuleStateResponse::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::GenesisState& QueryModuleStateResponse::_internal_state() const {
  const ::injective::exchange::v1beta1::GenesisState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::GenesisState&>(
      ::injective::exchange::v1beta1::_GenesisState_default_instance_);
}
inline const ::injective::exchange::v1beta1::GenesisState& QueryModuleStateResponse::state() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryModuleStateResponse.state)
  return _internal_state();
}
inline void QueryModuleStateResponse::unsafe_arena_set_allocated_state(
    ::injective::exchange::v1beta1::GenesisState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryModuleStateResponse.state)
}
inline ::injective::exchange::v1beta1::GenesisState* QueryModuleStateResponse::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::GenesisState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::GenesisState* QueryModuleStateResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryModuleStateResponse.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::GenesisState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::GenesisState* QueryModuleStateResponse::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::GenesisState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::injective::exchange::v1beta1::GenesisState* QueryModuleStateResponse::mutable_state() {
  ::injective::exchange::v1beta1::GenesisState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryModuleStateResponse.state)
  return _msg;
}
inline void QueryModuleStateResponse::set_allocated_state(::injective::exchange::v1beta1::GenesisState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryModuleStateResponse.state)
}

// -------------------------------------------------------------------

// QueryPositionsRequest

// -------------------------------------------------------------------

// QueryPositionsResponse

// repeated .injective.exchange.v1beta1.DerivativePosition state = 1 [json_name = "state", (.gogoproto.nullable) = false];
inline int QueryPositionsResponse::_internal_state_size() const {
  return _impl_.state_.size();
}
inline int QueryPositionsResponse::state_size() const {
  return _internal_state_size();
}
inline ::injective::exchange::v1beta1::DerivativePosition* QueryPositionsResponse::mutable_state(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryPositionsResponse.state)
  return _internal_mutable_state()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >*
QueryPositionsResponse::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryPositionsResponse.state)
  return _internal_mutable_state();
}
inline const ::injective::exchange::v1beta1::DerivativePosition& QueryPositionsResponse::_internal_state(int index) const {
  return _internal_state().Get(index);
}
inline const ::injective::exchange::v1beta1::DerivativePosition& QueryPositionsResponse::state(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryPositionsResponse.state)
  return _internal_state(index);
}
inline ::injective::exchange::v1beta1::DerivativePosition* QueryPositionsResponse::_internal_add_state() {
  return _internal_mutable_state()->Add();
}
inline ::injective::exchange::v1beta1::DerivativePosition* QueryPositionsResponse::add_state() {
  ::injective::exchange::v1beta1::DerivativePosition* _add = _internal_add_state();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryPositionsResponse.state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::DerivativePosition >&
QueryPositionsResponse::state() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryPositionsResponse.state)
  return _internal_state();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>&
QueryPositionsResponse::_internal_state() const {
  return _impl_.state_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::DerivativePosition>*
QueryPositionsResponse::_internal_mutable_state() {
  return &_impl_.state_;
}

// -------------------------------------------------------------------

// QueryTradeRewardPointsRequest

// repeated string accounts = 1 [json_name = "accounts"];
inline int QueryTradeRewardPointsRequest::_internal_accounts_size() const {
  return _impl_.accounts_.size();
}
inline int QueryTradeRewardPointsRequest::accounts_size() const {
  return _internal_accounts_size();
}
inline void QueryTradeRewardPointsRequest::clear_accounts() {
  _internal_mutable_accounts()->Clear();
}
inline std::string* QueryTradeRewardPointsRequest::add_accounts() {
  std::string* _s = _internal_add_accounts();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
  return _s;
}
inline const std::string& QueryTradeRewardPointsRequest::accounts(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
  return _internal_accounts(index);
}
inline std::string* QueryTradeRewardPointsRequest::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
  return _internal_mutable_accounts()->Mutable(index);
}
inline void QueryTradeRewardPointsRequest::set_accounts(int index, const std::string& value) {
  _internal_mutable_accounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::set_accounts(int index, std::string&& value) {
  _internal_mutable_accounts()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::set_accounts(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_accounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::set_accounts(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_accounts()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::set_accounts(int index, absl::string_view value) {
  _internal_mutable_accounts()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::add_accounts(const std::string& value) {
  _internal_mutable_accounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::add_accounts(std::string&& value) {
  _internal_mutable_accounts()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::add_accounts(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_accounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::add_accounts(const char* value, std::size_t size) {
  _internal_mutable_accounts()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline void QueryTradeRewardPointsRequest::add_accounts(absl::string_view value) {
  _internal_mutable_accounts()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryTradeRewardPointsRequest::accounts() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
  return _internal_accounts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryTradeRewardPointsRequest::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.accounts)
  return _internal_mutable_accounts();
}
inline const std::string& QueryTradeRewardPointsRequest::_internal_accounts(int index) const {
  return _internal_accounts().Get(index);
}
inline std::string* QueryTradeRewardPointsRequest::_internal_add_accounts() {
  return _internal_mutable_accounts()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryTradeRewardPointsRequest::_internal_accounts() const {
  return _impl_.accounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryTradeRewardPointsRequest::_internal_mutable_accounts() {
  return &_impl_.accounts_;
}

// int64 pending_pool_timestamp = 2 [json_name = "pendingPoolTimestamp"];
inline void QueryTradeRewardPointsRequest::clear_pending_pool_timestamp() {
  _impl_.pending_pool_timestamp_ = ::int64_t{0};
}
inline ::int64_t QueryTradeRewardPointsRequest::pending_pool_timestamp() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.pending_pool_timestamp)
  return _internal_pending_pool_timestamp();
}
inline void QueryTradeRewardPointsRequest::set_pending_pool_timestamp(::int64_t value) {
  _internal_set_pending_pool_timestamp(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardPointsRequest.pending_pool_timestamp)
}
inline ::int64_t QueryTradeRewardPointsRequest::_internal_pending_pool_timestamp() const {
  return _impl_.pending_pool_timestamp_;
}
inline void QueryTradeRewardPointsRequest::_internal_set_pending_pool_timestamp(::int64_t value) {
  ;
  _impl_.pending_pool_timestamp_ = value;
}

// -------------------------------------------------------------------

// QueryTradeRewardPointsResponse

// repeated string account_trade_reward_points = 1 [json_name = "accountTradeRewardPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline int QueryTradeRewardPointsResponse::_internal_account_trade_reward_points_size() const {
  return _impl_.account_trade_reward_points_.size();
}
inline int QueryTradeRewardPointsResponse::account_trade_reward_points_size() const {
  return _internal_account_trade_reward_points_size();
}
inline void QueryTradeRewardPointsResponse::clear_account_trade_reward_points() {
  _internal_mutable_account_trade_reward_points()->Clear();
}
inline std::string* QueryTradeRewardPointsResponse::add_account_trade_reward_points() {
  std::string* _s = _internal_add_account_trade_reward_points();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
  return _s;
}
inline const std::string& QueryTradeRewardPointsResponse::account_trade_reward_points(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
  return _internal_account_trade_reward_points(index);
}
inline std::string* QueryTradeRewardPointsResponse::mutable_account_trade_reward_points(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
  return _internal_mutable_account_trade_reward_points()->Mutable(index);
}
inline void QueryTradeRewardPointsResponse::set_account_trade_reward_points(int index, const std::string& value) {
  _internal_mutable_account_trade_reward_points()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::set_account_trade_reward_points(int index, std::string&& value) {
  _internal_mutable_account_trade_reward_points()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::set_account_trade_reward_points(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_account_trade_reward_points()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::set_account_trade_reward_points(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_account_trade_reward_points()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::set_account_trade_reward_points(int index, absl::string_view value) {
  _internal_mutable_account_trade_reward_points()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::add_account_trade_reward_points(const std::string& value) {
  _internal_mutable_account_trade_reward_points()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::add_account_trade_reward_points(std::string&& value) {
  _internal_mutable_account_trade_reward_points()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::add_account_trade_reward_points(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_account_trade_reward_points()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::add_account_trade_reward_points(const char* value, std::size_t size) {
  _internal_mutable_account_trade_reward_points()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline void QueryTradeRewardPointsResponse::add_account_trade_reward_points(absl::string_view value) {
  _internal_mutable_account_trade_reward_points()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryTradeRewardPointsResponse::account_trade_reward_points() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
  return _internal_account_trade_reward_points();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryTradeRewardPointsResponse::mutable_account_trade_reward_points() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTradeRewardPointsResponse.account_trade_reward_points)
  return _internal_mutable_account_trade_reward_points();
}
inline const std::string& QueryTradeRewardPointsResponse::_internal_account_trade_reward_points(int index) const {
  return _internal_account_trade_reward_points().Get(index);
}
inline std::string* QueryTradeRewardPointsResponse::_internal_add_account_trade_reward_points() {
  return _internal_mutable_account_trade_reward_points()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryTradeRewardPointsResponse::_internal_account_trade_reward_points() const {
  return _impl_.account_trade_reward_points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryTradeRewardPointsResponse::_internal_mutable_account_trade_reward_points() {
  return &_impl_.account_trade_reward_points_;
}

// -------------------------------------------------------------------

// QueryTradeRewardCampaignRequest

// -------------------------------------------------------------------

// QueryTradeRewardCampaignResponse

// .injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 1 [json_name = "tradingRewardCampaignInfo"];
inline bool QueryTradeRewardCampaignResponse::has_trading_reward_campaign_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trading_reward_campaign_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& QueryTradeRewardCampaignResponse::_internal_trading_reward_campaign_info() const {
  const ::injective::exchange::v1beta1::TradingRewardCampaignInfo* p = _impl_.trading_reward_campaign_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::TradingRewardCampaignInfo&>(
      ::injective::exchange::v1beta1::_TradingRewardCampaignInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::TradingRewardCampaignInfo& QueryTradeRewardCampaignResponse::trading_reward_campaign_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_campaign_info)
  return _internal_trading_reward_campaign_info();
}
inline void QueryTradeRewardCampaignResponse::unsafe_arena_set_allocated_trading_reward_campaign_info(
    ::injective::exchange::v1beta1::TradingRewardCampaignInfo* trading_reward_campaign_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trading_reward_campaign_info_);
  }
  _impl_.trading_reward_campaign_info_ = trading_reward_campaign_info;
  if (trading_reward_campaign_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_campaign_info)
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* QueryTradeRewardCampaignResponse::release_trading_reward_campaign_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.trading_reward_campaign_info_;
  _impl_.trading_reward_campaign_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* QueryTradeRewardCampaignResponse::unsafe_arena_release_trading_reward_campaign_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_campaign_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* temp = _impl_.trading_reward_campaign_info_;
  _impl_.trading_reward_campaign_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* QueryTradeRewardCampaignResponse::_internal_mutable_trading_reward_campaign_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trading_reward_campaign_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::TradingRewardCampaignInfo>(GetArenaForAllocation());
    _impl_.trading_reward_campaign_info_ = p;
  }
  return _impl_.trading_reward_campaign_info_;
}
inline ::injective::exchange::v1beta1::TradingRewardCampaignInfo* QueryTradeRewardCampaignResponse::mutable_trading_reward_campaign_info() {
  ::injective::exchange::v1beta1::TradingRewardCampaignInfo* _msg = _internal_mutable_trading_reward_campaign_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_campaign_info)
  return _msg;
}
inline void QueryTradeRewardCampaignResponse::set_allocated_trading_reward_campaign_info(::injective::exchange::v1beta1::TradingRewardCampaignInfo* trading_reward_campaign_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trading_reward_campaign_info_);
  }
  if (trading_reward_campaign_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trading_reward_campaign_info));
    if (message_arena != submessage_arena) {
      trading_reward_campaign_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trading_reward_campaign_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trading_reward_campaign_info_ = trading_reward_campaign_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_campaign_info)
}

// repeated .injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 2 [json_name = "tradingRewardPoolCampaignSchedule"];
inline int QueryTradeRewardCampaignResponse::_internal_trading_reward_pool_campaign_schedule_size() const {
  return _impl_.trading_reward_pool_campaign_schedule_.size();
}
inline int QueryTradeRewardCampaignResponse::trading_reward_pool_campaign_schedule_size() const {
  return _internal_trading_reward_pool_campaign_schedule_size();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* QueryTradeRewardCampaignResponse::mutable_trading_reward_pool_campaign_schedule(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_pool_campaign_schedule)
  return _internal_mutable_trading_reward_pool_campaign_schedule()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
QueryTradeRewardCampaignResponse::mutable_trading_reward_pool_campaign_schedule() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_pool_campaign_schedule)
  return _internal_mutable_trading_reward_pool_campaign_schedule();
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& QueryTradeRewardCampaignResponse::_internal_trading_reward_pool_campaign_schedule(int index) const {
  return _internal_trading_reward_pool_campaign_schedule().Get(index);
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& QueryTradeRewardCampaignResponse::trading_reward_pool_campaign_schedule(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_pool_campaign_schedule)
  return _internal_trading_reward_pool_campaign_schedule(index);
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* QueryTradeRewardCampaignResponse::_internal_add_trading_reward_pool_campaign_schedule() {
  return _internal_mutable_trading_reward_pool_campaign_schedule()->Add();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* QueryTradeRewardCampaignResponse::add_trading_reward_pool_campaign_schedule() {
  ::injective::exchange::v1beta1::CampaignRewardPool* _add = _internal_add_trading_reward_pool_campaign_schedule();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_pool_campaign_schedule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
QueryTradeRewardCampaignResponse::trading_reward_pool_campaign_schedule() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.trading_reward_pool_campaign_schedule)
  return _internal_trading_reward_pool_campaign_schedule();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>&
QueryTradeRewardCampaignResponse::_internal_trading_reward_pool_campaign_schedule() const {
  return _impl_.trading_reward_pool_campaign_schedule_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>*
QueryTradeRewardCampaignResponse::_internal_mutable_trading_reward_pool_campaign_schedule() {
  return &_impl_.trading_reward_pool_campaign_schedule_;
}

// string total_trade_reward_points = 3 [json_name = "totalTradeRewardPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryTradeRewardCampaignResponse::clear_total_trade_reward_points() {
  _impl_.total_trade_reward_points_.ClearToEmpty();
}
inline const std::string& QueryTradeRewardCampaignResponse::total_trade_reward_points() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.total_trade_reward_points)
  return _internal_total_trade_reward_points();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTradeRewardCampaignResponse::set_total_trade_reward_points(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_trade_reward_points_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.total_trade_reward_points)
}
inline std::string* QueryTradeRewardCampaignResponse::mutable_total_trade_reward_points() {
  std::string* _s = _internal_mutable_total_trade_reward_points();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.total_trade_reward_points)
  return _s;
}
inline const std::string& QueryTradeRewardCampaignResponse::_internal_total_trade_reward_points() const {
  return _impl_.total_trade_reward_points_.Get();
}
inline void QueryTradeRewardCampaignResponse::_internal_set_total_trade_reward_points(const std::string& value) {
  ;


  _impl_.total_trade_reward_points_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTradeRewardCampaignResponse::_internal_mutable_total_trade_reward_points() {
  ;
  return _impl_.total_trade_reward_points_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTradeRewardCampaignResponse::release_total_trade_reward_points() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.total_trade_reward_points)
  return _impl_.total_trade_reward_points_.Release();
}
inline void QueryTradeRewardCampaignResponse::set_allocated_total_trade_reward_points(std::string* value) {
  _impl_.total_trade_reward_points_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_trade_reward_points_.IsDefault()) {
          _impl_.total_trade_reward_points_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.total_trade_reward_points)
}

// repeated .injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4 [json_name = "pendingTradingRewardPoolCampaignSchedule"];
inline int QueryTradeRewardCampaignResponse::_internal_pending_trading_reward_pool_campaign_schedule_size() const {
  return _impl_.pending_trading_reward_pool_campaign_schedule_.size();
}
inline int QueryTradeRewardCampaignResponse::pending_trading_reward_pool_campaign_schedule_size() const {
  return _internal_pending_trading_reward_pool_campaign_schedule_size();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* QueryTradeRewardCampaignResponse::mutable_pending_trading_reward_pool_campaign_schedule(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_trading_reward_pool_campaign_schedule)
  return _internal_mutable_pending_trading_reward_pool_campaign_schedule()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >*
QueryTradeRewardCampaignResponse::mutable_pending_trading_reward_pool_campaign_schedule() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_trading_reward_pool_campaign_schedule)
  return _internal_mutable_pending_trading_reward_pool_campaign_schedule();
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& QueryTradeRewardCampaignResponse::_internal_pending_trading_reward_pool_campaign_schedule(int index) const {
  return _internal_pending_trading_reward_pool_campaign_schedule().Get(index);
}
inline const ::injective::exchange::v1beta1::CampaignRewardPool& QueryTradeRewardCampaignResponse::pending_trading_reward_pool_campaign_schedule(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_trading_reward_pool_campaign_schedule)
  return _internal_pending_trading_reward_pool_campaign_schedule(index);
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* QueryTradeRewardCampaignResponse::_internal_add_pending_trading_reward_pool_campaign_schedule() {
  return _internal_mutable_pending_trading_reward_pool_campaign_schedule()->Add();
}
inline ::injective::exchange::v1beta1::CampaignRewardPool* QueryTradeRewardCampaignResponse::add_pending_trading_reward_pool_campaign_schedule() {
  ::injective::exchange::v1beta1::CampaignRewardPool* _add = _internal_add_pending_trading_reward_pool_campaign_schedule();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_trading_reward_pool_campaign_schedule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::CampaignRewardPool >&
QueryTradeRewardCampaignResponse::pending_trading_reward_pool_campaign_schedule() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_trading_reward_pool_campaign_schedule)
  return _internal_pending_trading_reward_pool_campaign_schedule();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>&
QueryTradeRewardCampaignResponse::_internal_pending_trading_reward_pool_campaign_schedule() const {
  return _impl_.pending_trading_reward_pool_campaign_schedule_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::CampaignRewardPool>*
QueryTradeRewardCampaignResponse::_internal_mutable_pending_trading_reward_pool_campaign_schedule() {
  return &_impl_.pending_trading_reward_pool_campaign_schedule_;
}

// repeated string pending_total_trade_reward_points = 5 [json_name = "pendingTotalTradeRewardPoints", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline int QueryTradeRewardCampaignResponse::_internal_pending_total_trade_reward_points_size() const {
  return _impl_.pending_total_trade_reward_points_.size();
}
inline int QueryTradeRewardCampaignResponse::pending_total_trade_reward_points_size() const {
  return _internal_pending_total_trade_reward_points_size();
}
inline void QueryTradeRewardCampaignResponse::clear_pending_total_trade_reward_points() {
  _internal_mutable_pending_total_trade_reward_points()->Clear();
}
inline std::string* QueryTradeRewardCampaignResponse::add_pending_total_trade_reward_points() {
  std::string* _s = _internal_add_pending_total_trade_reward_points();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
  return _s;
}
inline const std::string& QueryTradeRewardCampaignResponse::pending_total_trade_reward_points(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
  return _internal_pending_total_trade_reward_points(index);
}
inline std::string* QueryTradeRewardCampaignResponse::mutable_pending_total_trade_reward_points(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
  return _internal_mutable_pending_total_trade_reward_points()->Mutable(index);
}
inline void QueryTradeRewardCampaignResponse::set_pending_total_trade_reward_points(int index, const std::string& value) {
  _internal_mutable_pending_total_trade_reward_points()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::set_pending_total_trade_reward_points(int index, std::string&& value) {
  _internal_mutable_pending_total_trade_reward_points()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::set_pending_total_trade_reward_points(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_pending_total_trade_reward_points()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::set_pending_total_trade_reward_points(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_pending_total_trade_reward_points()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::set_pending_total_trade_reward_points(int index, absl::string_view value) {
  _internal_mutable_pending_total_trade_reward_points()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::add_pending_total_trade_reward_points(const std::string& value) {
  _internal_mutable_pending_total_trade_reward_points()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::add_pending_total_trade_reward_points(std::string&& value) {
  _internal_mutable_pending_total_trade_reward_points()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::add_pending_total_trade_reward_points(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_pending_total_trade_reward_points()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::add_pending_total_trade_reward_points(const char* value, std::size_t size) {
  _internal_mutable_pending_total_trade_reward_points()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline void QueryTradeRewardCampaignResponse::add_pending_total_trade_reward_points(absl::string_view value) {
  _internal_mutable_pending_total_trade_reward_points()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryTradeRewardCampaignResponse::pending_total_trade_reward_points() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
  return _internal_pending_total_trade_reward_points();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryTradeRewardCampaignResponse::mutable_pending_total_trade_reward_points() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTradeRewardCampaignResponse.pending_total_trade_reward_points)
  return _internal_mutable_pending_total_trade_reward_points();
}
inline const std::string& QueryTradeRewardCampaignResponse::_internal_pending_total_trade_reward_points(int index) const {
  return _internal_pending_total_trade_reward_points().Get(index);
}
inline std::string* QueryTradeRewardCampaignResponse::_internal_add_pending_total_trade_reward_points() {
  return _internal_mutable_pending_total_trade_reward_points()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryTradeRewardCampaignResponse::_internal_pending_total_trade_reward_points() const {
  return _impl_.pending_total_trade_reward_points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryTradeRewardCampaignResponse::_internal_mutable_pending_total_trade_reward_points() {
  return &_impl_.pending_total_trade_reward_points_;
}

// -------------------------------------------------------------------

// QueryIsOptedOutOfRewardsRequest

// string account = 1 [json_name = "account"];
inline void QueryIsOptedOutOfRewardsRequest::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& QueryIsOptedOutOfRewardsRequest::account() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryIsOptedOutOfRewardsRequest::set_account(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest.account)
}
inline std::string* QueryIsOptedOutOfRewardsRequest::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest.account)
  return _s;
}
inline const std::string& QueryIsOptedOutOfRewardsRequest::_internal_account() const {
  return _impl_.account_.Get();
}
inline void QueryIsOptedOutOfRewardsRequest::_internal_set_account(const std::string& value) {
  ;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryIsOptedOutOfRewardsRequest::_internal_mutable_account() {
  ;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryIsOptedOutOfRewardsRequest::release_account() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest.account)
  return _impl_.account_.Release();
}
inline void QueryIsOptedOutOfRewardsRequest::set_allocated_account(std::string* value) {
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsRequest.account)
}

// -------------------------------------------------------------------

// QueryIsOptedOutOfRewardsResponse

// bool is_opted_out = 1 [json_name = "isOptedOut"];
inline void QueryIsOptedOutOfRewardsResponse::clear_is_opted_out() {
  _impl_.is_opted_out_ = false;
}
inline bool QueryIsOptedOutOfRewardsResponse::is_opted_out() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse.is_opted_out)
  return _internal_is_opted_out();
}
inline void QueryIsOptedOutOfRewardsResponse::set_is_opted_out(bool value) {
  _internal_set_is_opted_out(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryIsOptedOutOfRewardsResponse.is_opted_out)
}
inline bool QueryIsOptedOutOfRewardsResponse::_internal_is_opted_out() const {
  return _impl_.is_opted_out_;
}
inline void QueryIsOptedOutOfRewardsResponse::_internal_set_is_opted_out(bool value) {
  ;
  _impl_.is_opted_out_ = value;
}

// -------------------------------------------------------------------

// QueryOptedOutOfRewardsAccountsRequest

// -------------------------------------------------------------------

// QueryOptedOutOfRewardsAccountsResponse

// repeated string accounts = 1 [json_name = "accounts"];
inline int QueryOptedOutOfRewardsAccountsResponse::_internal_accounts_size() const {
  return _impl_.accounts_.size();
}
inline int QueryOptedOutOfRewardsAccountsResponse::accounts_size() const {
  return _internal_accounts_size();
}
inline void QueryOptedOutOfRewardsAccountsResponse::clear_accounts() {
  _internal_mutable_accounts()->Clear();
}
inline std::string* QueryOptedOutOfRewardsAccountsResponse::add_accounts() {
  std::string* _s = _internal_add_accounts();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
  return _s;
}
inline const std::string& QueryOptedOutOfRewardsAccountsResponse::accounts(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
  return _internal_accounts(index);
}
inline std::string* QueryOptedOutOfRewardsAccountsResponse::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
  return _internal_mutable_accounts()->Mutable(index);
}
inline void QueryOptedOutOfRewardsAccountsResponse::set_accounts(int index, const std::string& value) {
  _internal_mutable_accounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::set_accounts(int index, std::string&& value) {
  _internal_mutable_accounts()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::set_accounts(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_accounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::set_accounts(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_accounts()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::set_accounts(int index, absl::string_view value) {
  _internal_mutable_accounts()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::add_accounts(const std::string& value) {
  _internal_mutable_accounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::add_accounts(std::string&& value) {
  _internal_mutable_accounts()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::add_accounts(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_accounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::add_accounts(const char* value, std::size_t size) {
  _internal_mutable_accounts()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline void QueryOptedOutOfRewardsAccountsResponse::add_accounts(absl::string_view value) {
  _internal_mutable_accounts()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryOptedOutOfRewardsAccountsResponse::accounts() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
  return _internal_accounts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* QueryOptedOutOfRewardsAccountsResponse::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryOptedOutOfRewardsAccountsResponse.accounts)
  return _internal_mutable_accounts();
}
inline const std::string& QueryOptedOutOfRewardsAccountsResponse::_internal_accounts(int index) const {
  return _internal_accounts().Get(index);
}
inline std::string* QueryOptedOutOfRewardsAccountsResponse::_internal_add_accounts() {
  return _internal_mutable_accounts()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryOptedOutOfRewardsAccountsResponse::_internal_accounts() const {
  return _impl_.accounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryOptedOutOfRewardsAccountsResponse::_internal_mutable_accounts() {
  return &_impl_.accounts_;
}

// -------------------------------------------------------------------

// QueryFeeDiscountAccountInfoRequest

// string account = 1 [json_name = "account"];
inline void QueryFeeDiscountAccountInfoRequest::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& QueryFeeDiscountAccountInfoRequest::account() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryFeeDiscountAccountInfoRequest::set_account(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest.account)
}
inline std::string* QueryFeeDiscountAccountInfoRequest::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest.account)
  return _s;
}
inline const std::string& QueryFeeDiscountAccountInfoRequest::_internal_account() const {
  return _impl_.account_.Get();
}
inline void QueryFeeDiscountAccountInfoRequest::_internal_set_account(const std::string& value) {
  ;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryFeeDiscountAccountInfoRequest::_internal_mutable_account() {
  ;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryFeeDiscountAccountInfoRequest::release_account() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest.account)
  return _impl_.account_.Release();
}
inline void QueryFeeDiscountAccountInfoRequest::set_allocated_account(std::string* value) {
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoRequest.account)
}

// -------------------------------------------------------------------

// QueryFeeDiscountAccountInfoResponse

// uint64 tier_level = 1 [json_name = "tierLevel"];
inline void QueryFeeDiscountAccountInfoResponse::clear_tier_level() {
  _impl_.tier_level_ = ::uint64_t{0u};
}
inline ::uint64_t QueryFeeDiscountAccountInfoResponse::tier_level() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.tier_level)
  return _internal_tier_level();
}
inline void QueryFeeDiscountAccountInfoResponse::set_tier_level(::uint64_t value) {
  _internal_set_tier_level(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.tier_level)
}
inline ::uint64_t QueryFeeDiscountAccountInfoResponse::_internal_tier_level() const {
  return _impl_.tier_level_;
}
inline void QueryFeeDiscountAccountInfoResponse::_internal_set_tier_level(::uint64_t value) {
  ;
  _impl_.tier_level_ = value;
}

// .injective.exchange.v1beta1.FeeDiscountTierInfo account_info = 2 [json_name = "accountInfo"];
inline bool QueryFeeDiscountAccountInfoResponse::has_account_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.account_info_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::FeeDiscountTierInfo& QueryFeeDiscountAccountInfoResponse::_internal_account_info() const {
  const ::injective::exchange::v1beta1::FeeDiscountTierInfo* p = _impl_.account_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::FeeDiscountTierInfo&>(
      ::injective::exchange::v1beta1::_FeeDiscountTierInfo_default_instance_);
}
inline const ::injective::exchange::v1beta1::FeeDiscountTierInfo& QueryFeeDiscountAccountInfoResponse::account_info() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_info)
  return _internal_account_info();
}
inline void QueryFeeDiscountAccountInfoResponse::unsafe_arena_set_allocated_account_info(
    ::injective::exchange::v1beta1::FeeDiscountTierInfo* account_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_info_);
  }
  _impl_.account_info_ = account_info;
  if (account_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_info)
}
inline ::injective::exchange::v1beta1::FeeDiscountTierInfo* QueryFeeDiscountAccountInfoResponse::release_account_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* temp = _impl_.account_info_;
  _impl_.account_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountTierInfo* QueryFeeDiscountAccountInfoResponse::unsafe_arena_release_account_info() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* temp = _impl_.account_info_;
  _impl_.account_info_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountTierInfo* QueryFeeDiscountAccountInfoResponse::_internal_mutable_account_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.account_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountTierInfo>(GetArenaForAllocation());
    _impl_.account_info_ = p;
  }
  return _impl_.account_info_;
}
inline ::injective::exchange::v1beta1::FeeDiscountTierInfo* QueryFeeDiscountAccountInfoResponse::mutable_account_info() {
  ::injective::exchange::v1beta1::FeeDiscountTierInfo* _msg = _internal_mutable_account_info();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_info)
  return _msg;
}
inline void QueryFeeDiscountAccountInfoResponse::set_allocated_account_info(::injective::exchange::v1beta1::FeeDiscountTierInfo* account_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_info_);
  }
  if (account_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_info));
    if (message_arena != submessage_arena) {
      account_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_info_ = account_info;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_info)
}

// .injective.exchange.v1beta1.FeeDiscountTierTTL account_ttl = 3 [json_name = "accountTtl"];
inline bool QueryFeeDiscountAccountInfoResponse::has_account_ttl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.account_ttl_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::FeeDiscountTierTTL& QueryFeeDiscountAccountInfoResponse::_internal_account_ttl() const {
  const ::injective::exchange::v1beta1::FeeDiscountTierTTL* p = _impl_.account_ttl_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::FeeDiscountTierTTL&>(
      ::injective::exchange::v1beta1::_FeeDiscountTierTTL_default_instance_);
}
inline const ::injective::exchange::v1beta1::FeeDiscountTierTTL& QueryFeeDiscountAccountInfoResponse::account_ttl() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_ttl)
  return _internal_account_ttl();
}
inline void QueryFeeDiscountAccountInfoResponse::unsafe_arena_set_allocated_account_ttl(
    ::injective::exchange::v1beta1::FeeDiscountTierTTL* account_ttl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_ttl_);
  }
  _impl_.account_ttl_ = account_ttl;
  if (account_ttl) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_ttl)
}
inline ::injective::exchange::v1beta1::FeeDiscountTierTTL* QueryFeeDiscountAccountInfoResponse::release_account_ttl() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::FeeDiscountTierTTL* temp = _impl_.account_ttl_;
  _impl_.account_ttl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountTierTTL* QueryFeeDiscountAccountInfoResponse::unsafe_arena_release_account_ttl() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_ttl)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective::exchange::v1beta1::FeeDiscountTierTTL* temp = _impl_.account_ttl_;
  _impl_.account_ttl_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountTierTTL* QueryFeeDiscountAccountInfoResponse::_internal_mutable_account_ttl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.account_ttl_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountTierTTL>(GetArenaForAllocation());
    _impl_.account_ttl_ = p;
  }
  return _impl_.account_ttl_;
}
inline ::injective::exchange::v1beta1::FeeDiscountTierTTL* QueryFeeDiscountAccountInfoResponse::mutable_account_ttl() {
  ::injective::exchange::v1beta1::FeeDiscountTierTTL* _msg = _internal_mutable_account_ttl();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_ttl)
  return _msg;
}
inline void QueryFeeDiscountAccountInfoResponse::set_allocated_account_ttl(::injective::exchange::v1beta1::FeeDiscountTierTTL* account_ttl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_ttl_);
  }
  if (account_ttl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_ttl));
    if (message_arena != submessage_arena) {
      account_ttl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_ttl, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.account_ttl_ = account_ttl;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryFeeDiscountAccountInfoResponse.account_ttl)
}

// -------------------------------------------------------------------

// QueryFeeDiscountScheduleRequest

// -------------------------------------------------------------------

// QueryFeeDiscountScheduleResponse

// .injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 1 [json_name = "feeDiscountSchedule"];
inline bool QueryFeeDiscountScheduleResponse::has_fee_discount_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fee_discount_schedule_ != nullptr);
  return value;
}
inline const ::injective::exchange::v1beta1::FeeDiscountSchedule& QueryFeeDiscountScheduleResponse::_internal_fee_discount_schedule() const {
  const ::injective::exchange::v1beta1::FeeDiscountSchedule* p = _impl_.fee_discount_schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::FeeDiscountSchedule&>(
      ::injective::exchange::v1beta1::_FeeDiscountSchedule_default_instance_);
}
inline const ::injective::exchange::v1beta1::FeeDiscountSchedule& QueryFeeDiscountScheduleResponse::fee_discount_schedule() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse.fee_discount_schedule)
  return _internal_fee_discount_schedule();
}
inline void QueryFeeDiscountScheduleResponse::unsafe_arena_set_allocated_fee_discount_schedule(
    ::injective::exchange::v1beta1::FeeDiscountSchedule* fee_discount_schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_discount_schedule_);
  }
  _impl_.fee_discount_schedule_ = fee_discount_schedule;
  if (fee_discount_schedule) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse.fee_discount_schedule)
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* QueryFeeDiscountScheduleResponse::release_fee_discount_schedule() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* temp = _impl_.fee_discount_schedule_;
  _impl_.fee_discount_schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* QueryFeeDiscountScheduleResponse::unsafe_arena_release_fee_discount_schedule() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse.fee_discount_schedule)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::FeeDiscountSchedule* temp = _impl_.fee_discount_schedule_;
  _impl_.fee_discount_schedule_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* QueryFeeDiscountScheduleResponse::_internal_mutable_fee_discount_schedule() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fee_discount_schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::FeeDiscountSchedule>(GetArenaForAllocation());
    _impl_.fee_discount_schedule_ = p;
  }
  return _impl_.fee_discount_schedule_;
}
inline ::injective::exchange::v1beta1::FeeDiscountSchedule* QueryFeeDiscountScheduleResponse::mutable_fee_discount_schedule() {
  ::injective::exchange::v1beta1::FeeDiscountSchedule* _msg = _internal_mutable_fee_discount_schedule();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse.fee_discount_schedule)
  return _msg;
}
inline void QueryFeeDiscountScheduleResponse::set_allocated_fee_discount_schedule(::injective::exchange::v1beta1::FeeDiscountSchedule* fee_discount_schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_discount_schedule_);
  }
  if (fee_discount_schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fee_discount_schedule));
    if (message_arena != submessage_arena) {
      fee_discount_schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee_discount_schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_discount_schedule_ = fee_discount_schedule;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryFeeDiscountScheduleResponse.fee_discount_schedule)
}

// -------------------------------------------------------------------

// QueryBalanceMismatchesRequest

// int64 dust_factor = 1 [json_name = "dustFactor"];
inline void QueryBalanceMismatchesRequest::clear_dust_factor() {
  _impl_.dust_factor_ = ::int64_t{0};
}
inline ::int64_t QueryBalanceMismatchesRequest::dust_factor() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryBalanceMismatchesRequest.dust_factor)
  return _internal_dust_factor();
}
inline void QueryBalanceMismatchesRequest::set_dust_factor(::int64_t value) {
  _internal_set_dust_factor(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryBalanceMismatchesRequest.dust_factor)
}
inline ::int64_t QueryBalanceMismatchesRequest::_internal_dust_factor() const {
  return _impl_.dust_factor_;
}
inline void QueryBalanceMismatchesRequest::_internal_set_dust_factor(::int64_t value) {
  ;
  _impl_.dust_factor_ = value;
}

// -------------------------------------------------------------------

// BalanceMismatch

// string subaccountId = 1 [json_name = "subaccountId"];
inline void BalanceMismatch::clear_subaccountid() {
  _impl_.subaccountid_.ClearToEmpty();
}
inline const std::string& BalanceMismatch::subaccountid() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceMismatch.subaccountId)
  return _internal_subaccountid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceMismatch::set_subaccountid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccountid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceMismatch.subaccountId)
}
inline std::string* BalanceMismatch::mutable_subaccountid() {
  std::string* _s = _internal_mutable_subaccountid();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceMismatch.subaccountId)
  return _s;
}
inline const std::string& BalanceMismatch::_internal_subaccountid() const {
  return _impl_.subaccountid_.Get();
}
inline void BalanceMismatch::_internal_set_subaccountid(const std::string& value) {
  ;


  _impl_.subaccountid_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceMismatch::_internal_mutable_subaccountid() {
  ;
  return _impl_.subaccountid_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceMismatch::release_subaccountid() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceMismatch.subaccountId)
  return _impl_.subaccountid_.Release();
}
inline void BalanceMismatch::set_allocated_subaccountid(std::string* value) {
  _impl_.subaccountid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccountid_.IsDefault()) {
          _impl_.subaccountid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceMismatch.subaccountId)
}

// string denom = 2 [json_name = "denom"];
inline void BalanceMismatch::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& BalanceMismatch::denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceMismatch.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceMismatch::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceMismatch.denom)
}
inline std::string* BalanceMismatch::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceMismatch.denom)
  return _s;
}
inline const std::string& BalanceMismatch::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void BalanceMismatch::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceMismatch::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceMismatch::release_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceMismatch.denom)
  return _impl_.denom_.Release();
}
inline void BalanceMismatch::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceMismatch.denom)
}

// string available = 3 [json_name = "available", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceMismatch::clear_available() {
  _impl_.available_.ClearToEmpty();
}
inline const std::string& BalanceMismatch::available() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceMismatch.available)
  return _internal_available();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceMismatch::set_available(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.available_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceMismatch.available)
}
inline std::string* BalanceMismatch::mutable_available() {
  std::string* _s = _internal_mutable_available();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceMismatch.available)
  return _s;
}
inline const std::string& BalanceMismatch::_internal_available() const {
  return _impl_.available_.Get();
}
inline void BalanceMismatch::_internal_set_available(const std::string& value) {
  ;


  _impl_.available_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceMismatch::_internal_mutable_available() {
  ;
  return _impl_.available_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceMismatch::release_available() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceMismatch.available)
  return _impl_.available_.Release();
}
inline void BalanceMismatch::set_allocated_available(std::string* value) {
  _impl_.available_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.available_.IsDefault()) {
          _impl_.available_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceMismatch.available)
}

// string total = 4 [json_name = "total", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceMismatch::clear_total() {
  _impl_.total_.ClearToEmpty();
}
inline const std::string& BalanceMismatch::total() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceMismatch.total)
  return _internal_total();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceMismatch::set_total(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceMismatch.total)
}
inline std::string* BalanceMismatch::mutable_total() {
  std::string* _s = _internal_mutable_total();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceMismatch.total)
  return _s;
}
inline const std::string& BalanceMismatch::_internal_total() const {
  return _impl_.total_.Get();
}
inline void BalanceMismatch::_internal_set_total(const std::string& value) {
  ;


  _impl_.total_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceMismatch::_internal_mutable_total() {
  ;
  return _impl_.total_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceMismatch::release_total() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceMismatch.total)
  return _impl_.total_.Release();
}
inline void BalanceMismatch::set_allocated_total(std::string* value) {
  _impl_.total_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_.IsDefault()) {
          _impl_.total_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceMismatch.total)
}

// string balance_hold = 5 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceMismatch::clear_balance_hold() {
  _impl_.balance_hold_.ClearToEmpty();
}
inline const std::string& BalanceMismatch::balance_hold() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceMismatch.balance_hold)
  return _internal_balance_hold();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceMismatch::set_balance_hold(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_hold_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceMismatch.balance_hold)
}
inline std::string* BalanceMismatch::mutable_balance_hold() {
  std::string* _s = _internal_mutable_balance_hold();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceMismatch.balance_hold)
  return _s;
}
inline const std::string& BalanceMismatch::_internal_balance_hold() const {
  return _impl_.balance_hold_.Get();
}
inline void BalanceMismatch::_internal_set_balance_hold(const std::string& value) {
  ;


  _impl_.balance_hold_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceMismatch::_internal_mutable_balance_hold() {
  ;
  return _impl_.balance_hold_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceMismatch::release_balance_hold() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceMismatch.balance_hold)
  return _impl_.balance_hold_.Release();
}
inline void BalanceMismatch::set_allocated_balance_hold(std::string* value) {
  _impl_.balance_hold_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_hold_.IsDefault()) {
          _impl_.balance_hold_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceMismatch.balance_hold)
}

// string expected_total = 6 [json_name = "expectedTotal", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceMismatch::clear_expected_total() {
  _impl_.expected_total_.ClearToEmpty();
}
inline const std::string& BalanceMismatch::expected_total() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceMismatch.expected_total)
  return _internal_expected_total();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceMismatch::set_expected_total(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.expected_total_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceMismatch.expected_total)
}
inline std::string* BalanceMismatch::mutable_expected_total() {
  std::string* _s = _internal_mutable_expected_total();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceMismatch.expected_total)
  return _s;
}
inline const std::string& BalanceMismatch::_internal_expected_total() const {
  return _impl_.expected_total_.Get();
}
inline void BalanceMismatch::_internal_set_expected_total(const std::string& value) {
  ;


  _impl_.expected_total_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceMismatch::_internal_mutable_expected_total() {
  ;
  return _impl_.expected_total_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceMismatch::release_expected_total() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceMismatch.expected_total)
  return _impl_.expected_total_.Release();
}
inline void BalanceMismatch::set_allocated_expected_total(std::string* value) {
  _impl_.expected_total_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.expected_total_.IsDefault()) {
          _impl_.expected_total_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceMismatch.expected_total)
}

// string difference = 7 [json_name = "difference", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceMismatch::clear_difference() {
  _impl_.difference_.ClearToEmpty();
}
inline const std::string& BalanceMismatch::difference() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceMismatch.difference)
  return _internal_difference();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceMismatch::set_difference(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.difference_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceMismatch.difference)
}
inline std::string* BalanceMismatch::mutable_difference() {
  std::string* _s = _internal_mutable_difference();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceMismatch.difference)
  return _s;
}
inline const std::string& BalanceMismatch::_internal_difference() const {
  return _impl_.difference_.Get();
}
inline void BalanceMismatch::_internal_set_difference(const std::string& value) {
  ;


  _impl_.difference_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceMismatch::_internal_mutable_difference() {
  ;
  return _impl_.difference_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceMismatch::release_difference() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceMismatch.difference)
  return _impl_.difference_.Release();
}
inline void BalanceMismatch::set_allocated_difference(std::string* value) {
  _impl_.difference_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.difference_.IsDefault()) {
          _impl_.difference_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceMismatch.difference)
}

// -------------------------------------------------------------------

// QueryBalanceMismatchesResponse

// repeated .injective.exchange.v1beta1.BalanceMismatch balance_mismatches = 1 [json_name = "balanceMismatches"];
inline int QueryBalanceMismatchesResponse::_internal_balance_mismatches_size() const {
  return _impl_.balance_mismatches_.size();
}
inline int QueryBalanceMismatchesResponse::balance_mismatches_size() const {
  return _internal_balance_mismatches_size();
}
inline void QueryBalanceMismatchesResponse::clear_balance_mismatches() {
  _internal_mutable_balance_mismatches()->Clear();
}
inline ::injective::exchange::v1beta1::BalanceMismatch* QueryBalanceMismatchesResponse::mutable_balance_mismatches(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryBalanceMismatchesResponse.balance_mismatches)
  return _internal_mutable_balance_mismatches()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceMismatch >*
QueryBalanceMismatchesResponse::mutable_balance_mismatches() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryBalanceMismatchesResponse.balance_mismatches)
  return _internal_mutable_balance_mismatches();
}
inline const ::injective::exchange::v1beta1::BalanceMismatch& QueryBalanceMismatchesResponse::_internal_balance_mismatches(int index) const {
  return _internal_balance_mismatches().Get(index);
}
inline const ::injective::exchange::v1beta1::BalanceMismatch& QueryBalanceMismatchesResponse::balance_mismatches(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryBalanceMismatchesResponse.balance_mismatches)
  return _internal_balance_mismatches(index);
}
inline ::injective::exchange::v1beta1::BalanceMismatch* QueryBalanceMismatchesResponse::_internal_add_balance_mismatches() {
  return _internal_mutable_balance_mismatches()->Add();
}
inline ::injective::exchange::v1beta1::BalanceMismatch* QueryBalanceMismatchesResponse::add_balance_mismatches() {
  ::injective::exchange::v1beta1::BalanceMismatch* _add = _internal_add_balance_mismatches();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryBalanceMismatchesResponse.balance_mismatches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceMismatch >&
QueryBalanceMismatchesResponse::balance_mismatches() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryBalanceMismatchesResponse.balance_mismatches)
  return _internal_balance_mismatches();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceMismatch>&
QueryBalanceMismatchesResponse::_internal_balance_mismatches() const {
  return _impl_.balance_mismatches_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceMismatch>*
QueryBalanceMismatchesResponse::_internal_mutable_balance_mismatches() {
  return &_impl_.balance_mismatches_;
}

// -------------------------------------------------------------------

// QueryBalanceWithBalanceHoldsRequest

// -------------------------------------------------------------------

// BalanceWithMarginHold

// string subaccountId = 1 [json_name = "subaccountId"];
inline void BalanceWithMarginHold::clear_subaccountid() {
  _impl_.subaccountid_.ClearToEmpty();
}
inline const std::string& BalanceWithMarginHold::subaccountid() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceWithMarginHold.subaccountId)
  return _internal_subaccountid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceWithMarginHold::set_subaccountid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccountid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceWithMarginHold.subaccountId)
}
inline std::string* BalanceWithMarginHold::mutable_subaccountid() {
  std::string* _s = _internal_mutable_subaccountid();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceWithMarginHold.subaccountId)
  return _s;
}
inline const std::string& BalanceWithMarginHold::_internal_subaccountid() const {
  return _impl_.subaccountid_.Get();
}
inline void BalanceWithMarginHold::_internal_set_subaccountid(const std::string& value) {
  ;


  _impl_.subaccountid_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::_internal_mutable_subaccountid() {
  ;
  return _impl_.subaccountid_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::release_subaccountid() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceWithMarginHold.subaccountId)
  return _impl_.subaccountid_.Release();
}
inline void BalanceWithMarginHold::set_allocated_subaccountid(std::string* value) {
  _impl_.subaccountid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccountid_.IsDefault()) {
          _impl_.subaccountid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceWithMarginHold.subaccountId)
}

// string denom = 2 [json_name = "denom"];
inline void BalanceWithMarginHold::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& BalanceWithMarginHold::denom() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceWithMarginHold.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceWithMarginHold::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceWithMarginHold.denom)
}
inline std::string* BalanceWithMarginHold::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceWithMarginHold.denom)
  return _s;
}
inline const std::string& BalanceWithMarginHold::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void BalanceWithMarginHold::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::release_denom() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceWithMarginHold.denom)
  return _impl_.denom_.Release();
}
inline void BalanceWithMarginHold::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceWithMarginHold.denom)
}

// string available = 3 [json_name = "available", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceWithMarginHold::clear_available() {
  _impl_.available_.ClearToEmpty();
}
inline const std::string& BalanceWithMarginHold::available() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceWithMarginHold.available)
  return _internal_available();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceWithMarginHold::set_available(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.available_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceWithMarginHold.available)
}
inline std::string* BalanceWithMarginHold::mutable_available() {
  std::string* _s = _internal_mutable_available();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceWithMarginHold.available)
  return _s;
}
inline const std::string& BalanceWithMarginHold::_internal_available() const {
  return _impl_.available_.Get();
}
inline void BalanceWithMarginHold::_internal_set_available(const std::string& value) {
  ;


  _impl_.available_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::_internal_mutable_available() {
  ;
  return _impl_.available_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::release_available() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceWithMarginHold.available)
  return _impl_.available_.Release();
}
inline void BalanceWithMarginHold::set_allocated_available(std::string* value) {
  _impl_.available_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.available_.IsDefault()) {
          _impl_.available_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceWithMarginHold.available)
}

// string total = 4 [json_name = "total", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceWithMarginHold::clear_total() {
  _impl_.total_.ClearToEmpty();
}
inline const std::string& BalanceWithMarginHold::total() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceWithMarginHold.total)
  return _internal_total();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceWithMarginHold::set_total(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceWithMarginHold.total)
}
inline std::string* BalanceWithMarginHold::mutable_total() {
  std::string* _s = _internal_mutable_total();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceWithMarginHold.total)
  return _s;
}
inline const std::string& BalanceWithMarginHold::_internal_total() const {
  return _impl_.total_.Get();
}
inline void BalanceWithMarginHold::_internal_set_total(const std::string& value) {
  ;


  _impl_.total_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::_internal_mutable_total() {
  ;
  return _impl_.total_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::release_total() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceWithMarginHold.total)
  return _impl_.total_.Release();
}
inline void BalanceWithMarginHold::set_allocated_total(std::string* value) {
  _impl_.total_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_.IsDefault()) {
          _impl_.total_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceWithMarginHold.total)
}

// string balance_hold = 5 [json_name = "balanceHold", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void BalanceWithMarginHold::clear_balance_hold() {
  _impl_.balance_hold_.ClearToEmpty();
}
inline const std::string& BalanceWithMarginHold::balance_hold() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.BalanceWithMarginHold.balance_hold)
  return _internal_balance_hold();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BalanceWithMarginHold::set_balance_hold(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_hold_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.BalanceWithMarginHold.balance_hold)
}
inline std::string* BalanceWithMarginHold::mutable_balance_hold() {
  std::string* _s = _internal_mutable_balance_hold();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.BalanceWithMarginHold.balance_hold)
  return _s;
}
inline const std::string& BalanceWithMarginHold::_internal_balance_hold() const {
  return _impl_.balance_hold_.Get();
}
inline void BalanceWithMarginHold::_internal_set_balance_hold(const std::string& value) {
  ;


  _impl_.balance_hold_.Set(value, GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::_internal_mutable_balance_hold() {
  ;
  return _impl_.balance_hold_.Mutable( GetArenaForAllocation());
}
inline std::string* BalanceWithMarginHold::release_balance_hold() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.BalanceWithMarginHold.balance_hold)
  return _impl_.balance_hold_.Release();
}
inline void BalanceWithMarginHold::set_allocated_balance_hold(std::string* value) {
  _impl_.balance_hold_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_hold_.IsDefault()) {
          _impl_.balance_hold_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.BalanceWithMarginHold.balance_hold)
}

// -------------------------------------------------------------------

// QueryBalanceWithBalanceHoldsResponse

// repeated .injective.exchange.v1beta1.BalanceWithMarginHold balance_with_balance_holds = 1 [json_name = "balanceWithBalanceHolds"];
inline int QueryBalanceWithBalanceHoldsResponse::_internal_balance_with_balance_holds_size() const {
  return _impl_.balance_with_balance_holds_.size();
}
inline int QueryBalanceWithBalanceHoldsResponse::balance_with_balance_holds_size() const {
  return _internal_balance_with_balance_holds_size();
}
inline void QueryBalanceWithBalanceHoldsResponse::clear_balance_with_balance_holds() {
  _internal_mutable_balance_with_balance_holds()->Clear();
}
inline ::injective::exchange::v1beta1::BalanceWithMarginHold* QueryBalanceWithBalanceHoldsResponse::mutable_balance_with_balance_holds(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse.balance_with_balance_holds)
  return _internal_mutable_balance_with_balance_holds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceWithMarginHold >*
QueryBalanceWithBalanceHoldsResponse::mutable_balance_with_balance_holds() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse.balance_with_balance_holds)
  return _internal_mutable_balance_with_balance_holds();
}
inline const ::injective::exchange::v1beta1::BalanceWithMarginHold& QueryBalanceWithBalanceHoldsResponse::_internal_balance_with_balance_holds(int index) const {
  return _internal_balance_with_balance_holds().Get(index);
}
inline const ::injective::exchange::v1beta1::BalanceWithMarginHold& QueryBalanceWithBalanceHoldsResponse::balance_with_balance_holds(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse.balance_with_balance_holds)
  return _internal_balance_with_balance_holds(index);
}
inline ::injective::exchange::v1beta1::BalanceWithMarginHold* QueryBalanceWithBalanceHoldsResponse::_internal_add_balance_with_balance_holds() {
  return _internal_mutable_balance_with_balance_holds()->Add();
}
inline ::injective::exchange::v1beta1::BalanceWithMarginHold* QueryBalanceWithBalanceHoldsResponse::add_balance_with_balance_holds() {
  ::injective::exchange::v1beta1::BalanceWithMarginHold* _add = _internal_add_balance_with_balance_holds();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse.balance_with_balance_holds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BalanceWithMarginHold >&
QueryBalanceWithBalanceHoldsResponse::balance_with_balance_holds() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryBalanceWithBalanceHoldsResponse.balance_with_balance_holds)
  return _internal_balance_with_balance_holds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceWithMarginHold>&
QueryBalanceWithBalanceHoldsResponse::_internal_balance_with_balance_holds() const {
  return _impl_.balance_with_balance_holds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BalanceWithMarginHold>*
QueryBalanceWithBalanceHoldsResponse::_internal_mutable_balance_with_balance_holds() {
  return &_impl_.balance_with_balance_holds_;
}

// -------------------------------------------------------------------

// QueryFeeDiscountTierStatisticsRequest

// -------------------------------------------------------------------

// TierStatistic

// uint64 tier = 1 [json_name = "tier"];
inline void TierStatistic::clear_tier() {
  _impl_.tier_ = ::uint64_t{0u};
}
inline ::uint64_t TierStatistic::tier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TierStatistic.tier)
  return _internal_tier();
}
inline void TierStatistic::set_tier(::uint64_t value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TierStatistic.tier)
}
inline ::uint64_t TierStatistic::_internal_tier() const {
  return _impl_.tier_;
}
inline void TierStatistic::_internal_set_tier(::uint64_t value) {
  ;
  _impl_.tier_ = value;
}

// uint64 count = 2 [json_name = "count"];
inline void TierStatistic::clear_count() {
  _impl_.count_ = ::uint64_t{0u};
}
inline ::uint64_t TierStatistic::count() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TierStatistic.count)
  return _internal_count();
}
inline void TierStatistic::set_count(::uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TierStatistic.count)
}
inline ::uint64_t TierStatistic::_internal_count() const {
  return _impl_.count_;
}
inline void TierStatistic::_internal_set_count(::uint64_t value) {
  ;
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// QueryFeeDiscountTierStatisticsResponse

// repeated .injective.exchange.v1beta1.TierStatistic statistics = 1 [json_name = "statistics"];
inline int QueryFeeDiscountTierStatisticsResponse::_internal_statistics_size() const {
  return _impl_.statistics_.size();
}
inline int QueryFeeDiscountTierStatisticsResponse::statistics_size() const {
  return _internal_statistics_size();
}
inline void QueryFeeDiscountTierStatisticsResponse::clear_statistics() {
  _internal_mutable_statistics()->Clear();
}
inline ::injective::exchange::v1beta1::TierStatistic* QueryFeeDiscountTierStatisticsResponse::mutable_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse.statistics)
  return _internal_mutable_statistics()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TierStatistic >*
QueryFeeDiscountTierStatisticsResponse::mutable_statistics() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse.statistics)
  return _internal_mutable_statistics();
}
inline const ::injective::exchange::v1beta1::TierStatistic& QueryFeeDiscountTierStatisticsResponse::_internal_statistics(int index) const {
  return _internal_statistics().Get(index);
}
inline const ::injective::exchange::v1beta1::TierStatistic& QueryFeeDiscountTierStatisticsResponse::statistics(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse.statistics)
  return _internal_statistics(index);
}
inline ::injective::exchange::v1beta1::TierStatistic* QueryFeeDiscountTierStatisticsResponse::_internal_add_statistics() {
  return _internal_mutable_statistics()->Add();
}
inline ::injective::exchange::v1beta1::TierStatistic* QueryFeeDiscountTierStatisticsResponse::add_statistics() {
  ::injective::exchange::v1beta1::TierStatistic* _add = _internal_add_statistics();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse.statistics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TierStatistic >&
QueryFeeDiscountTierStatisticsResponse::statistics() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryFeeDiscountTierStatisticsResponse.statistics)
  return _internal_statistics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TierStatistic>&
QueryFeeDiscountTierStatisticsResponse::_internal_statistics() const {
  return _impl_.statistics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TierStatistic>*
QueryFeeDiscountTierStatisticsResponse::_internal_mutable_statistics() {
  return &_impl_.statistics_;
}

// -------------------------------------------------------------------

// MitoVaultInfosRequest

// -------------------------------------------------------------------

// MitoVaultInfosResponse

// repeated string master_addresses = 1 [json_name = "masterAddresses"];
inline int MitoVaultInfosResponse::_internal_master_addresses_size() const {
  return _impl_.master_addresses_.size();
}
inline int MitoVaultInfosResponse::master_addresses_size() const {
  return _internal_master_addresses_size();
}
inline void MitoVaultInfosResponse::clear_master_addresses() {
  _internal_mutable_master_addresses()->Clear();
}
inline std::string* MitoVaultInfosResponse::add_master_addresses() {
  std::string* _s = _internal_add_master_addresses();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
  return _s;
}
inline const std::string& MitoVaultInfosResponse::master_addresses(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
  return _internal_master_addresses(index);
}
inline std::string* MitoVaultInfosResponse::mutable_master_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
  return _internal_mutable_master_addresses()->Mutable(index);
}
inline void MitoVaultInfosResponse::set_master_addresses(int index, const std::string& value) {
  _internal_mutable_master_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::set_master_addresses(int index, std::string&& value) {
  _internal_mutable_master_addresses()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::set_master_addresses(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_master_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::set_master_addresses(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_master_addresses()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::set_master_addresses(int index, absl::string_view value) {
  _internal_mutable_master_addresses()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::add_master_addresses(const std::string& value) {
  _internal_mutable_master_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::add_master_addresses(std::string&& value) {
  _internal_mutable_master_addresses()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::add_master_addresses(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_master_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::add_master_addresses(const char* value, std::size_t size) {
  _internal_mutable_master_addresses()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline void MitoVaultInfosResponse::add_master_addresses(absl::string_view value) {
  _internal_mutable_master_addresses()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::master_addresses() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
  return _internal_master_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MitoVaultInfosResponse::mutable_master_addresses() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MitoVaultInfosResponse.master_addresses)
  return _internal_mutable_master_addresses();
}
inline const std::string& MitoVaultInfosResponse::_internal_master_addresses(int index) const {
  return _internal_master_addresses().Get(index);
}
inline std::string* MitoVaultInfosResponse::_internal_add_master_addresses() {
  return _internal_mutable_master_addresses()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::_internal_master_addresses() const {
  return _impl_.master_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MitoVaultInfosResponse::_internal_mutable_master_addresses() {
  return &_impl_.master_addresses_;
}

// repeated string derivative_addresses = 2 [json_name = "derivativeAddresses"];
inline int MitoVaultInfosResponse::_internal_derivative_addresses_size() const {
  return _impl_.derivative_addresses_.size();
}
inline int MitoVaultInfosResponse::derivative_addresses_size() const {
  return _internal_derivative_addresses_size();
}
inline void MitoVaultInfosResponse::clear_derivative_addresses() {
  _internal_mutable_derivative_addresses()->Clear();
}
inline std::string* MitoVaultInfosResponse::add_derivative_addresses() {
  std::string* _s = _internal_add_derivative_addresses();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
  return _s;
}
inline const std::string& MitoVaultInfosResponse::derivative_addresses(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
  return _internal_derivative_addresses(index);
}
inline std::string* MitoVaultInfosResponse::mutable_derivative_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
  return _internal_mutable_derivative_addresses()->Mutable(index);
}
inline void MitoVaultInfosResponse::set_derivative_addresses(int index, const std::string& value) {
  _internal_mutable_derivative_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::set_derivative_addresses(int index, std::string&& value) {
  _internal_mutable_derivative_addresses()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::set_derivative_addresses(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::set_derivative_addresses(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_derivative_addresses()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::set_derivative_addresses(int index, absl::string_view value) {
  _internal_mutable_derivative_addresses()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::add_derivative_addresses(const std::string& value) {
  _internal_mutable_derivative_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::add_derivative_addresses(std::string&& value) {
  _internal_mutable_derivative_addresses()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::add_derivative_addresses(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::add_derivative_addresses(const char* value, std::size_t size) {
  _internal_mutable_derivative_addresses()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline void MitoVaultInfosResponse::add_derivative_addresses(absl::string_view value) {
  _internal_mutable_derivative_addresses()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::derivative_addresses() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
  return _internal_derivative_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MitoVaultInfosResponse::mutable_derivative_addresses() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MitoVaultInfosResponse.derivative_addresses)
  return _internal_mutable_derivative_addresses();
}
inline const std::string& MitoVaultInfosResponse::_internal_derivative_addresses(int index) const {
  return _internal_derivative_addresses().Get(index);
}
inline std::string* MitoVaultInfosResponse::_internal_add_derivative_addresses() {
  return _internal_mutable_derivative_addresses()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::_internal_derivative_addresses() const {
  return _impl_.derivative_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MitoVaultInfosResponse::_internal_mutable_derivative_addresses() {
  return &_impl_.derivative_addresses_;
}

// repeated string spot_addresses = 3 [json_name = "spotAddresses"];
inline int MitoVaultInfosResponse::_internal_spot_addresses_size() const {
  return _impl_.spot_addresses_.size();
}
inline int MitoVaultInfosResponse::spot_addresses_size() const {
  return _internal_spot_addresses_size();
}
inline void MitoVaultInfosResponse::clear_spot_addresses() {
  _internal_mutable_spot_addresses()->Clear();
}
inline std::string* MitoVaultInfosResponse::add_spot_addresses() {
  std::string* _s = _internal_add_spot_addresses();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
  return _s;
}
inline const std::string& MitoVaultInfosResponse::spot_addresses(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
  return _internal_spot_addresses(index);
}
inline std::string* MitoVaultInfosResponse::mutable_spot_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
  return _internal_mutable_spot_addresses()->Mutable(index);
}
inline void MitoVaultInfosResponse::set_spot_addresses(int index, const std::string& value) {
  _internal_mutable_spot_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::set_spot_addresses(int index, std::string&& value) {
  _internal_mutable_spot_addresses()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::set_spot_addresses(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::set_spot_addresses(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_spot_addresses()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::set_spot_addresses(int index, absl::string_view value) {
  _internal_mutable_spot_addresses()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::add_spot_addresses(const std::string& value) {
  _internal_mutable_spot_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::add_spot_addresses(std::string&& value) {
  _internal_mutable_spot_addresses()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::add_spot_addresses(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::add_spot_addresses(const char* value, std::size_t size) {
  _internal_mutable_spot_addresses()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline void MitoVaultInfosResponse::add_spot_addresses(absl::string_view value) {
  _internal_mutable_spot_addresses()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::spot_addresses() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
  return _internal_spot_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MitoVaultInfosResponse::mutable_spot_addresses() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MitoVaultInfosResponse.spot_addresses)
  return _internal_mutable_spot_addresses();
}
inline const std::string& MitoVaultInfosResponse::_internal_spot_addresses(int index) const {
  return _internal_spot_addresses().Get(index);
}
inline std::string* MitoVaultInfosResponse::_internal_add_spot_addresses() {
  return _internal_mutable_spot_addresses()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::_internal_spot_addresses() const {
  return _impl_.spot_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MitoVaultInfosResponse::_internal_mutable_spot_addresses() {
  return &_impl_.spot_addresses_;
}

// repeated string cw20_addresses = 4 [json_name = "cw20Addresses"];
inline int MitoVaultInfosResponse::_internal_cw20_addresses_size() const {
  return _impl_.cw20_addresses_.size();
}
inline int MitoVaultInfosResponse::cw20_addresses_size() const {
  return _internal_cw20_addresses_size();
}
inline void MitoVaultInfosResponse::clear_cw20_addresses() {
  _internal_mutable_cw20_addresses()->Clear();
}
inline std::string* MitoVaultInfosResponse::add_cw20_addresses() {
  std::string* _s = _internal_add_cw20_addresses();
  // @@protoc_insertion_point(field_add_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
  return _s;
}
inline const std::string& MitoVaultInfosResponse::cw20_addresses(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
  return _internal_cw20_addresses(index);
}
inline std::string* MitoVaultInfosResponse::mutable_cw20_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
  return _internal_mutable_cw20_addresses()->Mutable(index);
}
inline void MitoVaultInfosResponse::set_cw20_addresses(int index, const std::string& value) {
  _internal_mutable_cw20_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::set_cw20_addresses(int index, std::string&& value) {
  _internal_mutable_cw20_addresses()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::set_cw20_addresses(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cw20_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::set_cw20_addresses(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_cw20_addresses()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::set_cw20_addresses(int index, absl::string_view value) {
  _internal_mutable_cw20_addresses()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::add_cw20_addresses(const std::string& value) {
  _internal_mutable_cw20_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::add_cw20_addresses(std::string&& value) {
  _internal_mutable_cw20_addresses()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::add_cw20_addresses(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cw20_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::add_cw20_addresses(const char* value, std::size_t size) {
  _internal_mutable_cw20_addresses()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline void MitoVaultInfosResponse::add_cw20_addresses(absl::string_view value) {
  _internal_mutable_cw20_addresses()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::cw20_addresses() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
  return _internal_cw20_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MitoVaultInfosResponse::mutable_cw20_addresses() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.MitoVaultInfosResponse.cw20_addresses)
  return _internal_mutable_cw20_addresses();
}
inline const std::string& MitoVaultInfosResponse::_internal_cw20_addresses(int index) const {
  return _internal_cw20_addresses().Get(index);
}
inline std::string* MitoVaultInfosResponse::_internal_add_cw20_addresses() {
  return _internal_mutable_cw20_addresses()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MitoVaultInfosResponse::_internal_cw20_addresses() const {
  return _impl_.cw20_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MitoVaultInfosResponse::_internal_mutable_cw20_addresses() {
  return &_impl_.cw20_addresses_;
}

// -------------------------------------------------------------------

// QueryMarketIDFromVaultRequest

// string vault_address = 1 [json_name = "vaultAddress"];
inline void QueryMarketIDFromVaultRequest::clear_vault_address() {
  _impl_.vault_address_.ClearToEmpty();
}
inline const std::string& QueryMarketIDFromVaultRequest::vault_address() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketIDFromVaultRequest.vault_address)
  return _internal_vault_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryMarketIDFromVaultRequest::set_vault_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.vault_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryMarketIDFromVaultRequest.vault_address)
}
inline std::string* QueryMarketIDFromVaultRequest::mutable_vault_address() {
  std::string* _s = _internal_mutable_vault_address();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketIDFromVaultRequest.vault_address)
  return _s;
}
inline const std::string& QueryMarketIDFromVaultRequest::_internal_vault_address() const {
  return _impl_.vault_address_.Get();
}
inline void QueryMarketIDFromVaultRequest::_internal_set_vault_address(const std::string& value) {
  ;


  _impl_.vault_address_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMarketIDFromVaultRequest::_internal_mutable_vault_address() {
  ;
  return _impl_.vault_address_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryMarketIDFromVaultRequest::release_vault_address() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketIDFromVaultRequest.vault_address)
  return _impl_.vault_address_.Release();
}
inline void QueryMarketIDFromVaultRequest::set_allocated_vault_address(std::string* value) {
  _impl_.vault_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vault_address_.IsDefault()) {
          _impl_.vault_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketIDFromVaultRequest.vault_address)
}

// -------------------------------------------------------------------

// QueryMarketIDFromVaultResponse

// string market_id = 1 [json_name = "marketId"];
inline void QueryMarketIDFromVaultResponse::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryMarketIDFromVaultResponse::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketIDFromVaultResponse.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryMarketIDFromVaultResponse::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryMarketIDFromVaultResponse.market_id)
}
inline std::string* QueryMarketIDFromVaultResponse::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketIDFromVaultResponse.market_id)
  return _s;
}
inline const std::string& QueryMarketIDFromVaultResponse::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryMarketIDFromVaultResponse::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMarketIDFromVaultResponse::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryMarketIDFromVaultResponse::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketIDFromVaultResponse.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryMarketIDFromVaultResponse::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketIDFromVaultResponse.market_id)
}

// -------------------------------------------------------------------

// QueryHistoricalTradeRecordsRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryHistoricalTradeRecordsRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryHistoricalTradeRecordsRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryHistoricalTradeRecordsRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest.market_id)
}
inline std::string* QueryHistoricalTradeRecordsRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest.market_id)
  return _s;
}
inline const std::string& QueryHistoricalTradeRecordsRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryHistoricalTradeRecordsRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryHistoricalTradeRecordsRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryHistoricalTradeRecordsRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryHistoricalTradeRecordsRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryHistoricalTradeRecordsRequest.market_id)
}

// -------------------------------------------------------------------

// QueryHistoricalTradeRecordsResponse

// repeated .injective.exchange.v1beta1.TradeRecords trade_records = 1 [json_name = "tradeRecords"];
inline int QueryHistoricalTradeRecordsResponse::_internal_trade_records_size() const {
  return _impl_.trade_records_.size();
}
inline int QueryHistoricalTradeRecordsResponse::trade_records_size() const {
  return _internal_trade_records_size();
}
inline ::injective::exchange::v1beta1::TradeRecords* QueryHistoricalTradeRecordsResponse::mutable_trade_records(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse.trade_records)
  return _internal_mutable_trade_records()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecords >*
QueryHistoricalTradeRecordsResponse::mutable_trade_records() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse.trade_records)
  return _internal_mutable_trade_records();
}
inline const ::injective::exchange::v1beta1::TradeRecords& QueryHistoricalTradeRecordsResponse::_internal_trade_records(int index) const {
  return _internal_trade_records().Get(index);
}
inline const ::injective::exchange::v1beta1::TradeRecords& QueryHistoricalTradeRecordsResponse::trade_records(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse.trade_records)
  return _internal_trade_records(index);
}
inline ::injective::exchange::v1beta1::TradeRecords* QueryHistoricalTradeRecordsResponse::_internal_add_trade_records() {
  return _internal_mutable_trade_records()->Add();
}
inline ::injective::exchange::v1beta1::TradeRecords* QueryHistoricalTradeRecordsResponse::add_trade_records() {
  ::injective::exchange::v1beta1::TradeRecords* _add = _internal_add_trade_records();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse.trade_records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecords >&
QueryHistoricalTradeRecordsResponse::trade_records() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryHistoricalTradeRecordsResponse.trade_records)
  return _internal_trade_records();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecords>&
QueryHistoricalTradeRecordsResponse::_internal_trade_records() const {
  return _impl_.trade_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecords>*
QueryHistoricalTradeRecordsResponse::_internal_mutable_trade_records() {
  return &_impl_.trade_records_;
}

// -------------------------------------------------------------------

// TradeHistoryOptions

// uint64 trade_grouping_sec = 1 [json_name = "tradeGroupingSec"];
inline void TradeHistoryOptions::clear_trade_grouping_sec() {
  _impl_.trade_grouping_sec_ = ::uint64_t{0u};
}
inline ::uint64_t TradeHistoryOptions::trade_grouping_sec() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeHistoryOptions.trade_grouping_sec)
  return _internal_trade_grouping_sec();
}
inline void TradeHistoryOptions::set_trade_grouping_sec(::uint64_t value) {
  _internal_set_trade_grouping_sec(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeHistoryOptions.trade_grouping_sec)
}
inline ::uint64_t TradeHistoryOptions::_internal_trade_grouping_sec() const {
  return _impl_.trade_grouping_sec_;
}
inline void TradeHistoryOptions::_internal_set_trade_grouping_sec(::uint64_t value) {
  ;
  _impl_.trade_grouping_sec_ = value;
}

// uint64 max_age = 2 [json_name = "maxAge"];
inline void TradeHistoryOptions::clear_max_age() {
  _impl_.max_age_ = ::uint64_t{0u};
}
inline ::uint64_t TradeHistoryOptions::max_age() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeHistoryOptions.max_age)
  return _internal_max_age();
}
inline void TradeHistoryOptions::set_max_age(::uint64_t value) {
  _internal_set_max_age(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeHistoryOptions.max_age)
}
inline ::uint64_t TradeHistoryOptions::_internal_max_age() const {
  return _impl_.max_age_;
}
inline void TradeHistoryOptions::_internal_set_max_age(::uint64_t value) {
  ;
  _impl_.max_age_ = value;
}

// bool include_raw_history = 4 [json_name = "includeRawHistory"];
inline void TradeHistoryOptions::clear_include_raw_history() {
  _impl_.include_raw_history_ = false;
}
inline bool TradeHistoryOptions::include_raw_history() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeHistoryOptions.include_raw_history)
  return _internal_include_raw_history();
}
inline void TradeHistoryOptions::set_include_raw_history(bool value) {
  _internal_set_include_raw_history(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeHistoryOptions.include_raw_history)
}
inline bool TradeHistoryOptions::_internal_include_raw_history() const {
  return _impl_.include_raw_history_;
}
inline void TradeHistoryOptions::_internal_set_include_raw_history(bool value) {
  ;
  _impl_.include_raw_history_ = value;
}

// bool include_metadata = 5 [json_name = "includeMetadata"];
inline void TradeHistoryOptions::clear_include_metadata() {
  _impl_.include_metadata_ = false;
}
inline bool TradeHistoryOptions::include_metadata() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TradeHistoryOptions.include_metadata)
  return _internal_include_metadata();
}
inline void TradeHistoryOptions::set_include_metadata(bool value) {
  _internal_set_include_metadata(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TradeHistoryOptions.include_metadata)
}
inline bool TradeHistoryOptions::_internal_include_metadata() const {
  return _impl_.include_metadata_;
}
inline void TradeHistoryOptions::_internal_set_include_metadata(bool value) {
  ;
  _impl_.include_metadata_ = value;
}

// -------------------------------------------------------------------

// QueryMarketVolatilityRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryMarketVolatilityRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryMarketVolatilityRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketVolatilityRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryMarketVolatilityRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryMarketVolatilityRequest.market_id)
}
inline std::string* QueryMarketVolatilityRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketVolatilityRequest.market_id)
  return _s;
}
inline const std::string& QueryMarketVolatilityRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryMarketVolatilityRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMarketVolatilityRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryMarketVolatilityRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketVolatilityRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryMarketVolatilityRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketVolatilityRequest.market_id)
}

// .injective.exchange.v1beta1.TradeHistoryOptions trade_history_options = 2 [json_name = "tradeHistoryOptions"];
inline bool QueryMarketVolatilityRequest::has_trade_history_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trade_history_options_ != nullptr);
  return value;
}
inline void QueryMarketVolatilityRequest::clear_trade_history_options() {
  if (_impl_.trade_history_options_ != nullptr) _impl_.trade_history_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective::exchange::v1beta1::TradeHistoryOptions& QueryMarketVolatilityRequest::_internal_trade_history_options() const {
  const ::injective::exchange::v1beta1::TradeHistoryOptions* p = _impl_.trade_history_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::exchange::v1beta1::TradeHistoryOptions&>(
      ::injective::exchange::v1beta1::_TradeHistoryOptions_default_instance_);
}
inline const ::injective::exchange::v1beta1::TradeHistoryOptions& QueryMarketVolatilityRequest::trade_history_options() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketVolatilityRequest.trade_history_options)
  return _internal_trade_history_options();
}
inline void QueryMarketVolatilityRequest::unsafe_arena_set_allocated_trade_history_options(
    ::injective::exchange::v1beta1::TradeHistoryOptions* trade_history_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trade_history_options_);
  }
  _impl_.trade_history_options_ = trade_history_options;
  if (trade_history_options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryMarketVolatilityRequest.trade_history_options)
}
inline ::injective::exchange::v1beta1::TradeHistoryOptions* QueryMarketVolatilityRequest::release_trade_history_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradeHistoryOptions* temp = _impl_.trade_history_options_;
  _impl_.trade_history_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::exchange::v1beta1::TradeHistoryOptions* QueryMarketVolatilityRequest::unsafe_arena_release_trade_history_options() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketVolatilityRequest.trade_history_options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::exchange::v1beta1::TradeHistoryOptions* temp = _impl_.trade_history_options_;
  _impl_.trade_history_options_ = nullptr;
  return temp;
}
inline ::injective::exchange::v1beta1::TradeHistoryOptions* QueryMarketVolatilityRequest::_internal_mutable_trade_history_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trade_history_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::exchange::v1beta1::TradeHistoryOptions>(GetArenaForAllocation());
    _impl_.trade_history_options_ = p;
  }
  return _impl_.trade_history_options_;
}
inline ::injective::exchange::v1beta1::TradeHistoryOptions* QueryMarketVolatilityRequest::mutable_trade_history_options() {
  ::injective::exchange::v1beta1::TradeHistoryOptions* _msg = _internal_mutable_trade_history_options();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketVolatilityRequest.trade_history_options)
  return _msg;
}
inline void QueryMarketVolatilityRequest::set_allocated_trade_history_options(::injective::exchange::v1beta1::TradeHistoryOptions* trade_history_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trade_history_options_;
  }
  if (trade_history_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trade_history_options);
    if (message_arena != submessage_arena) {
      trade_history_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade_history_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trade_history_options_ = trade_history_options;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketVolatilityRequest.trade_history_options)
}

// -------------------------------------------------------------------

// QueryMarketVolatilityResponse

// string volatility = 1 [json_name = "volatility", (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryMarketVolatilityResponse::clear_volatility() {
  _impl_.volatility_.ClearToEmpty();
}
inline const std::string& QueryMarketVolatilityResponse::volatility() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketVolatilityResponse.volatility)
  return _internal_volatility();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryMarketVolatilityResponse::set_volatility(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.volatility_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryMarketVolatilityResponse.volatility)
}
inline std::string* QueryMarketVolatilityResponse::mutable_volatility() {
  std::string* _s = _internal_mutable_volatility();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketVolatilityResponse.volatility)
  return _s;
}
inline const std::string& QueryMarketVolatilityResponse::_internal_volatility() const {
  return _impl_.volatility_.Get();
}
inline void QueryMarketVolatilityResponse::_internal_set_volatility(const std::string& value) {
  ;


  _impl_.volatility_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMarketVolatilityResponse::_internal_mutable_volatility() {
  ;
  return _impl_.volatility_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryMarketVolatilityResponse::release_volatility() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketVolatilityResponse.volatility)
  return _impl_.volatility_.Release();
}
inline void QueryMarketVolatilityResponse::set_allocated_volatility(std::string* value) {
  _impl_.volatility_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volatility_.IsDefault()) {
          _impl_.volatility_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketVolatilityResponse.volatility)
}

// .injective.oracle.v1beta1.MetadataStatistics history_metadata = 2 [json_name = "historyMetadata"];
inline bool QueryMarketVolatilityResponse::has_history_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.history_metadata_ != nullptr);
  return value;
}
inline const ::injective::oracle::v1beta1::MetadataStatistics& QueryMarketVolatilityResponse::_internal_history_metadata() const {
  const ::injective::oracle::v1beta1::MetadataStatistics* p = _impl_.history_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective::oracle::v1beta1::MetadataStatistics&>(
      ::injective::oracle::v1beta1::_MetadataStatistics_default_instance_);
}
inline const ::injective::oracle::v1beta1::MetadataStatistics& QueryMarketVolatilityResponse::history_metadata() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketVolatilityResponse.history_metadata)
  return _internal_history_metadata();
}
inline void QueryMarketVolatilityResponse::unsafe_arena_set_allocated_history_metadata(
    ::injective::oracle::v1beta1::MetadataStatistics* history_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.history_metadata_);
  }
  _impl_.history_metadata_ = history_metadata;
  if (history_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective.exchange.v1beta1.QueryMarketVolatilityResponse.history_metadata)
}
inline ::injective::oracle::v1beta1::MetadataStatistics* QueryMarketVolatilityResponse::release_history_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::MetadataStatistics* temp = _impl_.history_metadata_;
  _impl_.history_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective::oracle::v1beta1::MetadataStatistics* QueryMarketVolatilityResponse::unsafe_arena_release_history_metadata() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketVolatilityResponse.history_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective::oracle::v1beta1::MetadataStatistics* temp = _impl_.history_metadata_;
  _impl_.history_metadata_ = nullptr;
  return temp;
}
inline ::injective::oracle::v1beta1::MetadataStatistics* QueryMarketVolatilityResponse::_internal_mutable_history_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.history_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective::oracle::v1beta1::MetadataStatistics>(GetArenaForAllocation());
    _impl_.history_metadata_ = p;
  }
  return _impl_.history_metadata_;
}
inline ::injective::oracle::v1beta1::MetadataStatistics* QueryMarketVolatilityResponse::mutable_history_metadata() {
  ::injective::oracle::v1beta1::MetadataStatistics* _msg = _internal_mutable_history_metadata();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketVolatilityResponse.history_metadata)
  return _msg;
}
inline void QueryMarketVolatilityResponse::set_allocated_history_metadata(::injective::oracle::v1beta1::MetadataStatistics* history_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.history_metadata_);
  }
  if (history_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(history_metadata));
    if (message_arena != submessage_arena) {
      history_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, history_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.history_metadata_ = history_metadata;
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketVolatilityResponse.history_metadata)
}

// repeated .injective.exchange.v1beta1.TradeRecord raw_history = 3 [json_name = "rawHistory"];
inline int QueryMarketVolatilityResponse::_internal_raw_history_size() const {
  return _impl_.raw_history_.size();
}
inline int QueryMarketVolatilityResponse::raw_history_size() const {
  return _internal_raw_history_size();
}
inline ::injective::exchange::v1beta1::TradeRecord* QueryMarketVolatilityResponse::mutable_raw_history(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketVolatilityResponse.raw_history)
  return _internal_mutable_raw_history()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >*
QueryMarketVolatilityResponse::mutable_raw_history() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryMarketVolatilityResponse.raw_history)
  return _internal_mutable_raw_history();
}
inline const ::injective::exchange::v1beta1::TradeRecord& QueryMarketVolatilityResponse::_internal_raw_history(int index) const {
  return _internal_raw_history().Get(index);
}
inline const ::injective::exchange::v1beta1::TradeRecord& QueryMarketVolatilityResponse::raw_history(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketVolatilityResponse.raw_history)
  return _internal_raw_history(index);
}
inline ::injective::exchange::v1beta1::TradeRecord* QueryMarketVolatilityResponse::_internal_add_raw_history() {
  return _internal_mutable_raw_history()->Add();
}
inline ::injective::exchange::v1beta1::TradeRecord* QueryMarketVolatilityResponse::add_raw_history() {
  ::injective::exchange::v1beta1::TradeRecord* _add = _internal_add_raw_history();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryMarketVolatilityResponse.raw_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TradeRecord >&
QueryMarketVolatilityResponse::raw_history() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryMarketVolatilityResponse.raw_history)
  return _internal_raw_history();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>&
QueryMarketVolatilityResponse::_internal_raw_history() const {
  return _impl_.raw_history_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TradeRecord>*
QueryMarketVolatilityResponse::_internal_mutable_raw_history() {
  return &_impl_.raw_history_;
}

// -------------------------------------------------------------------

// QueryBinaryMarketsRequest

// string status = 1 [json_name = "status"];
inline void QueryBinaryMarketsRequest::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& QueryBinaryMarketsRequest::status() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryBinaryMarketsRequest.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryBinaryMarketsRequest::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryBinaryMarketsRequest.status)
}
inline std::string* QueryBinaryMarketsRequest::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryBinaryMarketsRequest.status)
  return _s;
}
inline const std::string& QueryBinaryMarketsRequest::_internal_status() const {
  return _impl_.status_.Get();
}
inline void QueryBinaryMarketsRequest::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryBinaryMarketsRequest::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryBinaryMarketsRequest::release_status() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryBinaryMarketsRequest.status)
  return _impl_.status_.Release();
}
inline void QueryBinaryMarketsRequest::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryBinaryMarketsRequest.status)
}

// -------------------------------------------------------------------

// QueryBinaryMarketsResponse

// repeated .injective.exchange.v1beta1.BinaryOptionsMarket markets = 1 [json_name = "markets"];
inline int QueryBinaryMarketsResponse::_internal_markets_size() const {
  return _impl_.markets_.size();
}
inline int QueryBinaryMarketsResponse::markets_size() const {
  return _internal_markets_size();
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarket* QueryBinaryMarketsResponse::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryBinaryMarketsResponse.markets)
  return _internal_mutable_markets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarket >*
QueryBinaryMarketsResponse::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryBinaryMarketsResponse.markets)
  return _internal_mutable_markets();
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarket& QueryBinaryMarketsResponse::_internal_markets(int index) const {
  return _internal_markets().Get(index);
}
inline const ::injective::exchange::v1beta1::BinaryOptionsMarket& QueryBinaryMarketsResponse::markets(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryBinaryMarketsResponse.markets)
  return _internal_markets(index);
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarket* QueryBinaryMarketsResponse::_internal_add_markets() {
  return _internal_mutable_markets()->Add();
}
inline ::injective::exchange::v1beta1::BinaryOptionsMarket* QueryBinaryMarketsResponse::add_markets() {
  ::injective::exchange::v1beta1::BinaryOptionsMarket* _add = _internal_add_markets();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryBinaryMarketsResponse.markets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::BinaryOptionsMarket >&
QueryBinaryMarketsResponse::markets() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryBinaryMarketsResponse.markets)
  return _internal_markets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarket>&
QueryBinaryMarketsResponse::_internal_markets() const {
  return _impl_.markets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::BinaryOptionsMarket>*
QueryBinaryMarketsResponse::_internal_mutable_markets() {
  return &_impl_.markets_;
}

// -------------------------------------------------------------------

// QueryTraderDerivativeConditionalOrdersRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void QueryTraderDerivativeConditionalOrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeConditionalOrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeConditionalOrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.subaccount_id)
}
inline std::string* QueryTraderDerivativeConditionalOrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& QueryTraderDerivativeConditionalOrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void QueryTraderDerivativeConditionalOrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeConditionalOrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeConditionalOrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void QueryTraderDerivativeConditionalOrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void QueryTraderDerivativeConditionalOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryTraderDerivativeConditionalOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryTraderDerivativeConditionalOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.market_id)
}
inline std::string* QueryTraderDerivativeConditionalOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.market_id)
  return _s;
}
inline const std::string& QueryTraderDerivativeConditionalOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryTraderDerivativeConditionalOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeConditionalOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryTraderDerivativeConditionalOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryTraderDerivativeConditionalOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersRequest.market_id)
}

// -------------------------------------------------------------------

// TrimmedDerivativeConditionalOrder

// string price = 1 [json_name = "price", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeConditionalOrder::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeConditionalOrder::price() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeConditionalOrder::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.price)
}
inline std::string* TrimmedDerivativeConditionalOrder::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.price)
  return _s;
}
inline const std::string& TrimmedDerivativeConditionalOrder::_internal_price() const {
  return _impl_.price_.Get();
}
inline void TrimmedDerivativeConditionalOrder::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::release_price() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.price)
  return _impl_.price_.Release();
}
inline void TrimmedDerivativeConditionalOrder::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.price)
}

// string quantity = 2 [json_name = "quantity", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeConditionalOrder::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeConditionalOrder::quantity() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeConditionalOrder::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.quantity)
}
inline std::string* TrimmedDerivativeConditionalOrder::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.quantity)
  return _s;
}
inline const std::string& TrimmedDerivativeConditionalOrder::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void TrimmedDerivativeConditionalOrder::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::release_quantity() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.quantity)
  return _impl_.quantity_.Release();
}
inline void TrimmedDerivativeConditionalOrder::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.quantity)
}

// string margin = 3 [json_name = "margin", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeConditionalOrder::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeConditionalOrder::margin() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeConditionalOrder::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.margin)
}
inline std::string* TrimmedDerivativeConditionalOrder::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.margin)
  return _s;
}
inline const std::string& TrimmedDerivativeConditionalOrder::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void TrimmedDerivativeConditionalOrder::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::release_margin() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.margin)
  return _impl_.margin_.Release();
}
inline void TrimmedDerivativeConditionalOrder::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.margin)
}

// string triggerPrice = 4 [json_name = "triggerPrice", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void TrimmedDerivativeConditionalOrder::clear_triggerprice() {
  _impl_.triggerprice_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeConditionalOrder::triggerprice() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.triggerPrice)
  return _internal_triggerprice();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeConditionalOrder::set_triggerprice(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.triggerprice_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.triggerPrice)
}
inline std::string* TrimmedDerivativeConditionalOrder::mutable_triggerprice() {
  std::string* _s = _internal_mutable_triggerprice();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.triggerPrice)
  return _s;
}
inline const std::string& TrimmedDerivativeConditionalOrder::_internal_triggerprice() const {
  return _impl_.triggerprice_.Get();
}
inline void TrimmedDerivativeConditionalOrder::_internal_set_triggerprice(const std::string& value) {
  ;


  _impl_.triggerprice_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::_internal_mutable_triggerprice() {
  ;
  return _impl_.triggerprice_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::release_triggerprice() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.triggerPrice)
  return _impl_.triggerprice_.Release();
}
inline void TrimmedDerivativeConditionalOrder::set_allocated_triggerprice(std::string* value) {
  _impl_.triggerprice_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.triggerprice_.IsDefault()) {
          _impl_.triggerprice_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.triggerPrice)
}

// bool isBuy = 5 [json_name = "isBuy", (.gogoproto.jsontag) = "isBuy"];
inline void TrimmedDerivativeConditionalOrder::clear_isbuy() {
  _impl_.isbuy_ = false;
}
inline bool TrimmedDerivativeConditionalOrder::isbuy() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.isBuy)
  return _internal_isbuy();
}
inline void TrimmedDerivativeConditionalOrder::set_isbuy(bool value) {
  _internal_set_isbuy(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.isBuy)
}
inline bool TrimmedDerivativeConditionalOrder::_internal_isbuy() const {
  return _impl_.isbuy_;
}
inline void TrimmedDerivativeConditionalOrder::_internal_set_isbuy(bool value) {
  ;
  _impl_.isbuy_ = value;
}

// bool isLimit = 6 [json_name = "isLimit", (.gogoproto.jsontag) = "isLimit"];
inline void TrimmedDerivativeConditionalOrder::clear_islimit() {
  _impl_.islimit_ = false;
}
inline bool TrimmedDerivativeConditionalOrder::islimit() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.isLimit)
  return _internal_islimit();
}
inline void TrimmedDerivativeConditionalOrder::set_islimit(bool value) {
  _internal_set_islimit(value);
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.isLimit)
}
inline bool TrimmedDerivativeConditionalOrder::_internal_islimit() const {
  return _impl_.islimit_;
}
inline void TrimmedDerivativeConditionalOrder::_internal_set_islimit(bool value) {
  ;
  _impl_.islimit_ = value;
}

// string order_hash = 7 [json_name = "orderHash"];
inline void TrimmedDerivativeConditionalOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& TrimmedDerivativeConditionalOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrimmedDerivativeConditionalOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.order_hash)
}
inline std::string* TrimmedDerivativeConditionalOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.order_hash)
  return _s;
}
inline const std::string& TrimmedDerivativeConditionalOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void TrimmedDerivativeConditionalOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* TrimmedDerivativeConditionalOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void TrimmedDerivativeConditionalOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder.order_hash)
}

// -------------------------------------------------------------------

// QueryTraderDerivativeConditionalOrdersResponse

// repeated .injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder orders = 1 [json_name = "orders"];
inline int QueryTraderDerivativeConditionalOrdersResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int QueryTraderDerivativeConditionalOrdersResponse::orders_size() const {
  return _internal_orders_size();
}
inline void QueryTraderDerivativeConditionalOrdersResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* QueryTraderDerivativeConditionalOrdersResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder >*
QueryTraderDerivativeConditionalOrdersResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder& QueryTraderDerivativeConditionalOrdersResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder& QueryTraderDerivativeConditionalOrdersResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse.orders)
  return _internal_orders(index);
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* QueryTraderDerivativeConditionalOrdersResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* QueryTraderDerivativeConditionalOrdersResponse::add_orders() {
  ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder >&
QueryTraderDerivativeConditionalOrdersResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective.exchange.v1beta1.QueryTraderDerivativeConditionalOrdersResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder>&
QueryTraderDerivativeConditionalOrdersResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective::exchange::v1beta1::TrimmedDerivativeConditionalOrder>*
QueryTraderDerivativeConditionalOrdersResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// -------------------------------------------------------------------

// QueryMarketAtomicExecutionFeeMultiplierRequest

// string market_id = 1 [json_name = "marketId"];
inline void QueryMarketAtomicExecutionFeeMultiplierRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& QueryMarketAtomicExecutionFeeMultiplierRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryMarketAtomicExecutionFeeMultiplierRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest.market_id)
}
inline std::string* QueryMarketAtomicExecutionFeeMultiplierRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest.market_id)
  return _s;
}
inline const std::string& QueryMarketAtomicExecutionFeeMultiplierRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void QueryMarketAtomicExecutionFeeMultiplierRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMarketAtomicExecutionFeeMultiplierRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryMarketAtomicExecutionFeeMultiplierRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void QueryMarketAtomicExecutionFeeMultiplierRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierRequest.market_id)
}

// -------------------------------------------------------------------

// QueryMarketAtomicExecutionFeeMultiplierResponse

// string multiplier = 1 [json_name = "multiplier", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec"];
inline void QueryMarketAtomicExecutionFeeMultiplierResponse::clear_multiplier() {
  _impl_.multiplier_.ClearToEmpty();
}
inline const std::string& QueryMarketAtomicExecutionFeeMultiplierResponse::multiplier() const {
  // @@protoc_insertion_point(field_get:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse.multiplier)
  return _internal_multiplier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryMarketAtomicExecutionFeeMultiplierResponse::set_multiplier(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.multiplier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse.multiplier)
}
inline std::string* QueryMarketAtomicExecutionFeeMultiplierResponse::mutable_multiplier() {
  std::string* _s = _internal_mutable_multiplier();
  // @@protoc_insertion_point(field_mutable:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse.multiplier)
  return _s;
}
inline const std::string& QueryMarketAtomicExecutionFeeMultiplierResponse::_internal_multiplier() const {
  return _impl_.multiplier_.Get();
}
inline void QueryMarketAtomicExecutionFeeMultiplierResponse::_internal_set_multiplier(const std::string& value) {
  ;


  _impl_.multiplier_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMarketAtomicExecutionFeeMultiplierResponse::_internal_mutable_multiplier() {
  ;
  return _impl_.multiplier_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryMarketAtomicExecutionFeeMultiplierResponse::release_multiplier() {
  // @@protoc_insertion_point(field_release:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse.multiplier)
  return _impl_.multiplier_.Release();
}
inline void QueryMarketAtomicExecutionFeeMultiplierResponse::set_allocated_multiplier(std::string* value) {
  _impl_.multiplier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.multiplier_.IsDefault()) {
          _impl_.multiplier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective.exchange.v1beta1.QueryMarketAtomicExecutionFeeMultiplierResponse.multiplier)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace exchange
}  // namespace injective


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::injective::exchange::v1beta1::OrderSide> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::OrderSide>() {
  return ::injective::exchange::v1beta1::OrderSide_descriptor();
}
template <>
struct is_proto_enum<::injective::exchange::v1beta1::CancellationStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::injective::exchange::v1beta1::CancellationStrategy>() {
  return ::injective::exchange::v1beta1::CancellationStrategy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_injective_2fexchange_2fv1beta1_2fquery_2eproto_2epb_2eh
